var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJSMin = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (all, symbols) => {
	let target = {};
	for (var name in all) __defProp(target, name, {
		get: all[name],
		enumerable: true
	});
	if (symbols) __defProp(target, Symbol.toStringTag, { value: "Module" });
	return target;
};
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i$6 = 0, n$4 = keys.length, key; i$6 < n$4; i$6++) {
		key = keys[i$6];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k$4) => from[k$4]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));
var __toDynamicImportESM = (isNodeMode) => (mod) => __toESM(mod.default, isNodeMode);
var __require = /* @__PURE__ */ ((x$4) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x$4, { get: (a$36, b$4) => (typeof require !== "undefined" ? require : a$36)[b$4] }) : x$4)(function(x$4) {
	if (typeof require !== "undefined") return require.apply(this, arguments);
	throw Error("Calling `require` for \"" + x$4 + "\" in an environment that doesn't expose the `require` function.");
});
(function polyfill() {
	const relList = document.createElement("link").relList;
	if (relList && relList.supports && relList.supports("modulepreload")) return;
	for (const link of document.querySelectorAll("link[rel=\"modulepreload\"]")) processPreload(link);
	new MutationObserver((mutations) => {
		for (const mutation of mutations) {
			if (mutation.type !== "childList") continue;
			for (const node of mutation.addedNodes) if (node.tagName === "LINK" && node.rel === "modulepreload") processPreload(node);
		}
	}).observe(document, {
		childList: true,
		subtree: true
	});
	function getFetchOpts(link) {
		const fetchOpts = {};
		if (link.integrity) fetchOpts.integrity = link.integrity;
		if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
		if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";
		else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
		else fetchOpts.credentials = "same-origin";
		return fetchOpts;
	}
	function processPreload(link) {
		if (link.ep) return;
		link.ep = true;
		const fetchOpts = getFetchOpts(link);
		fetch(link.href, fetchOpts);
	}
})();
var n$3, l, u$4, t$9, i$5, r$10, o$33, e$58, f$4, c$6, s$3, a$35, h$4, p$5 = {}, v$3 = [], y$4 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, d$4 = Array.isArray;
function w$4(n$4, l$10) {
	for (var u$5 in l$10) n$4[u$5] = l$10[u$5];
	return n$4;
}
function g$4(n$4) {
	n$4 && n$4.parentNode && n$4.parentNode.removeChild(n$4);
}
function _(l$10, u$5, t$12) {
	var i$6, r$11, o$34, e$59 = {};
	for (o$34 in u$5) "key" == o$34 ? i$6 = u$5[o$34] : "ref" == o$34 ? r$11 = u$5[o$34] : e$59[o$34] = u$5[o$34];
	if (arguments.length > 2 && (e$59.children = arguments.length > 3 ? n$3.call(arguments, 2) : t$12), "function" == typeof l$10 && null != l$10.defaultProps) for (o$34 in l$10.defaultProps) void 0 === e$59[o$34] && (e$59[o$34] = l$10.defaultProps[o$34]);
	return m$4(l$10, e$59, i$6, r$11, null);
}
function m$4(n$4, t$12, i$6, r$11, o$34) {
	var e$59 = {
		type: n$4,
		props: t$12,
		key: i$6,
		ref: r$11,
		__k: null,
		__: null,
		__b: 0,
		__e: null,
		__c: null,
		constructor: void 0,
		__v: null == o$34 ? ++u$4 : o$34,
		__i: -1,
		__u: 0
	};
	return null == o$34 && null != l.vnode && l.vnode(e$59), e$59;
}
function k(n$4) {
	return n$4.children;
}
function x(n$4, l$10) {
	this.props = n$4, this.context = l$10;
}
function S$2(n$4, l$10) {
	if (null == l$10) return n$4.__ ? S$2(n$4.__, n$4.__i + 1) : null;
	for (var u$5; l$10 < n$4.__k.length; l$10++) if (null != (u$5 = n$4.__k[l$10]) && null != u$5.__e) return u$5.__e;
	return "function" == typeof n$4.type ? S$2(n$4) : null;
}
function C$3(n$4) {
	if (n$4.__P && n$4.__d) {
		var u$5 = n$4.__v, t$12 = u$5.__e, i$6 = [], r$11 = [], o$34 = w$4({}, u$5);
		o$34.__v = u$5.__v + 1, l.vnode && l.vnode(o$34), z$2(n$4.__P, o$34, u$5, n$4.__n, n$4.__P.namespaceURI, 32 & u$5.__u ? [t$12] : null, i$6, null == t$12 ? S$2(u$5) : t$12, !!(32 & u$5.__u), r$11), o$34.__v = u$5.__v, o$34.__.__k[o$34.__i] = o$34, V$2(i$6, o$34, r$11), u$5.__e = u$5.__ = null, o$34.__e != t$12 && M$1(o$34);
	}
}
function M$1(n$4) {
	if (null != (n$4 = n$4.__) && null != n$4.__c) return n$4.__e = n$4.__c.base = null, n$4.__k.some(function(l$10) {
		if (null != l$10 && null != l$10.__e) return n$4.__e = n$4.__c.base = l$10.__e;
	}), M$1(n$4);
}
function $$1(n$4) {
	(!n$4.__d && (n$4.__d = !0) && i$5.push(n$4) && !I$1.__r++ || r$10 != l.debounceRendering) && ((r$10 = l.debounceRendering) || o$33)(I$1);
}
function I$1() {
	for (var n$4, l$10 = 1; i$5.length;) i$5.length > l$10 && i$5.sort(e$58), n$4 = i$5.shift(), l$10 = i$5.length, C$3(n$4);
	I$1.__r = 0;
}
function P$2(n$4, l$10, u$5, t$12, i$6, r$11, o$34, e$59, f$5, c$7, s$4) {
	var a$36, h$5, y$5, d$5, w$5, g$5, _$5, m$5 = t$12 && t$12.__k || v$3, b$4 = l$10.length;
	for (f$5 = A$2(u$5, l$10, m$5, f$5, b$4), a$36 = 0; a$36 < b$4; a$36++) null != (y$5 = u$5.__k[a$36]) && (h$5 = -1 != y$5.__i && m$5[y$5.__i] || p$5, y$5.__i = a$36, g$5 = z$2(n$4, y$5, h$5, i$6, r$11, o$34, e$59, f$5, c$7, s$4), d$5 = y$5.__e, y$5.ref && h$5.ref != y$5.ref && (h$5.ref && D$3(h$5.ref, null, y$5), s$4.push(y$5.ref, y$5.__c || d$5, y$5)), null == w$5 && null != d$5 && (w$5 = d$5), (_$5 = !!(4 & y$5.__u)) || h$5.__k === y$5.__k ? f$5 = H$2(y$5, f$5, n$4, _$5) : "function" == typeof y$5.type && void 0 !== g$5 ? f$5 = g$5 : d$5 && (f$5 = d$5.nextSibling), y$5.__u &= -7);
	return u$5.__e = w$5, f$5;
}
function A$2(n$4, l$10, u$5, t$12, i$6) {
	var r$11, o$34, e$59, f$5, c$7, s$4 = u$5.length, a$36 = s$4, h$5 = 0;
	for (n$4.__k = new Array(i$6), r$11 = 0; r$11 < i$6; r$11++) null != (o$34 = l$10[r$11]) && "boolean" != typeof o$34 && "function" != typeof o$34 ? ("string" == typeof o$34 || "number" == typeof o$34 || "bigint" == typeof o$34 || o$34.constructor == String ? o$34 = n$4.__k[r$11] = m$4(null, o$34, null, null, null) : d$4(o$34) ? o$34 = n$4.__k[r$11] = m$4(k, { children: o$34 }, null, null, null) : void 0 === o$34.constructor && o$34.__b > 0 ? o$34 = n$4.__k[r$11] = m$4(o$34.type, o$34.props, o$34.key, o$34.ref ? o$34.ref : null, o$34.__v) : n$4.__k[r$11] = o$34, f$5 = r$11 + h$5, o$34.__ = n$4, o$34.__b = n$4.__b + 1, e$59 = null, -1 != (c$7 = o$34.__i = T$3(o$34, u$5, f$5, a$36)) && (a$36--, (e$59 = u$5[c$7]) && (e$59.__u |= 2)), null == e$59 || null == e$59.__v ? (-1 == c$7 && (i$6 > s$4 ? h$5-- : i$6 < s$4 && h$5++), "function" != typeof o$34.type && (o$34.__u |= 4)) : c$7 != f$5 && (c$7 == f$5 - 1 ? h$5-- : c$7 == f$5 + 1 ? h$5++ : (c$7 > f$5 ? h$5-- : h$5++, o$34.__u |= 4))) : n$4.__k[r$11] = null;
	if (a$36) for (r$11 = 0; r$11 < s$4; r$11++) null != (e$59 = u$5[r$11]) && 0 == (2 & e$59.__u) && (e$59.__e == t$12 && (t$12 = S$2(e$59)), E$3(e$59, e$59));
	return t$12;
}
function H$2(n$4, l$10, u$5, t$12) {
	var i$6, r$11;
	if ("function" == typeof n$4.type) {
		for (i$6 = n$4.__k, r$11 = 0; i$6 && r$11 < i$6.length; r$11++) i$6[r$11] && (i$6[r$11].__ = n$4, l$10 = H$2(i$6[r$11], l$10, u$5, t$12));
		return l$10;
	}
	n$4.__e != l$10 && (t$12 && (l$10 && n$4.type && !l$10.parentNode && (l$10 = S$2(n$4)), u$5.insertBefore(n$4.__e, l$10 || null)), l$10 = n$4.__e);
	do
		l$10 = l$10 && l$10.nextSibling;
	while (null != l$10 && 8 == l$10.nodeType);
	return l$10;
}
function L(n$4, l$10) {
	return l$10 = l$10 || [], null == n$4 || "boolean" == typeof n$4 || (d$4(n$4) ? n$4.some(function(n$5) {
		L(n$5, l$10);
	}) : l$10.push(n$4)), l$10;
}
function T$3(n$4, l$10, u$5, t$12) {
	var i$6, r$11, o$34, e$59 = n$4.key, f$5 = n$4.type, c$7 = l$10[u$5], s$4 = null != c$7 && 0 == (2 & c$7.__u);
	if (null === c$7 && null == e$59 || s$4 && e$59 == c$7.key && f$5 == c$7.type) return u$5;
	if (t$12 > (s$4 ? 1 : 0)) {
		for (i$6 = u$5 - 1, r$11 = u$5 + 1; i$6 >= 0 || r$11 < l$10.length;) if (null != (c$7 = l$10[o$34 = i$6 >= 0 ? i$6-- : r$11++]) && 0 == (2 & c$7.__u) && e$59 == c$7.key && f$5 == c$7.type) return o$34;
	}
	return -1;
}
function j$3(n$4, l$10, u$5) {
	"-" == l$10[0] ? n$4.setProperty(l$10, null == u$5 ? "" : u$5) : n$4[l$10] = null == u$5 ? "" : "number" != typeof u$5 || y$4.test(l$10) ? u$5 : u$5 + "px";
}
function F$3(n$4, l$10, u$5, t$12, i$6) {
	var r$11, o$34;
	n: if ("style" == l$10) if ("string" == typeof u$5) n$4.style.cssText = u$5;
	else {
		if ("string" == typeof t$12 && (n$4.style.cssText = t$12 = ""), t$12) for (l$10 in t$12) u$5 && l$10 in u$5 || j$3(n$4.style, l$10, "");
		if (u$5) for (l$10 in u$5) t$12 && u$5[l$10] == t$12[l$10] || j$3(n$4.style, l$10, u$5[l$10]);
	}
	else if ("o" == l$10[0] && "n" == l$10[1]) r$11 = l$10 != (l$10 = l$10.replace(f$4, "$1")), o$34 = l$10.toLowerCase(), l$10 = o$34 in n$4 || "onFocusOut" == l$10 || "onFocusIn" == l$10 ? o$34.slice(2) : l$10.slice(2), n$4.l || (n$4.l = {}), n$4.l[l$10 + r$11] = u$5, u$5 ? t$12 ? u$5.u = t$12.u : (u$5.u = c$6, n$4.addEventListener(l$10, r$11 ? a$35 : s$3, r$11)) : n$4.removeEventListener(l$10, r$11 ? a$35 : s$3, r$11);
	else {
		if ("http://www.w3.org/2000/svg" == i$6) l$10 = l$10.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
		else if ("width" != l$10 && "height" != l$10 && "href" != l$10 && "list" != l$10 && "form" != l$10 && "tabIndex" != l$10 && "download" != l$10 && "rowSpan" != l$10 && "colSpan" != l$10 && "role" != l$10 && "popover" != l$10 && l$10 in n$4) try {
			n$4[l$10] = null == u$5 ? "" : u$5;
			break n;
		} catch (n$5) {}
		"function" == typeof u$5 || (null == u$5 || !1 === u$5 && "-" != l$10[4] ? n$4.removeAttribute(l$10) : n$4.setAttribute(l$10, "popover" == l$10 && 1 == u$5 ? "" : u$5));
	}
}
function O$2(n$4) {
	return function(u$5) {
		if (this.l) {
			var t$12 = this.l[u$5.type + n$4];
			if (null == u$5.t) u$5.t = c$6++;
			else if (u$5.t < t$12.u) return;
			return t$12(l.event ? l.event(u$5) : u$5);
		}
	};
}
function z$2(n$4, u$5, t$12, i$6, r$11, o$34, e$59, f$5, c$7, s$4) {
	var a$36, h$5, p$6, y$5, _$5, m$5, b$4, S$3, C$4, M$2, $$2, I$2, A$3, H$3, L$3, T$4 = u$5.type;
	if (void 0 !== u$5.constructor) return null;
	128 & t$12.__u && (c$7 = !!(32 & t$12.__u), o$34 = [f$5 = u$5.__e = t$12.__e]), (a$36 = l.__b) && a$36(u$5);
	n: if ("function" == typeof T$4) try {
		if (S$3 = u$5.props, C$4 = "prototype" in T$4 && T$4.prototype.render, M$2 = (a$36 = T$4.contextType) && i$6[a$36.__c], $$2 = a$36 ? M$2 ? M$2.props.value : a$36.__ : i$6, t$12.__c ? b$4 = (h$5 = u$5.__c = t$12.__c).__ = h$5.__E : (C$4 ? u$5.__c = h$5 = new T$4(S$3, $$2) : (u$5.__c = h$5 = new x(S$3, $$2), h$5.constructor = T$4, h$5.render = G$2), M$2 && M$2.sub(h$5), h$5.state || (h$5.state = {}), h$5.__n = i$6, p$6 = h$5.__d = !0, h$5.__h = [], h$5._sb = []), C$4 && null == h$5.__s && (h$5.__s = h$5.state), C$4 && null != T$4.getDerivedStateFromProps && (h$5.__s == h$5.state && (h$5.__s = w$4({}, h$5.__s)), w$4(h$5.__s, T$4.getDerivedStateFromProps(S$3, h$5.__s))), y$5 = h$5.props, _$5 = h$5.state, h$5.__v = u$5, p$6) C$4 && null == T$4.getDerivedStateFromProps && null != h$5.componentWillMount && h$5.componentWillMount(), C$4 && null != h$5.componentDidMount && h$5.__h.push(h$5.componentDidMount);
		else {
			if (C$4 && null == T$4.getDerivedStateFromProps && S$3 !== y$5 && null != h$5.componentWillReceiveProps && h$5.componentWillReceiveProps(S$3, $$2), u$5.__v == t$12.__v || !h$5.__e && null != h$5.shouldComponentUpdate && !1 === h$5.shouldComponentUpdate(S$3, h$5.__s, $$2)) {
				u$5.__v != t$12.__v && (h$5.props = S$3, h$5.state = h$5.__s, h$5.__d = !1), u$5.__e = t$12.__e, u$5.__k = t$12.__k, u$5.__k.some(function(n$5) {
					n$5 && (n$5.__ = u$5);
				}), v$3.push.apply(h$5.__h, h$5._sb), h$5._sb = [], h$5.__h.length && e$59.push(h$5);
				break n;
			}
			null != h$5.componentWillUpdate && h$5.componentWillUpdate(S$3, h$5.__s, $$2), C$4 && null != h$5.componentDidUpdate && h$5.__h.push(function() {
				h$5.componentDidUpdate(y$5, _$5, m$5);
			});
		}
		if (h$5.context = $$2, h$5.props = S$3, h$5.__P = n$4, h$5.__e = !1, I$2 = l.__r, A$3 = 0, C$4) h$5.state = h$5.__s, h$5.__d = !1, I$2 && I$2(u$5), a$36 = h$5.render(h$5.props, h$5.state, h$5.context), v$3.push.apply(h$5.__h, h$5._sb), h$5._sb = [];
		else do
			h$5.__d = !1, I$2 && I$2(u$5), a$36 = h$5.render(h$5.props, h$5.state, h$5.context), h$5.state = h$5.__s;
		while (h$5.__d && ++A$3 < 25);
		h$5.state = h$5.__s, null != h$5.getChildContext && (i$6 = w$4(w$4({}, i$6), h$5.getChildContext())), C$4 && !p$6 && null != h$5.getSnapshotBeforeUpdate && (m$5 = h$5.getSnapshotBeforeUpdate(y$5, _$5)), H$3 = null != a$36 && a$36.type === k && null == a$36.key ? q$4(a$36.props.children) : a$36, f$5 = P$2(n$4, d$4(H$3) ? H$3 : [H$3], u$5, t$12, i$6, r$11, o$34, e$59, f$5, c$7, s$4), h$5.base = u$5.__e, u$5.__u &= -161, h$5.__h.length && e$59.push(h$5), b$4 && (h$5.__E = h$5.__ = null);
	} catch (n$5) {
		if (u$5.__v = null, c$7 || null != o$34) if (n$5.then) {
			for (u$5.__u |= c$7 ? 160 : 128; f$5 && 8 == f$5.nodeType && f$5.nextSibling;) f$5 = f$5.nextSibling;
			o$34[o$34.indexOf(f$5)] = null, u$5.__e = f$5;
		} else {
			for (L$3 = o$34.length; L$3--;) g$4(o$34[L$3]);
			N$2(u$5);
		}
		else u$5.__e = t$12.__e, u$5.__k = t$12.__k, n$5.then || N$2(u$5);
		l.__e(n$5, u$5, t$12);
	}
	else null == o$34 && u$5.__v == t$12.__v ? (u$5.__k = t$12.__k, u$5.__e = t$12.__e) : f$5 = u$5.__e = B$3(t$12.__e, u$5, t$12, i$6, r$11, o$34, e$59, c$7, s$4);
	return (a$36 = l.diffed) && a$36(u$5), 128 & u$5.__u ? void 0 : f$5;
}
function N$2(n$4) {
	n$4 && (n$4.__c && (n$4.__c.__e = !0), n$4.__k && n$4.__k.some(N$2));
}
function V$2(n$4, u$5, t$12) {
	for (var i$6 = 0; i$6 < t$12.length; i$6++) D$3(t$12[i$6], t$12[++i$6], t$12[++i$6]);
	l.__c && l.__c(u$5, n$4), n$4.some(function(u$6) {
		try {
			n$4 = u$6.__h, u$6.__h = [], n$4.some(function(n$5) {
				n$5.call(u$6);
			});
		} catch (n$5) {
			l.__e(n$5, u$6.__v);
		}
	});
}
function q$4(n$4) {
	return "object" != typeof n$4 || null == n$4 || n$4.__b > 0 ? n$4 : d$4(n$4) ? n$4.map(q$4) : w$4({}, n$4);
}
function B$3(u$5, t$12, i$6, r$11, o$34, e$59, f$5, c$7, s$4) {
	var a$36, h$5, v$4, y$5, w$5, _$5, m$5, b$4 = i$6.props || p$5, k$4 = t$12.props, x$4 = t$12.type;
	if ("svg" == x$4 ? o$34 = "http://www.w3.org/2000/svg" : "math" == x$4 ? o$34 = "http://www.w3.org/1998/Math/MathML" : o$34 || (o$34 = "http://www.w3.org/1999/xhtml"), null != e$59) {
		for (a$36 = 0; a$36 < e$59.length; a$36++) if ((w$5 = e$59[a$36]) && "setAttribute" in w$5 == !!x$4 && (x$4 ? w$5.localName == x$4 : 3 == w$5.nodeType)) {
			u$5 = w$5, e$59[a$36] = null;
			break;
		}
	}
	if (null == u$5) {
		if (null == x$4) return document.createTextNode(k$4);
		u$5 = document.createElementNS(o$34, x$4, k$4.is && k$4), c$7 && (l.__m && l.__m(t$12, e$59), c$7 = !1), e$59 = null;
	}
	if (null == x$4) b$4 === k$4 || c$7 && u$5.data == k$4 || (u$5.data = k$4);
	else {
		if (e$59 = e$59 && n$3.call(u$5.childNodes), !c$7 && null != e$59) for (b$4 = {}, a$36 = 0; a$36 < u$5.attributes.length; a$36++) b$4[(w$5 = u$5.attributes[a$36]).name] = w$5.value;
		for (a$36 in b$4) w$5 = b$4[a$36], "dangerouslySetInnerHTML" == a$36 ? v$4 = w$5 : "children" == a$36 || a$36 in k$4 || "value" == a$36 && "defaultValue" in k$4 || "checked" == a$36 && "defaultChecked" in k$4 || F$3(u$5, a$36, null, w$5, o$34);
		for (a$36 in k$4) w$5 = k$4[a$36], "children" == a$36 ? y$5 = w$5 : "dangerouslySetInnerHTML" == a$36 ? h$5 = w$5 : "value" == a$36 ? _$5 = w$5 : "checked" == a$36 ? m$5 = w$5 : c$7 && "function" != typeof w$5 || b$4[a$36] === w$5 || F$3(u$5, a$36, w$5, b$4[a$36], o$34);
		if (h$5) c$7 || v$4 && (h$5.__html == v$4.__html || h$5.__html == u$5.innerHTML) || (u$5.innerHTML = h$5.__html), t$12.__k = [];
		else if (v$4 && (u$5.innerHTML = ""), P$2("template" == t$12.type ? u$5.content : u$5, d$4(y$5) ? y$5 : [y$5], t$12, i$6, r$11, "foreignObject" == x$4 ? "http://www.w3.org/1999/xhtml" : o$34, e$59, f$5, e$59 ? e$59[0] : i$6.__k && S$2(i$6, 0), c$7, s$4), null != e$59) for (a$36 = e$59.length; a$36--;) g$4(e$59[a$36]);
		c$7 || (a$36 = "value", "progress" == x$4 && null == _$5 ? u$5.removeAttribute("value") : null != _$5 && (_$5 !== u$5[a$36] || "progress" == x$4 && !_$5 || "option" == x$4 && _$5 != b$4[a$36]) && F$3(u$5, a$36, _$5, b$4[a$36], o$34), a$36 = "checked", null != m$5 && m$5 != u$5[a$36] && F$3(u$5, a$36, m$5, b$4[a$36], o$34));
	}
	return u$5;
}
function D$3(n$4, u$5, t$12) {
	try {
		if ("function" == typeof n$4) {
			var i$6 = "function" == typeof n$4.__u;
			i$6 && n$4.__u(), i$6 && null == u$5 || (n$4.__u = n$4(u$5));
		} else n$4.current = u$5;
	} catch (n$5) {
		l.__e(n$5, t$12);
	}
}
function E$3(n$4, u$5, t$12) {
	var i$6, r$11;
	if (l.unmount && l.unmount(n$4), (i$6 = n$4.ref) && (i$6.current && i$6.current != n$4.__e || D$3(i$6, null, u$5)), null != (i$6 = n$4.__c)) {
		if (i$6.componentWillUnmount) try {
			i$6.componentWillUnmount();
		} catch (n$5) {
			l.__e(n$5, u$5);
		}
		i$6.base = i$6.__P = null;
	}
	if (i$6 = n$4.__k) for (r$11 = 0; r$11 < i$6.length; r$11++) i$6[r$11] && E$3(i$6[r$11], u$5, t$12 || "function" != typeof n$4.type);
	t$12 || g$4(n$4.__e), n$4.__c = n$4.__ = n$4.__e = void 0;
}
function G$2(n$4, l$10, u$5) {
	return this.constructor(n$4, u$5);
}
function J(u$5, t$12, i$6) {
	var r$11, o$34, e$59, f$5;
	t$12 == document && (t$12 = document.documentElement), l.__ && l.__(u$5, t$12), o$34 = (r$11 = "function" == typeof i$6) ? null : i$6 && i$6.__k || t$12.__k, e$59 = [], f$5 = [], z$2(t$12, u$5 = (!r$11 && i$6 || t$12).__k = _(k, null, [u$5]), o$34 || p$5, p$5, t$12.namespaceURI, !r$11 && i$6 ? [i$6] : o$34 ? null : t$12.firstChild ? n$3.call(t$12.childNodes) : null, e$59, !r$11 && i$6 ? i$6 : o$34 ? o$34.__e : t$12.firstChild, r$11, f$5), V$2(e$59, u$5, f$5);
}
function R(n$4) {
	function l$10(n$5) {
		var u$5, t$12;
		return this.getChildContext || (u$5 = /* @__PURE__ */ new Set(), (t$12 = {})[l$10.__c] = this, this.getChildContext = function() {
			return t$12;
		}, this.componentWillUnmount = function() {
			u$5 = null;
		}, this.shouldComponentUpdate = function(n$6) {
			this.props.value != n$6.value && u$5.forEach(function(n$7) {
				n$7.__e = !0, $$1(n$7);
			});
		}, this.sub = function(n$6) {
			u$5.add(n$6);
			var l$11 = n$6.componentWillUnmount;
			n$6.componentWillUnmount = function() {
				u$5 && u$5.delete(n$6), l$11 && l$11.call(n$6);
			};
		}), n$5.children;
	}
	return l$10.__c = "__cC" + h$4++, l$10.__ = n$4, l$10.Provider = l$10.__l = (l$10.Consumer = function(n$5, l$11) {
		return n$5.children(l$11);
	}).contextType = l$10, l$10;
}
n$3 = v$3.slice, l = { __e: function(n$4, l$10, u$5, t$12) {
	for (var i$6, r$11, o$34; l$10 = l$10.__;) if ((i$6 = l$10.__c) && !i$6.__) try {
		if ((r$11 = i$6.constructor) && null != r$11.getDerivedStateFromError && (i$6.setState(r$11.getDerivedStateFromError(n$4)), o$34 = i$6.__d), null != i$6.componentDidCatch && (i$6.componentDidCatch(n$4, t$12 || {}), o$34 = i$6.__d), o$34) return i$6.__E = i$6;
	} catch (l$11) {
		n$4 = l$11;
	}
	throw n$4;
} }, u$4 = 0, t$9 = function(n$4) {
	return null != n$4 && void 0 === n$4.constructor;
}, x.prototype.setState = function(n$4, l$10) {
	var u$5 = null != this.__s && this.__s != this.state ? this.__s : this.__s = w$4({}, this.state);
	"function" == typeof n$4 && (n$4 = n$4(w$4({}, u$5), this.props)), n$4 && w$4(u$5, n$4), null != n$4 && this.__v && (l$10 && this._sb.push(l$10), $$1(this));
}, x.prototype.forceUpdate = function(n$4) {
	this.__v && (this.__e = !0, n$4 && this.__h.push(n$4), $$1(this));
}, x.prototype.render = k, i$5 = [], o$33 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, e$58 = function(n$4, l$10) {
	return n$4.__v.__b - l$10.__v.__b;
}, I$1.__r = 0, f$4 = /(PointerCapture)$|Capture$/i, c$6 = 0, s$3 = O$2(!1), a$35 = O$2(!0), h$4 = 0;
var t$11, r$9, u$3, i$4, o$32 = 0, f$3 = [], c$5 = l, e$57 = c$5.__b, a$34 = c$5.__r, v$2 = c$5.diffed, l$9 = c$5.__c, m$3 = c$5.unmount, s$2 = c$5.__;
function p$4(n$4, t$12) {
	c$5.__h && c$5.__h(r$9, n$4, o$32 || t$12), o$32 = 0;
	var u$5 = r$9.__H || (r$9.__H = {
		__: [],
		__h: []
	});
	return n$4 >= u$5.__.length && u$5.__.push({}), u$5.__[n$4];
}
function d(n$4) {
	return o$32 = 1, h$3(D$2, n$4);
}
function h$3(n$4, u$5, i$6) {
	var o$34 = p$4(t$11++, 2);
	if (o$34.t = n$4, !o$34.__c && (o$34.__ = [i$6 ? i$6(u$5) : D$2(void 0, u$5), function(n$5) {
		var t$12 = o$34.__N ? o$34.__N[0] : o$34.__[0], r$11 = o$34.t(t$12, n$5);
		t$12 !== r$11 && (o$34.__N = [r$11, o$34.__[1]], o$34.__c.setState({}));
	}], o$34.__c = r$9, !r$9.__f)) {
		var f$5 = function(n$5, t$12, r$11) {
			if (!o$34.__c.__H) return !0;
			var u$6 = o$34.__c.__H.__.filter(function(n$6) {
				return n$6.__c;
			});
			if (u$6.every(function(n$6) {
				return !n$6.__N;
			})) return !c$7 || c$7.call(this, n$5, t$12, r$11);
			var i$7 = o$34.__c.props !== n$5;
			return u$6.some(function(n$6) {
				if (n$6.__N) {
					var t$13 = n$6.__[0];
					n$6.__ = n$6.__N, n$6.__N = void 0, t$13 !== n$6.__[0] && (i$7 = !0);
				}
			}), c$7 && c$7.call(this, n$5, t$12, r$11) || i$7;
		};
		r$9.__f = !0;
		var c$7 = r$9.shouldComponentUpdate, e$59 = r$9.componentWillUpdate;
		r$9.componentWillUpdate = function(n$5, t$12, r$11) {
			if (this.__e) {
				var u$6 = c$7;
				c$7 = void 0, f$5(n$5, t$12, r$11), c$7 = u$6;
			}
			e$59 && e$59.call(this, n$5, t$12, r$11);
		}, r$9.shouldComponentUpdate = f$5;
	}
	return o$34.__N || o$34.__;
}
function y(n$4, u$5) {
	var i$6 = p$4(t$11++, 3);
	!c$5.__s && C$2(i$6.__H, u$5) && (i$6.__ = n$4, i$6.u = u$5, r$9.__H.__h.push(i$6));
}
function _$1(n$4, u$5) {
	var i$6 = p$4(t$11++, 4);
	!c$5.__s && C$2(i$6.__H, u$5) && (i$6.__ = n$4, i$6.u = u$5, r$9.__h.push(i$6));
}
function A(n$4) {
	return o$32 = 5, T(function() {
		return { current: n$4 };
	}, []);
}
function T(n$4, r$11) {
	var u$5 = p$4(t$11++, 7);
	return C$2(u$5.__H, r$11) && (u$5.__ = n$4(), u$5.__H = r$11, u$5.__h = n$4), u$5.__;
}
function q(n$4, t$12) {
	return o$32 = 8, T(function() {
		return n$4;
	}, t$12);
}
function x$3(n$4) {
	var u$5 = r$9.context[n$4.__c], i$6 = p$4(t$11++, 9);
	return i$6.c = n$4, u$5 ? (i$6.__ ?? (i$6.__ = !0, u$5.sub(r$9)), u$5.props.value) : n$4.__;
}
function j$2() {
	for (var n$4; n$4 = f$3.shift();) {
		var t$12 = n$4.__H;
		if (n$4.__P && t$12) try {
			t$12.__h.some(z$1), t$12.__h.some(B$2), t$12.__h = [];
		} catch (r$11) {
			t$12.__h = [], c$5.__e(r$11, n$4.__v);
		}
	}
}
c$5.__b = function(n$4) {
	r$9 = null, e$57 && e$57(n$4);
}, c$5.__ = function(n$4, t$12) {
	n$4 && t$12.__k && t$12.__k.__m && (n$4.__m = t$12.__k.__m), s$2 && s$2(n$4, t$12);
}, c$5.__r = function(n$4) {
	a$34 && a$34(n$4), t$11 = 0;
	var i$6 = (r$9 = n$4.__c).__H;
	i$6 && (u$3 === r$9 ? (i$6.__h = [], r$9.__h = [], i$6.__.some(function(n$5) {
		n$5.__N && (n$5.__ = n$5.__N), n$5.u = n$5.__N = void 0;
	})) : (i$6.__h.some(z$1), i$6.__h.some(B$2), i$6.__h = [], t$11 = 0)), u$3 = r$9;
}, c$5.diffed = function(n$4) {
	v$2 && v$2(n$4);
	var t$12 = n$4.__c;
	t$12 && t$12.__H && (t$12.__H.__h.length && (1 !== f$3.push(t$12) && i$4 === c$5.requestAnimationFrame || ((i$4 = c$5.requestAnimationFrame) || w$3)(j$2)), t$12.__H.__.some(function(n$5) {
		n$5.u && (n$5.__H = n$5.u), n$5.u = void 0;
	})), u$3 = r$9 = null;
}, c$5.__c = function(n$4, t$12) {
	t$12.some(function(n$5) {
		try {
			n$5.__h.some(z$1), n$5.__h = n$5.__h.filter(function(n$6) {
				return !n$6.__ || B$2(n$6);
			});
		} catch (r$11) {
			t$12.some(function(n$6) {
				n$6.__h && (n$6.__h = []);
			}), t$12 = [], c$5.__e(r$11, n$5.__v);
		}
	}), l$9 && l$9(n$4, t$12);
}, c$5.unmount = function(n$4) {
	m$3 && m$3(n$4);
	var t$12, r$11 = n$4.__c;
	r$11 && r$11.__H && (r$11.__H.__.some(function(n$5) {
		try {
			z$1(n$5);
		} catch (n$6) {
			t$12 = n$6;
		}
	}), r$11.__H = void 0, t$12 && c$5.__e(t$12, r$11.__v));
};
var k$3 = "function" == typeof requestAnimationFrame;
function w$3(n$4) {
	var t$12, r$11 = function() {
		clearTimeout(u$5), k$3 && cancelAnimationFrame(t$12), setTimeout(n$4);
	}, u$5 = setTimeout(r$11, 35);
	k$3 && (t$12 = requestAnimationFrame(r$11));
}
function z$1(n$4) {
	var t$12 = r$9, u$5 = n$4.__c;
	"function" == typeof u$5 && (n$4.__c = void 0, u$5()), r$9 = t$12;
}
function B$2(n$4) {
	var t$12 = r$9;
	n$4.__c = n$4.__(), r$9 = t$12;
}
function C$2(n$4, t$12) {
	return !n$4 || n$4.length !== t$12.length || t$12.some(function(t$13, r$11) {
		return t$13 !== n$4[r$11];
	});
}
function D$2(n$4, t$12) {
	return "function" == typeof t$12 ? t$12(n$4) : t$12;
}
var i$3 = Symbol.for("preact-signals");
function t$10() {
	if (!(s$1 > 1)) {
		var i$6, t$12 = !1;
		while (void 0 !== h$2) {
			var n$4 = h$2;
			h$2 = void 0;
			v$1++;
			while (void 0 !== n$4) {
				var r$11 = n$4.o;
				n$4.o = void 0;
				n$4.f &= -3;
				if (!(8 & n$4.f) && a$33(n$4)) try {
					n$4.c();
				} catch (n$5) {
					if (!t$12) {
						i$6 = n$5;
						t$12 = !0;
					}
				}
				n$4 = r$11;
			}
		}
		v$1 = 0;
		s$1--;
		if (t$12) throw i$6;
	} else s$1--;
}
function n(i$6) {
	if (s$1 > 0) return i$6();
	s$1++;
	try {
		return i$6();
	} finally {
		t$10();
	}
}
var r$8 = void 0;
function o$24(i$6) {
	var t$12 = r$8;
	r$8 = void 0;
	try {
		return i$6();
	} finally {
		r$8 = t$12;
	}
}
var f$2, h$2 = void 0, s$1 = 0, v$1 = 0, u$2 = 0;
function e$56(i$6) {
	if (void 0 !== r$8) {
		var t$12 = i$6.n;
		if (void 0 === t$12 || t$12.t !== r$8) {
			t$12 = {
				i: 0,
				S: i$6,
				p: r$8.s,
				n: void 0,
				t: r$8,
				e: void 0,
				x: void 0,
				r: t$12
			};
			if (void 0 !== r$8.s) r$8.s.n = t$12;
			r$8.s = t$12;
			i$6.n = t$12;
			if (32 & r$8.f) i$6.S(t$12);
			return t$12;
		} else if (-1 === t$12.i) {
			t$12.i = 0;
			if (void 0 !== t$12.n) {
				t$12.n.p = t$12.p;
				if (void 0 !== t$12.p) t$12.p.n = t$12.n;
				t$12.p = r$8.s;
				t$12.n = void 0;
				r$8.s.n = t$12;
				r$8.s = t$12;
			}
			return t$12;
		}
	}
}
function d$2(i$6, t$12) {
	this.v = i$6;
	this.i = 0;
	this.n = void 0;
	this.t = void 0;
	this.W = null == t$12 ? void 0 : t$12.watched;
	this.Z = null == t$12 ? void 0 : t$12.unwatched;
	this.name = null == t$12 ? void 0 : t$12.name;
}
d$2.prototype.brand = i$3;
d$2.prototype.h = function() {
	return !0;
};
d$2.prototype.S = function(i$6) {
	var t$12 = this, n$4 = this.t;
	if (n$4 !== i$6 && void 0 === i$6.e) {
		i$6.x = n$4;
		this.t = i$6;
		if (void 0 !== n$4) n$4.e = i$6;
		else o$24(function() {
			var i$7;
			null == (i$7 = t$12.W) || i$7.call(t$12);
		});
	}
};
d$2.prototype.U = function(i$6) {
	var t$12 = this;
	if (void 0 !== this.t) {
		var n$4 = i$6.e, r$11 = i$6.x;
		if (void 0 !== n$4) {
			n$4.x = r$11;
			i$6.e = void 0;
		}
		if (void 0 !== r$11) {
			r$11.e = n$4;
			i$6.x = void 0;
		}
		if (i$6 === this.t) {
			this.t = r$11;
			if (void 0 === r$11) o$24(function() {
				var i$7;
				null == (i$7 = t$12.Z) || i$7.call(t$12);
			});
		}
	}
};
d$2.prototype.subscribe = function(i$6) {
	var t$12 = this;
	return m(function() {
		var n$4 = t$12.value, o$34 = r$8;
		r$8 = void 0;
		try {
			i$6(n$4);
		} finally {
			r$8 = o$34;
		}
	}, { name: "sub" });
};
d$2.prototype.valueOf = function() {
	return this.value;
};
d$2.prototype.toString = function() {
	return this.value + "";
};
d$2.prototype.toJSON = function() {
	return this.value;
};
d$2.prototype.peek = function() {
	var i$6 = r$8;
	r$8 = void 0;
	try {
		return this.value;
	} finally {
		r$8 = i$6;
	}
};
Object.defineProperty(d$2.prototype, "value", {
	get: function() {
		var i$6 = e$56(this);
		if (void 0 !== i$6) i$6.i = this.i;
		return this.v;
	},
	set: function(i$6) {
		if (i$6 !== this.v) {
			if (v$1 > 100) throw new Error("Cycle detected");
			this.v = i$6;
			this.i++;
			u$2++;
			s$1++;
			try {
				for (var n$4 = this.t; void 0 !== n$4; n$4 = n$4.x) n$4.t.N();
			} finally {
				t$10();
			}
		}
	}
});
function c$3(i$6, t$12) {
	return new d$2(i$6, t$12);
}
function a$33(i$6) {
	for (var t$12 = i$6.s; void 0 !== t$12; t$12 = t$12.n) if (t$12.S.i !== t$12.i || !t$12.S.h() || t$12.S.i !== t$12.i) return !0;
	return !1;
}
function l$8(i$6) {
	for (var t$12 = i$6.s; void 0 !== t$12; t$12 = t$12.n) {
		var n$4 = t$12.S.n;
		if (void 0 !== n$4) t$12.r = n$4;
		t$12.S.n = t$12;
		t$12.i = -1;
		if (void 0 === t$12.n) {
			i$6.s = t$12;
			break;
		}
	}
}
function y$3(i$6) {
	var t$12 = i$6.s, n$4 = void 0;
	while (void 0 !== t$12) {
		var r$11 = t$12.p;
		if (-1 === t$12.i) {
			t$12.S.U(t$12);
			if (void 0 !== r$11) r$11.n = t$12.n;
			if (void 0 !== t$12.n) t$12.n.p = r$11;
		} else n$4 = t$12;
		t$12.S.n = t$12.r;
		if (void 0 !== t$12.r) t$12.r = void 0;
		t$12 = r$11;
	}
	i$6.s = n$4;
}
function w$2(i$6, t$12) {
	d$2.call(this, void 0);
	this.x = i$6;
	this.s = void 0;
	this.g = u$2 - 1;
	this.f = 4;
	this.W = null == t$12 ? void 0 : t$12.watched;
	this.Z = null == t$12 ? void 0 : t$12.unwatched;
	this.name = null == t$12 ? void 0 : t$12.name;
}
w$2.prototype = new d$2();
w$2.prototype.h = function() {
	this.f &= -3;
	if (1 & this.f) return !1;
	if (32 == (36 & this.f)) return !0;
	this.f &= -5;
	if (this.g === u$2) return !0;
	this.g = u$2;
	this.f |= 1;
	if (this.i > 0 && !a$33(this)) {
		this.f &= -2;
		return !0;
	}
	var i$6 = r$8;
	try {
		l$8(this);
		r$8 = this;
		var t$12 = this.x();
		if (16 & this.f || this.v !== t$12 || 0 === this.i) {
			this.v = t$12;
			this.f &= -17;
			this.i++;
		}
	} catch (i$7) {
		this.v = i$7;
		this.f |= 16;
		this.i++;
	}
	r$8 = i$6;
	y$3(this);
	this.f &= -2;
	return !0;
};
w$2.prototype.S = function(i$6) {
	if (void 0 === this.t) {
		this.f |= 36;
		for (var t$12 = this.s; void 0 !== t$12; t$12 = t$12.n) t$12.S.S(t$12);
	}
	d$2.prototype.S.call(this, i$6);
};
w$2.prototype.U = function(i$6) {
	if (void 0 !== this.t) {
		d$2.prototype.U.call(this, i$6);
		if (void 0 === this.t) {
			this.f &= -33;
			for (var t$12 = this.s; void 0 !== t$12; t$12 = t$12.n) t$12.S.U(t$12);
		}
	}
};
w$2.prototype.N = function() {
	if (!(2 & this.f)) {
		this.f |= 6;
		for (var i$6 = this.t; void 0 !== i$6; i$6 = i$6.x) i$6.t.N();
	}
};
Object.defineProperty(w$2.prototype, "value", { get: function() {
	if (1 & this.f) throw new Error("Cycle detected");
	var i$6 = e$56(this);
	this.h();
	if (void 0 !== i$6) i$6.i = this.i;
	if (16 & this.f) throw this.v;
	return this.v;
} });
function b(i$6, t$12) {
	return new w$2(i$6, t$12);
}
function _$4(i$6) {
	var n$4 = i$6.u;
	i$6.u = void 0;
	if ("function" == typeof n$4) {
		s$1++;
		var o$34 = r$8;
		r$8 = void 0;
		try {
			n$4();
		} catch (t$12) {
			i$6.f &= -2;
			i$6.f |= 8;
			p$3(i$6);
			throw t$12;
		} finally {
			r$8 = o$34;
			t$10();
		}
	}
}
function p$3(i$6) {
	for (var t$12 = i$6.s; void 0 !== t$12; t$12 = t$12.n) t$12.S.U(t$12);
	i$6.x = void 0;
	i$6.s = void 0;
	_$4(i$6);
}
function g$3(i$6) {
	if (r$8 !== this) throw new Error("Out-of-order effect");
	y$3(this);
	r$8 = i$6;
	this.f &= -2;
	if (8 & this.f) p$3(this);
	t$10();
}
function S$1(i$6, t$12) {
	this.x = i$6;
	this.u = void 0;
	this.s = void 0;
	this.o = void 0;
	this.f = 32;
	this.name = null == t$12 ? void 0 : t$12.name;
	if (f$2) f$2.push(this);
}
S$1.prototype.c = function() {
	var i$6 = this.S();
	try {
		if (8 & this.f) return;
		if (void 0 === this.x) return;
		var t$12 = this.x();
		if ("function" == typeof t$12) this.u = t$12;
	} finally {
		i$6();
	}
};
S$1.prototype.S = function() {
	if (1 & this.f) throw new Error("Cycle detected");
	this.f |= 1;
	this.f &= -9;
	_$4(this);
	l$8(this);
	s$1++;
	var i$6 = r$8;
	r$8 = this;
	return g$3.bind(this, i$6);
};
S$1.prototype.N = function() {
	if (!(2 & this.f)) {
		this.f |= 2;
		this.o = h$2;
		h$2 = this;
	}
};
S$1.prototype.d = function() {
	this.f |= 8;
	if (!(1 & this.f)) p$3(this);
};
S$1.prototype.dispose = function() {
	this.d();
};
function m(i$6, t$12) {
	var n$4 = new S$1(i$6, t$12);
	try {
		n$4.c();
	} catch (i$7) {
		n$4.d();
		throw i$7;
	}
	var r$11 = n$4.d.bind(n$4);
	r$11[Symbol.dispose] = r$11;
	return r$11;
}
var l$7, d$3, h$1, p$2 = "undefined" != typeof window && !!window.__PREACT_SIGNALS_DEVTOOLS__, _$3 = [];
m(function() {
	l$7 = this.N;
})();
function g$2(i$6, r$11) {
	l[i$6] = r$11.bind(null, l[i$6] || function() {});
}
function b$3(i$6) {
	if (h$1) {
		var n$4 = h$1;
		h$1 = void 0;
		n$4();
	}
	h$1 = i$6 && i$6.S();
}
function y$2(i$6) {
	var n$4 = this, t$12 = i$6.data, f$5 = useSignal(t$12);
	f$5.value = t$12;
	var e$59 = T(function() {
		var i$7 = n$4, t$13 = n$4.__v;
		while (t$13 = t$13.__) if (t$13.__c) {
			t$13.__c.__$f |= 4;
			break;
		}
		var o$34 = b(function() {
			var i$8 = f$5.value.value;
			return 0 === i$8 ? 0 : !0 === i$8 ? "" : i$8 || "";
		}), e$60 = b(function() {
			return !Array.isArray(o$34.value) && !t$9(o$34.value);
		}), a$37 = m(function() {
			this.N = F$2;
			if (e$60.value) {
				var n$5 = o$34.value;
				if (i$7.__v && i$7.__v.__e && 3 === i$7.__v.__e.nodeType) i$7.__v.__e.data = n$5;
			}
		}), v$5 = n$4.__$u.d;
		n$4.__$u.d = function() {
			a$37();
			v$5.call(this);
		};
		return [e$60, o$34];
	}, []), a$36 = e$59[0], v$4 = e$59[1];
	return a$36.value ? v$4.peek() : v$4.value;
}
y$2.displayName = "ReactiveTextNode";
Object.defineProperties(d$2.prototype, {
	constructor: {
		configurable: !0,
		value: void 0
	},
	type: {
		configurable: !0,
		value: y$2
	},
	props: {
		configurable: !0,
		get: function() {
			return { data: this };
		}
	},
	__b: {
		configurable: !0,
		value: 1
	}
});
g$2("__b", function(i$6, n$4) {
	if ("string" == typeof n$4.type) {
		var r$11, t$12 = n$4.props;
		for (var o$34 in t$12) if ("children" !== o$34) {
			var f$5 = t$12[o$34];
			if (f$5 instanceof d$2) {
				if (!r$11) n$4.__np = r$11 = {};
				r$11[o$34] = f$5;
				t$12[o$34] = f$5.peek();
			}
		}
	}
	i$6(n$4);
});
g$2("__r", function(i$6, n$4) {
	i$6(n$4);
	if (n$4.type !== k) {
		b$3();
		var r$11, o$34 = n$4.__c;
		if (o$34) {
			o$34.__$f &= -2;
			if (void 0 === (r$11 = o$34.__$u)) o$34.__$u = r$11 = function(i$7, n$5) {
				var r$12;
				m(function() {
					r$12 = this;
				}, { name: n$5 });
				r$12.c = i$7;
				return r$12;
			}(function() {
				var i$7;
				if (p$2) null == (i$7 = r$11.y) || i$7.call(r$11);
				o$34.__$f |= 1;
				o$34.setState({});
			}, "function" == typeof n$4.type ? n$4.type.displayName || n$4.type.name : "");
		}
		d$3 = o$34;
		b$3(r$11);
	}
});
g$2("__e", function(i$6, n$4, r$11, t$12) {
	b$3();
	d$3 = void 0;
	i$6(n$4, r$11, t$12);
});
g$2("diffed", function(i$6, n$4) {
	b$3();
	d$3 = void 0;
	var r$11;
	if ("string" == typeof n$4.type && (r$11 = n$4.__e)) {
		var t$12 = n$4.__np, o$34 = n$4.props;
		if (t$12) {
			var f$5 = r$11.U;
			if (f$5) for (var e$59 in f$5) {
				var u$5 = f$5[e$59];
				if (void 0 !== u$5 && !(e$59 in t$12)) {
					u$5.d();
					f$5[e$59] = void 0;
				}
			}
			else {
				f$5 = {};
				r$11.U = f$5;
			}
			for (var a$36 in t$12) {
				var c$7 = f$5[a$36], v$4 = t$12[a$36];
				if (void 0 === c$7) {
					c$7 = w$1(r$11, a$36, v$4);
					f$5[a$36] = c$7;
				} else c$7.o(v$4, o$34);
			}
			for (var s$4 in t$12) o$34[s$4] = t$12[s$4];
		}
	}
	i$6(n$4);
});
function w$1(i$6, n$4, r$11, t$12) {
	var o$34 = n$4 in i$6 && void 0 === i$6.ownerSVGElement, f$5 = c$3(r$11), e$59 = r$11.peek();
	return {
		o: function(i$7, n$5) {
			f$5.value = i$7;
			e$59 = i$7.peek();
		},
		d: m(function() {
			this.N = F$2;
			var r$12 = f$5.value.value;
			if (e$59 !== r$12) {
				e$59 = void 0;
				if (o$34) i$6[n$4] = r$12;
				else if (null != r$12 && (!1 !== r$12 || "-" === n$4[4])) i$6.setAttribute(n$4, r$12);
				else i$6.removeAttribute(n$4);
			} else e$59 = void 0;
		})
	};
}
g$2("unmount", function(i$6, n$4) {
	if ("string" == typeof n$4.type) {
		var r$11 = n$4.__e;
		if (r$11) {
			var t$12 = r$11.U;
			if (t$12) {
				r$11.U = void 0;
				for (var o$34 in t$12) {
					var f$5 = t$12[o$34];
					if (f$5) f$5.d();
				}
			}
		}
		n$4.__np = void 0;
	} else {
		var e$59 = n$4.__c;
		if (e$59) {
			var u$5 = e$59.__$u;
			if (u$5) {
				e$59.__$u = void 0;
				u$5.d();
			}
		}
	}
	i$6(n$4);
});
g$2("__h", function(i$6, n$4, r$11, t$12) {
	if (t$12 < 3 || 9 === t$12) n$4.__$f |= 2;
	i$6(n$4, r$11, t$12);
});
x.prototype.shouldComponentUpdate = function(i$6, n$4) {
	if (this.__R) return !0;
	var r$11 = this.__$u, t$12 = r$11 && void 0 !== r$11.s;
	for (var o$34 in n$4) return !0;
	if (this.__f || "boolean" == typeof this.u && !0 === this.u) {
		var f$5 = 2 & this.__$f;
		if (!(t$12 || f$5 || 4 & this.__$f)) return !0;
		if (1 & this.__$f) return !0;
	} else {
		if (!(t$12 || 4 & this.__$f)) return !0;
		if (3 & this.__$f) return !0;
	}
	for (var e$59 in i$6) if ("__source" !== e$59 && i$6[e$59] !== this.props[e$59]) return !0;
	for (var u$5 in this.props) if (!(u$5 in i$6)) return !0;
	return !1;
};
function useSignal(i$6, n$4) {
	return T(function() {
		return c$3(i$6, n$4);
	}, []);
}
function useComputed(i$6, n$4) {
	var r$11 = A(i$6);
	r$11.current = i$6;
	d$3.__$f |= 4;
	return T(function() {
		return b(function() {
			return r$11.current();
		}, n$4);
	}, []);
}
"undefined" == typeof requestAnimationFrame && setTimeout;
var q$3 = function(i$6) {
	queueMicrotask(function() {
		queueMicrotask(i$6);
	});
};
function x$2() {
	n(function() {
		var i$6;
		while (i$6 = _$3.shift()) l$7.call(i$6);
	});
}
function F$2() {
	if (1 === _$3.push(this)) (l.requestAnimationFrame || q$3)(x$2);
}
var Node = class {
	value;
	level;
	width;
	next;
	constructor(value, level) {
		this.value = value;
		this.level = level;
		this.width = new Array(this.level).fill(value && value.length || 0);
		this.next = new Array(this.level).fill(null);
	}
	get length() {
		return this.width[0];
	}
};
var SkipString = class SkipString {
	levels;
	bias;
	head;
	chunkSize;
	constructor(o$34 = {}) {
		this.levels = o$34.levels || 11;
		this.bias = o$34.bias || 1 / Math.E;
		this.head = new Node(null, this.levels);
		this.chunkSize = o$34.chunkSize || 5e3;
	}
	get length() {
		return this.head.width[this.levels - 1];
	}
	get(offset) {
		return this.search(offset, true);
	}
	set(text) {
		if (this.length > 0) this.remove([0, this.length]);
		this.insertChunked(0, text);
	}
	search(offset, incl) {
		const inclValue = incl ? .1 : 0;
		const steps = new Array(this.levels);
		const width = new Array(this.levels);
		let i$6 = this.levels;
		let node = this.head;
		while (i$6--) {
			while (offset + inclValue > node.width[i$6] && node.next[i$6] !== null) {
				offset -= node.width[i$6];
				node = node.next[i$6];
			}
			steps[i$6] = node;
			width[i$6] = offset;
		}
		return {
			node,
			steps,
			width,
			offset
		};
	}
	splice(s$4, offset, value, level) {
		const steps = s$4.steps;
		const width = s$4.width;
		let p$6;
		let q$5;
		let len;
		level = level || this.randomLevel();
		q$5 = new Node(value, level);
		len = q$5.width[0];
		let i$6;
		i$6 = level;
		while (i$6--) {
			p$6 = steps[i$6];
			q$5.next[i$6] = p$6.next[i$6];
			p$6.next[i$6] = q$5;
			q$5.width[i$6] = p$6.width[i$6] - width[i$6] + len;
			p$6.width[i$6] = width[i$6];
		}
		i$6 = this.levels;
		while (i$6-- > level) {
			p$6 = steps[i$6];
			p$6.width[i$6] += len;
		}
		return q$5;
	}
	insert(offset, value, level) {
		const s$4 = this.search(offset);
		if (s$4.offset && s$4.node.value && s$4.offset < s$4.node.value.length) {
			this.update(s$4, insert(s$4.offset, s$4.node.value, value));
			return s$4.node;
		}
		return this.splice(s$4, offset, value, level);
	}
	update(s$4, value) {
		const length = (s$4.node.value?.length || 0) - value.length;
		s$4.node.value = value;
		let i$6 = this.levels;
		while (i$6--) s$4.steps[i$6].width[i$6] -= length;
		return length;
	}
	remove(range) {
		if (range[1] > this.length) throw new Error(`range end over maximum length(${this.length}): [${range.join()}]`);
		let x$4 = range[1] - range[0];
		const s$4 = this.search(range[0]);
		let offset = s$4.offset;
		const steps = s$4.steps;
		let node = s$4.node;
		if (this.head === node) node = node.next[0];
		if (!node) return;
		if (offset) {
			if (offset < node.width[0]) x$4 -= this.update(s$4, node.value.slice(0, offset) + node.value.slice(offset + Math.min(x$4, node.length - offset)));
			node = node.next[0];
			if (!node) return;
		}
		while (node && x$4 >= node.width[0]) {
			x$4 -= this.removeNode(steps, node);
			node = node.next[0];
		}
		if (x$4 && node) this.replace(steps, node, node.value.slice(x$4));
	}
	removeNode(steps, node) {
		const length = node.width[0];
		let i$6 = node.level;
		while (i$6--) {
			steps[i$6].width[i$6] -= length - node.width[i$6];
			steps[i$6].next[i$6] = node.next[i$6];
		}
		i$6 = this.levels;
		while (i$6-- > node.level) steps[i$6].width[i$6] -= length;
		return length;
	}
	replace(steps, node, value) {
		const length = (node.value?.length || 0) - value.length;
		node.value = value;
		let i$6 = node.level;
		while (i$6--) node.width[i$6] -= length;
		i$6 = this.levels;
		while (i$6-- > node.level) steps[i$6].width[i$6] -= length;
		return length;
	}
	removeCharAt(offset) {
		this.remove([offset, offset + 1]);
	}
	insertChunked(offset, text) {
		let currentOffset = offset;
		for (let i$6 = 0; i$6 < text.length; i$6 += this.chunkSize) {
			const chunk = text.slice(i$6, i$6 + this.chunkSize);
			this.insert(currentOffset, chunk);
			currentOffset += chunk.length;
		}
	}
	substring(a$36, b$4) {
		const length = b$4 - a$36;
		const search = this.search(a$36, true);
		let node = search.node;
		if (this.head === node) node = node.next[0];
		if (!node) return "";
		let d$5 = length + search.offset;
		let s$4 = "";
		while (node && d$5 >= 0) {
			d$5 -= node.width[0];
			s$4 += node.value;
			node = node.next[0];
		}
		if (node) s$4 += node.value;
		return s$4.slice(search.offset, search.offset + length);
	}
	randomLevel() {
		let level = 1;
		while (level < this.levels - 1 && Math.random() < this.bias) level++;
		return level;
	}
	getRange(range) {
		return this.substring(range[0], range[1]);
	}
	copy() {
		const copy = new SkipString();
		let node = this.head;
		let offset = 0;
		while (node = node.next[0]) {
			copy.insert(offset, node.value);
			offset += node.width[0];
		}
		return copy;
	}
	joinString(delimiter) {
		const parts = [];
		let node = this.head;
		while (node = node.next[0]) parts.push(node.value);
		return parts.join(delimiter);
	}
	toString() {
		return this.substring(0, this.length);
	}
};
function insert(offset, string, part) {
	return string.slice(0, offset) + part + string.slice(offset);
}
let BufferOpType = /* @__PURE__ */ function(BufferOpType$1) {
	BufferOpType$1[BufferOpType$1["Insert"] = 0] = "Insert";
	BufferOpType$1[BufferOpType$1["Delete"] = 1] = "Delete";
	return BufferOpType$1;
}({});
function spliceChangeForOp(op) {
	if (op.type === BufferOpType.Insert) return {
		type: "splice",
		start: op.index,
		deletedText: "",
		insertedText: op.text
	};
	return {
		type: "splice",
		start: op.start,
		deletedText: op.text,
		insertedText: ""
	};
}
function applyBufferOp(skipString, op) {
	switch (op.type) {
		case BufferOpType.Insert:
			skipString.insert(op.index, op.text);
			break;
		case BufferOpType.Delete:
			skipString.remove([op.start, op.end]);
			break;
	}
}
function indexFromLineColumn(lines, line, column) {
	let index = 0;
	for (let i$6 = 0; i$6 < line; i$6++) index += lines[i$6].length + 1;
	index += column;
	return index;
}
function lineColumnFromIndex(code, index) {
	let line = 0;
	let column = 0;
	for (let i$6 = 0; i$6 < index && i$6 < code.length; i$6++) if (code[i$6] === "\n") {
		line++;
		column = 0;
	} else column++;
	return [line, column];
}
function createBuffer(bufferCode) {
	const skipString = new SkipString();
	skipString.set(bufferCode);
	const changeListeners = /* @__PURE__ */ new Set();
	const onChange = (listener) => {
		changeListeners.add(listener);
		return () => {
			changeListeners.delete(listener);
		};
	};
	const emitChange = (change) => {
		o$24(() => {
			for (const listener of changeListeners) listener(change);
		});
	};
	const codeSignal = c$3(bufferCode);
	const code = {
		get value() {
			return codeSignal.value;
		},
		set value(value) {
			const prevCode = codeSignal.peek();
			if (value === prevCode) return;
			skipString.set(value);
			emitChange({
				type: "reset",
				prevCode,
				nextCode: value
			});
			codeSignal.value = value;
		}
	};
	const lines = b(() => code.value.split("\n"));
	const history$1 = c$3([]);
	const index = c$3(-1);
	let mergeTimestamp = -Infinity;
	const applyOp = (op) => {
		applyBufferOp(skipString, op);
		codeSignal.value = skipString.toString();
	};
	const apply = (op, merge = false) => {
		const prevOp = history$1.value[index.value];
		const now = Date.now();
		applyOp(op);
		if (merge && prevOp && now - mergeTimestamp < 1e3) {
			if (op.type === BufferOpType.Insert && prevOp.type === BufferOpType.Insert) {
				if (op.index === prevOp.index + prevOp.text.length) {
					if (prevOp.replace) {
						const prevDeleteOp = history$1.value[index.value - 1];
						if (prevDeleteOp && prevDeleteOp.type === BufferOpType.Delete && prevDeleteOp.replace) {
							const mergedOp$1 = {
								type: BufferOpType.Insert,
								index: prevOp.index,
								text: prevOp.text + op.text,
								replace: true,
								selection: prevOp.selection
							};
							if (prevOp.caretIndex !== void 0) mergedOp$1.caretIndex = op.caretIndex !== void 0 ? op.caretIndex : prevOp.caretIndex;
							else if (op.caretIndex !== void 0) mergedOp$1.caretIndex = op.caretIndex;
							history$1.value = [
								...history$1.value.slice(0, index.value),
								mergedOp$1,
								...history$1.value.slice(index.value + 1)
							];
							mergeTimestamp = now;
							emitChange(spliceChangeForOp(op));
							return;
						}
					}
					const mergedOp = {
						type: BufferOpType.Insert,
						index: prevOp.index,
						text: prevOp.text + op.text,
						selection: prevOp.selection
					};
					if (prevOp.caretIndex !== void 0) mergedOp.caretIndex = prevOp.caretIndex;
					history$1.value = [
						...history$1.value.slice(0, index.value),
						mergedOp,
						...history$1.value.slice(index.value + 1)
					];
					mergeTimestamp = now;
					emitChange(spliceChangeForOp(op));
					return;
				}
			}
			if (op.type === BufferOpType.Insert && op.replace && prevOp.type === BufferOpType.Delete && prevOp.replace) {
				const prevPrevOp = history$1.value[index.value - 1];
				if (prevPrevOp && prevPrevOp.type === BufferOpType.Insert && prevPrevOp.replace) {
					const prevPrevDeleteOp = history$1.value[index.value - 2];
					if (prevPrevDeleteOp && prevPrevDeleteOp.type === BufferOpType.Delete && prevPrevDeleteOp.replace) {
						const sameLines = prevOp.selection && prevPrevDeleteOp.selection && prevOp.selection.start.line === prevPrevDeleteOp.selection.start.line && prevOp.selection.end.line === prevPrevDeleteOp.selection.end.line;
						const sameIndex = op.index === prevPrevOp.index && prevOp.start === prevPrevOp.index && prevOp.end === prevPrevOp.index + prevPrevOp.text.length && prevPrevDeleteOp.start === prevPrevOp.index && prevPrevDeleteOp.end === prevPrevOp.index + prevPrevOp.text.length;
						const adjacentIndex = op.index === prevPrevOp.index + prevPrevOp.text.length && prevOp.start === op.index && prevPrevDeleteOp.start === prevPrevOp.index && prevPrevDeleteOp.end === prevPrevOp.index + prevPrevOp.text.length;
						if (sameLines || sameIndex) {
							n(() => {
								history$1.value = history$1.value.slice(0, index.value - 2);
								history$1.value.push({
									type: BufferOpType.Delete,
									start: prevPrevDeleteOp.start,
									end: prevPrevDeleteOp.end,
									text: prevPrevDeleteOp.text,
									replace: true,
									selection: prevPrevDeleteOp.selection,
									caretIndex: prevPrevDeleteOp.caretIndex
								});
								history$1.value.push({
									type: BufferOpType.Insert,
									index: prevPrevOp.index,
									text: op.text,
									replace: true,
									selection: op.selection || prevPrevOp.selection,
									caretIndex: op.caretIndex
								});
								index.value = history$1.value.length - 1;
							});
							mergeTimestamp = now;
							emitChange(spliceChangeForOp(op));
							return;
						}
						if (adjacentIndex) {
							n(() => {
								history$1.value = history$1.value.slice(0, index.value - 1);
								history$1.value.push({
									type: BufferOpType.Delete,
									start: prevPrevDeleteOp.start,
									end: prevOp.end,
									text: prevPrevDeleteOp.text + prevOp.text,
									replace: true,
									selection: prevPrevDeleteOp.selection || prevOp.selection,
									caretIndex: prevPrevDeleteOp.caretIndex
								});
								history$1.value.push({
									type: BufferOpType.Insert,
									index: prevPrevOp.index,
									text: prevPrevOp.text + op.text,
									replace: true,
									selection: op.selection || prevPrevOp.selection,
									caretIndex: op.caretIndex
								});
								index.value = history$1.value.length - 1;
							});
							mergeTimestamp = now;
							emitChange(spliceChangeForOp(op));
							return;
						}
					}
				}
			} else if (op.type === BufferOpType.Delete && prevOp.type === BufferOpType.Delete) {
				if (prevOp.end === op.start || op.end === prevOp.start || prevOp.start === op.start) {
					const isForwardDeleteAtSamePos = prevOp.start === op.start && prevOp.end !== op.start && op.end !== prevOp.start;
					const start = Math.min(prevOp.start, op.start);
					const end = isForwardDeleteAtSamePos ? prevOp.start + prevOp.text.length + op.text.length : Math.max(prevOp.end, op.end);
					const text = isForwardDeleteAtSamePos ? prevOp.text + op.text : prevOp.start < op.start ? prevOp.text + op.text : op.text + prevOp.text;
					const mergedOp = {
						type: BufferOpType.Delete,
						start,
						end,
						text,
						selection: prevOp.selection
					};
					if (prevOp.caretIndex !== void 0) mergedOp.caretIndex = prevOp.caretIndex;
					history$1.value = [
						...history$1.value.slice(0, index.value),
						mergedOp,
						...history$1.value.slice(index.value + 1)
					];
					mergeTimestamp = now;
					emitChange(spliceChangeForOp(op));
					return;
				}
			}
		}
		n(() => {
			history$1.value = history$1.value.slice(0, index.value + 1);
			history$1.value.push(op);
			index.value++;
		});
		mergeTimestamp = now;
		emitChange(spliceChangeForOp(op));
	};
	const undo = () => {
		const op = history$1.value[index.value];
		if (!op) return null;
		index.value--;
		switch (op.type) {
			case BufferOpType.Insert: {
				skipString.remove([op.index, op.index + op.text.length]);
				codeSignal.value = skipString.toString();
				emitChange({
					type: "splice",
					start: op.index,
					deletedText: op.text,
					insertedText: ""
				});
				if (op.replace) {
					const deleteOp = history$1.value[index.value];
					if (deleteOp && deleteOp.type === BufferOpType.Delete) {
						skipString.insert(deleteOp.start, deleteOp.text);
						codeSignal.value = skipString.toString();
						index.value--;
						emitChange({
							type: "splice",
							start: deleteOp.start,
							deletedText: "",
							insertedText: deleteOp.text
						});
						if (deleteOp.selection) {
							const lines$4 = code.value.split("\n");
							const maxLine$3 = Math.max(0, lines$4.length - 1);
							const startLine = Math.min(deleteOp.selection.start.line, maxLine$3);
							const endLine = Math.min(deleteOp.selection.end.line, maxLine$3);
							const startMaxColumn = lines$4[startLine]?.length || 0;
							const endMaxColumn = lines$4[endLine]?.length || 0;
							const startColumn = Math.min(deleteOp.selection.start.column, startMaxColumn);
							const endColumn = Math.min(deleteOp.selection.end.column, endMaxColumn);
							const caretPos = deleteOp.selection.direction === "forward" ? {
								line: endLine,
								column: endColumn
							} : {
								line: startLine,
								column: startColumn
							};
							return {
								line: caretPos.line,
								column: caretPos.column,
								selection: {
									start: {
										line: startLine,
										column: startColumn
									},
									end: {
										line: endLine,
										column: endColumn
									},
									direction: deleteOp.selection.direction
								}
							};
						}
						if (deleteOp.caretIndex !== void 0) {
							const clampedCaretIndex = Math.min(deleteOp.caretIndex, code.value.length);
							const [line$3, column$3] = lineColumnFromIndex(code.value, clampedCaretIndex);
							const lines$4 = code.value.split("\n");
							const maxLine$3 = Math.max(0, lines$4.length - 1);
							const maxColumn$3 = lines$4[Math.min(line$3, maxLine$3)]?.length || 0;
							return {
								line: Math.min(line$3, maxLine$3),
								column: Math.min(column$3, maxColumn$3)
							};
						}
						const caretIndex$2 = deleteOp.start + deleteOp.text.length;
						const [line$2, column$2] = lineColumnFromIndex(code.value, caretIndex$2);
						const lines$3 = code.value.split("\n");
						const maxLine$2 = Math.max(0, lines$3.length - 1);
						const maxColumn$2 = lines$3[Math.min(line$2, maxLine$2)]?.length || 0;
						return {
							line: Math.min(line$2, maxLine$2),
							column: Math.min(column$2, maxColumn$2)
						};
					}
					const caretIndex$1 = Math.min(op.index, code.value.length);
					const [line$1, column$1] = lineColumnFromIndex(code.value, caretIndex$1);
					const lines$2 = code.value.split("\n");
					const maxLine$1 = Math.max(0, lines$2.length - 1);
					const maxColumn$1 = lines$2[Math.min(line$1, maxLine$1)]?.length || 0;
					return {
						line: Math.min(line$1, maxLine$1),
						column: Math.min(column$1, maxColumn$1)
					};
				}
				if (op.selection) {
					const lines$2 = code.value.split("\n");
					const maxLine$1 = Math.max(0, lines$2.length - 1);
					const startLine = Math.min(op.selection.start.line, maxLine$1);
					const endLine = Math.min(op.selection.end.line, maxLine$1);
					const startMaxColumn = lines$2[startLine]?.length || 0;
					const endMaxColumn = lines$2[endLine]?.length || 0;
					const startColumn = Math.min(op.selection.start.column, startMaxColumn);
					const endColumn = Math.min(op.selection.end.column, endMaxColumn);
					const caretPos = op.selection.direction === "forward" ? {
						line: endLine,
						column: endColumn
					} : {
						line: startLine,
						column: startColumn
					};
					return {
						line: caretPos.line,
						column: caretPos.column,
						selection: {
							start: {
								line: startLine,
								column: startColumn
							},
							end: {
								line: endLine,
								column: endColumn
							},
							direction: op.selection.direction
						}
					};
				}
				if (op.caretIndex !== void 0) {
					const [line$1, column$1] = lineColumnFromIndex(code.value, op.caretIndex);
					const lines$2 = code.value.split("\n");
					const maxLine$1 = Math.max(0, lines$2.length - 1);
					const maxColumn$1 = lines$2[Math.min(line$1, maxLine$1)]?.length || 0;
					return {
						line: Math.min(line$1, maxLine$1),
						column: Math.min(column$1, maxColumn$1)
					};
				}
				const caretIndex = Math.min(op.index, code.value.length);
				const [line, column] = lineColumnFromIndex(code.value, caretIndex);
				const lines$1 = code.value.split("\n");
				const maxLine = Math.max(0, lines$1.length - 1);
				const maxColumn = lines$1[Math.min(line, maxLine)]?.length || 0;
				return {
					line: Math.min(line, maxLine),
					column: Math.min(column, maxColumn)
				};
			}
			case BufferOpType.Delete: {
				skipString.insert(op.start, op.text);
				codeSignal.value = skipString.toString();
				emitChange({
					type: "splice",
					start: op.start,
					deletedText: "",
					insertedText: op.text
				});
				if (op.selection) {
					const lines$2 = code.value.split("\n");
					const maxLine$1 = Math.max(0, lines$2.length - 1);
					const startLine = Math.min(op.selection.start.line, maxLine$1);
					const endLine = Math.min(op.selection.end.line, maxLine$1);
					const startMaxColumn = lines$2[startLine]?.length || 0;
					const endMaxColumn = lines$2[endLine]?.length || 0;
					const startColumn = Math.min(op.selection.start.column, startMaxColumn);
					const endColumn = Math.min(op.selection.end.column, endMaxColumn);
					const caretPos = op.selection.direction === "forward" ? {
						line: endLine,
						column: endColumn
					} : {
						line: startLine,
						column: startColumn
					};
					return {
						line: caretPos.line,
						column: caretPos.column,
						selection: {
							start: {
								line: startLine,
								column: startColumn
							},
							end: {
								line: endLine,
								column: endColumn
							},
							direction: op.selection.direction
						}
					};
				}
				if (op.caretIndex !== void 0) {
					const [line$1, column$1] = lineColumnFromIndex(code.value, op.caretIndex);
					const lines$2 = code.value.split("\n");
					const maxLine$1 = Math.max(0, lines$2.length - 1);
					const maxColumn$1 = lines$2[Math.min(line$1, maxLine$1)]?.length || 0;
					return {
						line: Math.min(line$1, maxLine$1),
						column: Math.min(column$1, maxColumn$1)
					};
				}
				const caretIndex = op.start + op.text.length;
				const [line, column] = lineColumnFromIndex(code.value, caretIndex);
				const lines$1 = code.value.split("\n");
				const maxLine = Math.max(0, lines$1.length - 1);
				const maxColumn = lines$1[Math.min(line, maxLine)]?.length || 0;
				return {
					line: Math.min(line, maxLine),
					column: Math.min(column, maxColumn)
				};
			}
		}
	};
	const redo = () => {
		const op = history$1.value[index.value + 1];
		if (!op) return null;
		index.value++;
		applyOp(op);
		emitChange(spliceChangeForOp(op));
		if (op.replace) {
			const nextOp = history$1.value[index.value + 1];
			if (nextOp && nextOp.type === BufferOpType.Insert && nextOp.replace) {
				index.value++;
				applyOp(nextOp);
				emitChange(spliceChangeForOp(nextOp));
				if (nextOp.selection) {
					const lines$1 = code.value.split("\n");
					const maxLine = Math.max(0, lines$1.length - 1);
					const startLine = Math.min(nextOp.selection.start.line, maxLine);
					const endLine = Math.min(nextOp.selection.end.line, maxLine);
					const startMaxColumn = lines$1[startLine]?.length || 0;
					const endMaxColumn = lines$1[endLine]?.length || 0;
					const startColumn = Math.min(nextOp.selection.start.column, startMaxColumn);
					const endColumn = Math.min(nextOp.selection.end.column, endMaxColumn);
					const caretPos = nextOp.selection.direction === "forward" ? {
						line: endLine,
						column: endColumn
					} : {
						line: startLine,
						column: startColumn
					};
					return {
						line: caretPos.line,
						column: caretPos.column,
						selection: {
							start: {
								line: startLine,
								column: startColumn
							},
							end: {
								line: endLine,
								column: endColumn
							},
							direction: nextOp.selection.direction
						}
					};
				}
				if (nextOp.caretIndex !== void 0) {
					const [line$2, column$2] = lineColumnFromIndex(code.value, nextOp.caretIndex);
					return {
						line: line$2,
						column: column$2
					};
				}
				const [line$1, column$1] = lineColumnFromIndex(code.value, nextOp.index + nextOp.text.length);
				return {
					line: line$1,
					column: column$1
				};
			}
			if (op.type === BufferOpType.Delete) {
				const [line$1, column$1] = lineColumnFromIndex(code.value, op.start);
				return {
					line: line$1,
					column: column$1
				};
			}
			const [line, column] = lineColumnFromIndex(code.value, op.index);
			return {
				line,
				column
			};
		}
		switch (op.type) {
			case BufferOpType.Insert: {
				if (op.caretIndex !== void 0) {
					const [line$1, column$1] = lineColumnFromIndex(code.value, op.caretIndex);
					return {
						line: line$1,
						column: column$1
					};
				}
				const [line, column] = lineColumnFromIndex(code.value, op.index + op.text.length);
				return {
					line,
					column
				};
			}
			case BufferOpType.Delete: {
				const [line, column] = lineColumnFromIndex(code.value, op.start);
				return {
					line,
					column
				};
			}
			default: {
				const [line, column] = lineColumnFromIndex(code.value, 0);
				return {
					line,
					column
				};
			}
		}
	};
	const insert$1 = (line, column, text) => {
		const raw = indexFromLineColumn(lines.value, line, column);
		const index$1 = Math.max(0, Math.min(raw, code.value.length));
		apply({
			type: BufferOpType.Insert,
			index: index$1,
			text
		}, true);
	};
	const del = (line, column) => {
		const index$1 = indexFromLineColumn(lines.value, line, column);
		const char = skipString.substring(index$1, index$1 + 1);
		apply({
			type: BufferOpType.Delete,
			start: index$1,
			end: index$1 + 1,
			text: char,
			caretIndex: index$1
		}, true);
	};
	const backspace = (line, column) => {
		const index$1 = indexFromLineColumn(lines.value, line, column);
		const char = skipString.substring(index$1 - 1, index$1);
		apply({
			type: BufferOpType.Delete,
			start: index$1 - 1,
			end: index$1,
			text: char,
			caretIndex: index$1
		}, true);
	};
	const deleteSelection = (start, end, selection, merge = false, caretPosition) => {
		const startIndex = indexFromLineColumn(lines.value, start.line, start.column);
		const endIndex = indexFromLineColumn(lines.value, end.line, end.column);
		const text = skipString.substring(startIndex, endIndex);
		const caretIndex = caretPosition ? indexFromLineColumn(lines.value, caretPosition.line, caretPosition.column) : void 0;
		apply({
			type: BufferOpType.Delete,
			start: startIndex,
			end: endIndex,
			text,
			selection,
			caretIndex
		}, merge);
	};
	const replace = (index$1, length, text) => {
		const deletedText = skipString.substring(index$1, index$1 + length);
		const deleteOp = {
			type: BufferOpType.Delete,
			start: index$1,
			end: index$1 + length,
			text: deletedText,
			replace: true
		};
		const insertOp = {
			type: BufferOpType.Insert,
			index: index$1,
			text,
			replace: true
		};
		n(() => {
			apply(deleteOp, true);
			apply(insertOp, true);
		});
	};
	const replaceSelection = (start, end, text, selectionBefore, caretPositionBefore, selectionAfter, caretPositionAfter) => {
		const startIndex = indexFromLineColumn(lines.value, start.line, start.column);
		const endIndex = indexFromLineColumn(lines.value, end.line, end.column);
		const deletedText = skipString.substring(startIndex, endIndex);
		const beforeCaretIndex = caretPositionBefore !== void 0 ? indexFromLineColumn(lines.value, caretPositionBefore.line, caretPositionBefore.column) : void 0;
		const afterCaretIndex = caretPositionAfter !== void 0 ? (() => {
			const tempSkipString = skipString.copy();
			tempSkipString.remove([startIndex, endIndex]);
			tempSkipString.insert(startIndex, text);
			return indexFromLineColumn(tempSkipString.toString().split("\n"), caretPositionAfter.line, caretPositionAfter.column);
		})() : void 0;
		const deleteOp = {
			type: BufferOpType.Delete,
			start: startIndex,
			end: endIndex,
			text: deletedText,
			replace: true,
			selection: selectionBefore,
			caretIndex: beforeCaretIndex
		};
		const insertOp = {
			type: BufferOpType.Insert,
			index: startIndex,
			text,
			replace: true,
			selection: selectionAfter,
			caretIndex: afterCaretIndex
		};
		const now = Date.now();
		n(() => {
			applyOp(deleteOp);
			applyOp(insertOp);
			history$1.value = history$1.value.slice(0, index.value + 1);
			history$1.value.push(deleteOp);
			history$1.value.push(insertOp);
			index.value += 2;
		});
		mergeTimestamp = now;
		emitChange(spliceChangeForOp(deleteOp));
		emitChange(spliceChangeForOp(insertOp));
	};
	const pack = () => {
		const packedHistory = [];
		for (const op of history$1.value) if (op.type === BufferOpType.Insert) {
			const item = [
				0,
				op.index,
				op.text
			];
			if (op.replace) item.push(1);
			if (op.selection) {
				item.push(op.selection.direction === "forward" ? "f" : "b");
				item.push(op.selection.start.line, op.selection.start.column, op.selection.end.line, op.selection.end.column);
			}
			if (op.caretIndex !== void 0) item.push(op.caretIndex);
			packedHistory.push(item);
		} else {
			const item = [
				1,
				op.start,
				op.end,
				op.text
			];
			if (op.replace) item.push(1);
			if (op.selection) {
				item.push(op.selection.direction === "forward" ? "f" : "b");
				item.push(op.selection.start.line, op.selection.start.column, op.selection.end.line, op.selection.end.column);
			}
			if (op.caretIndex !== void 0) item.push(op.caretIndex);
			packedHistory.push(item);
		}
		return {
			code: code.value,
			history: packedHistory,
			index: index.value
		};
	};
	return {
		code,
		lines,
		history: history$1,
		index,
		onChange,
		apply,
		undo,
		redo,
		insert: insert$1,
		del,
		backspace,
		deleteSelection,
		replace,
		replaceSelection,
		pack
	};
}
function unpack(data) {
	const buffer = createBuffer(data.code ?? "");
	if (data.history && Array.isArray(data.history)) {
		const unpackedHistory = [];
		for (const item of data.history) {
			if (!Array.isArray(item) || item.length < 2) continue;
			const type = item[0];
			if (type === 0) {
				const op = {
					type: BufferOpType.Insert,
					index: item[1],
					text: item[2]
				};
				let offset = 3;
				if (item[3] === 1) {
					op.replace = true;
					offset = 4;
				}
				if (item.length > offset && typeof item[offset] === "string" && (item[offset] === "f" || item[offset] === "b")) {
					const direction = item[offset] === "f" ? "forward" : "backward";
					if (item.length > offset + 4 && typeof item[offset + 1] === "number" && typeof item[offset + 2] === "number" && typeof item[offset + 3] === "number" && typeof item[offset + 4] === "number") {
						op.selection = {
							start: {
								line: item[offset + 1],
								column: item[offset + 2]
							},
							end: {
								line: item[offset + 3],
								column: item[offset + 4]
							},
							direction
						};
						offset += 5;
					} else {
						const [startLine, startColumn] = lineColumnFromIndex(buffer.code.value, op.index);
						const [endLine, endColumn] = lineColumnFromIndex(buffer.code.value, op.index + op.text.length);
						op.selection = {
							start: {
								line: startLine,
								column: startColumn
							},
							end: {
								line: endLine,
								column: endColumn
							},
							direction
						};
						offset += 1;
					}
				}
				if (item.length > offset && typeof item[offset] === "number") op.caretIndex = item[offset];
				unpackedHistory.push(op);
			} else if (type === 1) {
				const op = {
					type: BufferOpType.Delete,
					start: item[1],
					end: item[2],
					text: item[3]
				};
				let offset = 4;
				if (item[4] === 1) {
					op.replace = true;
					offset = 5;
				}
				if (item.length > offset && typeof item[offset] === "string" && (item[offset] === "f" || item[offset] === "b")) {
					const direction = item[offset] === "f" ? "forward" : "backward";
					if (item.length > offset + 4 && typeof item[offset + 1] === "number" && typeof item[offset + 2] === "number" && typeof item[offset + 3] === "number" && typeof item[offset + 4] === "number") {
						op.selection = {
							start: {
								line: item[offset + 1],
								column: item[offset + 2]
							},
							end: {
								line: item[offset + 3],
								column: item[offset + 4]
							},
							direction
						};
						offset += 5;
					} else {
						const [startLine, startColumn] = lineColumnFromIndex(buffer.code.value, op.start);
						const [endLine, endColumn] = lineColumnFromIndex(buffer.code.value, op.start + op.text.length);
						op.selection = {
							start: {
								line: startLine,
								column: startColumn
							},
							end: {
								line: endLine,
								column: endColumn
							},
							direction
						};
						offset += 1;
					}
				}
				if (item.length > offset && typeof item[offset] === "number") op.caretIndex = item[offset];
				unpackedHistory.push(op);
			}
		}
		buffer.history.value = unpackedHistory;
	}
	if (data.index !== void 0) buffer.index.value = data.index;
	return buffer;
}
var openingBraces = new Set([
	"{",
	"(",
	"["
]);
var closingBraces = new Set([
	"}",
	")",
	"]"
]);
var quoteChars = new Set([
	"'",
	"\"",
	"`"
]);
var braceCache = /* @__PURE__ */ new WeakMap();
function getMatchingOpenBrace(closeChar) {
	switch (closeChar) {
		case "}": return "{";
		case ")": return "(";
		case "]": return "[";
		case "'": return "'";
		case "\"": return "\"";
		case "`": return "`";
		default: return "";
	}
}
function buildBraceCache(tokenLines) {
	const existing = braceCache.get(tokenLines);
	if (existing) return existing;
	const braces = [];
	const lineLengths = [];
	let inString = null;
	for (let lineIndex = 0; lineIndex < tokenLines.length; lineIndex++) {
		const line = tokenLines[lineIndex];
		let currentColumn = 0;
		let lineLength = 0;
		for (let tokenIndex = 0; tokenIndex < line.length; tokenIndex++) {
			const token = line[tokenIndex];
			const text = token.text;
			lineLength += text.length;
			if (token.type !== "comment") {
				let escaped = false;
				for (let charIndex = 0; charIndex < text.length; charIndex++) {
					const char = text[charIndex];
					if (escaped) {
						escaped = false;
						continue;
					}
					if (char === "\\") {
						escaped = true;
						continue;
					}
					if (quoteChars.has(char)) {
						if (inString === null) {
							inString = char;
							braces.push({
								char,
								line: lineIndex,
								tokenIndex,
								token,
								charIndex,
								position: currentColumn + charIndex,
								isOpening: true
							});
						} else if (inString === char) {
							inString = null;
							braces.push({
								char,
								line: lineIndex,
								tokenIndex,
								token,
								charIndex,
								position: currentColumn + charIndex,
								isOpening: false
							});
						}
					} else if (openingBraces.has(char) || closingBraces.has(char)) braces.push({
						char,
						line: lineIndex,
						tokenIndex,
						token,
						charIndex,
						position: currentColumn + charIndex,
						isOpening: openingBraces.has(char)
					});
				}
			}
			currentColumn += text.length;
		}
		lineLengths.push(lineLength);
	}
	const matchedPairs = [];
	const stack = [];
	for (let i$6 = 0; i$6 < braces.length; i$6++) {
		const brace = braces[i$6];
		if (brace.isOpening) {
			const depth = stack.length;
			stack.push({
				char: brace.char,
				index: i$6,
				depth
			});
		} else {
			const expectedOpen = getMatchingOpenBrace(brace.char);
			for (let j$4 = stack.length - 1; j$4 >= 0; j$4--) if (stack[j$4].char === expectedOpen) {
				matchedPairs.push({
					openIndex: stack[j$4].index,
					closeIndex: i$6,
					depth: stack[j$4].depth
				});
				stack.splice(j$4, 1);
				break;
			}
		}
	}
	const cache = {
		braces,
		matchedPairs,
		lineLengths
	};
	braceCache.set(tokenLines, cache);
	return cache;
}
function detectBlockStart(codeLines, lineIndex) {
	if (lineIndex >= codeLines.length) return false;
	const line = codeLines[lineIndex];
	if (line.trim().length === 0) return false;
	const nextLineIndex = lineIndex + 1;
	if (nextLineIndex >= codeLines.length) return false;
	const nextLine = codeLines[nextLineIndex];
	if (nextLine.trim().length === 0) return false;
	const currentIndent = line.length - line.trimStart().length;
	return nextLine.length - nextLine.trimStart().length > currentIndent;
}
function findBlockEnd(codeLines, startLine) {
	const startLineContent = codeLines[startLine];
	const startIndent = startLineContent.length - startLineContent.trimStart().length;
	for (let i$6 = startLine + 1; i$6 < codeLines.length; i$6++) {
		const line = codeLines[i$6];
		const indent = line.length - line.trimStart().length;
		if (line.trim().length > 0 && indent <= startIndent) return i$6 - 1;
	}
	return codeLines.length - 1;
}
function createBlocks(doc, caches) {
	const blockStarts = b(() => {
		const codeLines = doc.lines;
		const starts = /* @__PURE__ */ new Set();
		for (let i$6 = 0; i$6 < codeLines.length; i$6++) if (detectBlockStart(codeLines, i$6)) starts.add(i$6);
		return starts;
	});
	const blockEnds = b(() => {
		const codeLines = doc.lines;
		const starts = blockStarts.value;
		const ends = /* @__PURE__ */ new Map();
		for (const startLine of starts) ends.set(startLine, findBlockEnd(codeLines, startLine));
		return ends;
	});
	const braceDepths = b(() => {
		const tokenLines = doc.tokenLines;
		const { braces, matchedPairs } = buildBraceCache(tokenLines);
		const depths = /* @__PURE__ */ new Map();
		for (const pair of matchedPairs) {
			const openBrace = braces[pair.openIndex];
			if (openBrace.isOpening) {
				const existing = depths.get(openBrace.line);
				if (existing === void 0 || existing === null || pair.depth < existing) depths.set(openBrace.line, pair.depth);
			}
		}
		return depths;
	});
	const braceGlobalPos = b(() => {
		const tokenLines = doc.tokenLines;
		const { lineLengths } = buildBraceCache(tokenLines);
		const globalPos = /* @__PURE__ */ new Map();
		let pos = 0;
		let i$6 = 0;
		for (; i$6 < lineLengths.length; i$6++) {
			globalPos.set(i$6, pos);
			pos += lineLengths[i$6] + 1;
		}
		globalPos.set(i$6, pos);
		return globalPos;
	});
	const isCollapsed = (line) => {
		return doc.collapsed.has(line);
	};
	const toggle = (line) => {
		const newCollapsed = new Set(doc.collapsed);
		if (newCollapsed.has(line)) newCollapsed.delete(line);
		else newCollapsed.add(line);
		doc.collapsed = newCollapsed;
	};
	const expand = (line) => {
		const newCollapsed = new Set(doc.collapsed);
		newCollapsed.delete(line);
		doc.collapsed = newCollapsed;
	};
	const collapse = (line) => {
		const newCollapsed = new Set(doc.collapsed);
		newCollapsed.add(line);
		doc.collapsed = newCollapsed;
	};
	const adjustOnLineInsert = (insertedAt) => {
		const newCollapsed = /* @__PURE__ */ new Set();
		for (const line of doc.collapsed) if (line >= insertedAt) newCollapsed.add(line + 1);
		else newCollapsed.add(line);
		doc.collapsed = newCollapsed;
	};
	const adjustOnLineInsertRange = (startLine, endLine) => {
		const insertedCount = endLine - startLine + 1;
		const newCollapsed = /* @__PURE__ */ new Set();
		for (const line of doc.collapsed) if (line >= startLine) newCollapsed.add(line + insertedCount);
		else newCollapsed.add(line);
		doc.collapsed = newCollapsed;
	};
	const adjustOnLineDelete = (deletedAt) => {
		const newCollapsed = /* @__PURE__ */ new Set();
		for (const line of doc.collapsed) if (line > deletedAt) newCollapsed.add(line - 1);
		else if (line < deletedAt) newCollapsed.add(line);
		doc.collapsed = newCollapsed;
	};
	const adjustOnLineDeleteRange = (startLine, endLine) => {
		const deletedCount = endLine - startLine;
		const newCollapsed = /* @__PURE__ */ new Set();
		for (const line of doc.collapsed) if (line > endLine) newCollapsed.add(line - deletedCount);
		else if (line < startLine) newCollapsed.add(line);
		doc.collapsed = newCollapsed;
	};
	const getBraceDepthForPosition = (line, tokenIndex, charIndex) => {
		const tokenLines = doc.tokenLines;
		const { braces, matchedPairs } = buildBraceCache(tokenLines);
		let column = 0;
		const lineTokens = tokenLines[line] || [];
		for (let i$6 = 0; i$6 < tokenIndex && i$6 < lineTokens.length; i$6++) column += lineTokens[i$6]?.text.length || 0;
		column += charIndex;
		for (const pair of matchedPairs) {
			const openBrace = braces[pair.openIndex];
			const closeBrace = braces[pair.closeIndex];
			if (openBrace.line === line && openBrace.tokenIndex === tokenIndex && openBrace.charIndex === charIndex) return pair.depth;
			if (closeBrace.line === line && closeBrace.tokenIndex === tokenIndex && closeBrace.charIndex === charIndex) return pair.depth;
		}
		return null;
	};
	const getBraceGlobalPos = (brace) => {
		return (braceGlobalPos.value.get(brace.line) ?? 0) + brace.position;
	};
	const findMatchingBrace = (cursorLine, cursorColumn) => {
		const cacheKey = `${cursorLine}:${cursorColumn}`;
		const cached = caches.matchingBraceCache.get(cacheKey);
		if (cached !== void 0) return cached;
		const tokenLines = doc.tokenLines;
		const { braces, matchedPairs, lineLengths } = buildBraceCache(tokenLines);
		if (braces.length === 0 || matchedPairs.length === 0) {
			caches.matchingBraceCache.set(cacheKey, null);
			return null;
		}
		const clampedCursorLine = Math.max(0, Math.min(cursorLine, tokenLines.length));
		let cursorGlobalPos = 0;
		for (let i$6 = 0; i$6 < clampedCursorLine; i$6++) cursorGlobalPos += lineLengths[i$6] + 1;
		cursorGlobalPos += cursorColumn;
		let innermostPair = null;
		let smallestRange = Infinity;
		for (const pair of matchedPairs) {
			const openBrace$1 = braces[pair.openIndex];
			const closeBrace$1 = braces[pair.closeIndex];
			const openStart = getBraceGlobalPos(openBrace$1);
			const closeStart = getBraceGlobalPos(closeBrace$1);
			const openEnd = openStart + 1;
			const closeEnd = closeStart + 1;
			if (cursorGlobalPos > openStart && cursorGlobalPos < closeEnd || cursorGlobalPos === openStart || cursorGlobalPos === openEnd || cursorGlobalPos === closeStart || cursorGlobalPos === closeEnd) {
				const range = closeEnd - openStart;
				if (range < smallestRange) {
					smallestRange = range;
					innermostPair = pair;
				}
			}
		}
		if (!innermostPair) {
			caches.matchingBraceCache.set(cacheKey, null);
			return null;
		}
		const openBrace = braces[innermostPair.openIndex];
		const closeBrace = braces[innermostPair.closeIndex];
		const result = {
			line: openBrace.line,
			tokenIndex: openBrace.tokenIndex,
			token: openBrace.token,
			charIndex: openBrace.charIndex,
			matchingLine: closeBrace.line,
			matchingTokenIndex: closeBrace.tokenIndex,
			matchingToken: closeBrace.token,
			matchingCharIndex: closeBrace.charIndex,
			depth: innermostPair.depth
		};
		caches.matchingBraceCache.set(cacheKey, result);
		return result;
	};
	return {
		blockStarts,
		blockEnds,
		braceDepths,
		isCollapsed,
		toggle,
		expand,
		collapse,
		adjustOnLineInsert,
		adjustOnLineInsertRange,
		adjustOnLineDelete,
		adjustOnLineDeleteRange,
		findMatchingBrace,
		getBraceGlobalPos,
		getBraceDepthForPosition
	};
}
function getTokenCacheKey(token) {
	return `${token.type}${token.text}`;
}
function getWidgetCacheKey(widget) {
	const type = widget.type;
	if (widget.type === "above" || widget.type === "below" || widget.type === "overlay") {
		const [x1, x2] = widget.pos.x;
		return `${type}${x1}${x2}${widget.pos.y}`;
	} else if (widget.type === "before" || widget.type === "after") return `${type}${widget.pos.x}${widget.pos.y}${widget.pos.width}`;
	else if (widget.type === "inlay") return `${type}${widget.pos.x}${widget.pos.y}${widget.content}`;
	else return `${type}${widget.pos.y}`;
}
function getErrorCacheKey(error$1) {
	const [x1, x2] = error$1.x;
	return `${x1}${x2}${error$1.y}${error$1.message}`;
}
function getWrapTokensCacheKey(tokens, logicalLine, maxWidth, lineWidgets, lineErrors, settings$1) {
	let tokensKey = "";
	for (let i$6 = 0; i$6 < tokens.length; i$6++) tokensKey += getTokenCacheKey(tokens[i$6]);
	let widgetsKey = "";
	for (let i$6 = 0; i$6 < lineWidgets.length; i$6++) widgetsKey += getWidgetCacheKey(lineWidgets[i$6]);
	let errorsKey = "";
	for (let i$6 = 0; i$6 < lineErrors.length; i$6++) errorsKey += getErrorCacheKey(lineErrors[i$6]);
	return [
		tokensKey,
		logicalLine,
		maxWidth,
		widgetsKey,
		errorsKey,
		settings$1.lineHeight,
		settings$1.fontSize
	].join(WRAP_TOKENS_CACHE_KEY_DELIMITER);
}
var WRAP_TOKENS_CACHE_KEY_DELIMITER = "|||";
function parseCacheKeyLineNumber(key) {
	const delimiterIndex = key.indexOf(WRAP_TOKENS_CACHE_KEY_DELIMITER);
	if (delimiterIndex === -1) return null;
	const afterDelimiter = key.slice(delimiterIndex + 3);
	const nextDelimiterIndex = afterDelimiter.indexOf(WRAP_TOKENS_CACHE_KEY_DELIMITER);
	if (nextDelimiterIndex === -1) return null;
	const lineNumStr = afterDelimiter.slice(0, nextDelimiterIndex);
	const lineNum = Number.parseInt(lineNumStr, 10);
	if (!Number.isNaN(lineNum)) return lineNum;
	return null;
}
function updateCacheKeyLineNumber(key, newLineNumber) {
	const delimiterIndex = key.indexOf(WRAP_TOKENS_CACHE_KEY_DELIMITER);
	if (delimiterIndex === -1) return key;
	const before = key.slice(0, delimiterIndex + 3);
	const afterDelimiter = key.slice(delimiterIndex + 3);
	const nextDelimiterIndex = afterDelimiter.indexOf(WRAP_TOKENS_CACHE_KEY_DELIMITER);
	if (nextDelimiterIndex === -1) return key;
	return `${before}${newLineNumber}${afterDelimiter.slice(nextDelimiterIndex)}`;
}
function getLineCacheKey(context, visualTokens) {
	return visualTokens.map((vt) => getTokenCacheKey(vt.token)).join("") + `${context.canvas.ligatureDpr.value}${context.settings.lineHeight}${context.settings.fontSize}`;
}
function createCaches(canvas, settings$1, doc) {
	const measureTextCache = /* @__PURE__ */ new Map();
	const lineCanvasCache = /* @__PURE__ */ new Map();
	const lineCanvasCacheByLine = /* @__PURE__ */ new Map();
	const wrapTokensCache = /* @__PURE__ */ new Map();
	const wrapTokensCacheByLine = /* @__PURE__ */ new Map();
	const matchingBraceCache = /* @__PURE__ */ new Map();
	const getXFromColumnCache = /* @__PURE__ */ new Map();
	const findVisualLineForColumnCache = /* @__PURE__ */ new Map();
	const blockInfoCache = /* @__PURE__ */ new Map();
	const clear = () => {
		measureTextCache.clear();
		lineCanvasCache.clear();
		lineCanvasCacheByLine.clear();
		wrapTokensCache.clear();
		wrapTokensCacheByLine.clear();
		matchingBraceCache.clear();
		getXFromColumnCache.clear();
		findVisualLineForColumnCache.clear();
		blockInfoCache.clear();
	};
	const adjustWrapTokensCacheOnLineInsert = (insertedAt) => {
		const splitLineKey = wrapTokensCacheByLine.get(insertedAt - 1);
		if (splitLineKey) {
			wrapTokensCache.delete(splitLineKey);
			wrapTokensCacheByLine.delete(insertedAt - 1);
		}
		const lineNums = Array.from(wrapTokensCacheByLine.keys()).filter((lineNum) => lineNum >= insertedAt);
		for (const lineNum of lineNums) {
			const key = wrapTokensCacheByLine.get(lineNum);
			if (key) {
				wrapTokensCache.delete(key);
				wrapTokensCacheByLine.delete(lineNum);
			}
		}
	};
	const adjustWrapTokensCacheOnLineInsertRange = (startLine, endLine) => {
		endLine - startLine + 1;
		const splitLineKey = wrapTokensCacheByLine.get(startLine - 1);
		if (splitLineKey) {
			wrapTokensCache.delete(splitLineKey);
			wrapTokensCacheByLine.delete(startLine - 1);
		}
		const lineNums = Array.from(wrapTokensCacheByLine.keys()).filter((lineNum) => lineNum >= startLine);
		for (const lineNum of lineNums) {
			const key = wrapTokensCacheByLine.get(lineNum);
			if (key) {
				wrapTokensCache.delete(key);
				wrapTokensCacheByLine.delete(lineNum);
			}
		}
	};
	const adjustWrapTokensCacheOnLineDelete = (deletedAt) => {
		const deletedKey = wrapTokensCacheByLine.get(deletedAt);
		if (deletedKey) {
			wrapTokensCache.delete(deletedKey);
			wrapTokensCacheByLine.delete(deletedAt);
		}
		const prevLineKey = wrapTokensCacheByLine.get(deletedAt - 1);
		if (prevLineKey) {
			wrapTokensCache.delete(prevLineKey);
			wrapTokensCacheByLine.delete(deletedAt - 1);
		}
		const keysToUpdate = [];
		for (const [lineNum, key] of wrapTokensCacheByLine.entries()) if (lineNum > deletedAt) {
			const value = wrapTokensCache.get(key);
			if (value) {
				const lineNumInKey = parseCacheKeyLineNumber(key);
				if (lineNumInKey !== null && lineNumInKey === lineNum) {
					const parts = key.split(WRAP_TOKENS_CACHE_KEY_DELIMITER);
					const widgetsPart = parts.length > 3 ? parts[3] : "";
					const errorsPart = parts.length > 4 ? parts[4] : "";
					if (!(widgetsPart !== "" || errorsPart !== "")) {
						const newKey = updateCacheKeyLineNumber(key, lineNum - 1);
						const updatedValue = value.map((line) => ({
							...line,
							logicalLine: line.logicalLine - 1
						}));
						keysToUpdate.push([
							key,
							newKey,
							lineNum,
							updatedValue
						]);
					} else {
						wrapTokensCache.delete(key);
						wrapTokensCacheByLine.delete(lineNum);
					}
				}
			}
		}
		for (const [oldKey, newKey, oldLineNum, updatedValue] of keysToUpdate) {
			wrapTokensCache.set(newKey, updatedValue);
			wrapTokensCache.delete(oldKey);
			wrapTokensCacheByLine.delete(oldLineNum);
			wrapTokensCacheByLine.set(oldLineNum - 1, newKey);
		}
	};
	const adjustWrapTokensCacheOnLineDeleteRange = (startLine, endLine) => {
		const deletedCount = endLine - startLine;
		for (let i$6 = startLine; i$6 <= endLine; i$6++) {
			const deletedKey = wrapTokensCacheByLine.get(i$6);
			if (deletedKey) {
				wrapTokensCache.delete(deletedKey);
				wrapTokensCacheByLine.delete(i$6);
			}
		}
		const prevLineKey = wrapTokensCacheByLine.get(startLine - 1);
		if (prevLineKey) {
			wrapTokensCache.delete(prevLineKey);
			wrapTokensCacheByLine.delete(startLine - 1);
		}
		const keysToUpdate = [];
		for (const [lineNum, key] of wrapTokensCacheByLine.entries()) if (lineNum > endLine) {
			const value = wrapTokensCache.get(key);
			if (value) {
				const lineNumInKey = parseCacheKeyLineNumber(key);
				if (lineNumInKey !== null && lineNumInKey === lineNum) {
					const parts = key.split(WRAP_TOKENS_CACHE_KEY_DELIMITER);
					const widgetsPart = parts.length > 3 ? parts[3] : "";
					const errorsPart = parts.length > 4 ? parts[4] : "";
					if (!(widgetsPart !== "" || errorsPart !== "")) {
						const newKey = updateCacheKeyLineNumber(key, lineNum - deletedCount);
						const updatedValue = value.map((line) => ({
							...line,
							logicalLine: line.logicalLine - deletedCount
						}));
						keysToUpdate.push([
							key,
							newKey,
							lineNum,
							updatedValue
						]);
					} else {
						wrapTokensCache.delete(key);
						wrapTokensCacheByLine.delete(lineNum);
					}
				}
			}
		}
		for (const [oldKey, newKey, oldLineNum, updatedValue] of keysToUpdate) {
			wrapTokensCache.set(newKey, updatedValue);
			wrapTokensCache.delete(oldKey);
			wrapTokensCacheByLine.delete(oldLineNum);
			wrapTokensCacheByLine.set(oldLineNum - deletedCount, newKey);
		}
	};
	const invalidateWrapTokensCacheForLine = (line) => {
		const cacheKey = wrapTokensCacheByLine.get(line);
		if (cacheKey) {
			wrapTokensCache.delete(cacheKey);
			wrapTokensCacheByLine.delete(line);
		}
	};
	m(() => {
		doc.widgets;
		canvas.dpr.value;
		canvas.size.width.value;
		canvas.size.height.value;
		settings$1.lineHeight;
		settings$1.fontSize;
		settings$1.theme;
		settings$1.wordWrap;
		settings$1.autoHeight;
		clear();
	});
	m(() => {
		doc.buffer.code.value;
		doc.errors;
		settings$1.wordWrap;
		matchingBraceCache.clear();
		getXFromColumnCache.clear();
		findVisualLineForColumnCache.clear();
		blockInfoCache.clear();
	});
	const dispose = () => {
		clear();
	};
	return {
		measureTextCache,
		lineCanvasCache,
		lineCanvasCacheByLine,
		wrapTokensCache,
		wrapTokensCacheByLine,
		matchingBraceCache,
		getXFromColumnCache,
		findVisualLineForColumnCache,
		blockInfoCache,
		adjustWrapTokensCacheOnLineInsert,
		adjustWrapTokensCacheOnLineInsertRange,
		adjustWrapTokensCacheOnLineDelete,
		adjustWrapTokensCacheOnLineDeleteRange,
		invalidateWrapTokensCacheForLine,
		clear,
		dispose
	};
}
function measureText(c$7, settings$1, caches, token) {
	const measureTextCache = caches.measureTextCache;
	const { text, type } = token;
	const { fontSize: fontSize$1, fontFamilyName: fontFamilyName$1, theme: { [type]: { style, weight } } } = settings$1;
	const cacheKey = `${text}${style}${weight}${fontSize$1}${fontFamilyName$1}`;
	if (measureTextCache.has(cacheKey)) return measureTextCache.get(cacheKey);
	c$7.save();
	c$7.font = `${weight === "bold" ? 700 : 400} ${style} ${fontSize$1} '${fontFamilyName$1}', monospace`;
	const width = c$7.measureText(text).width;
	const heightMetrics = c$7.measureText("Mg");
	const height = Math.ceil(heightMetrics.actualBoundingBoxAscent + heightMetrics.actualBoundingBoxDescent);
	const fontHeight = Math.ceil(heightMetrics.fontBoundingBoxAscent + heightMetrics.fontBoundingBoxDescent);
	c$7.restore();
	measureTextCache.set(cacheKey, {
		width,
		height,
		fontHeight
	});
	return {
		width,
		height,
		fontHeight
	};
}
function measureVisualTokens(c$7, settings$1, caches, visualTokens) {
	let width = 0;
	let height = 0;
	for (const { token } of visualTokens) {
		const metrics = measureText(c$7, settings$1, caches, token);
		width += metrics.width;
		height = Math.max(height, metrics.fontHeight);
	}
	return {
		width: Math.max(1, width),
		height: Math.ceil(Math.max(1, height))
	};
}
var visualLineCharOffsetCache = /* @__PURE__ */ new WeakMap();
function isLineEmpty(line) {
	if (line.tokens.length === 0) return true;
	return line.tokens.every((token) => token.token.text.trim() === "");
}
function findVisualLineForColumn(lines, logicalLine, column, tokenLines, caches) {
	const cacheKey = `${logicalLine}:${column}`;
	const cached = caches.findVisualLineForColumnCache.get(cacheKey);
	if (cached !== void 0) return cached;
	const relevantLines = lines.visualLinesByLogicalLine.value.get(logicalLine) ?? [];
	if (relevantLines.length === 0) return null;
	for (const visualLine of relevantLines) {
		const lineStartColumn = getCharOffsetForVisualLine(logicalLine, visualLine, tokenLines, lines);
		let lineEndColumn = lineStartColumn;
		for (let i$6 = 0; i$6 < visualLine.tokens.length; i$6++) lineEndColumn += visualLine.tokens[i$6].token.text.length;
		const isLast = visualLine === relevantLines[relevantLines.length - 1];
		if (column >= lineStartColumn && (column < lineEndColumn || isLast)) {
			caches.findVisualLineForColumnCache.set(cacheKey, visualLine);
			return visualLine;
		}
	}
	const result = relevantLines[relevantLines.length - 1];
	caches.findVisualLineForColumnCache.set(cacheKey, result);
	return result;
}
function getCharOffsetForVisualLine(logicalLine, visualLine, tokenLines, lines) {
	if (lines) {
		const cached = visualLineCharOffsetCache.get(visualLine);
		if (cached !== void 0) return cached;
	}
	const logicalLineTokens = tokenLines[logicalLine] || [];
	const currentTokenIndices = new Set(visualLine.tokens.map((t$12) => t$12.logicalTokenIndex));
	let columnOffset = 0;
	for (let i$6 = 0; i$6 < visualLine.tokenOffset; i$6++) if (!currentTokenIndices.has(i$6)) columnOffset += logicalLineTokens[i$6]?.text.length || 0;
	if (lines) {
		const allVisualLines = lines.visualLinesByLogicalLine.value.get(logicalLine) ?? [];
		for (const prevLine of allVisualLines) {
			if (prevLine === visualLine) break;
			for (const token of prevLine.tokens) if (currentTokenIndices.has(token.logicalTokenIndex)) columnOffset += token.token.text.length;
		}
	}
	if (lines) visualLineCharOffsetCache.set(visualLine, columnOffset);
	return columnOffset;
}
function getColumnFromVisualPosition(lines, visualLine, worldX, tokenLines, codeLines, canvas, settings$1, caches) {
	const logicalLine = visualLine.logicalLine;
	const lineText = codeLines[logicalLine] || "";
	const columnOffset = getCharOffsetForVisualLine(logicalLine, visualLine, tokenLines, lines);
	let currentColumn = columnOffset;
	if (visualLine.tokens.length === 0) return Math.min(columnOffset, lineText.length);
	for (let i$6 = 0; i$6 < visualLine.tokens.length; i$6++) {
		const visualToken = visualLine.tokens[i$6];
		if (worldX >= visualToken.x && worldX < visualToken.endX) {
			const tokenRelativeX = worldX - visualToken.x;
			const token = visualToken.token;
			if (tokenRelativeX < visualToken.tokenEndX - visualToken.x) {
				let charIndex = 0;
				let currentWidth = 0;
				for (let j$4 = 0; j$4 < token.text.length; j$4++) {
					const char = token.text[j$4];
					const charWidth = measureText(canvas.c, settings$1, caches, {
						type: token.type,
						text: char
					}).width;
					if (currentWidth + charWidth / 2 > tokenRelativeX) {
						charIndex = j$4;
						break;
					}
					currentWidth += charWidth;
					charIndex = j$4 + 1;
				}
				return Math.min(currentColumn + charIndex, lineText.length);
			} else return Math.min(currentColumn + token.text.length, lineText.length);
		}
		currentColumn += visualToken.token.text.length;
	}
	if (worldX < 0) return Math.min(columnOffset, lineText.length);
	else {
		if (visualLine.tokens[visualLine.tokens.length - 1]) return Math.min(currentColumn, lineText.length);
		return Math.min(columnOffset, lineText.length);
	}
}
function getXFromColumn(lines, visualLine, column, tokenLines, canvas, settings$1, caches) {
	const logicalLine = visualLine.logicalLine;
	if ((tokenLines[logicalLine] || []).length === 0 || visualLine.tokens.length === 0) return 0;
	const columnOffset = getCharOffsetForVisualLine(logicalLine, visualLine, tokenLines, lines);
	const cacheKey = `${logicalLine}:${visualLine.tokenOffset}:${column}`;
	const cached = caches.getXFromColumnCache.get(cacheKey);
	if (cached !== void 0) return cached;
	let currentColumn = columnOffset;
	for (let i$6 = 0; i$6 < visualLine.tokens.length; i$6++) {
		const visualToken = visualLine.tokens[i$6];
		const tokenStartColumn = currentColumn;
		const tokenEndColumn = currentColumn + visualToken.token.text.length;
		if (column >= tokenStartColumn && column <= tokenEndColumn) {
			const relativePos = column - tokenStartColumn;
			const tokenWidth = visualToken.tokenEndX - visualToken.x;
			const charWidth = visualToken.token.text.length > 0 ? tokenWidth / visualToken.token.text.length : 0;
			const result$1 = visualToken.x + relativePos * charWidth;
			caches.getXFromColumnCache.set(cacheKey, result$1);
			return result$1;
		} else if (column < tokenStartColumn && i$6 === 0) {
			caches.getXFromColumnCache.set(cacheKey, 0);
			return 0;
		} else if (column > tokenEndColumn && i$6 === visualLine.tokens.length - 1) {
			caches.getXFromColumnCache.set(cacheKey, visualToken.endX);
			return visualToken.endX;
		}
		currentColumn = tokenEndColumn;
	}
	const lastToken = visualLine.tokens[visualLine.tokens.length - 1];
	if (lastToken) {
		caches.getXFromColumnCache.set(cacheKey, lastToken.endX);
		return lastToken.endX;
	}
	const result = 0;
	caches.getXFromColumnCache.set(cacheKey, result);
	return result;
}
function getXFromColumnUnclamped(lines, visualLine, column, tokenLines, canvas, settings$1, caches) {
	const logicalLine = visualLine.logicalLine;
	if ((tokenLines[logicalLine] || []).length === 0 || visualLine.tokens.length === 0) return 0;
	const cacheKey = `u:${logicalLine}:${visualLine.tokenOffset}:${column}`;
	const cached = caches.getXFromColumnCache.get(cacheKey);
	if (cached !== void 0) return cached;
	const columnOffset = getCharOffsetForVisualLine(logicalLine, visualLine, tokenLines, lines);
	if (column < columnOffset) {
		caches.getXFromColumnCache.set(cacheKey, 0);
		return 0;
	}
	if (column === columnOffset) {
		caches.getXFromColumnCache.set(cacheKey, 0);
		return 0;
	}
	let currentColumn = columnOffset;
	for (let i$6 = 0; i$6 < visualLine.tokens.length; i$6++) {
		const visualToken = visualLine.tokens[i$6];
		const tokenStartColumn = currentColumn;
		const tokenEndColumn = currentColumn + visualToken.token.text.length;
		if (column >= tokenStartColumn && column <= tokenEndColumn) {
			const relativePos = column - tokenStartColumn;
			const tokenWidth = visualToken.tokenEndX - visualToken.x;
			const charWidth = visualToken.token.text.length > 0 ? tokenWidth / visualToken.token.text.length : 0;
			const result = visualToken.x + relativePos * charWidth;
			caches.getXFromColumnCache.set(cacheKey, result);
			return result;
		} else if (column < tokenStartColumn && i$6 === 0) {
			caches.getXFromColumnCache.set(cacheKey, 0);
			return 0;
		}
		currentColumn = tokenEndColumn;
	}
	const lastToken = visualLine.tokens[visualLine.tokens.length - 1];
	if (lastToken) {
		const tokenWidth = lastToken.tokenEndX - lastToken.x;
		const charWidth = lastToken.token.text.length > 0 ? tokenWidth / lastToken.token.text.length : 0;
		const columnsBeyond = column - currentColumn;
		const result = lastToken.endX + columnsBeyond * charWidth;
		caches.getXFromColumnCache.set(cacheKey, result);
		return result;
	}
	caches.getXFromColumnCache.set(cacheKey, 0);
	return 0;
}
function getColumnForTokenIndex(tokens, tokenIndex) {
	let column = 0;
	for (let i$6 = 0; i$6 < tokenIndex && i$6 < tokens.length; i$6++) column += tokens[i$6].text.length;
	return column;
}
function getTokenIndexFromColumn(tokens, column) {
	let charOffset = 0;
	for (let i$6 = 0; i$6 < tokens.length; i$6++) {
		const token = tokens[i$6];
		const tokenEnd = charOffset + token.text.length;
		if (column >= charOffset && column < tokenEnd) return i$6;
		if (column === tokenEnd && i$6 === tokens.length - 1) return i$6 + 1;
		charOffset = tokenEnd;
	}
	return tokens.length;
}
function isWordChar(char) {
	return /[a-zA-Z0-9_]/.test(char);
}
function findWordBoundaries(line, column) {
	if (line.length === 0) return {
		start: 0,
		end: 0
	};
	const clampedColumn = Math.max(0, Math.min(column, line.length));
	if (clampedColumn === line.length) {
		if (isWordChar(line[clampedColumn - 1])) {
			let start = clampedColumn - 1;
			while (start > 0 && isWordChar(line[start - 1])) start--;
			return {
				start,
				end: clampedColumn
			};
		}
		return {
			start: clampedColumn,
			end: clampedColumn
		};
	}
	const char = line[clampedColumn];
	if (isWordChar(char)) {
		let start = clampedColumn;
		while (start > 0 && isWordChar(line[start - 1])) start--;
		let end = clampedColumn + 1;
		while (end < line.length && isWordChar(line[end])) end++;
		return {
			start,
			end
		};
	}
	return {
		start: clampedColumn,
		end: clampedColumn
	};
}
function findLineBoundaries(line) {
	return {
		start: 0,
		end: line.length
	};
}
var SCROLLBAR_MIN_THUMB = 20;
var SCROLLBAR_TRACK_COLOR = "rgba(255, 255, 255, 0.05)";
var SCROLLBAR_THUMB_COLOR = "rgba(255, 255, 255, 0.1)";
var SCROLLBAR_THUMB_HOVER_COLOR = "rgba(255, 255, 255, 0.2)";
function hitTestScrollbar(canvas, scroll, lines, settings$1, gutter, header, x$4, y$5) {
	const width = canvas.size.width.value;
	const height = canvas.size.height.value;
	const totalWidth = lines.totalWidth.value;
	const totalHeight = lines.totalHeight.value;
	const scrollWidth = scroll.scrollWidth.value;
	const scrollHeight = scroll.scrollHeight.value;
	const scrollX = scroll.targetX.value;
	const scrollY = scroll.targetY.value;
	const headerHeight = header.value?.height ?? 0;
	const availableHeight = height - headerHeight - settings$1.paddingTop - settings$1.paddingBottom;
	const availableWidth = width - settings$1.paddingLeft - settings$1.paddingRight - gutter.width.value;
	const needsVertical = totalHeight > availableHeight;
	const needsHorizontal = !settings$1.wordWrap && totalWidth > availableWidth;
	if (needsVertical) {
		if (x$4 >= width - 12 && x$4 <= width && y$5 >= headerHeight) {
			const trackHeight = height - headerHeight;
			const thumbHeight = Math.max(SCROLLBAR_MIN_THUMB, availableHeight / totalHeight * trackHeight);
			const scrollRange = -scrollHeight;
			const thumbY = headerHeight + (scrollRange > 0 ? -scrollY / scrollRange : 0) * (trackHeight - thumbHeight);
			return {
				type: "vertical",
				thumb: y$5 >= thumbY && y$5 <= thumbY + thumbHeight
			};
		}
	}
	if (needsHorizontal) {
		if (y$5 >= height - 3 && y$5 <= height) {
			const trackWidth = width - (needsVertical ? 12 : 0);
			const thumbWidth = Math.max(SCROLLBAR_MIN_THUMB, availableWidth / totalWidth * trackWidth);
			const scrollRange = -scrollWidth;
			const thumbX = (scrollRange > 0 ? -scrollX / scrollRange : 0) * (trackWidth - thumbWidth);
			return {
				type: "horizontal",
				thumb: x$4 >= thumbX && x$4 <= thumbX + thumbWidth
			};
		}
	}
	return {
		type: null,
		thumb: false
	};
}
function drawScrollbars(context) {
	const { canvas, scroll, lines, settings: settings$1, gutter, header } = context;
	const { c: c$7 } = canvas;
	const width = canvas.size.width.value;
	const height = canvas.size.height.value;
	const totalWidth = lines.totalWidth.value;
	const totalHeight = lines.totalHeight.value;
	const scrollWidth = scroll.scrollWidth.value;
	const scrollHeight = scroll.scrollHeight.value;
	const scrollX = scroll.targetX.value;
	const scrollY = scroll.targetY.value;
	const headerHeight = header.value?.height ?? 0;
	const availableHeight = height - headerHeight - settings$1.paddingTop - settings$1.paddingBottom;
	const availableWidth = width - settings$1.paddingLeft - settings$1.paddingRight - gutter.width.value;
	const needsVertical = totalHeight > availableHeight;
	const needsHorizontal = !settings$1.wordWrap && totalWidth > availableWidth;
	if (needsVertical) {
		const scrollbarX = width - 12;
		const trackHeight = height - headerHeight;
		c$7.strokeStyle = SCROLLBAR_TRACK_COLOR;
		c$7.lineWidth = 1;
		c$7.beginPath();
		c$7.moveTo(scrollbarX, headerHeight);
		c$7.lineTo(scrollbarX, height);
		c$7.stroke();
		const thumbHeight = Math.max(SCROLLBAR_MIN_THUMB, availableHeight / totalHeight * trackHeight);
		const scrollRange = -scrollHeight;
		const thumbY = headerHeight + (scrollRange > 0 ? -scrollY / scrollRange : 0) * (trackHeight - thumbHeight);
		c$7.fillStyle = context.mouse.hovered.scrollbar === "vertical" ? SCROLLBAR_THUMB_HOVER_COLOR : SCROLLBAR_THUMB_COLOR;
		c$7.fillRect(scrollbarX, thumbY, 12, thumbHeight);
	}
	if (needsHorizontal) {
		const scrollbarY = height - 3;
		const trackWidth = width - (needsVertical ? 12 : 0);
		const thumbWidth = Math.max(SCROLLBAR_MIN_THUMB, availableWidth / totalWidth * trackWidth);
		const scrollRange = -scrollWidth;
		const thumbX = (scrollRange > 0 ? -scrollX / scrollRange : 0) * (trackWidth - thumbWidth);
		c$7.fillStyle = context.mouse.hovered.scrollbar === "horizontal" ? SCROLLBAR_THUMB_HOVER_COLOR : SCROLLBAR_THUMB_COLOR;
		c$7.fillRect(thumbX, scrollbarY, thumbWidth, 3);
	}
}
function getAboveHeight(visualLines, line) {
	if (line.widgets.above.length === 0) return 0;
	const firstVisualLineIndex = visualLines.findIndex((l$10) => l$10.logicalLine === line.logicalLine && l$10.tokenOffset === 0);
	if (firstVisualLineIndex === -1) return 0;
	let emptyHeight = 0;
	for (let i$6 = firstVisualLineIndex - 1; i$6 >= 0; i$6--) {
		const prevLine = visualLines[i$6];
		if (prevLine.logicalLine >= line.logicalLine) continue;
		if (isLineEmpty(prevLine)) emptyHeight += prevLine.height;
		else break;
	}
	return emptyHeight;
}
function calculateAboveHeightForLine(context, line) {
	return getAboveHeight(context.lines.visualLines.value, line);
}
function shouldBreakBottom(visualLines, line, lineY, visibleBottom, scrollY) {
	if (lineY <= visibleBottom + getAboveHeight(visualLines, line)) return false;
	if (!isLineEmpty(line)) return true;
	const idx = visualLines.indexOf(line);
	for (let j$4 = idx + 1; j$4 < visualLines.length; j$4++) {
		const next = visualLines[j$4];
		if (next.tokenOffset === 0 && next.widgets.above.length > 0) {
			const nextAbove = getAboveHeight(visualLines, next);
			if (next.y + scrollY <= visibleBottom + nextAbove) return false;
			break;
		}
	}
	return true;
}
function drawAboveWidgets(context, line) {
	const aboveWidgets = line.widgets.above;
	if (aboveWidgets.length === 0) return;
	const { lines } = context;
	const { c: c$7, size } = context.canvas;
	const visualLines = context.lines.visualLines.value;
	if (visualLines.findIndex((l$10) => l$10 === line) === -1) return;
	let emptyHeight = 0;
	const firstVisualLineIndex = visualLines.findIndex((l$10) => l$10.logicalLine === line.logicalLine && l$10.tokenOffset === 0);
	if (firstVisualLineIndex === -1) return;
	for (let i$6 = firstVisualLineIndex - 1; i$6 >= 0; i$6--) {
		const prevLine = visualLines[i$6];
		if (prevLine.logicalLine >= line.logicalLine) continue;
		if (isLineEmpty(prevLine)) emptyHeight += prevLine.height;
		else break;
	}
	if (emptyHeight === 0) return;
	const tokenLines = context.doc.tokenLines;
	tokenLines[line.logicalLine];
	const lineStartColumn = getCharOffsetForVisualLine(line.logicalLine, line, tokenLines, context.lines);
	let lineEndColumn = lineStartColumn;
	for (const token of line.tokens) lineEndColumn += token.token.text.length;
	const widgetPositions = [];
	for (const widget of aboveWidgets) {
		const [startColumn, endColumn] = widget.pos.x;
		const startCol0 = startColumn - 1;
		const endCol0 = endColumn - 1;
		if (startCol0 >= lineEndColumn) continue;
		const clampedStartColumn = Math.max(startCol0, lineStartColumn);
		const clampedEndColumn = Math.min(endCol0, lineEndColumn);
		const startX = getXFromColumnUnclamped(lines, line, clampedStartColumn, tokenLines, context.canvas, context.settings, context.caches);
		const widgetWidth = getXFromColumnUnclamped(lines, line, clampedEndColumn, tokenLines, context.canvas, context.settings, context.caches) - startX;
		const finalWidth = widgetWidth > 0 ? widgetWidth : size.width.value - startX;
		widgetPositions.push({
			widget,
			x: startX,
			width: finalWidth
		});
	}
	widgetPositions.sort((a$36, b$4) => a$36.x - b$4.x);
	const widgetY = line.tokenOffset === 0 ? line.y - emptyHeight : line.y;
	for (let i$6 = 0; i$6 < widgetPositions.length; i$6++) {
		const current = widgetPositions[i$6];
		let width = current.width;
		if (i$6 < widgetPositions.length - 1) {
			const next = widgetPositions[i$6 + 1];
			if (current.x + width > next.x) width = next.x - current.x;
		}
		if (width > 0) {
			c$7.save();
			current.widget.draw(c$7, current.x, widgetY, width, emptyHeight);
			c$7.restore();
		}
	}
}
function drawFullWidgets(context, line) {
	const fullWidgets = line.widgets.full ?? [];
	if (fullWidgets.length === 0 || line.tokenOffset !== 0) return;
	const { c: c$7 } = context.canvas;
	const visualLines = context.lines.visualLines.value;
	const firstVisualLineIndex = visualLines.findIndex((l$10) => l$10.logicalLine === line.logicalLine && l$10.tokenOffset === 0);
	if (firstVisualLineIndex === -1) return;
	let emptyHeight = 0;
	for (let i$6 = firstVisualLineIndex - 1; i$6 >= 0; i$6--) {
		const prevLine = visualLines[i$6];
		if (prevLine.logicalLine >= line.logicalLine) continue;
		if (isLineEmpty(prevLine)) emptyHeight += prevLine.height;
		else break;
	}
	if (emptyHeight === 0) return;
	const headerHeight = context.header.value?.height ?? 0;
	const needsVertical = context.lines.totalHeight.value > context.canvas.size.height.value - headerHeight - context.settings.paddingTop - context.settings.paddingBottom;
	const widgetY = line.y - emptyHeight;
	const x$4 = -context.scroll.pos.x;
	const contentLeft = context.gutter.width.value + context.settings.paddingLeft;
	const w$5 = context.canvas.size.width.value - context.gutter.width.value - (needsVertical ? 12 : 0);
	const fw = context.canvas.size.width.value;
	for (const widget of fullWidgets) {
		c$7.save();
		widget.draw(c$7, x$4, widgetY, w$5, emptyHeight, fw, contentLeft);
		c$7.restore();
	}
}
function drawBelowWidgets(context, line) {
	const widgets = line.widgets.below;
	if (widgets.length === 0) return;
	const { lines } = context;
	const { c: c$7 } = context.canvas;
	const { lineHeight: lineHeight$1 } = context.settings;
	const tokenLines = context.doc.tokenLines;
	const aboveHeight = calculateAboveHeightForLine(context, line);
	const contentY = line.tokenOffset === 0 ? line.y : line.y + aboveHeight;
	for (const widget of widgets) {
		const [startColumn, endColumn] = widget.pos.x;
		const startCol0 = startColumn - 1;
		const endCol0 = endColumn - 1;
		const startX = getXFromColumnUnclamped(lines, line, startCol0, tokenLines, context.canvas, context.settings, context.caches);
		const widgetWidth = getXFromColumnUnclamped(lines, line, endCol0, tokenLines, context.canvas, context.settings, context.caches) - startX;
		c$7.save();
		widget.draw(c$7, startX, contentY + lineHeight$1 - 2, widgetWidth, lineHeight$1);
		c$7.restore();
	}
}
function drawOverlayWidgets(context, line) {
	const widgets = line.widgets.overlay;
	if (widgets.length === 0) return;
	const { lines } = context;
	const { c: c$7 } = context.canvas;
	const { lineHeight: lineHeight$1 } = context.settings;
	const tokenLines = context.doc.tokenLines;
	const aboveHeight = calculateAboveHeightForLine(context, line);
	const contentY = line.tokenOffset === 0 ? line.y : line.y + aboveHeight;
	for (const widget of widgets) {
		const [startColumn, endColumn] = widget.pos.x;
		const startCol0 = startColumn - 1;
		const endCol0 = endColumn - 1;
		const startX = getXFromColumnUnclamped(lines, line, startCol0, tokenLines, context.canvas, context.settings, context.caches);
		const widgetWidth = getXFromColumnUnclamped(lines, line, endCol0, tokenLines, context.canvas, context.settings, context.caches) - startX;
		c$7.save();
		widget.draw(c$7, startX, contentY, widgetWidth, lineHeight$1);
		c$7.restore();
	}
}
function drawInlayWidgets(context, line) {
	const widgets = line.widgets.inlay;
	if (widgets.length === 0) return;
	const { lines } = context;
	const { c: c$7 } = context.canvas;
	const { lineHeight: lineHeight$1 } = context.settings;
	const tokenLines = context.doc.tokenLines;
	const lineY = line.y;
	const charOffset = getCharOffsetForVisualLine(line.logicalLine, line, tokenLines, context.lines);
	const tokenStart = line.tokenOffset;
	for (const widget of widgets) {
		const widgetColumn = widget.pos.x - 1;
		let currentCharOffset = charOffset;
		for (let i$6 = tokenStart; i$6 < tokenStart + line.tokens.length; i$6++) {
			const token = tokenLines[line.logicalLine]?.[i$6];
			if (!token) break;
			const tokenEnd = currentCharOffset + token.text.length;
			if (widgetColumn >= currentCharOffset && widgetColumn <= tokenEnd) {
				const widgetX = getXFromColumnUnclamped(lines, line, widgetColumn, tokenLines, context.canvas, context.settings, context.caches);
				const { width } = measureText(c$7, context.settings, context.caches, {
					text: widget.content,
					type: "text"
				});
				c$7.save();
				c$7.font = `400 normal ${context.settings.fontSize} '${context.settings.fontFamilyName}', monospace`;
				c$7.textBaseline = "top";
				widget.draw(c$7, widgetX, lineY, width, lineHeight$1);
				c$7.restore();
				break;
			}
			currentCharOffset = tokenEnd;
		}
	}
}
function drawBeforeAfterWidgets(context, line) {
	const widgets = line.widgets.beforeAfter;
	if (widgets.length === 0) return;
	const { lines } = context;
	const { c: c$7 } = context.canvas;
	const { lineHeight: lineHeight$1 } = context.settings;
	const tokenLines = context.doc.tokenLines;
	const aboveHeight = calculateAboveHeightForLine(context, line);
	const contentY = line.tokenOffset === 0 ? line.y : line.y + aboveHeight;
	let lineStartColumn = getCharOffsetForVisualLine(line.logicalLine, line, tokenLines, context.lines);
	let lineEndColumn = lineStartColumn;
	for (const token of line.tokens) lineEndColumn += token.token.text.length;
	for (const widget of widgets) {
		const widgetColumn = widget.pos.x - 1;
		if (widget.type === "before") {
			if (widgetColumn < lineStartColumn || widgetColumn >= lineEndColumn) continue;
			const widgetX = getXFromColumnUnclamped(lines, line, widgetColumn, tokenLines, context.canvas, context.settings, context.caches);
			c$7.save();
			widget.draw(c$7, widgetX, contentY, widget.pos.width, lineHeight$1);
			c$7.restore();
			continue;
		}
		if (widget.type === "after") {
			if (widgetColumn <= lineStartColumn || widgetColumn > lineEndColumn) continue;
			const widgetX = getXFromColumnUnclamped(lines, line, widgetColumn + 1, tokenLines, context.canvas, context.settings, context.caches);
			c$7.save();
			widget.draw(c$7, widgetX, contentY, widget.pos.width, lineHeight$1);
			c$7.restore();
			continue;
		}
	}
}
var OPACITY_HIGHLIGHT = .8;
var OPACITY_NORMAL = .3;
var LINE_WIDTH$6 = 1;
function drawBlocks(context) {
	const { canvas, doc, lines, blocks, settings: settings$1, caches, scroll, header, caret } = context;
	const { c: c$7 } = canvas;
	const visualLines = lines.visualLines.value;
	const visualLinesByLogicalLine = lines.visualLinesByLogicalLine.value;
	const blockStarts = blocks.blockStarts.value;
	const codeLines = doc.lines;
	const tokenLines = doc.tokenLines;
	const scrollY = scroll.pos.y;
	const visibleTop = -(header.value?.height ?? 0) - settings$1.paddingTop;
	const canvasHeight = canvas.size.height.value - settings$1.paddingTop;
	const matchingBrace = blocks.findMatchingBrace(caret.line.value, caret.column.value);
	const blockColors = settings$1.ui.blockColors;
	function textBottom(line) {
		return line.y + (line.widgets.below.length > 0 ? settings$1.lineHeight : line.height);
	}
	c$7.save();
	c$7.lineWidth = LINE_WIDTH$6;
	c$7.lineCap = "square";
	c$7.lineJoin = "miter";
	if (matchingBrace && matchingBrace.line === matchingBrace.matchingLine) {
		let openColumn = 0;
		for (let i$6 = 0; i$6 < matchingBrace.tokenIndex; i$6++) openColumn += tokenLines[matchingBrace.line][i$6]?.text.length || 0;
		openColumn += matchingBrace.charIndex + 1;
		let closeColumn = 0;
		for (let i$6 = 0; i$6 < matchingBrace.matchingTokenIndex; i$6++) closeColumn += tokenLines[matchingBrace.matchingLine][i$6]?.text.length || 0;
		closeColumn += matchingBrace.matchingCharIndex;
		if (closeColumn !== openColumn) {
			const braceVisualLine = findVisualLineForColumn(lines, matchingBrace.line, openColumn, tokenLines, caches);
			if (braceVisualLine) {
				const openX = getXFromColumn(lines, braceVisualLine, openColumn, tokenLines, canvas, settings$1, caches);
				const closeX = getXFromColumn(lines, braceVisualLine, closeColumn, tokenLines, canvas, settings$1, caches);
				const braceY = textBottom(braceVisualLine);
				c$7.strokeStyle = blockColors[matchingBrace.depth % blockColors.length];
				c$7.globalAlpha = OPACITY_HIGHLIGHT;
				c$7.beginPath();
				c$7.moveTo(openX, braceY);
				c$7.lineTo(closeX, braceY);
				c$7.stroke();
			}
		}
	}
	function getBlockInfo(startLine) {
		if (startLine < 0 || startLine >= codeLines.length) return null;
		const cached = caches.blockInfoCache.get(startLine);
		if (cached !== void 0) return cached;
		const endLine = blocks.blockEnds.value.get(startLine);
		if (endLine === void 0 || endLine < startLine) return null;
		const depth = blocks.braceDepths.value.get(startLine) ?? null;
		const startLineText = codeLines[startLine];
		const info = {
			endLine,
			depth,
			indent: startLineText.length - startLineText.trimStart().length
		};
		caches.blockInfoCache.set(startLine, info);
		return info;
	}
	function findBlockContainingLine(line) {
		if (line < 0 || line >= codeLines.length) return null;
		let bestStart = null;
		for (const startLine of blockStarts) {
			if (startLine > line) continue;
			const info = getBlockInfo(startLine);
			if (!info) continue;
			if (line >= startLine && line <= info.endLine) {
				if (bestStart === null || startLine > bestStart) {
					bestStart = startLine;
					info.endLine;
				}
			}
		}
		return bestStart;
	}
	function findNearestBlockStart(line) {
		if (line < 0 || line >= codeLines.length) return null;
		let nearest = null;
		for (const startLine of blockStarts) if (startLine <= line) {
			if (nearest === null || startLine > nearest) nearest = startLine;
		}
		return nearest;
	}
	const visibleLogicalLines = /* @__PURE__ */ new Set();
	for (let i$6 = 0; i$6 < visualLines.length; i$6++) {
		const visualLine = visualLines[i$6];
		const lineY = visualLine.y + scrollY;
		const blockTop = lineY - calculateAboveHeightForLine(context, visualLine);
		if (lineY + visualLine.height > visibleTop && blockTop < canvasHeight) visibleLogicalLines.add(visualLine.logicalLine);
		else if (isLineEmpty(visualLine)) for (let j$4 = i$6 + 1; j$4 < visualLines.length; j$4++) {
			const next = visualLines[j$4];
			if (next.tokenOffset === 0 && next.widgets.above.length > 0) {
				const nextAbove = calculateAboveHeightForLine(context, next);
				const nextY = next.y + scrollY;
				if (nextY + next.height > visibleTop && nextY - nextAbove < canvasHeight) visibleLogicalLines.add(visualLine.logicalLine);
				break;
			}
		}
	}
	if (visibleLogicalLines.size === 0) {
		c$7.restore();
		return;
	}
	const blocksToDraw = /* @__PURE__ */ new Set();
	for (const logicalLine of visibleLogicalLines) {
		const containingBlock = findBlockContainingLine(logicalLine);
		if (containingBlock !== null) blocksToDraw.add(containingBlock);
		else {
			const nearestBlock = findNearestBlockStart(logicalLine);
			if (nearestBlock !== null) blocksToDraw.add(nearestBlock);
		}
	}
	const drawnBlocks = /* @__PURE__ */ new Set();
	function drawBlock(startLine) {
		if (drawnBlocks.has(startLine)) return;
		if (!blockStarts.has(startLine)) return;
		drawnBlocks.add(startLine);
		const info = getBlockInfo(startLine);
		if (!info) return;
		const { endLine, depth } = info;
		if (depth === null) return;
		const startVisualLines = visualLinesByLogicalLine.get(startLine) ?? [];
		const endVisualLines = visualLinesByLogicalLine.get(endLine) ?? [];
		if (startVisualLines.length === 0) return;
		const startVisualLine = startVisualLines.at(0);
		const isCollapsed = blocks.isCollapsed(startLine);
		const hasMatchingBrace = matchingBrace && startLine === matchingBrace.line && endLine === matchingBrace.matchingLine - 1;
		if (isCollapsed && !hasMatchingBrace) return;
		const startLineText = codeLines[startLine];
		const x$4 = getXFromColumn(lines, startVisualLine, startLineText.length - startLineText.trimStart().length, tokenLines, canvas, settings$1, caches) + 1;
		const startY = startVisualLine.y + startVisualLine.height;
		if (isCollapsed) {
			if (hasMatchingBrace && matchingBrace.line === startLine) {
				let braceColumn = 0;
				for (let i$6 = 0; i$6 < matchingBrace.tokenIndex; i$6++) braceColumn += tokenLines[matchingBrace.line][i$6]?.text.length || 0;
				braceColumn += matchingBrace.charIndex;
				const braceVisualLine = findVisualLineForColumn(lines, matchingBrace.line, braceColumn, tokenLines, caches);
				if (braceVisualLine) {
					const braceX = getXFromColumn(lines, braceVisualLine, braceColumn, tokenLines, canvas, settings$1, caches);
					const startYCanvas$1 = startY + scrollY;
					if (startYCanvas$1 < visibleTop || startYCanvas$1 > canvasHeight) return;
					c$7.strokeStyle = blockColors[matchingBrace.depth % blockColors.length];
					c$7.globalAlpha = OPACITY_HIGHLIGHT;
					c$7.beginPath();
					c$7.moveTo(x$4, startY);
					c$7.lineTo(braceX, startY);
					c$7.stroke();
				}
			}
			return;
		}
		if (endVisualLines.length === 0) return;
		const endY = textBottom(endVisualLines.at(-1));
		const startYCanvas = startY + scrollY;
		if (endY + scrollY < visibleTop || startYCanvas > canvasHeight) return;
		if (hasMatchingBrace) {
			c$7.strokeStyle = blockColors[matchingBrace.depth % blockColors.length];
			c$7.globalAlpha = OPACITY_HIGHLIGHT;
		} else {
			c$7.strokeStyle = blockColors[depth % blockColors.length];
			c$7.globalAlpha = OPACITY_NORMAL;
		}
		c$7.beginPath();
		c$7.moveTo(x$4, endY);
		c$7.lineTo(x$4, startY);
		if (hasMatchingBrace) {
			if (matchingBrace.line === startLine) {
				let braceColumn = 0;
				for (let i$6 = 0; i$6 < matchingBrace.tokenIndex; i$6++) braceColumn += tokenLines[matchingBrace.line][i$6]?.text.length || 0;
				braceColumn += matchingBrace.charIndex;
				const braceVisualLine = findVisualLineForColumn(lines, matchingBrace.line, braceColumn, tokenLines, caches);
				if (braceVisualLine) {
					const braceX = getXFromColumn(lines, braceVisualLine, braceColumn, tokenLines, canvas, settings$1, caches);
					c$7.lineTo(braceX, startY);
				}
			}
		}
		c$7.stroke();
	}
	function walkUp(fromLine) {
		if (fromLine < 0) return;
		for (let line = fromLine; line >= 0; line--) {
			if (!blockStarts.has(line)) continue;
			const info = getBlockInfo(line);
			if (!info) continue;
			if (!blocksToDraw.has(line)) blocksToDraw.add(line);
			if (info.indent === 0) return;
		}
	}
	function walkDown(fromLine) {
		if (fromLine >= codeLines.length) return;
		for (let line = fromLine; line < codeLines.length; line++) {
			if (!blockStarts.has(line)) continue;
			const info = getBlockInfo(line);
			if (!info) continue;
			if (!blocksToDraw.has(line)) blocksToDraw.add(line);
			if (info.indent === 0) return;
		}
	}
	const visibleLinesArray = Array.from(visibleLogicalLines).sort((a$36, b$4) => a$36 - b$4);
	if (visibleLinesArray.length > 0) {
		const firstVisibleLine = visibleLinesArray[0];
		const lastVisibleLine = visibleLinesArray[visibleLinesArray.length - 1];
		walkUp(firstVisibleLine - 1);
		walkDown(lastVisibleLine + 1);
	}
	for (const startLine of blocksToDraw) drawBlock(startLine);
	c$7.restore();
}
let MouseButton$1 = /* @__PURE__ */ function(MouseButton$2) {
	MouseButton$2[MouseButton$2["Left"] = 0] = "Left";
	MouseButton$2[MouseButton$2["Middle"] = 1] = "Middle";
	MouseButton$2[MouseButton$2["Right"] = 2] = "Right";
	MouseButton$2[MouseButton$2["Back"] = 3] = "Back";
	MouseButton$2[MouseButton$2["Forward"] = 4] = "Forward";
	return MouseButton$2;
}({});
const activeEditor$1 = c$3(null);
function setActiveEditor(editor$1) {
	activeEditor$1.value = editor$1;
}
var keyOverride = null;
function onKeyOverride(fn$1) {
	keyOverride = fn$1;
}
function runKeyOverride(event) {
	return keyOverride?.(event) === true;
}
var textarea = null;
var activeHandlers = null;
var activeCanvas = null;
var isRefocusing = false;
function getTextarea() {
	if (!textarea) {
		textarea = document.createElement("textarea");
		textarea.style.position = "fixed";
		textarea.style.left = "0";
		textarea.style.top = "0";
		textarea.style.width = "1px";
		textarea.style.height = "1px";
		textarea.style.opacity = "0.01";
		textarea.style.zIndex = "-1";
		textarea.style.outline = "none";
		textarea.style.border = "none";
		textarea.style.padding = "0";
		textarea.style.margin = "0";
		textarea.style.overflow = "hidden";
		textarea.setAttribute("tabindex", "0");
		document.body.appendChild(textarea);
		const handleBlur = () => {
			if (isRefocusing) return;
			if (activeCanvas && document.activeElement === activeCanvas) {
				isRefocusing = true;
				setTimeout(() => {
					if (activeCanvas && document.activeElement !== textarea) textarea?.focus();
					isRefocusing = false;
				}, 10);
			}
		};
		const handleWindowFocus = () => {
			if (activeCanvas && document.activeElement === activeCanvas) setTimeout(() => {
				if (activeCanvas && document.activeElement !== textarea) textarea?.focus();
			}, 10);
		};
		textarea.addEventListener("blur", handleBlur);
		window.addEventListener("focus", handleWindowFocus);
		const handleDocumentMouseDown = (event) => {
			if (event.button !== 0) return;
			if (!activeCanvas) return;
			const target = event.target;
			if (!target) return;
			if (target === textarea) return;
			let isInsideCanvas = false;
			let node = target;
			while (node) {
				if (node.nodeName === "CANVAS") {
					isInsideCanvas = true;
					break;
				}
				node = node.parentNode;
			}
			if (!isInsideCanvas) setTimeout(() => {
				const activeElement = document.activeElement;
				if (activeElement !== textarea && activeElement?.tagName !== "CANVAS") setActiveCanvas(null);
			}, 0);
		};
		document.addEventListener("mousedown", handleDocumentMouseDown, true);
		textarea.addEventListener("paste", (event) => {
			activeHandlers?.handlePaste(event);
		});
		textarea.addEventListener("input", (event) => {
			activeHandlers?.handleInput(event);
		});
		textarea.addEventListener("keydown", (event) => {
			if (runKeyOverride(event)) {
				event.stopPropagation();
				event.stopImmediatePropagation();
				event.preventDefault();
				return;
			}
			activeHandlers?.handleKeyDown(event);
		});
		textarea.addEventListener("keyup", (event) => {
			activeHandlers?.handleKeyUp(event);
		});
	}
	return textarea;
}
function setActiveClipboard(handlers, canvas) {
	activeHandlers = handlers;
	if (canvas !== void 0) activeCanvas = canvas;
	if (handlers && activeCanvas) handlers.focus();
}
function getActiveCanvas() {
	return activeCanvas;
}
function setActiveCanvas(canvas) {
	activeCanvas = canvas;
	if (!canvas) setActiveEditor(null);
}
function getTextareaElement() {
	return getTextarea();
}
var COLLAPSE_TOGGLE_SIZE = 11;
function drawGutterBackground(context) {
	if (!context.settings.showGutter) return;
	const { canvas, gutter, header } = context;
	const { c: c$7 } = canvas;
	const gutterWidth = gutter.width.value;
	const { size: { height: { value: height } } } = canvas;
	const headerHeight = header.value?.height ?? 0;
	c$7.save();
	c$7.fillStyle = context.settings.ui.background + "dd";
	c$7.fillRect(-context.settings.paddingLeft, -headerHeight - context.settings.paddingTop, gutterWidth + context.settings.paddingLeft, height + headerHeight + context.settings.paddingTop);
	c$7.restore();
}
function drawGutter(context) {
	if (!context.settings.showGutter) return;
	const { canvas, lines, caret, settings: settings$1, gutter, doc, header, caches } = context;
	const { c: c$7 } = canvas;
	const visualLines = lines.visualLines.value;
	const currentLine = caret.line.value;
	const currentColumn = caret.column.value;
	const collapsedLines = doc.collapsed;
	const gutterWidth = gutter.width.value;
	const { size: { height: { value: height } } } = canvas;
	const { paddingTop } = settings$1;
	const { y: scrollY } = context.scroll.pos;
	const visibleTop = -(header.value?.height ?? 0) - paddingTop;
	const visibleBottom = height - paddingTop;
	const lineNumberMap = gutter.lineNumberMap.value;
	const blockStarts = gutter.blockStarts.value;
	const lineNumberMetrics = gutter.lineNumberMetrics.value;
	const isFocused = getActiveCanvas() === canvas.el;
	const currentVisualLine = isFocused && currentLine >= 0 && currentLine < doc.lines.length ? findVisualLineForColumn(lines, currentLine, currentColumn, doc.tokenLines, caches) : null;
	c$7.save();
	for (const visualLine of visualLines) {
		const lineY = visualLine.y + scrollY;
		if (lineY + visualLine.height < visibleTop) continue;
		if (shouldBreakBottom(visualLines, visualLine, lineY, visibleBottom, scrollY)) break;
		const logicalLine = visualLine.logicalLine;
		const isFirstVisualLine = lineNumberMap.get(logicalLine)?.[0] === visualLine;
		const hasError = visualLine.errors.length > 0;
		const isCurrentVisualLine = visualLine.y === currentVisualLine?.y;
		const isCollapsed = collapsedLines.has(logicalLine);
		const canCollapse = blockStarts.has(logicalLine);
		if (isCurrentVisualLine) {
			c$7.fillStyle = "rgba(255, 255, 255, 0.05)";
			c$7.fillRect(-settings$1.paddingLeft, lineY, gutterWidth + settings$1.paddingLeft, settings$1.lineHeight);
		}
		if (!isFirstVisualLine) continue;
		const metrics = lineNumberMetrics.get(logicalLine);
		if (metrics) {
			const lineNumberY = lineY + 2;
			c$7.fillStyle = hasError ? "#f00" : "rgba(255, 255, 255, 0.3)";
			c$7.font = `${settings$1.fontSize} ${settings$1.fontFamilyName}`;
			c$7.textBaseline = "top";
			c$7.fillText(metrics.text, metrics.x, lineNumberY);
		}
		if (canCollapse && (isCollapsed || context.mouse.hovered.gutter)) {
			const toggleX = gutterWidth - COLLAPSE_TOGGLE_SIZE - 5;
			const toggleY = lineY + 6.5;
			const size = COLLAPSE_TOGGLE_SIZE - 4;
			const centerX = toggleX + size / 2;
			const centerY = toggleY + size / 2;
			const halfSize = size / 2;
			c$7.lineWidth = 1.5;
			c$7.lineCap = "round";
			c$7.lineJoin = "round";
			c$7.beginPath();
			if (isCollapsed) {
				c$7.strokeStyle = hasError ? settings$1.colors.white : settings$1.colors.white;
				c$7.save();
				c$7.translate(-halfSize * .25, -halfSize * 1.75);
				c$7.moveTo(centerX, centerY);
				c$7.lineTo(centerX + halfSize, centerY + halfSize);
				c$7.lineTo(centerX, centerY + halfSize * 2);
				c$7.restore();
			} else {
				c$7.strokeStyle = hasError ? settings$1.colors.white : settings$1.colors.gray;
				c$7.moveTo(centerX - halfSize, centerY - halfSize);
				c$7.lineTo(centerX, centerY);
				c$7.lineTo(centerX + halfSize, centerY - halfSize);
			}
			c$7.stroke();
		}
	}
	const lastLineIndex = context.doc.lines.length - 1;
	if (lastLineIndex >= 0 && !lineNumberMap.has(lastLineIndex)) {
		const lastVisualLine = visualLines[visualLines.length - 1];
		if (lastVisualLine) {
			const lineY = lastVisualLine.y + lastVisualLine.height + scrollY;
			if (lineY >= -paddingTop && lineY <= visibleBottom) {
				const isCurrentVisualLine = isFocused && lastLineIndex === currentLine && currentVisualLine?.logicalLine === lastLineIndex;
				const metrics = lineNumberMetrics.get(lastLineIndex);
				if (isCurrentVisualLine) {
					c$7.fillStyle = "rgba(255, 255, 255, 0.05)";
					c$7.fillRect(-settings$1.paddingLeft, lineY, gutterWidth + settings$1.paddingLeft, settings$1.lineHeight);
				}
				if (metrics) {
					const lineNumberY = lineY + 2;
					c$7.fillStyle = "rgba(255, 255, 255, 0.3)";
					c$7.font = `${settings$1.fontSize} ${settings$1.fontFamilyName}`;
					c$7.textBaseline = "top";
					c$7.fillText(metrics.text, metrics.x, lineNumberY);
				}
			}
		}
	}
	c$7.restore();
}
function hitTestGutter(canvas, settings$1, lines, scroll, gutter, x$4, y$5, headerHeight) {
	x$4 = Math.floor(x$4);
	y$5 = Math.floor(y$5);
	const gutterWidth = gutter.width.value;
	const { paddingLeft, paddingTop } = settings$1;
	const { y: scrollY } = scroll.pos;
	const gutterX = x$4 - paddingLeft;
	if (!(x$4 >= 0 && x$4 < gutterWidth) || y$5 < headerHeight) return {
		type: null,
		line: null
	};
	const relativeY = y$5 - headerHeight - paddingTop;
	const visualLines = lines.visualLines.value;
	const lineNumberMap = gutter.lineNumberMap.value;
	const blockStarts = gutter.blockStarts.value;
	const visibleBottom = canvas.size.height.value - headerHeight - paddingTop;
	for (const visualLine of visualLines) {
		const lineY = visualLine.y + scrollY;
		if (lineY + visualLine.height + paddingTop < 0) continue;
		if (shouldBreakBottom(visualLines, visualLine, lineY, visibleBottom, scrollY)) break;
		if (relativeY >= lineY && relativeY < lineY + visualLine.height) {
			const logicalLine = visualLine.logicalLine;
			const isFirstVisualLine = lineNumberMap.get(logicalLine)?.[0] === visualLine;
			if (blockStarts.has(logicalLine) && isFirstVisualLine) {
				const toggleX = gutterWidth - COLLAPSE_TOGGLE_SIZE - 4;
				const toggleRight = toggleX + COLLAPSE_TOGGLE_SIZE;
				if (gutterX >= toggleX && gutterX <= toggleRight) return {
					type: "collapse",
					line: logicalLine
				};
			}
			return {
				type: "line",
				line: logicalLine
			};
		}
	}
	return {
		type: "gutter",
		line: null
	};
}
var signalified$1 = /* @__PURE__ */ new WeakSet();
function signalify$1(value) {
	if (signalified$1.has(value)) return value;
	const descs = Object.getOwnPropertyDescriptors(value);
	const state = value;
	signalified$1.add(state);
	for (const [key, desc] of Object.entries(descs)) if (desc.get) {
		const s$4 = b(desc.get.bind(state));
		Object.defineProperty(state, key, {
			get: () => s$4.value,
			set: desc.set?.bind(state),
			configurable: false,
			enumerable: true
		});
	} else {
		const s$4 = c$3(desc.value);
		Object.defineProperty(state, key, {
			get: () => s$4.value,
			set: (value$1) => s$4.value = value$1,
			configurable: false,
			enumerable: true
		});
	}
	return state;
}
var overlayCanvasInstance = null;
function createOverlayCanvas() {
	if (overlayCanvasInstance) return overlayCanvasInstance;
	const el = document.createElement("canvas");
	el.style.position = "fixed";
	el.style.top = "0";
	el.style.left = "0";
	el.style.width = "100dvw";
	el.style.height = "100dvh";
	el.style.pointerEvents = "none";
	el.style.zIndex = "9999";
	document.body.appendChild(el);
	const width = c$3(window.innerWidth);
	const height = c$3(window.innerHeight);
	const size = {
		width,
		height
	};
	const c$7 = el.getContext("2d");
	const dpr = c$3(window.devicePixelRatio);
	const ligatureDpr = b(() => dpr.value * 1.5);
	const clear = () => {
		c$7.clearRect(0, 0, width.value, height.value);
	};
	m(() => {
		el.width = width.value * dpr.value;
		el.height = height.value * dpr.value;
		c$7.scale(dpr.value, dpr.value);
		clear();
	});
	const handleResize = () => {
		n(() => {
			width.value = window.innerWidth;
			height.value = window.innerHeight;
			dpr.value = window.devicePixelRatio;
		});
	};
	window.addEventListener("resize", handleResize);
	const dispose = () => {
		window.removeEventListener("resize", handleResize);
		el.remove();
		overlayCanvasInstance = null;
	};
	overlayCanvasInstance = {
		el,
		size,
		get rect() {
			return el.getBoundingClientRect();
		},
		c: c$7,
		dpr,
		ligatureDpr,
		clear,
		dispose
	};
	return overlayCanvasInstance;
}
const SCROLL_SMOOTH_KEYBOARD = .2;
const SCROLL_SMOOTH_SCROLLING = .4;
function createScroll(canvas, lines, settings$1, gutter, header, metrics) {
	const pos = signalify$1({
		x: Infinity,
		y: Infinity
	});
	const targetX = c$3(Infinity);
	const targetY = c$3(Infinity);
	const smooth = c$3(.2);
	const update = () => {
		n(() => {
			if (pos.x === Infinity || pos.y === Infinity) {
				if (targetX.value === Infinity || targetY.value === Infinity) return;
				pos.x = targetX.value;
				pos.y = targetY.value;
				return;
			}
			const dx = targetX.value - pos.x;
			const dy = targetY.value - pos.y;
			pos.x = pos.x + dx * smooth.value;
			pos.y = pos.y + dy * smooth.value;
			if (Math.abs(dx) < .1 && Math.abs(dy) < .1) {
				pos.x = targetX.value;
				pos.y = targetY.value;
			}
		});
	};
	const scrollWidth = b(() => {
		if (settings$1.wordWrap) return 0;
		const headerHeight = header.value?.height ?? 0;
		const needsVertical = lines.totalHeight.value > canvas.size.height.value - headerHeight - settings$1.paddingTop - settings$1.paddingBottom;
		const availableWidth = canvas.size.width.value - settings$1.paddingLeft - settings$1.paddingRight - gutter.width.value - (needsVertical ? 12 : 0);
		return Math.min(0, -lines.totalWidth.value + availableWidth);
	});
	const scrollHeight = b(() => {
		const headerHeight = header.value?.height ?? 0;
		const needsVertical = lines.totalHeight.value > canvas.size.height.value - headerHeight - settings$1.paddingTop - settings$1.paddingBottom;
		const availableWidth = canvas.size.width.value - settings$1.paddingLeft - settings$1.paddingRight - gutter.width.value - (needsVertical ? 12 : 0);
		const needsHorizontal = !settings$1.wordWrap && lines.totalWidth.value > availableWidth;
		const availableHeight = canvas.size.height.value - headerHeight - settings$1.paddingTop - settings$1.paddingBottom - (needsHorizontal ? 3 : 0);
		return Math.min(0, -lines.totalHeight.value + availableHeight);
	});
	m(() => {
		if (pos.x === Infinity || pos.y === Infinity) {
			metrics.visibleLines.value = {
				start: 0,
				end: 0
			};
			return;
		}
		const visualLines = o$24(() => lines.visualLines.value);
		if (visualLines.length === 0) {
			metrics.visibleLines.value = {
				start: 0,
				end: 0
			};
			return;
		}
		const scrollY = pos.y;
		const visibleTop = -(header.value?.height ?? 0) - settings$1.paddingTop;
		const visibleBottom = canvas.size.height.value - settings$1.paddingTop;
		let start = null;
		let end = null;
		for (const line of visualLines) {
			const lineY = line.y + scrollY;
			if (lineY + line.height < visibleTop) continue;
			if (shouldBreakBottom(visualLines, line, lineY, visibleBottom, scrollY)) break;
			const logicalLine = line.logicalLine;
			if (start === null) start = logicalLine;
			end = logicalLine;
		}
		if (start === null || end === null) {
			metrics.visibleLines.value = {
				start: 0,
				end: 0
			};
			return;
		}
		metrics.visibleLines.value = {
			start,
			end
		};
	});
	m(() => {
		if (pos.x === Infinity || pos.y === Infinity) return;
		if (targetX.value < scrollWidth.value) targetX.value = scrollWidth.value;
		if (targetX.value > 0) targetX.value = 0;
		if (targetY.value < scrollHeight.value) targetY.value = scrollHeight.value;
		if (targetY.value > 0) targetY.value = 0;
	});
	return {
		pos,
		targetX,
		targetY,
		smooth,
		scrollWidth,
		scrollHeight,
		update
	};
}
function findCallBlock(tokenLines, lineIndex, tokenIndex) {
	const line = tokenLines[lineIndex];
	if (!line || tokenIndex >= line.length) return [];
	const token = line[tokenIndex];
	if (token.type !== "function" && token.type !== "identifier") return [];
	if (tokenIndex + 1 >= line.length) return [];
	const nextToken = line[tokenIndex + 1];
	if (nextToken.text !== "(") return [];
	const memberAccessTokens = [];
	let currentMemberIndex = tokenIndex - 1;
	while (currentMemberIndex >= 0) {
		const currentToken = line[currentMemberIndex];
		if (currentToken.type === "punctuation" && currentToken.text === ".") {
			if (currentMemberIndex > 0) {
				const prevToken = line[currentMemberIndex - 1];
				if (prevToken && (prevToken.type === "identifier" || prevToken.type === "function")) {
					memberAccessTokens.unshift(prevToken, currentToken);
					currentMemberIndex -= 2;
					continue;
				}
			}
		}
		break;
	}
	const callBlock = [
		...memberAccessTokens,
		token,
		nextToken
	];
	let depth = 1;
	let currentTokenIndex = tokenIndex + 2;
	let currentLineIndex = lineIndex;
	while (depth > 0 && currentLineIndex < tokenLines.length) {
		const currentLine = tokenLines[currentLineIndex];
		if (!currentLine) break;
		while (currentTokenIndex < currentLine.length) {
			const currentToken = currentLine[currentTokenIndex];
			callBlock.push(currentToken);
			for (let i$6 = 0; i$6 < currentToken.text.length; i$6++) {
				const char = currentToken.text[i$6];
				if (char === "(") depth++;
				else if (char === ")") {
					depth--;
					if (depth === 0) return callBlock;
				}
			}
			currentTokenIndex++;
		}
		currentLineIndex++;
		currentTokenIndex = 0;
	}
	return callBlock;
}
function getParameterIndex(callBlock, tokenLines, lineIndex, tokenIndex) {
	if (callBlock.length === 0) return -1;
	const line = tokenLines[lineIndex];
	if (!line || tokenIndex >= line.length) return -1;
	const targetToken = line[tokenIndex];
	let parenDepth = 0;
	let braceDepth = 0;
	let bracketDepth = 0;
	let parameterIndex = 0;
	let foundTarget = false;
	for (let i$6 = 0; i$6 < callBlock.length; i$6++) {
		const token = callBlock[i$6];
		if (token === targetToken) {
			if (parenDepth === 1 && braceDepth === 0 && bracketDepth === 0) {
				if (token.text === ",") return parameterIndex + 1;
				return parameterIndex;
			}
			if (parenDepth === 0) {
				if (token.text === "(") return 0;
				return -1;
			}
			foundTarget = true;
		}
		for (let j$4 = 0; j$4 < token.text.length; j$4++) {
			const char = token.text[j$4];
			if (char === "(") {
				if (token === targetToken && parenDepth === 0) return 0;
				parenDepth++;
			} else if (char === ")") {
				parenDepth--;
				if (parenDepth === 0 && foundTarget) return parameterIndex;
			} else if (char === "{") braceDepth++;
			else if (char === "}") braceDepth--;
			else if (char === "[") bracketDepth++;
			else if (char === "]") bracketDepth--;
			else if (char === "," && parenDepth === 1 && braceDepth === 0 && bracketDepth === 0) {
				if (foundTarget) return parameterIndex;
				parameterIndex++;
			}
		}
	}
	return foundTarget ? parameterIndex : -1;
}
function getParameterStartToken(callBlock, parameterIndex) {
	if (callBlock.length === 0 || parameterIndex < 0) return null;
	let parenDepth = 0;
	let braceDepth = 0;
	let bracketDepth = 0;
	let openParenIndex = -1;
	let currentParam = 0;
	for (let i$6 = 0; i$6 < callBlock.length; i$6++) {
		const token = callBlock[i$6];
		for (let j$4 = 0; j$4 < token.text.length; j$4++) {
			const char = token.text[j$4];
			if (char === "(") {
				parenDepth++;
				if (parenDepth === 1) openParenIndex = i$6;
			} else if (char === ")") parenDepth--;
			else if (char === "{") braceDepth++;
			else if (char === "}") braceDepth--;
			else if (char === "[") bracketDepth++;
			else if (char === "]") bracketDepth--;
			else if (char === "," && parenDepth === 1 && braceDepth === 0 && bracketDepth === 0) {
				currentParam++;
				if (currentParam === parameterIndex) return callBlock[i$6 + 1] ?? null;
			}
		}
	}
	if (parameterIndex === 0 && openParenIndex >= 0 && openParenIndex + 1 < callBlock.length) return callBlock[openParenIndex + 1];
	return null;
}
function findTokenPositionInTokenLines(tokenLines, token) {
	for (let lineIndex = 0; lineIndex < tokenLines.length; lineIndex++) {
		const line = tokenLines[lineIndex];
		if (!line) continue;
		const tokenIndex = line.indexOf(token);
		if (tokenIndex >= 0) return {
			lineIndex,
			tokenIndex
		};
	}
	return null;
}
function findCallBlockForToken(tokenLines, lineIndex, tokenIndex) {
	const line = tokenLines[lineIndex];
	if (!line || tokenIndex >= line.length) return [];
	const currentToken = line[tokenIndex];
	if (currentToken && (currentToken.type === "identifier" || currentToken.type === "function")) {
		let checkIndex = tokenIndex + 1;
		while (checkIndex < line.length) {
			const nextToken = line[checkIndex];
			if (nextToken.type === "punctuation" && nextToken.text === ".") {
				if (checkIndex + 1 < line.length) {
					const afterDotToken = line[checkIndex + 1];
					if (afterDotToken && (afterDotToken.type === "function" || afterDotToken.type === "identifier")) {
						if (checkIndex + 2 < line.length) {
							const afterMemberToken = line[checkIndex + 2];
							if (afterMemberToken && afterMemberToken.text === "(") return findCallBlock(tokenLines, lineIndex, checkIndex + 1);
						}
					}
				}
			} else if (nextToken && nextToken.text === "(") return findCallBlock(tokenLines, lineIndex, tokenIndex);
			else break;
			checkIndex++;
		}
	} else if (currentToken && currentToken.type === "punctuation" && currentToken.text === ".") {
		if (tokenIndex > 0 && tokenIndex + 1 < line.length) {
			const prevToken = line[tokenIndex - 1];
			const nextToken = line[tokenIndex + 1];
			if (prevToken && (prevToken.type === "identifier" || prevToken.type === "function") && nextToken && (nextToken.type === "function" || nextToken.type === "identifier")) {
				if (tokenIndex + 2 < line.length) {
					const afterMemberToken = line[tokenIndex + 2];
					if (afterMemberToken && afterMemberToken.text === "(") return findCallBlock(tokenLines, lineIndex, tokenIndex + 1);
				}
			}
		}
	}
	let depth = 0;
	let foundOpenParen = false;
	let functionTokenIndex = -1;
	let openParenTokenIndex = -1;
	let currentTokenIndex = tokenIndex;
	let currentLineIndex = lineIndex;
	while (currentLineIndex >= 0) {
		const currentLine = tokenLines[currentLineIndex];
		if (!currentLine) break;
		while (currentTokenIndex >= 0) {
			const currentToken$1 = currentLine[currentTokenIndex];
			for (let i$6 = currentToken$1.text.length - 1; i$6 >= 0; i$6--) {
				const char = currentToken$1.text[i$6];
				if (char === ")") depth++;
				else if (char === "(") if (depth === 0) {
					foundOpenParen = true;
					openParenTokenIndex = currentTokenIndex;
					if (currentTokenIndex > 0) {
						const prevToken = currentLine[currentTokenIndex - 1];
						if (prevToken && (prevToken.type === "function" || prevToken.type === "identifier")) functionTokenIndex = currentTokenIndex - 1;
						else if (prevToken && prevToken.type === "punctuation" && prevToken.text === ".") {
							if (currentTokenIndex > 1) {
								const prevPrevToken = currentLine[currentTokenIndex - 2];
								if (prevPrevToken && (prevPrevToken.type === "function" || prevPrevToken.type === "identifier")) functionTokenIndex = currentTokenIndex - 2;
							}
						}
					}
					break;
				} else depth--;
			}
			if (foundOpenParen && functionTokenIndex >= 0) return findCallBlock(tokenLines, currentLineIndex, functionTokenIndex);
			currentTokenIndex--;
		}
		if (foundOpenParen) break;
		currentLineIndex--;
		if (currentLineIndex >= 0 && currentLineIndex < tokenLines.length) currentTokenIndex = tokenLines[currentLineIndex].length - 1;
		else currentTokenIndex = -1;
	}
	if (functionTokenIndex >= 0 && openParenTokenIndex >= 0) return findCallBlock(tokenLines, currentLineIndex, functionTokenIndex);
	return [];
}
function createMouse(canvas, scroll, lines, settings$1, caches, doc, caret, scrollbars, selection, gutter, blocks, header, notifyActivated) {
	let dominantAxisTimeoutId = null;
	let dominantAxis = null;
	let allowScrollPassThrough = false;
	let allowScrollTimeoutId = null;
	let hasMouseMovedInEditor = false;
	const ALLOW_SCROLL_DEBOUNCE_MS = 200;
	let velocityX = 0;
	let velocityY = 0;
	let accelerationX = 0;
	let accelerationY = 0;
	const FRICTION = .65;
	const MIN_VELOCITY = .01;
	const MIN_ACCELERATION = .01;
	let lastMouseX = null;
	let autoScrollInterval = null;
	let currentAutoScrollDirection = null;
	const AUTO_SCROLL_SPEED = 10;
	const widgetPressed = c$3(false);
	const headerPressed = c$3(false);
	let isClickNotDrag = false;
	let clickStartX = 0;
	let clickStartY = 0;
	let prevMouseX = 0;
	let prevMouseY = 0;
	let clickCount = 0;
	let clickTimeout = null;
	let lastClickTime = 0;
	let lastClickLine = null;
	let lastClickColumn = null;
	let selectionMode = "normal";
	const CLICK_TIMEOUT_MS = 300;
	let hoverShowTimeout = null;
	let hoverHideTimeout = null;
	let currentHoverTokenId = null;
	let escapePressed = false;
	const HOVER_SHOW_DELAY_MS = 500;
	const HOVER_HIDE_DELAY_MS = 200;
	const lastHoverMoveTime = c$3(0);
	const buttonsDown = c$3(false);
	const hovered = signalify$1({
		scrollbar: null,
		line: null,
		column: null,
		token: null,
		error: null,
		gutter: false,
		hoverToken: null
	});
	const pos = signalify$1({
		x: -1,
		y: -1
	});
	const hoverHitPos = c$3(null);
	const update = () => {
		updateScrollAnimation();
	};
	const updateScrollAnimation = () => {
		scroll.smooth.value = SCROLL_SMOOTH_KEYBOARD;
		if (Math.abs(accelerationX) > MIN_ACCELERATION || Math.abs(accelerationY) > MIN_ACCELERATION) {
			scroll.smooth.value = SCROLL_SMOOTH_SCROLLING;
			const torqueX = Math.pow(Math.abs(accelerationX), 1.5) * Math.sign(accelerationX);
			const torqueY = Math.pow(Math.abs(accelerationY), 1.5) * Math.sign(accelerationY);
			velocityX += torqueX;
			velocityY += torqueY;
			accelerationX *= FRICTION;
			accelerationY *= FRICTION;
			if (Math.abs(accelerationX) < MIN_ACCELERATION) accelerationX = 0;
			if (Math.abs(accelerationY) < MIN_ACCELERATION) accelerationY = 0;
		}
		if (Math.abs(velocityX) > MIN_VELOCITY || Math.abs(velocityY) > MIN_VELOCITY) {
			scroll.smooth.value = SCROLL_SMOOTH_SCROLLING;
			scroll.targetX.value += velocityX;
			scroll.targetY.value += velocityY;
			velocityX *= FRICTION;
			velocityY *= FRICTION;
			if (Math.abs(velocityX) < MIN_VELOCITY) velocityX = 0;
			if (Math.abs(velocityY) < MIN_VELOCITY) velocityY = 0;
		}
	};
	const findLineColumnFromPosition = (x$4, y$5) => {
		const headerHeight = header.value?.height ?? 0;
		const visualLines = lines.visualLines.value;
		const scrollY = scroll.pos.y;
		const scrollX = scroll.pos.x;
		const worldY = y$5 - headerHeight - settings$1.paddingTop - scrollY;
		const worldX = x$4 - settings$1.paddingLeft - gutter.width.value - scrollX;
		let foundLine = null;
		let minDistance = Infinity;
		for (const line of visualLines) {
			if (worldY >= line.y && worldY < line.y + line.height) {
				foundLine = line;
				break;
			}
			const lineCenterY = line.y + line.height / 2;
			const distance = Math.abs(worldY - lineCenterY);
			if (distance < minDistance) {
				minDistance = distance;
				foundLine = line;
			}
		}
		if (!foundLine) {
			if (visualLines.length === 0) return null;
			foundLine = worldY < 0 ? visualLines[0] : visualLines[visualLines.length - 1];
		}
		const codeLines = doc.lines;
		const tokenLines = doc.tokenLines;
		const column = getColumnFromVisualPosition(lines, foundLine, worldX, tokenLines, codeLines, canvas, settings$1, caches);
		return {
			line: foundLine,
			column
		};
	};
	const getAboveHeightForLine = (line) => {
		if (line.widgets.above.length === 0) return 0;
		const visualLines = lines.visualLines.value;
		const firstIndex = visualLines.findIndex((l$10) => l$10.logicalLine === line.logicalLine && l$10.tokenOffset === 0);
		if (firstIndex === -1) return 0;
		let emptyHeight = 0;
		for (let i$6 = firstIndex - 1; i$6 >= 0; i$6--) {
			const prev = visualLines[i$6];
			if (prev.logicalLine >= line.logicalLine) continue;
			if (isLineEmpty(prev)) emptyHeight += prev.height;
			else break;
		}
		return emptyHeight;
	};
	const findBelowWidgetHit = (x$4, y$5) => {
		const headerHeight = header.value?.height ?? 0;
		const visualLines = lines.visualLines.value;
		const scrollY = scroll.pos.y;
		const scrollX = scroll.pos.x;
		const worldY = y$5 - headerHeight - settings$1.paddingTop - scrollY;
		const worldX = x$4 - settings$1.paddingLeft - gutter.width.value - scrollX;
		const tokenLines = doc.tokenLines;
		const { lineHeight: lineHeight$1 } = settings$1;
		let foundLine = null;
		for (const line of visualLines) if (worldY >= line.y && worldY < line.y + line.height) {
			foundLine = line;
			break;
		}
		if (!foundLine || foundLine.widgets.below.length === 0) return null;
		if (worldY < foundLine.y + lineHeight$1 || worldY >= foundLine.y + foundLine.height) return null;
		const widgetWorldY = (foundLine.tokenOffset === 0 ? foundLine.y : foundLine.y + getAboveHeightForLine(foundLine)) + lineHeight$1 - 2;
		for (const widget of foundLine.widgets.below) {
			if (!widget.onMouseDown) continue;
			const [startColumn, endColumn] = widget.pos.x;
			const startCol0 = startColumn - 1;
			const endCol0 = endColumn - 1;
			const startX = getXFromColumnUnclamped(lines, foundLine, startCol0, tokenLines, canvas, settings$1, caches);
			const endX = getXFromColumnUnclamped(lines, foundLine, endCol0, tokenLines, canvas, settings$1, caches);
			const widgetWorldX = startX;
			const widgetWorldW = endX - startX;
			if (worldX >= widgetWorldX && worldX < widgetWorldX + widgetWorldW && worldY >= widgetWorldY && worldY < widgetWorldY + lineHeight$1) return {
				widget,
				canvasX: widgetWorldX + scrollX + gutter.width.value + settings$1.paddingLeft,
				canvasY: widgetWorldY + headerHeight + settings$1.paddingTop + scrollY,
				canvasW: widgetWorldW,
				canvasH: lineHeight$1
			};
		}
		return null;
	};
	const findBeforeAfterWidgetHit = (x$4, y$5) => {
		const headerHeight = header.value?.height ?? 0;
		const visualLines = lines.visualLines.value;
		const scrollY = scroll.pos.y;
		const scrollX = scroll.pos.x;
		const worldY = y$5 - headerHeight - settings$1.paddingTop - scrollY;
		const worldX = x$4 - settings$1.paddingLeft - gutter.width.value - scrollX;
		const tokenLines = doc.tokenLines;
		const { lineHeight: lineHeight$1 } = settings$1;
		let foundLine = null;
		for (const line of visualLines) if (worldY >= line.y && worldY < line.y + line.height) {
			foundLine = line;
			break;
		}
		if (!foundLine || foundLine.widgets.beforeAfter.length === 0) return null;
		const contentY = foundLine.tokenOffset === 0 ? foundLine.y : foundLine.y + getAboveHeightForLine(foundLine);
		if (worldY < contentY || worldY >= contentY + lineHeight$1) return null;
		const lineStartColumn = getCharOffsetForVisualLine(foundLine.logicalLine, foundLine, tokenLines, lines);
		let lineEndColumn = lineStartColumn;
		for (const t$12 of foundLine.tokens) lineEndColumn += t$12.token.text.length;
		for (const widget of foundLine.widgets.beforeAfter) {
			if (!widget.onMouseDown) continue;
			const widgetColumn = widget.pos.x - 1;
			if (widgetColumn < lineStartColumn || widgetColumn > lineEndColumn) continue;
			const widgetWorldX = widget.type === "before" ? getXFromColumnUnclamped(lines, foundLine, widgetColumn, tokenLines, canvas, settings$1, caches) : getXFromColumnUnclamped(lines, foundLine, widgetColumn + 1, tokenLines, canvas, settings$1, caches);
			const widgetWorldW = widget.pos.width;
			if (worldX >= widgetWorldX && worldX < widgetWorldX + widgetWorldW) return {
				widget,
				canvasX: widgetWorldX + scrollX + gutter.width.value + settings$1.paddingLeft,
				canvasY: contentY + headerHeight + settings$1.paddingTop + scrollY,
				canvasW: widgetWorldW,
				canvasH: lineHeight$1
			};
		}
		return null;
	};
	m(() => {
		const { x: x$4, y: y$5 } = pos;
		const headerHeight = header.value?.height ?? 0;
		const gutterWidth = gutter.width.value;
		const inHeader = y$5 >= 0 && y$5 < headerHeight;
		const scrollbarHit = hitTestScrollbar(canvas, scroll, lines, settings$1, gutter, header, x$4, y$5);
		const belowWidgetHit = findBelowWidgetHit(x$4, y$5);
		const beforeAfterWidgetHit = findBeforeAfterWidgetHit(x$4, y$5);
		canvas.el.style.cursor = y$5 < 0 || inHeader || x$4 < gutterWidth || scrollbarHit.type !== null || belowWidgetHit || beforeAfterWidgetHit || widgetPressed.value || headerPressed.value || scrollbars.isDragging.value ? "default" : "text";
	});
	m(() => {
		const { x: x$4, y: y$5 } = pos;
		hovered.gutter = hitTestGutter(canvas, settings$1, lines, scroll, gutter, x$4, y$5, header.value?.height ?? 0).type !== null;
	});
	m(() => {
		const hit = hoverHitPos.value;
		header.value?.height;
		if (!hit) {
			hovered.line = null;
			hovered.column = null;
			hovered.token = null;
			hovered.error = null;
			if (hoverShowTimeout) {
				clearTimeout(hoverShowTimeout);
				hoverShowTimeout = null;
			}
			if (escapePressed) escapePressed = false;
			if (currentHoverTokenId !== null) {
				currentHoverTokenId = null;
				if (hoverHideTimeout) clearTimeout(hoverHideTimeout);
				hoverHideTimeout = setTimeout(() => {
					hovered.hoverToken = null;
					hoverHideTimeout = null;
				}, HOVER_HIDE_DELAY_MS);
			}
			return;
		}
		if (buttonsDown.value) {
			hovered.line = null;
			hovered.column = null;
			hovered.token = null;
			hovered.error = null;
			if (hoverShowTimeout) {
				clearTimeout(hoverShowTimeout);
				hoverShowTimeout = null;
			}
			if (currentHoverTokenId !== null) {
				currentHoverTokenId = null;
				if (hoverHideTimeout) clearTimeout(hoverHideTimeout);
				hoverHideTimeout = setTimeout(() => {
					hovered.hoverToken = null;
					hoverHideTimeout = null;
				}, HOVER_HIDE_DELAY_MS);
			}
			return;
		}
		o$24(() => {
			const visualLines = lines.visualLines.value;
			const worldX = hit.worldX;
			const worldY = hit.worldY;
			let foundLine = null;
			for (const line of visualLines) if (worldY >= line.y && worldY < line.y + line.height) {
				foundLine = line;
				break;
			}
			if (!foundLine) {
				hovered.line = null;
				hovered.column = null;
				hovered.token = null;
				hovered.error = null;
				if (hoverShowTimeout) {
					clearTimeout(hoverShowTimeout);
					hoverShowTimeout = null;
				}
				if (escapePressed) escapePressed = false;
				const existing = hovered.hoverToken;
				const hitMoved = !existing || existing.hitWorldX !== hit.worldX || existing.hitWorldY !== hit.worldY;
				if (currentHoverTokenId !== null && hitMoved) {
					currentHoverTokenId = null;
					if (hoverHideTimeout) clearTimeout(hoverHideTimeout);
					hoverHideTimeout = setTimeout(() => {
						hovered.hoverToken = null;
						hoverHideTimeout = null;
					}, HOVER_HIDE_DELAY_MS);
				}
				return;
			}
			hovered.line = foundLine;
			const errors = foundLine.errors;
			const lineHeight$1 = settings$1.lineHeight;
			const textAreaY = foundLine.y;
			const textAreaHeight = lineHeight$1;
			hovered.error = null;
			if (worldY >= textAreaY && worldY < textAreaY + textAreaHeight) {
				const tokenLines$1 = doc.tokenLines;
				for (const error$1 of errors) {
					const [errorStartColumn, errorEndColumn] = [error$1.x[0] - 1, error$1.x[1] - 1];
					const errorStartX = getXFromColumn(lines, foundLine, errorStartColumn, tokenLines$1, canvas, settings$1, caches);
					const errorEndX = getXFromColumn(lines, foundLine, errorEndColumn, tokenLines$1, canvas, settings$1, caches);
					if (worldX >= errorStartX && worldX <= errorEndX) hovered.error = error$1;
				}
			}
			const codeLines = doc.lines;
			const tokenLines = doc.tokenLines;
			let foundToken = null;
			for (const visualToken of foundLine.tokens) if (worldX >= visualToken.x && worldX < visualToken.endX) {
				foundToken = visualToken;
				break;
			}
			const column = getColumnFromVisualPosition(lines, foundLine, worldX, tokenLines, codeLines, canvas, settings$1, caches);
			hovered.token = foundToken;
			hovered.column = column;
			if (foundToken && foundLine) {
				const tokenId = `${foundLine.logicalLine}:${foundToken.logicalTokenIndex}`;
				if (tokenId !== currentHoverTokenId && !escapePressed && !buttonsDown.value) {
					if (hoverShowTimeout) {
						clearTimeout(hoverShowTimeout);
						hoverShowTimeout = null;
					}
					if (hoverHideTimeout) {
						clearTimeout(hoverHideTimeout);
						hoverHideTimeout = null;
					}
					currentHoverTokenId = tokenId;
					escapePressed = false;
					hoverShowTimeout = setTimeout(() => {
						if (currentHoverTokenId === tokenId && foundToken && foundLine && !buttonsDown.value) {
							const tokenLines$1 = doc.tokenLines;
							const logicalLine = foundLine.logicalLine;
							const logicalTokenIndex = foundToken.logicalTokenIndex;
							const callBlock = findCallBlockForToken(tokenLines$1, logicalLine, logicalTokenIndex);
							const parameterIndex = callBlock.length > 0 ? getParameterIndex(callBlock, tokenLines$1, logicalLine, logicalTokenIndex) : -1;
							const headerHeight = header.value?.height ?? 0;
							const scrollX = scroll.pos.x;
							const scrollY = scroll.pos.y;
							const canvasRect = canvas.rect;
							const contentY = foundLine.tokenOffset === 0 ? foundLine.y : foundLine.y + getAboveHeightForLine(foundLine);
							const tokenX = foundToken.x + gutter.width.value + settings$1.paddingLeft + scrollX + canvasRect.left;
							const tokenY = contentY + headerHeight + settings$1.paddingTop + scrollY + canvasRect.top;
							let paramX;
							let paramY;
							if (parameterIndex >= 0) {
								const paramStartToken = getParameterStartToken(callBlock, parameterIndex);
								if (paramStartToken) {
									const pos$1 = findTokenPositionInTokenLines(tokenLines$1, paramStartToken);
									if (pos$1) {
										const column$1 = getColumnForTokenIndex(tokenLines$1[pos$1.lineIndex] || [], pos$1.tokenIndex);
										const paramLine = findVisualLineForColumn(lines, pos$1.lineIndex, column$1, tokenLines$1, caches);
										if (paramLine) {
											const px = getXFromColumn(lines, paramLine, column$1, tokenLines$1, canvas, settings$1, caches);
											const paramContentY = paramLine.tokenOffset === 0 ? paramLine.y : paramLine.y + getAboveHeightForLine(paramLine);
											paramX = px + gutter.width.value + settings$1.paddingLeft + scrollX + canvasRect.left;
											paramY = paramContentY + headerHeight + settings$1.paddingTop + scrollY + canvasRect.top;
										}
									}
								}
							}
							let callBlockX = tokenX;
							let callBlockY = tokenY;
							if (callBlock.length > 0) {
								const lineTokens = tokenLines$1[logicalLine] || [];
								let functionTokenIndex = -1;
								for (let i$6 = 0; i$6 < callBlock.length; i$6++) if (callBlock[i$6].text === "(" && i$6 > 0) {
									const prevToken = callBlock[i$6 - 1];
									if (prevToken && (prevToken.type === "function" || prevToken.type === "identifier")) {
										functionTokenIndex = lineTokens.indexOf(prevToken);
										break;
									}
								}
								if (functionTokenIndex >= 0) {
									for (const visualToken of foundLine.tokens) if (visualToken.logicalTokenIndex === functionTokenIndex) {
										callBlockX = visualToken.x + gutter.width.value + settings$1.paddingLeft + scrollX + canvasRect.left;
										callBlockY = contentY + headerHeight + settings$1.paddingTop + scrollY + canvasRect.top;
										break;
									}
								}
							}
							hovered.hoverToken = {
								canvas: createOverlayCanvas(),
								contentX: tokenX - scrollX - canvasRect.left,
								contentY: tokenY - scrollY - canvasRect.top,
								contentParamX: paramX != null ? paramX - scrollX - canvasRect.left : void 0,
								contentParamY: paramY != null ? paramY - scrollY - canvasRect.top : void 0,
								contentCallBlockX: callBlockX - scrollX - canvasRect.left,
								contentCallBlockY: callBlockY - scrollY - canvasRect.top,
								hitWorldX: hit.worldX,
								hitWorldY: hit.worldY,
								token: foundToken.token,
								callBlock,
								parameterIndex
							};
						}
						hoverShowTimeout = null;
					}, HOVER_SHOW_DELAY_MS);
				}
			} else {
				if (hoverShowTimeout) {
					clearTimeout(hoverShowTimeout);
					hoverShowTimeout = null;
				}
				if (escapePressed) escapePressed = false;
				if (currentHoverTokenId !== null) {
					currentHoverTokenId = null;
					if (hoverHideTimeout) clearTimeout(hoverHideTimeout);
					hoverHideTimeout = setTimeout(() => {
						hovered.hoverToken = null;
						hoverHideTimeout = null;
					}, HOVER_HIDE_DELAY_MS);
				}
			}
		});
	});
	const updateMousePositionFromPoint = (clientX, clientY) => {
		const rect = canvas.rect;
		const x$4 = clientX - rect.left;
		const y$5 = clientY - rect.top;
		n(() => {
			pos.x = x$4;
			pos.y = y$5;
		});
	};
	const updateMousePositionFromEvent = (event) => {
		updateMousePositionFromPoint(event.clientX, event.clientY);
	};
	m(() => {
		if (!selection.isSelecting.value) return;
		const lineColumn = findLineColumnFromPosition(pos.x, pos.y);
		if (lineColumn && selection.start.value) {
			const codeLines = doc.lines;
			const logicalLine = lineColumn.line.logicalLine;
			let targetColumn = lineColumn.column;
			const start = selection.start.value;
			if (selectionMode === "word") {
				const boundaries = findWordBoundaries(codeLines[logicalLine] || "", targetColumn);
				targetColumn = logicalLine > start.line || logicalLine === start.line && targetColumn >= start.column ? boundaries.end : boundaries.start;
			} else if (selectionMode === "line") {
				const boundaries = findLineBoundaries(codeLines[logicalLine] || "");
				if (logicalLine > start.line) targetColumn = boundaries.end;
				else if (logicalLine < start.line) targetColumn = boundaries.start;
				else targetColumn = targetColumn >= start.column ? boundaries.end : boundaries.start;
			}
			if (autoScrollInterval) {
				lastMouseX = pos.x;
				caret.column.value = targetColumn;
				caret.resetBlink();
			} else {
				selection.setEnd(logicalLine, targetColumn);
				lastMouseX = pos.x;
				caret.setPosition(logicalLine, targetColumn, codeLines);
				caret.resetBlink();
			}
		}
		const headerHeight = header.value?.height ?? 0;
		const canvasHeight = canvas.size.height.value - headerHeight - settings$1.paddingTop - settings$1.paddingBottom;
		const canvasWidth = canvas.size.width.value - settings$1.paddingLeft - settings$1.paddingRight;
		const relativeY = pos.y - headerHeight - settings$1.paddingTop;
		const relativeX = pos.x - settings$1.paddingLeft - gutter.width.value;
		if (isClickNotDrag) {
			stopAutoScroll();
			return;
		}
		const deltaX = pos.x - prevMouseX;
		const deltaY = pos.y - prevMouseY;
		prevMouseX = pos.x;
		prevMouseY = pos.y;
		const maxScrollY = -(lines.totalHeight.value - canvasHeight);
		const maxScrollX = settings$1.wordWrap ? 0 : -(lines.totalWidth.value - canvasWidth);
		const canScrollUp = scroll.targetY.value < 0;
		const canScrollDown = scroll.targetY.value > maxScrollY;
		const canScrollLeft = scroll.targetX.value < 0;
		const canScrollRight = scroll.targetX.value > maxScrollX;
		if (currentAutoScrollDirection === "up") {
			if (!canScrollUp || relativeY >= 0) stopAutoScroll();
		} else if (currentAutoScrollDirection === "down") {
			if (!canScrollDown || relativeY <= canvasHeight - settings$1.lineHeight) stopAutoScroll();
		} else if (currentAutoScrollDirection === "left") {
			if (!canScrollLeft || relativeX >= 0) stopAutoScroll();
		} else if (currentAutoScrollDirection === "right") {
			if (!canScrollRight || relativeX <= canvasWidth) stopAutoScroll();
		} else if (relativeY < 0 && canScrollUp && deltaY < 0) startAutoScroll("up");
		else if (relativeY > canvasHeight - settings$1.lineHeight && canScrollDown && deltaY > 0) startAutoScroll("down");
		else if (relativeX < 0 && canScrollLeft && deltaX < 0) startAutoScroll("left");
		else if (relativeX > canvasWidth && canScrollRight && deltaX > 0) startAutoScroll("right");
	});
	const stopAutoScroll = () => {
		if (autoScrollInterval) {
			clearInterval(autoScrollInterval);
			autoScrollInterval = null;
			currentAutoScrollDirection = null;
		}
	};
	const startAutoScroll = (direction) => {
		if (currentAutoScrollDirection === direction) return;
		stopAutoScroll();
		currentAutoScrollDirection = direction;
		autoScrollInterval = setInterval(() => {
			const headerHeight = header.value?.height ?? 0;
			const canvasHeight = canvas.size.height.value - headerHeight - settings$1.paddingTop - settings$1.paddingBottom;
			const canvasWidth = canvas.size.width.value - settings$1.paddingLeft - settings$1.paddingRight;
			const maxScrollY = -(lines.totalHeight.value - canvasHeight);
			const maxScrollX = settings$1.wordWrap ? 0 : -(lines.totalWidth.value - canvasWidth);
			if (direction === "up") {
				if (scroll.targetY.value >= 0) {
					stopAutoScroll();
					return;
				}
				scroll.targetY.value += AUTO_SCROLL_SPEED;
				if (scroll.targetY.value > 0) scroll.targetY.value = 0;
			} else if (direction === "down") {
				if (scroll.targetY.value <= maxScrollY) {
					stopAutoScroll();
					return;
				}
				scroll.targetY.value -= AUTO_SCROLL_SPEED;
				if (scroll.targetY.value < maxScrollY) scroll.targetY.value = maxScrollY;
			} else if (direction === "left") {
				if (scroll.targetX.value >= 0) {
					stopAutoScroll();
					return;
				}
				scroll.targetX.value += AUTO_SCROLL_SPEED;
				if (scroll.targetX.value > 0) scroll.targetX.value = 0;
			} else if (direction === "right") {
				if (scroll.targetX.value <= maxScrollX) {
					stopAutoScroll();
					return;
				}
				scroll.targetX.value -= AUTO_SCROLL_SPEED;
				if (scroll.targetX.value < maxScrollX) scroll.targetX.value = maxScrollX;
			}
			if (selection.isSelecting.value) {
				const codeLines = doc.lines;
				if (direction === "down") {
					const visualLines = lines.visualLines.value;
					const headerHeight$1 = header.value?.height ?? 0;
					const canvasHeight$1 = canvas.size.height.value - headerHeight$1 - settings$1.paddingTop - settings$1.paddingBottom;
					const scrollY = scroll.pos.y;
					const scrollX = scroll.pos.x;
					const maxCaretY = canvasHeight$1 - settings$1.lineHeight;
					let targetLine = null;
					for (const line of visualLines) {
						const lineY = line.y + scrollY;
						if (lineY <= maxCaretY && lineY + line.height > 0) targetLine = line;
						else if (lineY > maxCaretY) break;
					}
					if (targetLine && lastMouseX !== null && selection.start.value) {
						const logicalLine = targetLine.logicalLine;
						const worldX = lastMouseX - settings$1.paddingLeft - gutter.width.value - scrollX;
						const tokenLines = doc.tokenLines;
						let targetColumn = getColumnFromVisualPosition(lines, targetLine, worldX, tokenLines, codeLines, canvas, settings$1, caches);
						const start = selection.start.value;
						if (selectionMode === "word") {
							const boundaries = findWordBoundaries(codeLines[logicalLine] || "", targetColumn);
							targetColumn = logicalLine > start.line || logicalLine === start.line && targetColumn >= start.column ? boundaries.end : boundaries.start;
						} else if (selectionMode === "line") {
							const boundaries = findLineBoundaries(codeLines[logicalLine] || "");
							if (logicalLine > start.line) targetColumn = boundaries.end;
							else if (logicalLine < start.line) targetColumn = boundaries.start;
							else targetColumn = targetColumn >= start.column ? boundaries.end : boundaries.start;
						}
						selection.setEnd(logicalLine, targetColumn);
						caret.setPosition(logicalLine, targetColumn, codeLines);
						caret.resetBlink();
					}
				} else if (direction === "up") {
					const visualLines = lines.visualLines.value;
					const scrollY = scroll.pos.y;
					const scrollX = scroll.pos.x;
					let targetLine = null;
					for (const line of visualLines) {
						const lineY = line.y + scrollY;
						if (lineY >= 0 && lineY + line.height > 0) {
							targetLine = line;
							break;
						}
					}
					if (targetLine && lastMouseX !== null) {
						const logicalLine = targetLine.logicalLine;
						const worldX = lastMouseX - settings$1.paddingLeft - gutter.width.value - scrollX;
						const tokenLines = doc.tokenLines;
						let targetColumn = getColumnFromVisualPosition(lines, targetLine, worldX, tokenLines, codeLines, canvas, settings$1, caches);
						if (selectionMode === "word") targetColumn = findWordBoundaries(codeLines[logicalLine] || "", targetColumn).end;
						else if (selectionMode === "line") targetColumn = findLineBoundaries(codeLines[logicalLine] || "").end;
						selection.setEnd(logicalLine, targetColumn);
						caret.setPosition(logicalLine, targetColumn, codeLines);
						caret.resetBlink();
					}
				} else {
					const lineColumn = lastMouseX !== null ? findLineColumnFromPosition(lastMouseX, pos.y) : null;
					if (lineColumn && selection.start.value) {
						const logicalLine = lineColumn.line.logicalLine;
						let targetColumn = lineColumn.column;
						const start = selection.start.value;
						if (selectionMode === "word") {
							const boundaries = findWordBoundaries(codeLines[logicalLine] || "", targetColumn);
							targetColumn = logicalLine > start.line || logicalLine === start.line && targetColumn >= start.column ? boundaries.end : boundaries.start;
						} else if (selectionMode === "line") {
							const boundaries = findLineBoundaries(codeLines[logicalLine] || "");
							if (logicalLine > start.line) targetColumn = boundaries.end;
							else if (logicalLine < start.line) targetColumn = boundaries.start;
							else targetColumn = targetColumn >= start.column ? boundaries.end : boundaries.start;
						}
						selection.setEnd(logicalLine, targetColumn);
						caret.setPosition(logicalLine, targetColumn, codeLines);
						caret.resetBlink();
					}
				}
			}
		}, 16);
	};
	const handleScroll = (event) => {
		updateMousePositionFromEvent(event);
		clearTimeout(dominantAxisTimeoutId);
		let { deltaX, deltaY } = event;
		const newDominantAxis = Math.abs(deltaX) > Math.abs(deltaY) ? "x" : "y";
		if (!dominantAxis) dominantAxis = newDominantAxis;
		dominantAxisTimeoutId = setTimeout(() => {
			if (newDominantAxis !== dominantAxis) dominantAxis = newDominantAxis;
			dominantAxisTimeoutId = null;
		}, 15);
		const atEdgeY = deltaY > 0 && scroll.targetY.value <= scroll.scrollHeight.value || deltaY < 0 && scroll.targetY.value >= 0;
		const atEdgeX = deltaX > 0 && scroll.targetX.value <= scroll.scrollWidth.value || deltaX < 0 && scroll.targetX.value >= 0;
		if (newDominantAxis === "y" ? atEdgeY : atEdgeX) {
			if (allowScrollPassThrough) return;
			clearTimeout(allowScrollTimeoutId);
			allowScrollTimeoutId = setTimeout(() => {
				allowScrollPassThrough = true;
				allowScrollTimeoutId = null;
			}, ALLOW_SCROLL_DEBOUNCE_MS);
			event.preventDefault();
			return;
		}
		clearTimeout(allowScrollTimeoutId);
		allowScrollTimeoutId = null;
		if (!hasMouseMovedInEditor) return;
		allowScrollPassThrough = false;
		event.preventDefault();
		if (dominantAxis === "x") if (deltaX === Math.floor(deltaX)) accelerationX += -deltaX / 5;
		else accelerationX += -deltaX / 30;
		else if (deltaY === Math.floor(deltaY)) accelerationY += -deltaY / 40;
		else accelerationY += -deltaY / 30;
	};
	const handleDocumentScroll = () => {
		if (allowScrollPassThrough) hasMouseMovedInEditor = false;
	};
	const handleCanvasMouseMove = (event) => {
		if (scrollbars.isDragging.value) return;
		n(() => {
			hasMouseMovedInEditor = true;
			updateMousePositionFromEvent(event);
			const headerHeight = header.value?.height ?? 0;
			hoverHitPos.value = {
				worldX: pos.x - settings$1.paddingLeft - gutter.width.value - scroll.pos.x,
				worldY: pos.y - headerHeight - settings$1.paddingTop - scroll.pos.y
			};
			lastHoverMoveTime.value = Date.now();
			const hit = hitTestScrollbar(canvas, scroll, lines, settings$1, gutter, header, pos.x, pos.y);
			hovered.scrollbar = hit.type;
			if (hit.type) {
				hovered.line = null;
				hovered.column = null;
				hovered.token = null;
				hovered.error = null;
				if (hoverShowTimeout) {
					clearTimeout(hoverShowTimeout);
					hoverShowTimeout = null;
				}
				if (escapePressed) escapePressed = false;
				if (currentHoverTokenId !== null) {
					currentHoverTokenId = null;
					if (hoverHideTimeout) clearTimeout(hoverHideTimeout);
					hoverHideTimeout = setTimeout(() => {
						hovered.hoverToken = null;
						hoverHideTimeout = null;
					}, HOVER_HIDE_DELAY_MS);
				}
			}
		});
	};
	const handleCanvasMouseLeave = () => {
		if (scrollbars.isDragging.value) return;
		n(() => {
			pos.x = -1;
			pos.y = -1;
			hoverHitPos.value = null;
		});
		hovered.scrollbar = null;
		hovered.gutter = false;
		hovered.line = null;
		hovered.column = null;
		hovered.token = null;
		if (hoverShowTimeout) {
			clearTimeout(hoverShowTimeout);
			hoverShowTimeout = null;
		}
		if (escapePressed) escapePressed = false;
		if (currentHoverTokenId !== null) {
			currentHoverTokenId = null;
			if (hoverHideTimeout) clearTimeout(hoverHideTimeout);
			hoverHideTimeout = setTimeout(() => {
				hovered.hoverToken = null;
				hoverHideTimeout = null;
			}, HOVER_HIDE_DELAY_MS);
		}
	};
	const handleWindowMouseMove = (event) => {
		updateMousePositionFromEvent(event);
		scrollbars.handleMouseMove(pos.x, pos.y);
		if (isClickNotDrag) {
			const dx = Math.abs(pos.x - clickStartX);
			const dy = Math.abs(pos.y - clickStartY);
			if (dx > 3 || dy > 3) isClickNotDrag = false;
		}
	};
	const handleMouseDown = (event) => {
		if (Date.now() < ignoreMouseEventsUntil) {
			event.preventDefault();
			return;
		}
		buttonsDown.value = true;
		const onMouseUpForButtons = () => {
			buttonsDown.value = false;
			window.removeEventListener("mouseup", onMouseUpForButtons);
		};
		window.addEventListener("mouseup", onMouseUpForButtons);
		setActiveCanvas(canvas.el);
		notifyActivated?.();
		const textarea$1 = getTextareaElement();
		setTimeout(() => {
			textarea$1.focus();
		}, 0);
		updateMousePositionFromEvent(event);
		caret.isTyping.value = false;
		caret.caretToken = null;
		caret.suppressAutoScroll = true;
		isClickNotDrag = true;
		clickStartX = pos.x;
		clickStartY = pos.y;
		prevMouseX = pos.x;
		prevMouseY = pos.y;
		if (hoverShowTimeout) {
			clearTimeout(hoverShowTimeout);
			hoverShowTimeout = null;
		}
		if (hoverHideTimeout) {
			clearTimeout(hoverHideTimeout);
			hoverHideTimeout = null;
		}
		hovered.hoverToken = null;
		currentHoverTokenId = null;
		escapePressed = false;
		const headerHeight = header.value?.height ?? 0;
		const inHeader = headerHeight > 0 && pos.y >= 0 && pos.y < headerHeight;
		const headerValue = header.value;
		const onMouseDown = headerValue?.onMouseDown;
		if (inHeader && onMouseDown) {
			headerPressed.value = true;
			const onHeaderMouseUp = () => {
				headerPressed.value = false;
				window.removeEventListener("mouseup", onHeaderMouseUp);
			};
			window.addEventListener("mouseup", onHeaderMouseUp);
			const w$5 = canvas.size.width.value;
			const h$5 = headerValue.height;
			const tx = gutter.width.value;
			const tw = w$5 - tx;
			onMouseDown(event, pos.x, pos.y, w$5, h$5, tx, tw);
			event.preventDefault();
			caret.suppressAutoScroll = false;
			return;
		}
		const onWidgetMouseUp = () => {
			widgetPressed.value = false;
			window.removeEventListener("mouseup", onWidgetMouseUp);
		};
		const belowHit = findBelowWidgetHit(pos.x, pos.y);
		if (belowHit) {
			widgetPressed.value = true;
			window.addEventListener("mouseup", onWidgetMouseUp);
			belowHit.widget.onMouseDown(event, belowHit.canvasX, belowHit.canvasY, belowHit.canvasW, belowHit.canvasH);
			event.preventDefault();
			caret.suppressAutoScroll = false;
			return;
		}
		const beforeAfterHit = findBeforeAfterWidgetHit(pos.x, pos.y);
		if (beforeAfterHit) {
			widgetPressed.value = true;
			window.addEventListener("mouseup", onWidgetMouseUp);
			beforeAfterHit.widget.onMouseDown(event, beforeAfterHit.canvasX, beforeAfterHit.canvasY, beforeAfterHit.canvasW, beforeAfterHit.canvasH);
			event.preventDefault();
			caret.suppressAutoScroll = false;
			return;
		}
		if (event.button !== MouseButton$1.Left) return;
		const gutterHit = hitTestGutter(canvas, settings$1, lines, scroll, gutter, pos.x, pos.y, headerHeight);
		if (gutterHit.type === "collapse" && gutterHit.line !== null) {
			blocks.toggle(gutterHit.line);
			event.preventDefault();
			caret.suppressAutoScroll = false;
			return;
		}
		if (!hitTestScrollbar(canvas, scroll, lines, settings$1, gutter, header, pos.x, pos.y).type) {
			const lineColumn = findLineColumnFromPosition(pos.x, pos.y);
			if (lineColumn) {
				const codeLines = doc.lines;
				const logicalLine = lineColumn.line.logicalLine;
				const column = lineColumn.column;
				const now = Date.now();
				const isSamePosition = lastClickLine === logicalLine && lastClickColumn === column;
				const timeSinceLastClick = now - lastClickTime;
				if (isSamePosition && timeSinceLastClick < CLICK_TIMEOUT_MS) clickCount++;
				else clickCount = 1;
				lastClickTime = now;
				lastClickLine = logicalLine;
				lastClickColumn = column;
				if (clickTimeout) clearTimeout(clickTimeout);
				clickTimeout = setTimeout(() => {
					clickCount = 0;
					clickTimeout = null;
				}, CLICK_TIMEOUT_MS);
				if (clickCount === 2) {
					selectionMode = "word";
					const boundaries = findWordBoundaries(codeLines[logicalLine] || "", column);
					selection.setStart(logicalLine, boundaries.start);
					selection.setEnd(logicalLine, boundaries.end);
					lastMouseX = pos.x;
					selection.isSelecting.value = true;
					window.addEventListener("mousemove", handleWindowMouseMove);
					window.addEventListener("mouseup", handleWindowMouseUp);
					caret.setPosition(logicalLine, boundaries.end, codeLines);
					caret.resetBlink();
				} else if (clickCount === 3) {
					selectionMode = "line";
					const boundaries = findLineBoundaries(codeLines[logicalLine] || "");
					selection.setStart(logicalLine, boundaries.start);
					selection.setEnd(logicalLine, boundaries.end);
					lastMouseX = pos.x;
					selection.isSelecting.value = true;
					window.addEventListener("mousemove", handleWindowMouseMove);
					window.addEventListener("mouseup", handleWindowMouseUp);
					caret.setPosition(logicalLine, boundaries.end, codeLines);
					caret.resetBlink();
				} else {
					selectionMode = "normal";
					if (event.shiftKey && selection.start.value) {
						selection.setEnd(logicalLine, column);
						lastMouseX = pos.x;
						selection.isSelecting.value = true;
						window.addEventListener("mousemove", handleWindowMouseMove);
						window.addEventListener("mouseup", handleWindowMouseUp);
					} else {
						selection.setStart(logicalLine, column);
						lastMouseX = pos.x;
						selection.isSelecting.value = true;
						window.addEventListener("mousemove", handleWindowMouseMove);
						window.addEventListener("mouseup", handleWindowMouseUp);
					}
					caret.setPosition(logicalLine, column, codeLines);
					caret.resetBlink();
				}
			}
		} else if (scrollbars.handleMouseDown(pos.x, pos.y)) {
			window.addEventListener("mousemove", handleWindowMouseMove);
			window.addEventListener("mouseup", handleWindowMouseUp);
			caret.suppressAutoScroll = false;
			event.preventDefault();
		}
	};
	const handleWindowMouseUp = (event) => {
		if (Date.now() < ignoreMouseEventsUntil) {
			event.preventDefault();
			return;
		}
		if (event.button !== 0) return;
		updateMousePositionFromEvent(event);
		hovered.scrollbar = scrollbars.handleMouseUp(pos.x, pos.y);
		selection.isSelecting.value = false;
		selectionMode = "normal";
		stopAutoScroll();
		window.removeEventListener("mousemove", handleWindowMouseMove);
		window.removeEventListener("mouseup", handleWindowMouseUp);
		if (hovered.line && hovered.column !== null) {
			const lineLength = doc.lines[hovered.line.logicalLine]?.length || 0;
			caret.columnIntent.value = Math.min(hovered.column, lineLength);
		}
		caret.suppressAutoScroll = false;
		isClickNotDrag = false;
	};
	let touchStartClientX = 0;
	let touchStartClientY = 0;
	let lastTouchClientX = 0;
	let lastTouchClientY = 0;
	let isTouchScrolling = false;
	let ignoreMouseEventsUntil = 0;
	const TOUCH_SCROLL_THRESHOLD = 5;
	const handleTouchStart = (event) => {
		if (event.touches.length !== 1) return;
		const touch = event.touches[0];
		touchStartClientX = touch.clientX;
		touchStartClientY = touch.clientY;
		lastTouchClientX = touch.clientX;
		lastTouchClientY = touch.clientY;
		isTouchScrolling = false;
		hasMouseMovedInEditor = true;
		ignoreMouseEventsUntil = Date.now() + 1e3;
	};
	const handleTouchMove = (event) => {
		if (event.touches.length !== 1) return;
		const touch = event.touches[0];
		const clientX = touch.clientX;
		const clientY = touch.clientY;
		const deltaX = clientX - lastTouchClientX;
		const deltaY = clientY - lastTouchClientY;
		if (!isTouchScrolling) {
			const totalDx = clientX - touchStartClientX;
			const totalDy = clientY - touchStartClientY;
			if (Math.abs(totalDx) < TOUCH_SCROLL_THRESHOLD && Math.abs(totalDy) < TOUCH_SCROLL_THRESHOLD) return;
			isTouchScrolling = true;
		}
		lastTouchClientX = clientX;
		lastTouchClientY = clientY;
		const headerHeight = header.value?.height ?? 0;
		const canvasHeight = canvas.size.height.value - headerHeight - settings$1.paddingTop - settings$1.paddingBottom;
		const canvasWidth = canvas.size.width.value - settings$1.paddingLeft - settings$1.paddingRight;
		const maxScrollY = -(lines.totalHeight.value - canvasHeight);
		const maxScrollX = settings$1.wordWrap ? 0 : -(lines.totalWidth.value - canvasWidth);
		const atEdgeY = deltaY < 0 && scroll.targetY.value <= maxScrollY || deltaY > 0 && scroll.targetY.value >= 0;
		const atEdgeX = deltaX < 0 && scroll.targetX.value <= maxScrollX || deltaX > 0 && scroll.targetX.value >= 0;
		if ((Math.abs(deltaX) > Math.abs(deltaY) ? "x" : "y") === "y" ? atEdgeY : atEdgeX) {
			if (allowScrollPassThrough) return;
			clearTimeout(allowScrollTimeoutId);
			allowScrollTimeoutId = setTimeout(() => {
				allowScrollPassThrough = true;
				allowScrollTimeoutId = null;
			}, ALLOW_SCROLL_DEBOUNCE_MS);
			event.preventDefault();
			return;
		}
		clearTimeout(allowScrollTimeoutId);
		allowScrollPassThrough = false;
		event.preventDefault();
		scroll.smooth.value = SCROLL_SMOOTH_SCROLLING;
		scroll.targetX.value += deltaX;
		scroll.targetY.value += deltaY;
		if (scroll.targetY.value > 0) scroll.targetY.value = 0;
		if (scroll.targetY.value < maxScrollY) scroll.targetY.value = maxScrollY;
		if (scroll.targetX.value > 0) scroll.targetX.value = 0;
		if (scroll.targetX.value < maxScrollX) scroll.targetX.value = maxScrollX;
		updateMousePositionFromPoint(clientX, clientY);
		hoverHitPos.value = {
			worldX: pos.x - settings$1.paddingLeft - gutter.width.value - scroll.pos.x,
			worldY: pos.y - headerHeight - settings$1.paddingTop - scroll.pos.y
		};
	};
	const handleTouchEnd = () => {
		isTouchScrolling = false;
		clearTimeout(allowScrollTimeoutId);
		allowScrollTimeoutId = null;
		allowScrollPassThrough = false;
	};
	canvas.el.addEventListener("wheel", handleScroll, { passive: false });
	canvas.el.addEventListener("mousemove", handleCanvasMouseMove);
	canvas.el.addEventListener("mousedown", handleMouseDown);
	canvas.el.addEventListener("mouseleave", handleCanvasMouseLeave);
	canvas.el.addEventListener("touchstart", handleTouchStart, { passive: true });
	canvas.el.addEventListener("touchmove", handleTouchMove, { passive: false });
	canvas.el.addEventListener("touchend", handleTouchEnd);
	canvas.el.addEventListener("touchcancel", handleTouchEnd);
	const clearHoverToken = (setEscapePressed = false) => {
		if (hoverShowTimeout) {
			clearTimeout(hoverShowTimeout);
			hoverShowTimeout = null;
		}
		if (hoverHideTimeout) {
			clearTimeout(hoverHideTimeout);
			hoverHideTimeout = null;
		}
		hovered.hoverToken = null;
		currentHoverTokenId = null;
		if (setEscapePressed) escapePressed = true;
	};
	const dispose = () => {
		stopAutoScroll();
		if (clickTimeout) {
			clearTimeout(clickTimeout);
			clickTimeout = null;
		}
		if (hoverShowTimeout) {
			clearTimeout(hoverShowTimeout);
			hoverShowTimeout = null;
		}
		if (hoverHideTimeout) {
			clearTimeout(hoverHideTimeout);
			hoverHideTimeout = null;
		}
		canvas.el.removeEventListener("wheel", handleScroll);
		window.removeEventListener("scroll", handleDocumentScroll, true);
		canvas.el.removeEventListener("mousemove", handleCanvasMouseMove);
		canvas.el.removeEventListener("mousedown", handleMouseDown);
		canvas.el.removeEventListener("mouseleave", handleCanvasMouseLeave);
		canvas.el.removeEventListener("touchstart", handleTouchStart);
		canvas.el.removeEventListener("touchmove", handleTouchMove);
		canvas.el.removeEventListener("touchend", handleTouchEnd);
		canvas.el.removeEventListener("touchcancel", handleTouchEnd);
		window.removeEventListener("mousemove", handleWindowMouseMove);
		window.removeEventListener("mouseup", handleWindowMouseUp);
	};
	return {
		hovered,
		pos,
		update,
		dispose,
		clearHoverToken,
		lastHoverMoveTime,
		buttonsDown
	};
}
function drawCaret(context) {
	const { canvas, doc, lines, caret, settings: settings$1, caches, gutter, scroll, header } = context;
	const { c: c$7 } = canvas;
	if (!(getActiveCanvas() === canvas.el)) {
		caret.caretToken = null;
		return;
	}
	if (context.mouse.buttonsDown.value) {
		caret.caretToken = null;
		return;
	}
	const opacity = caret.updateBlink();
	lines.visualLines.value;
	const codeLines = doc.code.split("\n");
	const currentLine = caret.line.value;
	const currentColumn = caret.column.value;
	if (currentLine < 0 || currentLine >= codeLines.length) {
		caret.caretToken = null;
		return;
	}
	const tokenLines = doc.tokenLines;
	let foundLine = findVisualLineForColumn(lines, currentLine, currentColumn, tokenLines, caches);
	if (!foundLine) {
		const visualLines = lines.visualLines.value;
		const relevantLines = visualLines.filter((line) => line.logicalLine === currentLine);
		if (relevantLines.length > 0) foundLine = relevantLines[0];
		else {
			const lastVisualLine = visualLines[visualLines.length - 1];
			if (lastVisualLine && currentLine === lastVisualLine.logicalLine + 1) foundLine = {
				tokens: [],
				logicalLine: currentLine,
				tokenOffset: 0,
				y: lastVisualLine.y + lastVisualLine.height,
				width: 0,
				height: settings$1.lineHeight,
				widgets: {
					above: [],
					below: [],
					overlay: [],
					inlay: [],
					beforeAfter: [],
					full: []
				},
				errors: []
			};
			else {
				caret.caretToken = null;
				return;
			}
		}
	}
	let x$4 = Math.max(1, getXFromColumn(lines, foundLine, currentColumn, tokenLines, canvas, settings$1, caches));
	for (const w$5 of doc.widgets) if (w$5.type === "before" && w$5.pos.y - 1 === currentLine && w$5.pos.x - 1 === currentColumn) x$4 += w$5.pos.width;
	const aboveHeight = calculateAboveHeightForLine(context, foundLine);
	const contentY = foundLine.tokenOffset === 0 ? foundLine.y : foundLine.y + aboveHeight;
	const lineHeight$1 = settings$1.lineHeight;
	c$7.strokeStyle = settings$1.colors.brightWhite;
	c$7.globalAlpha = opacity;
	c$7.lineWidth = 1.5;
	c$7.beginPath();
	c$7.moveTo(x$4, contentY);
	c$7.lineTo(x$4, contentY + lineHeight$1);
	c$7.stroke();
	c$7.globalAlpha = 1;
	const logicalLineTokens = tokenLines[currentLine] || [];
	codeLines[currentLine];
	if (logicalLineTokens.length > 0 && foundLine.tokens.length > 0) {
		let tokenIndex = getTokenIndexFromColumn(logicalLineTokens, currentColumn > 0 ? currentColumn - 1 : currentColumn);
		let finalToken = tokenIndex >= 0 && tokenIndex < logicalLineTokens.length ? logicalLineTokens[tokenIndex] : null;
		let finalTokenIndex = tokenIndex;
		if (finalToken && finalTokenIndex >= 0 && finalTokenIndex < logicalLineTokens.length) {
			if (caret.isTyping.value) {
				const callBlock = findCallBlockForToken(tokenLines, currentLine, finalTokenIndex);
				const parameterIndex = callBlock.length > 0 ? getParameterIndex(callBlock, tokenLines, currentLine, finalTokenIndex) : -1;
				let tokenX = x$4;
				for (const visualToken of foundLine.tokens) if (visualToken.logicalTokenIndex === finalTokenIndex) {
					tokenX = visualToken.x;
					break;
				}
				const headerHeight = header.value?.height ?? 0;
				const scrollX = scroll.pos.x;
				const scrollY = scroll.pos.y;
				const canvasRect = canvas.rect;
				let screenX = tokenX + gutter.width.value + settings$1.paddingLeft + scrollX + canvasRect.left;
				let screenY = contentY + headerHeight + settings$1.paddingTop + scrollY + canvasRect.top;
				if (parameterIndex >= 0) {
					const paramStartToken = getParameterStartToken(callBlock, parameterIndex);
					if (paramStartToken) {
						const pos = findTokenPositionInTokenLines(tokenLines, paramStartToken);
						if (pos) {
							const column = getColumnForTokenIndex(tokenLines[pos.lineIndex] || [], pos.tokenIndex);
							const paramLine = findVisualLineForColumn(lines, pos.lineIndex, column, tokenLines, caches);
							if (paramLine) {
								const paramX = getXFromColumn(lines, paramLine, column, tokenLines, canvas, settings$1, caches);
								const paramContentY = paramLine.tokenOffset === 0 ? paramLine.y : paramLine.y + calculateAboveHeightForLine(context, paramLine);
								screenX = paramX + gutter.width.value + settings$1.paddingLeft + scrollX + canvasRect.left;
								screenY = paramContentY + headerHeight + settings$1.paddingTop + scrollY + canvasRect.top;
							}
						}
					}
				}
				let callBlockX = screenX;
				let callBlockY = screenY;
				if (callBlock.length > 0) {
					const lineTokens = tokenLines[currentLine] || [];
					let functionTokenIndex = -1;
					for (let i$6 = 0; i$6 < callBlock.length; i$6++) if (callBlock[i$6].text === "(" && i$6 > 0) {
						const prevToken = callBlock[i$6 - 1];
						if (prevToken && (prevToken.type === "function" || prevToken.type === "identifier")) {
							functionTokenIndex = lineTokens.indexOf(prevToken);
							break;
						}
					}
					if (functionTokenIndex >= 0) {
						for (const visualToken of foundLine.tokens) if (visualToken.logicalTokenIndex === functionTokenIndex) {
							callBlockX = visualToken.x + gutter.width.value + settings$1.paddingLeft + scrollX + canvasRect.left;
							callBlockY = contentY + headerHeight + settings$1.paddingTop + scrollY + canvasRect.top;
							break;
						}
					}
				}
				caret.caretToken = {
					canvas: createOverlayCanvas(),
					x: screenX,
					y: screenY,
					token: finalToken,
					callBlock,
					parameterIndex,
					callBlockX,
					callBlockY
				};
			} else if (!context.mouse.hovered.hoverToken) caret.caretToken = null;
		} else if (!context.mouse.hovered.hoverToken) caret.caretToken = null;
	} else caret.caretToken = null;
}
function getCaretScreenPosition(context) {
	const { doc, lines, caret, settings: settings$1, caches, gutter, scroll, header } = context;
	const codeLines = doc.code.split("\n");
	const currentLine = caret.line.value;
	const currentColumn = caret.column.value;
	if (currentLine < 0 || currentLine >= codeLines.length) return null;
	const tokenLines = doc.tokenLines;
	let foundLine = findVisualLineForColumn(lines, currentLine, currentColumn, tokenLines, caches);
	if (!foundLine) {
		const visualLines = lines.visualLines.value;
		const relevantLines = visualLines.filter((line) => line.logicalLine === currentLine);
		if (relevantLines.length > 0) foundLine = relevantLines[0];
		else {
			const lastVisualLine = visualLines[visualLines.length - 1];
			if (lastVisualLine && currentLine === lastVisualLine.logicalLine + 1) foundLine = {
				tokens: [],
				logicalLine: currentLine,
				tokenOffset: 0,
				y: lastVisualLine.y + lastVisualLine.height,
				width: 0,
				height: settings$1.lineHeight,
				widgets: {
					above: [],
					below: [],
					overlay: [],
					inlay: [],
					beforeAfter: [],
					full: []
				},
				errors: []
			};
			else return null;
		}
	}
	const { canvas } = context;
	let x$4 = Math.max(1, getXFromColumn(lines, foundLine, currentColumn, tokenLines, canvas, settings$1, caches));
	for (const w$5 of doc.widgets) if (w$5.type === "before" && w$5.pos.y - 1 === currentLine && w$5.pos.x - 1 === currentColumn) x$4 += w$5.pos.width;
	const aboveHeight = calculateAboveHeightForLine(context, foundLine);
	const contentY = foundLine.tokenOffset === 0 ? foundLine.y : foundLine.y + aboveHeight;
	const headerHeight = header.value?.height ?? 0;
	const canvasRect = canvas.rect;
	return {
		x: x$4 + gutter.width.value + settings$1.paddingLeft + scroll.pos.x + canvasRect.left,
		y: contentY + headerHeight + settings$1.paddingTop + scroll.pos.y + canvasRect.top
	};
}
function drawHeader(context) {
	const header = context.header.value;
	if (!header) return;
	const { canvas, gutter } = context;
	const { c: c$7 } = canvas;
	const width = canvas.size.width.value;
	const tx = gutter.width.value;
	const tw = width - tx;
	c$7.save();
	header.draw(c$7, 0, 0, width, header.height, tx, tw);
	c$7.restore();
}
function drawSquiggle(c$7, x$4, y$5, width) {
	c$7.strokeStyle = "#ff0000";
	c$7.lineWidth = 1.25;
	c$7.beginPath();
	const amplitude = 1;
	const period = 5;
	for (let i$6 = 0; i$6 <= width; i$6 += .5) {
		const squiggleY = y$5 + (2 * amplitude * Math.abs(2 * (i$6 / period - Math.floor(.5 + i$6 / period))) - amplitude);
		if (i$6 === 0) c$7.moveTo(x$4 + i$6, squiggleY);
		else c$7.lineTo(x$4 + i$6, squiggleY);
	}
	c$7.stroke();
}
function drawErrorSquiggles(context, line) {
	const errors = line.errors;
	if (errors.length === 0) return;
	const { lines, doc, canvas, settings: settings$1, caches } = context;
	const { c: c$7 } = canvas;
	const { lineHeight: lineHeight$1 } = settings$1;
	const tokenLines = doc.tokenLines;
	const aboveHeight = calculateAboveHeightForLine(context, line);
	const contentY = line.tokenOffset === 0 ? line.y : line.y + aboveHeight;
	for (const error$1 of errors) {
		const [startColumn, endColumn] = [error$1.x[0] - 1, error$1.x[1] - 1];
		const startX = getXFromColumn(lines, line, startColumn, tokenLines, canvas, settings$1, caches);
		const errorWidth = getXFromColumn(lines, line, endColumn, tokenLines, canvas, settings$1, caches) - startX;
		drawSquiggle(c$7, startX, contentY + lineHeight$1 - 2, errorWidth);
	}
}
function Deferred$2() {
	const _onwhen = () => {
		deferred.hasSettled = true;
		deferred.resolve = deferred.reject = noop;
	};
	const noop = () => {};
	let onwhen = _onwhen;
	const deferred = {
		hasSettled: false,
		when: (fn$1) => {
			onwhen = () => {
				_onwhen();
				fn$1();
			};
		}
	};
	deferred.promise = new Promise((resolve, reject) => {
		deferred.resolve = (arg) => {
			onwhen();
			deferred.value = arg;
			resolve(arg);
		};
		deferred.reject = (error$1) => {
			onwhen();
			deferred.error = error$1;
			reject(error$1);
		};
	});
	return deferred;
}
var fontBase64Cache = /* @__PURE__ */ new Map();
var ligatureCanvasCache = /* @__PURE__ */ new Map();
async function loadFontAsBase64(fontUrl) {
	if (fontBase64Cache.has(fontUrl)) return fontBase64Cache.get(fontUrl).promise;
	const deferred = Deferred$2();
	fontBase64Cache.set(fontUrl, deferred);
	const buffer = await fetch(fontUrl).then((response) => response.arrayBuffer());
	const bytes = new Uint8Array(buffer);
	let binary = "";
	for (let i$6 = 0; i$6 < bytes.length; i$6++) binary += String.fromCharCode(bytes[i$6]);
	const base64 = btoa(binary);
	deferred.resolve(base64);
	return deferred.promise;
}
function getCacheKey(ligature, fontSize$1, fontUrl, textColor$1, bgColor, dpr) {
	return [
		ligature,
		fontSize$1,
		fontUrl,
		textColor$1,
		bgColor,
		dpr
	].join("|");
}
function renderLigatureSync(ligature, options$2) {
	const { fontSize: fontSize$1 = "16px", fontUrl, fontWeight = 400, textColor: textColor$1 = "black", bgColor = "transparent", dpr = 1.5 } = options$2;
	const cacheKey = getCacheKey(ligature, fontSize$1, fontUrl, textColor$1, bgColor, dpr);
	if (ligatureCanvasCache.has(cacheKey)) return ligatureCanvasCache.get(cacheKey);
	return false;
}
async function renderLigature(ligature, width, height, options$2) {
	const { fontSize: fontSize$1 = "16px", fontUrl, fontWeight = 400, textColor: textColor$1 = "black", bgColor = "transparent", dpr = 1.5 } = options$2;
	const cacheKey = getCacheKey(ligature, fontSize$1, fontUrl, textColor$1, bgColor, dpr);
	const span = document.createElement("span");
	span.innerText = ligature;
	ligature = span.innerHTML;
	const base64 = await loadFontAsBase64(fontUrl);
	const makeSvg = ({ width: width$1, height: height$1 }) => {
		return `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${width$1} ${height$1}" preserveAspectRatio="xMidYMid slice" width="${width$1}" height="${height$1}">
  <style>
    @font-face {
      font-family: 'LigaFont';
      src: url(data:application/font-truetype;base64,${base64}) format('truetype');
    }
    .ligature-text {
      font-family: 'LigaFont';
      font-size: ${fontSize$1};
      font-weight: ${fontWeight};
      fill: ${textColor$1};
      dominant-baseline: hanging;
    }
    .ligature-bg {
      fill: ${bgColor};
    }
  </style>
  <rect class="ligature-bg" x="0" y="0" width="${width$1}" height="${height$1}" />
  <text
    x="0"
    y="50%"
    class="ligature-text"
    dominant-baseline="middle"
    alignment-baseline="middle"
  >${ligature}</text>
</svg>
`;
	};
	const svg = makeSvg({
		width,
		height
	});
	const canvas = new OffscreenCanvas(width * dpr, height * dpr);
	const ctx$1 = canvas.getContext("2d");
	if (!ctx$1) throw new Error("Could not get 2D context from OffscreenCanvas");
	ctx$1.scale(dpr, dpr);
	await new Promise((resolve, reject) => {
		const img = new Image(width, height);
		img.onload = () => {
			ctx$1.drawImage(img, 0, 0);
			resolve();
		};
		img.onerror = () => {
			reject(/* @__PURE__ */ new Error("Failed to load SVG image"));
		};
		img.src = "data:image/svg+xml;utf8," + encodeURIComponent(svg);
	});
	ligatureCanvasCache.set(cacheKey, canvas);
	return canvas;
}
const ligatures = new Set([
	"->",
	"->>",
	"-->",
	"<-",
	"<<-",
	"<-->",
	"=>",
	"==>",
	"<=>",
	"<=",
	">=",
	"<|",
	"|>",
	"<~",
	"~>",
	"<~>",
	"~~>",
	"<->",
	"==",
	"===",
	"!=",
	"!==",
	"<>",
	"<=",
	"<+",
	"+=",
	"-=",
	"*=",
	"/=",
	"**",
	"**=",
	"++",
	"--",
	"-+",
	"+-",
	"&&",
	"||",
	"!!",
	"&=",
	"|=",
	"^=",
	"~=",
	"::",
	":::",
	"|->",
	"<-",
	"|",
	"...",
	"..<",
	"..<.",
	"!!!",
	"~~~",
	"<*>",
	"<$>",
	"<$>",
	"<$!>",
	"+++",
	"^^"
]);
function drawLigatureCanvas(c$7, ligatureCanvas, x$4, y$5, options$2) {
	c$7.drawImage(ligatureCanvas, x$4, y$5, ligatureCanvas.width / options$2.dpr, ligatureCanvas.height / options$2.dpr);
}
async function drawLigature(c$7, ligature, x$4, y$5, width, height, options$2) {
	let ligatureCanvas = renderLigatureSync(ligature, options$2);
	if (ligatureCanvas) {
		drawLigatureCanvas(c$7, ligatureCanvas, x$4, y$5, options$2);
		return null;
	}
	ligatureCanvas = await renderLigature(ligature, width, height, options$2);
	drawLigatureCanvas(c$7, ligatureCanvas, x$4, y$5, options$2);
}
function drawRoundedRect(c$7, x$4, y$5, width, height, radius) {
	c$7.beginPath();
	c$7.moveTo(x$4 + radius, y$5);
	c$7.lineTo(x$4 + width - radius, y$5);
	c$7.quadraticCurveTo(x$4 + width, y$5, x$4 + width, y$5 + radius);
	c$7.lineTo(x$4 + width, y$5 + height - radius);
	c$7.quadraticCurveTo(x$4 + width, y$5 + height, x$4 + width - radius, y$5 + height);
	c$7.lineTo(x$4 + radius, y$5 + height);
	c$7.quadraticCurveTo(x$4, y$5 + height, x$4, y$5 + height - radius);
	c$7.lineTo(x$4, y$5 + radius);
	c$7.quadraticCurveTo(x$4, y$5, x$4 + radius, y$5);
	c$7.closePath();
}
function drawText(c$7, text, x$4, y$5, color) {
	c$7.fillStyle = color;
	c$7.strokeStyle = color;
	c$7.lineWidth = .2;
	c$7.lineCap = "round";
	c$7.lineJoin = "miter";
	c$7.miterLimit = 3;
	c$7.fillText(text, x$4, y$5);
	c$7.strokeText(text, x$4, y$5);
}
var IS_CHROME = navigator.userAgent.includes("Chrome");
function drawToken(c$7, context, token, x$4, y$5, colorOverride) {
	const { text, type } = token;
	const { color: themeColor, style, weight } = context.settings.theme[type];
	const color = colorOverride ?? themeColor;
	const { width, height } = measureText(context.canvas.c, context.settings, context.caches, token);
	const fontWeight = weight === "bold" ? 700 : 400;
	c$7.save();
	try {
		c$7.font = `${fontWeight} ${style} ${context.settings.fontSize} '${context.settings.fontFamilyName}', monospace`;
		c$7.textBaseline = "top";
		if (IS_CHROME && ligatures.has(text)) return {
			promise: drawLigature(c$7, text, x$4, y$5, width, height, {
				fontUrl: context.settings.fontFamilies.find((font) => font.style === style && font.weight === (weight === "bold" ? "bold" : "normal"))?.url,
				fontWeight,
				fontSize: context.settings.fontSize,
				bgColor: "transparent",
				textColor: color,
				dpr: context.canvas.ligatureDpr.value
			}),
			width,
			height
		};
		else {
			drawText(c$7, text, x$4, y$5, color);
			return {
				promise: null,
				width,
				height
			};
		}
	} finally {
		c$7.restore();
	}
}
function isBraceOrQuoteChar(char) {
	switch (char) {
		case "{":
		case "(":
		case "[":
		case "}":
		case ")":
		case "]":
		case "'":
		case "\"":
		case "`": return true;
		default: return false;
	}
}
function drawLine(context, line) {
	const { canvas, settings: settings$1, caches } = context;
	const { c: c$7, dpr } = canvas;
	const { lineCanvasCache, lineCanvasCacheByLine } = caches;
	const logicalLine = line.logicalLine;
	const visualTokens = line.tokens;
	const lineCacheKey = getLineCacheKey(context, visualTokens);
	let needsRedraw = false;
	let lineCanvas = lineCanvasCacheByLine.get(logicalLine);
	const cachedLineCanvas = lineCanvasCache.get(lineCacheKey);
	if (cachedLineCanvas) {
		lineCanvas = cachedLineCanvas;
		lineCanvas.lineCacheKey = lineCacheKey;
		lineCanvasCacheByLine.set(logicalLine, lineCanvas);
	} else if (!lineCanvas) {
		needsRedraw = true;
		const metrics = measureVisualTokens(c$7, settings$1, caches, visualTokens);
		const lineWidth = Math.max(metrics.width, line.width);
		const offscreenCanvas = new OffscreenCanvas(lineWidth * dpr.value, metrics.height * dpr.value);
		lineCanvas = {
			lineCacheKey,
			canvas: offscreenCanvas,
			c: offscreenCanvas.getContext("2d")
		};
		lineCanvas.c.setTransform(dpr.value, 0, 0, dpr.value, 0, 0);
		lineCanvasCacheByLine.set(logicalLine, lineCanvas);
		lineCanvasCache.set(lineCacheKey, lineCanvas);
	} else if (lineCanvas.lineCacheKey !== lineCacheKey) {
		needsRedraw = true;
		const metrics = measureVisualTokens(c$7, settings$1, caches, visualTokens);
		const lineWidth = Math.max(metrics.width, line.width);
		const { canvas: offscreenCanvas, c: offscreenContext } = lineCanvas;
		const targetWidth = lineWidth * dpr.value;
		const targetHeight = metrics.height * dpr.value;
		const needsResize = offscreenCanvas.width !== targetWidth || offscreenCanvas.height !== targetHeight;
		if (needsResize) {
			offscreenCanvas.width = targetWidth;
			offscreenCanvas.height = targetHeight;
		}
		offscreenContext.setTransform(dpr.value, 0, 0, dpr.value, 0, 0);
		if (!needsResize) offscreenContext.clearRect(0, 0, targetWidth / dpr.value, targetHeight / dpr.value);
		lineCanvasCache.delete(lineCanvas.lineCacheKey);
		lineCanvas.lineCacheKey = lineCacheKey;
		lineCanvasCache.set(lineCacheKey, lineCanvas);
	}
	if (needsRedraw) {
		const { c: c$8 } = lineCanvas;
		const logicalLineTokens = context.doc.tokenLines[logicalLine] || [];
		const blockColors = context.settings.ui.blockColors;
		for (const visualToken of visualTokens) {
			const { token, x: x$4, logicalTokenIndex } = visualToken;
			const logicalToken = logicalLineTokens[logicalTokenIndex];
			let colorOverride;
			if (logicalToken && logicalToken.type !== "comment" && token.type !== "comment" && token.text.length === 1) {
				const char = token.text;
				if (isBraceOrQuoteChar(char)) {
					const charIndex = logicalToken.text.indexOf(char);
					if (charIndex !== -1) {
						const depth = context.blocks.getBraceDepthForPosition(logicalLine, logicalTokenIndex, charIndex);
						if (depth !== null) colorOverride = blockColors[depth % blockColors.length];
						else colorOverride = "red";
					}
				}
			}
			drawToken(c$8, context, token, x$4, 2, colorOverride);
		}
	}
	const aboveHeight = calculateAboveHeightForLine(context, line);
	const contentY = line.tokenOffset === 0 ? line.y : line.y + aboveHeight;
	drawFullWidgets(context, line);
	drawAboveWidgets(context, line);
	drawOverlayWidgets(context, line);
	drawInlayWidgets(context, line);
	drawBeforeAfterWidgets(context, line);
	drawBelowWidgets(context, line);
	drawErrorSquiggles(context, line);
	c$7.drawImage(lineCanvas.canvas, 0, contentY, lineCanvas.canvas.width / dpr.value, lineCanvas.canvas.height / dpr.value);
}
function drawLines(context) {
	const visualLines = context.lines.visualLines.value;
	const { size: { height: { value: height } } } = context.canvas;
	const { paddingTop } = context.settings;
	const { y: y$5 } = context.scroll.pos;
	const visibleTop = -(context.header.value?.height ?? 0) - paddingTop;
	const visibleBottom = height - paddingTop;
	for (const line of visualLines) {
		const lineY = line.y + y$5;
		if (lineY + line.height < visibleTop) continue;
		if (shouldBreakBottom(visualLines, line, lineY, visibleBottom, y$5)) break;
		drawLine(context, line);
	}
}
function drawSelection(context) {
	const { canvas, doc, lines, selection, settings: settings$1, scroll, caches, header } = context;
	const { c: c$7 } = canvas;
	if (!selection.hasSelection.value) return;
	const ordered = selection.getOrdered.value;
	if (!ordered) return;
	const codeLines = doc.lines;
	const tokenLines = doc.tokenLines;
	const scrollY = scroll.pos.y;
	const visibleTop = -(header.value?.height ?? 0) - settings$1.paddingTop;
	const visibleBottom = canvas.size.height.value - settings$1.paddingTop;
	const visibleLeft = -settings$1.paddingLeft;
	const startLine = ordered.start.line;
	const endLine = ordered.end.line;
	const startColumn = ordered.start.column;
	const endColumn = ordered.end.column;
	const newlineIndicatorWidth = measureText(c$7, settings$1, caches, {
		type: "text",
		text: " "
	}).width / 2;
	const baseX = visibleLeft - scroll.pos.x;
	const baseY = visibleTop - scroll.pos.y;
	const temp = selection.getOffscreenCanvas(canvas.size.width.value, canvas.size.height.value, canvas.dpr.value);
	const tempCanvas = temp.canvas;
	const tempC = temp.c;
	tempC.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
	tempC.fillStyle = settings$1.colors.blue + "dd";
	tempC.beginPath();
	let prevEmpty = false;
	for (let logicalLine = startLine; logicalLine <= endLine; logicalLine++) {
		if (logicalLine < 0 || logicalLine >= codeLines.length) continue;
		const visualLines = lines.visualLinesByLogicalLine.value.get(logicalLine) ?? [];
		if (!visualLines.length) continue;
		let prevVisualBottom = null;
		let lastIndex = null;
		let prevVisualEndX = null;
		let prevVisualStartX = null;
		let prevVisualWidth = null;
		for (let i$6 = 0; i$6 < visualLines.length; i$6++) {
			const isFirst = i$6 === 0;
			if (isFirst) {
				prevVisualEndX = null;
				prevVisualStartX = null;
				prevVisualWidth = null;
			}
			const v$4 = visualLines[i$6];
			const y$5 = v$4.y;
			const h$5 = v$4.height;
			const yScroll = y$5 + scrollY;
			if (yScroll + h$5 < visibleTop) continue;
			if (yScroll > visibleBottom + calculateAboveHeightForLine(context, v$4)) break;
			const isStartLine = logicalLine === startLine;
			const isEndLine = logicalLine === endLine;
			const lineLen = codeLines[logicalLine]?.length || 0;
			const vStartCol = getCharOffsetForVisualLine(logicalLine, v$4, tokenLines, lines);
			let vEndCol = vStartCol;
			for (const token of v$4.tokens) vEndCol += token.token.text.length;
			const selStart = isStartLine ? startColumn : 0;
			const selEnd = isEndLine ? endColumn : lineLen;
			const colStart = Math.max(selStart, vStartCol);
			const colEnd = Math.min(selEnd, vEndCol);
			const isEmptyVisual = colStart >= colEnd && logicalLine < endLine;
			if (!isEmptyVisual && colStart >= colEnd) {
				prevVisualEndX = null;
				prevVisualStartX = null;
				prevVisualWidth = null;
				prevEmpty = false;
				continue;
			}
			let startX;
			let endX;
			if (isEmptyVisual) {
				startX = getXFromColumn(lines, v$4, vEndCol, tokenLines, canvas, settings$1, caches);
				endX = startX + newlineIndicatorWidth;
			} else {
				startX = getXFromColumn(lines, v$4, colStart, tokenLines, canvas, settings$1, caches);
				endX = getXFromColumn(lines, v$4, colEnd, tokenLines, canvas, settings$1, caches);
				if (logicalLine < endLine) endX += newlineIndicatorWidth / 2;
			}
			const widthRaw = Math.abs(endX - startX);
			const ox = Math.min(startX, endX) - baseX;
			const oy = y$5 - baseY;
			let oyInt;
			let hInt;
			const consecutive = lastIndex !== null && i$6 === lastIndex + 1;
			if (isFirst || !consecutive || prevVisualBottom === null) {
				oyInt = oy;
				hInt = h$5;
				if (isFirst);
			} else {
				oyInt = prevVisualBottom;
				hInt = h$5;
			}
			prevVisualBottom = oyInt + hInt;
			const width = widthRaw;
			if (width <= 0 || hInt <= 0) {
				prevVisualEndX = null;
				prevVisualStartX = null;
				prevVisualWidth = null;
				continue;
			}
			lastIndex = i$6;
			let radius = 3;
			const eps = .5;
			const isLast = i$6 === visualLines.length - 1;
			const hasAbove = logicalLine > startLine;
			const hasBelow = logicalLine < endLine;
			let tl = false;
			let tr = false;
			let bl = false;
			let br = false;
			let drawTopLine = false;
			let prevWidth = null;
			let nextWidth = null;
			let prevStartX = null;
			let nextStartX = null;
			if (consecutive && prevVisualEndX !== null && prevVisualStartX !== null && prevVisualWidth !== null) {
				const prevEndX = prevVisualEndX;
				prevStartX = prevVisualStartX;
				prevWidth = prevVisualWidth;
				if (prevEndX > endX + eps) tr = true;
				if (prevStartX < startX - eps) tl = true;
			}
			prevVisualEndX = endX;
			prevVisualStartX = startX;
			prevVisualWidth = widthRaw;
			let nextIsEmpty = false;
			if (!isLast) {
				const nv = visualLines[i$6 + 1];
				const nvStartCol = getCharOffsetForVisualLine(logicalLine, nv, tokenLines, lines);
				let nvEndCol = nvStartCol;
				for (const token of nv.tokens) nvEndCol += token.token.text.length;
				const nvSelStart = isStartLine ? startColumn : 0;
				const nvSelEnd = isEndLine ? endColumn : lineLen;
				const nvColStart = Math.max(nvSelStart, nvStartCol);
				const nvColEnd = Math.min(nvSelEnd, nvEndCol);
				const nvIsEmptyVisual = nvColStart >= nvColEnd && logicalLine < endLine;
				nextIsEmpty = nvIsEmptyVisual;
				if (nvColStart < nvColEnd || nvIsEmptyVisual) {
					let nvStartX;
					let nvEndX;
					if (nvIsEmptyVisual) {
						nvStartX = getXFromColumn(lines, nv, nvEndCol, tokenLines, canvas, settings$1, caches);
						nvEndX = nvStartX + newlineIndicatorWidth;
					} else {
						nvStartX = getXFromColumn(lines, nv, nvColStart, tokenLines, canvas, settings$1, caches);
						nvEndX = getXFromColumn(lines, nv, nvColEnd, tokenLines, canvas, settings$1, caches);
						if (logicalLine < endLine) nvEndX += newlineIndicatorWidth / 2;
					}
					nextStartX = nvStartX;
					nextWidth = Math.abs(nvEndX - nvStartX);
					if (nvEndX > endX + eps) br = true;
					if (nvStartX < startX - eps) bl = true;
				}
			}
			if (hasAbove && isFirst) {
				const pl = logicalLine - 1;
				const pv = lines.visualLinesByLogicalLine.value.get(pl) ?? [];
				if (pv.length) {
					const lv = pv[pv.length - 1];
					const ps = getCharOffsetForVisualLine(pl, lv, tokenLines, lines);
					let pe = ps;
					for (const token of lv.tokens) pe += token.token.text.length;
					const s0 = pl === startLine ? startColumn : 0;
					const e0 = pl < endLine ? codeLines[pl]?.length || 0 : endColumn;
					const cs = Math.max(s0, ps);
					const ce = Math.min(e0, pe);
					let psx = getXFromColumn(lines, lv, cs, tokenLines, canvas, settings$1, caches);
					let pex = getXFromColumn(lines, lv, ce, tokenLines, canvas, settings$1, caches);
					if (pl < endLine) pex += newlineIndicatorWidth / 2;
					if (prevStartX === null || prevWidth === null) {
						prevStartX = psx;
						prevWidth = Math.abs(pex - psx);
					}
					if (pex > endX + eps) tr = true;
					if (psx < startX - eps) tl = true;
					if (psx > endX + eps) drawTopLine = true;
				}
			}
			if (hasBelow && isLast) {
				const nl = logicalLine + 1;
				const nv = lines.visualLinesByLogicalLine.value.get(nl) ?? [];
				if (nv.length) {
					const fv = nv[0];
					const ns = getCharOffsetForVisualLine(nl, fv, tokenLines, lines);
					let ne = ns;
					for (const token of fv.tokens) ne += token.token.text.length;
					const s0 = nl === startLine ? startColumn : 0;
					const e0 = nl === endLine ? endColumn : codeLines[nl]?.length || 0;
					const cs = Math.max(s0, ns);
					const ce = Math.min(e0, ne);
					if ((codeLines[nl]?.length || 0) === 0 && nl < endLine) nextIsEmpty = true;
					let nsx = getXFromColumn(lines, fv, cs, tokenLines, canvas, settings$1, caches);
					let nex = getXFromColumn(lines, fv, ce, tokenLines, canvas, settings$1, caches);
					if (nl < endLine) nex += newlineIndicatorWidth / 2;
					if (nextStartX === null || nextWidth === null) {
						nextStartX = nsx;
						nextWidth = Math.abs(nex - nsx);
					}
					if (nex > endX + eps) br = true;
					if (nsx < startX - eps) bl = true;
				}
			}
			const straightTop = isEmptyVisual && prevEmpty;
			const straightBottom = isEmptyVisual && nextIsEmpty;
			const startsAtVisualStart = colStart === vStartCol;
			let roundTL = !startsAtVisualStart && !tl;
			let roundBL = !startsAtVisualStart && !bl;
			const widerThanNL = widthRaw > newlineIndicatorWidth;
			const moreVisuals = !isLast;
			let roundTR = !tr && (hasBelow || moreVisuals || widerThanNL);
			let roundBR = !br && (hasBelow || moreVisuals || widerThanNL);
			if (straightTop) {
				roundTL = false;
				roundTR = false;
			}
			if (straightBottom) {
				roundBL = false;
				roundBR = false;
			}
			tempC.moveTo(roundTL ? ox + radius : ox, oyInt);
			if (roundTR) {
				tempC.lineTo(ox + width - radius, oyInt);
				tempC.arcTo(ox + width, oyInt, ox + width, oyInt + radius, radius);
			} else tempC.lineTo(ox + width, oyInt);
			if (roundBR) {
				tempC.lineTo(ox + width, oyInt + hInt - radius);
				tempC.arcTo(ox + width, oyInt + hInt, ox + width - radius, oyInt + hInt, radius);
			} else tempC.lineTo(ox + width, oyInt + hInt);
			if (roundBL) {
				tempC.lineTo(ox + radius, oyInt + hInt);
				tempC.arcTo(ox, oyInt + hInt, ox, oyInt + hInt - radius, radius);
			} else tempC.lineTo(ox, oyInt + hInt);
			if (roundTL) {
				tempC.lineTo(ox, oyInt + radius);
				tempC.arcTo(ox, oyInt, ox + radius, oyInt, radius);
			} else tempC.lineTo(ox, oyInt);
			tempC.closePath();
			radius = 2.75;
			if (!straightTop && tr && prevWidth !== null) {
				const extra$1 = Math.max(newlineIndicatorWidth, prevWidth - widthRaw);
				const b$4 = Math.min(radius, Math.max(0, extra$1));
				if (b$4 > 0) {
					tempC.moveTo(ox + width, oyInt);
					tempC.lineTo(ox + width + b$4, oyInt);
					tempC.quadraticCurveTo(ox + width + b$4 * .6, oyInt + radius * .5, ox + width, oyInt + radius);
					tempC.closePath();
				}
			}
			if (!straightBottom && br && nextWidth !== null) {
				const extra$1 = nextWidth - widthRaw;
				const b$4 = Math.min(radius, Math.max(0, extra$1));
				if (b$4 > 0) {
					tempC.moveTo(ox + width, oyInt + hInt);
					tempC.lineTo(ox + width + b$4, oyInt + hInt);
					tempC.quadraticCurveTo(ox + width + b$4 * .6, oyInt + hInt - radius * .5, ox + width, oyInt + hInt - radius);
					tempC.closePath();
				}
			}
			if (tl && prevStartX !== null) {
				const extra$1 = startX - prevStartX;
				const b$4 = Math.min(radius, Math.max(0, extra$1));
				if (b$4 > 0) {
					tempC.moveTo(ox, oyInt);
					tempC.lineTo(ox - b$4, oyInt);
					tempC.quadraticCurveTo(ox - b$4 * .6, oyInt + radius * .5, ox, oyInt + radius);
					tempC.closePath();
				}
			}
			if (!straightBottom && bl && nextStartX !== null) {
				const extra$1 = startX - nextStartX;
				const b$4 = Math.min(radius, Math.max(0, extra$1));
				if (b$4 > 0) {
					tempC.moveTo(ox, oyInt + hInt);
					tempC.lineTo(ox - b$4, oyInt + hInt);
					tempC.quadraticCurveTo(ox - b$4 * .6, oyInt + hInt - radius * .5, ox, oyInt + hInt - radius);
					tempC.closePath();
				}
			}
			if (drawTopLine && prevStartX !== null) {
				const ex = endX - baseX;
				const psx = prevStartX - baseX;
				const t$12 = .75;
				tempC.moveTo(ex, oyInt);
				tempC.lineTo(psx, oyInt);
				tempC.lineTo(psx, oyInt + t$12);
				tempC.lineTo(ex, oyInt + t$12);
				tempC.closePath();
			}
			prevEmpty = isEmptyVisual;
		}
	}
	tempC.fill();
	c$7.globalAlpha = .3;
	c$7.drawImage(tempCanvas, baseX, baseY, canvas.size.width.value, canvas.size.height.value);
	c$7.globalAlpha = 1;
}
var PADDING = 10;
var ARROW_SIZE = 6;
var MAX_WIDTH = 400;
var MARGIN = 4;
var TOOLTIP_GAP = 0;
var RADIUS = 8;
function wrapTooltipText(c$7, font, message, maxWidth) {
	c$7.save();
	c$7.font = font;
	const out = [];
	let maxLineWidth = 0;
	const maxLineWidthLimit = Math.max(1, maxWidth);
	for (const paragraph of message.split("\n")) {
		const words = paragraph.split(" ");
		let current = "";
		for (const word of words) {
			const candidate = current ? current + " " + word : word;
			if (c$7.measureText(candidate).width <= maxLineWidthLimit) current = candidate;
			else {
				if (current) {
					const cw = c$7.measureText(current).width;
					maxLineWidth = Math.max(maxLineWidth, cw);
					out.push(current);
					current = "";
				}
				if (c$7.measureText(word).width <= maxLineWidthLimit) current = word;
				else {
					let rest = word;
					while (rest) {
						let fit = rest.length;
						while (fit > 0 && c$7.measureText(rest.slice(0, fit)).width > maxLineWidthLimit) fit--;
						if (fit === 0) fit = 1;
						const segment = rest.slice(0, fit);
						maxLineWidth = Math.max(maxLineWidth, c$7.measureText(segment).width);
						out.push(segment);
						rest = rest.slice(fit);
					}
				}
			}
		}
		if (current) {
			maxLineWidth = Math.max(maxLineWidth, c$7.measureText(current).width);
			out.push(current);
		}
	}
	c$7.restore();
	return {
		lines: out,
		width: maxLineWidth
	};
}
function drawTooltip(context, error$1, overlayCanvas, preferErrorAbove) {
	if (!error$1) return;
	const { canvas, settings: settings$1, lines, scroll, caches } = context;
	const { c: c$7 } = overlayCanvas;
	const canvasRect = canvas.rect;
	const tokenLines = context.doc.tokenLines;
	const logicalLine = error$1.y - 1;
	const [errorStartColumn, errorEndColumn] = [error$1.x[0] - 1, error$1.x[1] - 1];
	const errorLine = findVisualLineForColumn(lines, logicalLine, errorStartColumn, tokenLines, caches);
	if (!errorLine) return;
	const errorStartX = getXFromColumn(lines, errorLine, errorStartColumn, tokenLines, canvas, settings$1, caches);
	getXFromColumn(lines, errorLine, errorEndColumn, tokenLines, canvas, settings$1, caches);
	const textY = errorLine.y;
	const message = error$1.message;
	const font = `${settings$1.theme.text.weight === "bold" ? 700 : 400} ${settings$1.theme.text.style} 10pt '${settings$1.fontFamilyName}', monospace`;
	const { lines: wrappedLines, width: textWidth } = wrapTooltipText(c$7, font, message, MAX_WIDTH - PADDING * 2);
	const lineHeight$1 = 12;
	const tooltipWidth = Math.min(MAX_WIDTH, textWidth + PADDING * 2);
	const tooltipHeight = wrappedLines.length * lineHeight$1 + PADDING * 2;
	const headerHeight = context.header.value?.height ?? 0;
	const gutterWidth = context.gutter.width.value;
	const viewport = window.visualViewport;
	const viewportLeft = viewport.offsetLeft;
	const viewportTop = viewport.offsetTop;
	const viewportWidth = viewport.width;
	const viewportHeight = viewport.height;
	const screenX = errorStartX + canvasRect.left + gutterWidth + settings$1.paddingLeft + scroll.pos.x;
	const screenY = textY + canvasRect.top + headerHeight + settings$1.paddingTop + scroll.pos.y;
	const tooltipYAbove = screenY - tooltipHeight - ARROW_SIZE - TOOLTIP_GAP;
	const tooltipYBelow = screenY + settings$1.lineHeight + ARROW_SIZE + TOOLTIP_GAP;
	const viewportTopWithMargin = viewportTop + MARGIN;
	const viewportBottomWithMargin = viewportTop + viewportHeight - MARGIN;
	const fitsAbove = tooltipYAbove >= viewportTopWithMargin && tooltipYAbove + tooltipHeight <= viewportBottomWithMargin;
	const fitsBelow = tooltipYBelow >= viewportTopWithMargin && tooltipYBelow + tooltipHeight <= viewportBottomWithMargin;
	let tooltipX = screenX;
	let tooltipY;
	let tooltipAbove;
	if (preferErrorAbove) {
		tooltipAbove = true;
		tooltipY = tooltipYAbove;
	} else if (fitsBelow) {
		tooltipAbove = false;
		tooltipY = tooltipYBelow;
	} else if (fitsAbove) {
		tooltipAbove = true;
		tooltipY = tooltipYAbove;
	} else {
		tooltipAbove = tooltipYAbove >= viewportTopWithMargin;
		tooltipY = tooltipAbove ? tooltipYAbove : tooltipYBelow;
	}
	if (tooltipX < viewportLeft + MARGIN) tooltipX = viewportLeft + MARGIN;
	if (tooltipX + tooltipWidth > viewportLeft + viewportWidth - MARGIN) tooltipX = viewportLeft + viewportWidth - tooltipWidth - MARGIN;
	if (tooltipY < viewportTopWithMargin) tooltipY = viewportTopWithMargin;
	if (tooltipY + tooltipHeight > viewportBottomWithMargin) tooltipY = viewportBottomWithMargin - tooltipHeight;
	c$7.save();
	const BG_COLOR = context.settings.colors.black;
	const STROKE_COLOR = "#f00";
	c$7.fillStyle = BG_COLOR;
	c$7.strokeStyle = STROKE_COLOR;
	c$7.lineWidth = 1.35;
	c$7.beginPath();
	if (tooltipAbove) {
		c$7.moveTo(tooltipX + RADIUS, tooltipY);
		c$7.lineTo(tooltipX + tooltipWidth - RADIUS, tooltipY);
		c$7.quadraticCurveTo(tooltipX + tooltipWidth, tooltipY, tooltipX + tooltipWidth, tooltipY + RADIUS);
		c$7.lineTo(tooltipX + tooltipWidth, tooltipY + tooltipHeight - RADIUS);
		c$7.quadraticCurveTo(tooltipX + tooltipWidth, tooltipY + tooltipHeight, tooltipX + tooltipWidth - RADIUS, tooltipY + tooltipHeight);
		c$7.lineTo(tooltipX + ARROW_SIZE, tooltipY + tooltipHeight);
		c$7.lineTo(tooltipX, tooltipY + tooltipHeight + ARROW_SIZE);
		c$7.lineTo(tooltipX, tooltipY + tooltipHeight);
		c$7.lineTo(tooltipX, tooltipY + RADIUS);
		c$7.quadraticCurveTo(tooltipX, tooltipY, tooltipX + RADIUS, tooltipY);
		c$7.closePath();
	} else {
		c$7.moveTo(tooltipX + ARROW_SIZE, tooltipY);
		c$7.lineTo(tooltipX, tooltipY - ARROW_SIZE);
		c$7.lineTo(tooltipX, tooltipY);
		c$7.lineTo(tooltipX, tooltipY + tooltipHeight - RADIUS);
		c$7.quadraticCurveTo(tooltipX, tooltipY + tooltipHeight, tooltipX + RADIUS, tooltipY + tooltipHeight);
		c$7.lineTo(tooltipX + tooltipWidth - RADIUS, tooltipY + tooltipHeight);
		c$7.quadraticCurveTo(tooltipX + tooltipWidth, tooltipY + tooltipHeight, tooltipX + tooltipWidth, tooltipY + tooltipHeight - RADIUS);
		c$7.lineTo(tooltipX + tooltipWidth, tooltipY + RADIUS);
		c$7.quadraticCurveTo(tooltipX + tooltipWidth, tooltipY, tooltipX + tooltipWidth - RADIUS, tooltipY);
		c$7.lineTo(tooltipX + ARROW_SIZE, tooltipY);
		c$7.closePath();
	}
	c$7.fill();
	c$7.stroke();
	c$7.fillStyle = settings$1.theme.text.color;
	c$7.font = font;
	c$7.textBaseline = "top";
	for (let i$6 = 0; i$6 < wrappedLines.length; i$6++) drawText(c$7, wrappedLines[i$6], tooltipX + PADDING, tooltipY + PADDING + i$6 * lineHeight$1, settings$1.theme.text.color);
	c$7.restore();
}
function drawContext(context, overlayCanvas, activeTooltip) {
	const { canvas } = context;
	context.mouse.update();
	context.scroll.update();
	const rect = canvas.rect;
	const viewport = window.visualViewport;
	const viewportTop = viewport?.offsetTop ?? 0;
	const viewportLeft = viewport?.offsetLeft ?? 0;
	const viewportHeight = viewport?.height ?? window.innerHeight;
	const viewportWidth = viewport?.width ?? window.innerWidth;
	if (!(rect.bottom > viewportTop && rect.top < viewportTop + viewportHeight && rect.right > viewportLeft && rect.left < viewportLeft + viewportWidth)) return;
	canvas.clear();
	const headerHeight = context.header.value?.height ?? 0;
	canvas.c.save();
	canvas.c.translate(context.gutter.width.value, headerHeight);
	canvas.c.translate(context.settings.paddingLeft, context.settings.paddingTop);
	canvas.c.translate(context.scroll.pos.x, context.scroll.pos.y);
	drawLines(context);
	drawBlocks(context);
	drawSelection(context);
	drawCaret(context);
	canvas.c.restore();
	canvas.c.save();
	canvas.c.translate(context.gutter.width.value, headerHeight);
	canvas.c.translate(context.settings.paddingLeft, context.settings.paddingTop);
	canvas.c.save();
	canvas.c.translate(-context.gutter.width.value, 0);
	drawGutterBackground(context);
	drawGutter(context);
	canvas.c.restore();
	canvas.c.restore();
	drawScrollbars(context);
	drawHeader(context);
	const currentlyActive = activeTooltip.get(context) || null;
	const hoverToken = context.mouse.hovered.hoverToken;
	const hoverTime = context.mouse.lastHoverMoveTime.value;
	const caretTime = context.caret.lastInputTime.value;
	const caretToken = context.caret.caretToken;
	const canDrawHover = !!hoverToken && !!context.onHoverToken;
	const canDrawCaret = !!caretToken && context.caret.isTyping.value && !!context.onCaretToken;
	const hoverIsPrimary = hoverTime >= caretTime || !context.caret.isTyping.value;
	const scroll = context.scroll.pos;
	const canvasRect = context.canvas.rect;
	const hoverX = hoverToken ? hoverToken.contentX + scroll.x + canvasRect.left : 0;
	const hoverY = hoverToken ? hoverToken.contentY + scroll.y + canvasRect.top : 0;
	const hoverParamX = hoverToken?.contentParamX != null ? hoverToken.contentParamX + scroll.x + canvasRect.left : void 0;
	const hoverParamY = hoverToken?.contentParamY != null ? hoverToken.contentParamY + scroll.y + canvasRect.top : void 0;
	const hoverCallBlockX = hoverToken ? hoverToken.contentCallBlockX + scroll.x + canvasRect.left : 0;
	const hoverCallBlockY = hoverToken ? hoverToken.contentCallBlockY + scroll.y + canvasRect.top : 0;
	const caretPos = getCaretScreenPosition(context);
	let hoverPosition = null;
	let caretPosition = null;
	if (hoverIsPrimary && canDrawHover) hoverPosition = context.onHoverToken(overlayCanvas, hoverX, hoverY, hoverToken.token, hoverToken.callBlock, hoverToken.parameterIndex, hoverCallBlockX, hoverCallBlockY, context.doc, hoverParamX, hoverParamY, caretPos?.x, caretPos?.y);
	else if (!hoverIsPrimary && canDrawCaret) caretPosition = context.onCaretToken(overlayCanvas, caretToken.x, caretToken.y, caretToken.token, caretToken.callBlock, caretToken.parameterIndex, caretToken.callBlockX, caretToken.callBlockY, context.doc, void 0, void 0, caretPos?.x, caretPos?.y);
	if (hoverPosition == null && caretPosition == null) {
		if (currentlyActive === "hover" && canDrawHover) hoverPosition = context.onHoverToken(overlayCanvas, hoverX, hoverY, hoverToken.token, hoverToken.callBlock, hoverToken.parameterIndex, hoverCallBlockX, hoverCallBlockY, context.doc, hoverParamX, hoverParamY, caretPos?.x, caretPos?.y);
		else if (currentlyActive === "caret" && canDrawCaret) caretPosition = context.onCaretToken(overlayCanvas, caretToken.x, caretToken.y, caretToken.token, caretToken.callBlock, caretToken.parameterIndex, caretToken.callBlockX, caretToken.callBlockY, context.doc, void 0, void 0, caretPos?.x, caretPos?.y);
	}
	const hoverDrew = hoverPosition != null;
	const caretDrew = caretPosition != null;
	const primaryPosition = hoverIsPrimary ? hoverPosition : caretPosition;
	const positionToPreferAbove = (p$6) => p$6 === Position.BottomLeft || p$6 === Position.BottomRight;
	const preferErrorAbove = hoverDrew && caretDrew ? !positionToPreferAbove(primaryPosition) : primaryPosition != null ? positionToPreferAbove(primaryPosition) : false;
	const error$1 = context.tooltipDismissed ? context.mouse.hovered.error : context.mouse.hovered.error ?? context.pinnedError;
	if (context.mouse.hovered.error) context.tooltipDismissed = false;
	drawTooltip(context, error$1, overlayCanvas, preferErrorAbove);
	if (hoverDrew) {
		activeTooltip.set(context, "hover");
		if (caretToken) context.caret.caretToken = null;
	} else if (currentlyActive === "hover") activeTooltip.set(context, null);
	if (caretDrew) {
		activeTooltip.set(context, "caret");
		if (hoverToken) {
			context.mouse.hovered.hoverToken = null;
			context.mouse.clearHoverToken(false);
		}
	} else if (currentlyActive === "caret") activeTooltip.set(context, null);
}
var RenderManager = class {
	contexts = /* @__PURE__ */ new Set();
	overlayCanvas = createOverlayCanvas();
	activeTooltip = /* @__PURE__ */ new Map();
	register(context) {
		this.contexts.add(context);
	}
	unregister(context) {
		this.contexts.delete(context);
		this.activeTooltip.delete(context);
	}
	draw() {
		this.overlayCanvas.clear();
		for (const context of this.contexts) drawContext(context, this.overlayCanvas, this.activeTooltip);
	}
};
const renderManager = new RenderManager();
function draw() {
	renderManager.draw();
}
function createCanvas(settings$1) {
	const el = document.createElement("canvas");
	el.height = 20;
	el.style.display = "block";
	const width = c$3(0);
	const height = c$3(0);
	const size = {
		width,
		height
	};
	const c$7 = el.getContext("2d");
	const dpr = c$3(window.devicePixelRatio);
	const ligatureDpr = b(() => dpr.value * 1.5);
	const clear = () => {
		c$7.fillStyle = settings$1.ui.background;
		c$7.fillRect(0, 0, width.value, height.value);
	};
	m(() => {
		if (!width.value || !height.value) return;
		el.width = width.value * dpr.value;
		el.height = height.value * dpr.value;
		c$7.scale(dpr.value, dpr.value);
		if (settings$1.autoHeight) el.style.height = `${height.value}px`;
		clear();
		o$24(draw);
	});
	const handleResize = () => {
		if (!el.parentElement) return;
		const rect = el.parentElement.getBoundingClientRect();
		n(() => {
			width.value = rect.width;
			if (!settings$1.autoHeight) height.value = rect.height;
			dpr.value = window.devicePixelRatio;
		});
		el.style.width = `${rect.width}px`;
		if (!settings$1.autoHeight) el.style.height = `${rect.height}px`;
	};
	let resizeObserver = null;
	let mutationObserver = null;
	const initialize = () => {
		if (resizeObserver || !el.parentElement) return;
		resizeObserver = new ResizeObserver(handleResize);
		resizeObserver.observe(el.parentElement);
		window.addEventListener("resize", handleResize);
		handleResize();
		if (mutationObserver) {
			mutationObserver.disconnect();
			mutationObserver = null;
		}
	};
	mutationObserver = new MutationObserver(() => {
		if (el.parentElement) initialize();
	});
	mutationObserver.observe(document.body, {
		childList: true,
		subtree: true
	});
	if (el.parentElement) initialize();
	const dispose = () => {
		if (resizeObserver) {
			resizeObserver.disconnect();
			window.removeEventListener("resize", handleResize);
		}
		if (mutationObserver) mutationObserver.disconnect();
		el.remove();
	};
	return {
		el,
		size,
		get rect() {
			return settings$1.rect ?? el.getBoundingClientRect();
		},
		c: c$7,
		dpr,
		ligatureDpr,
		clear,
		dispose
	};
}
function createCaret(settings$1) {
	const line = c$3(0);
	const column = c$3(0);
	const columnIntent = c$3(0);
	const isTyping = c$3(false);
	const lastInputTime = c$3(0);
	let startTime = Date.now();
	let suppressAutoScroll = false;
	let caretToken = null;
	const resetBlink = () => {
		startTime = Date.now();
	};
	const updateBlink = () => {
		const elapsed = Date.now() - startTime;
		const delay = 500 * settings$1.caretPhaseCoeff;
		if (elapsed < delay) return 1;
		const pulseElapsed = elapsed - delay;
		const period = 1e3 * settings$1.caretPhaseCoeff;
		return ((Math.sin(Math.PI + pulseElapsed / period * Math.PI * 2) + 1) / 2) ** .707;
	};
	const setPosition = (newLine, newColumn, codeLines) => {
		line.value = Math.max(0, Math.min(newLine, codeLines.length - 1));
		const lineLength = codeLines[line.value]?.length || 0;
		column.value = Math.max(0, Math.min(newColumn, lineLength));
		resetBlink();
	};
	return {
		line,
		column,
		columnIntent,
		isTyping,
		lastInputTime,
		resetBlink,
		updateBlink,
		setPosition,
		get suppressAutoScroll() {
			return suppressAutoScroll;
		},
		set suppressAutoScroll(value) {
			suppressAutoScroll = value;
		},
		get caretToken() {
			return caretToken;
		},
		set caretToken(value) {
			caretToken = value;
		}
	};
}
function createGutter(doc, canvas, metrics, settings$1, caches, blocks, lines) {
	const rightReserved = 24;
	const width = b(() => {
		if (!settings$1.showGutter) return 0;
		const maxLineNumber = doc.lines.length;
		const minDigits = 10 ** settings$1.minGutterDigits - 1;
		const token = {
			type: "text",
			text: Math.max(maxLineNumber, minDigits).toString()
		};
		const metrics$1 = measureText(canvas.c, settings$1, caches, token);
		return settings$1.paddingLeft + metrics$1.width + rightReserved;
	});
	m(() => {
		metrics.gutterWidth.value = width.value;
	});
	return {
		width,
		lineNumberMap: b(() => {
			if (!lines) return /* @__PURE__ */ new Map();
			const visualLines = lines.visualLines.value;
			const map = /* @__PURE__ */ new Map();
			for (const visualLine of visualLines) {
				const logicalLine = visualLine.logicalLine;
				if (!map.has(logicalLine)) map.set(logicalLine, []);
				map.get(logicalLine).push(visualLine);
			}
			return map;
		}),
		blockStarts: b(() => blocks.blockStarts.value),
		lineNumberMetrics: b(() => {
			const codeLines = doc.lines;
			const metrics$1 = /* @__PURE__ */ new Map();
			const numbersRightEdge = width.value - rightReserved;
			for (let i$6 = 0; i$6 < codeLines.length; i$6++) {
				const lineNumber = (i$6 + 1).toString();
				const token = {
					type: "text",
					text: lineNumber
				};
				const measure = measureText(canvas.c, settings$1, caches, token);
				const x$4 = numbersRightEdge - measure.width;
				metrics$1.set(i$6, {
					width: measure.width,
					text: lineNumber,
					x: x$4
				});
			}
			return metrics$1;
		})
	};
}
function createClipboard(doc, selection, insertText, deleteSelection, ensureCaretVisible, onKeyDown, onKeyUp, canvas) {
	const textarea$1 = getTextareaElement();
	function getSelectedText() {
		const ordered = selection.getOrdered.value;
		if (!ordered) return "";
		const { start, end } = ordered;
		const lines = doc.lines;
		if (start.line === end.line) return (lines[start.line] || "").slice(start.column, end.column);
		let text = "";
		for (let line = start.line; line <= end.line; line++) {
			const lineText = lines[line] || "";
			if (line === start.line) text += lineText.slice(start.column);
			else if (line === end.line) text += lineText.slice(0, end.column);
			else text += lineText;
			if (line < end.line) text += "\n";
		}
		return text;
	}
	function copy() {
		const text = getSelectedText();
		if (!text) return;
		textarea$1.value = text;
		textarea$1.select();
		try {
			if (!document.execCommand("copy")) console.error("Failed to copy: execCommand returned false");
		} catch (err) {
			console.error("Failed to copy:", err);
		} finally {
			textarea$1.value = "";
			const activeCanvas$1 = document.activeElement?.tagName === "CANVAS" ? document.activeElement : null;
			if (activeCanvas$1) setTimeout(() => {
				if (document.activeElement === activeCanvas$1) textarea$1.focus();
			}, 0);
		}
	}
	function cut() {
		const text = getSelectedText();
		if (!text) return;
		textarea$1.value = text;
		textarea$1.select();
		try {
			if (!document.execCommand("copy")) {
				console.error("Failed to cut: execCommand returned false");
				textarea$1.value = "";
				return;
			}
			deleteSelection();
		} catch (err) {
			console.error("Failed to cut:", err);
		} finally {
			textarea$1.value = "";
			const activeCanvas$1 = document.activeElement?.tagName === "CANVAS" ? document.activeElement : null;
			if (activeCanvas$1) setTimeout(() => {
				if (document.activeElement === activeCanvas$1) textarea$1.focus();
			}, 0);
		}
	}
	function focus() {
		textarea$1.focus();
	}
	function handlePaste(event) {
		event.preventDefault();
		event.stopPropagation();
		const text = event.clipboardData?.getData("text/plain") || "";
		if (text) {
			insertText(text);
			ensureCaretVisible?.();
		}
		textarea$1.value = "";
		const activeCanvas$1 = document.activeElement?.tagName === "CANVAS" ? document.activeElement : null;
		if (activeCanvas$1) setTimeout(() => {
			if (document.activeElement === activeCanvas$1) textarea$1.focus();
		}, 0);
	}
	function handleInput(event) {
		event.preventDefault();
		const text = textarea$1.value;
		if (text) {
			insertText(text);
			ensureCaretVisible?.();
		}
		textarea$1.value = "";
	}
	function handleKeyDown(event) {
		onKeyDown?.(event);
	}
	function handleKeyUp(event) {
		onKeyUp?.(event);
	}
	const handlers = {
		handlePaste,
		handleInput,
		handleKeyDown,
		handleKeyUp,
		focus
	};
	const activate = () => {
		setActiveClipboard(handlers, canvas?.el);
	};
	const deactivate = () => {
		setActiveClipboard(null, void 0);
	};
	const dispose = () => {
		deactivate();
	};
	return {
		copy,
		cut,
		focus,
		handlePaste,
		activate,
		deactivate,
		el: textarea$1,
		dispose
	};
}
function isDerivedError(error$1) {
	const desc = Object.getOwnPropertyDescriptor(error$1, "y");
	return desc != null && desc.get != null && desc.set == null;
}
function adjustError(error$1, adjust) {
	if (isDerivedError(error$1)) return error$1;
	const next = adjust([...error$1.x], error$1.y);
	return next ? {
		...error$1,
		x: next.x,
		y: next.y
	} : error$1;
}
function adjustWidgetsOnLineSplit(doc, line, column, delta) {
	const widgetLine = line + 1;
	const widgetColumn = column + 1;
	for (const widget of doc.widgets) if (widget.pos.y === widgetLine) {
		let shouldMove = false;
		if (widget.type === "above" || widget.type === "below" || widget.type === "overlay") {
			const [startColumn, endColumn] = widget.pos.x;
			if (startColumn >= widgetColumn) {
				shouldMove = true;
				widget.pos.x[0] = startColumn - column;
				widget.pos.x[1] = endColumn - column;
			} else if (endColumn >= widgetColumn) widget.pos.x[1] = widgetColumn;
		} else if (widget.type === "before" || widget.type === "after" || widget.type === "inlay") {
			const widgetCol = widget.pos.x;
			shouldMove = widgetCol >= widgetColumn;
			if (shouldMove) widget.pos.x = widgetCol - column;
		} else if (widget.type === "full") shouldMove = true;
		if (shouldMove) widget.pos.y += delta;
	} else if (widget.pos.y > widgetLine) widget.pos.y += delta;
	doc.errors = doc.errors.map((error$1) => adjustError(error$1, (x$4, y$5) => {
		if (y$5 === line + 1) {
			const [startColumn, endColumn] = [x$4[0] - 1, x$4[1] - 1];
			if (startColumn >= column) return {
				x: [startColumn - column + 1, endColumn - column + 1],
				y: y$5 + delta
			};
			if (endColumn >= column) return {
				x: [x$4[0], column + 1],
				y: y$5
			};
			return null;
		}
		if (y$5 > line + 1) return {
			x: x$4,
			y: y$5 + delta
		};
		return null;
	}));
}
function adjustWidgetsOnLineMerge(doc, line, prevLineLength) {
	const widgetLine = line + 1;
	for (const widget of doc.widgets) if (widget.pos.y === widgetLine) {
		if (widget.type === "above" || widget.type === "below" || widget.type === "overlay") {
			widget.pos.x[0] = widget.pos.x[0] + prevLineLength;
			widget.pos.x[1] = widget.pos.x[1] + prevLineLength;
		} else if (widget.type === "before" || widget.type === "after" || widget.type === "inlay") widget.pos.x = widget.pos.x + prevLineLength;
		widget.pos.y = line;
	} else if (widget.pos.y > widgetLine) widget.pos.y--;
	doc.errors = doc.errors.map((error$1) => adjustError(error$1, (x$4, y$5) => {
		if (y$5 === line + 1) return {
			x: [x$4[0] + prevLineLength, x$4[1] + prevLineLength],
			y: line
		};
		if (y$5 > line + 1) return {
			x: x$4,
			y: y$5 - 1
		};
		return null;
	}));
}
function adjustWidgetsOnNextLineMerge(doc, line, currentLineLength) {
	const widgetLine = line + 2;
	for (const widget of doc.widgets) if (widget.pos.y === widgetLine) {
		if (widget.type === "above" || widget.type === "below" || widget.type === "overlay") {
			widget.pos.x[0] = widget.pos.x[0] + currentLineLength;
			widget.pos.x[1] = widget.pos.x[1] + currentLineLength;
		} else if (widget.type === "before" || widget.type === "after" || widget.type === "inlay") widget.pos.x = widget.pos.x + currentLineLength;
		widget.pos.y = line + 1;
	} else if (widget.pos.y > widgetLine) widget.pos.y--;
	doc.errors = doc.errors.map((error$1) => adjustError(error$1, (x$4, y$5) => {
		if (y$5 === line + 2) return {
			x: [x$4[0] + currentLineLength, x$4[1] + currentLineLength],
			y: line + 1
		};
		if (y$5 > line + 2) return {
			x: x$4,
			y: y$5 - 1
		};
		return null;
	}));
}
function adjustWidgetsOnColumnInsert(doc, line, column, length, newLineLength) {
	const widgetLine = line + 1;
	const widgetColumn = column + 1;
	const newWidgetLineLength = newLineLength + 1;
	for (const widget of doc.widgets) if (widget.pos.y === widgetLine) {
		if (widget.type === "above" || widget.type === "below" || widget.type === "overlay") {
			const [startColumn, endColumn] = widget.pos.x;
			if (startColumn >= widgetColumn) {
				widget.pos.x[0] = startColumn + length;
				widget.pos.x[1] = Math.min(endColumn + length, newWidgetLineLength);
			} else if (widgetColumn > startColumn && widgetColumn < endColumn) {
				widget.pos.x[1] = Math.min(endColumn + length, newWidgetLineLength);
				if (widget.pos.x[1] < widget.pos.x[0]) widget.pos.x[1] = widget.pos.x[0];
			}
		} else if (widget.type === "before" || widget.type === "inlay") {
			if (widget.pos.x >= widgetColumn) widget.pos.x = Math.min(widget.pos.x + length, newWidgetLineLength);
		} else if (widget.type === "after") {
			if (widget.pos.x > widgetColumn) widget.pos.x = Math.min(widget.pos.x + length, newWidgetLineLength);
		}
	}
	doc.errors = doc.errors.map((error$1) => adjustError(error$1, (x$4, y$5) => {
		if (y$5 !== line + 1) return null;
		const [startColumn, endColumn] = [x$4[0] - 1, x$4[1] - 1];
		if (startColumn >= column) return {
			x: [startColumn + length + 1, Math.min(endColumn + length + 1, newLineLength)],
			y: y$5
		};
		if (endColumn >= column) {
			const end = Math.min(endColumn + length + 1, newLineLength);
			return {
				x: [x$4[0], Math.max(end, x$4[0])],
				y: y$5
			};
		}
		return null;
	}));
}
function adjustWidgetsOnLineDeleteRange(doc, startLine, endLine) {
	const deletedCount = endLine - startLine;
	const startWidgetLine = startLine + 1;
	const endWidgetLine = endLine + 1;
	const widgetsToRemove = [];
	for (const widget of doc.widgets) if (widget.pos.y > startWidgetLine && widget.pos.y <= endWidgetLine) widgetsToRemove.push(widget);
	else if (widget.pos.y > endWidgetLine) widget.pos.y -= deletedCount;
	for (const widget of widgetsToRemove) {
		const index = doc.widgets.indexOf(widget);
		if (index !== -1) doc.widgets.splice(index, 1);
	}
	doc.errors = doc.errors.flatMap((error$1) => {
		const y$5 = error$1.y;
		if (y$5 > startLine + 1 && y$5 <= endLine + 1) return [];
		if (y$5 > endLine + 1) return [adjustError(error$1, (x$4, y$6) => ({
			x: x$4,
			y: y$6 - deletedCount
		}))];
		return [error$1];
	});
}
function adjustWidgetsOnMultiLineDelete(doc, startLine, startColumn, endLine, endColumn, startLineLength) {
	if (endLine === startLine) {
		adjustWidgetsOnColumnDelete(doc, startLine, startColumn, endColumn - startColumn);
		return;
	}
	const deletedFromStartLine = startLineLength - startColumn;
	if (deletedFromStartLine > 0) adjustWidgetsOnColumnDelete(doc, startLine, startColumn, deletedFromStartLine);
	if (endColumn > 0) {
		const endWidgetLine = endLine + 1;
		const endWidgetColumn = endColumn + 1;
		const startWidgetLine = startLine + 1;
		const deletedCount = endLine - startLine;
		for (const widget of doc.widgets) if (widget.pos.y === endWidgetLine) {
			if (widget.type === "above" || widget.type === "below" || widget.type === "overlay") {
				const [startCol, endCol] = widget.pos.x;
				if (startCol >= endWidgetColumn) {
					widget.pos.x[0] = startCol - endColumn + startColumn;
					widget.pos.x[1] = endCol - endColumn + startColumn;
					widget.pos.y = startWidgetLine;
				} else if (endCol > endWidgetColumn) {
					widget.pos.x[0] = startColumn + 1;
					widget.pos.x[1] = endCol - endColumn + startColumn;
					widget.pos.y = startWidgetLine;
				}
			} else if (widget.type === "before" || widget.type === "after" || widget.type === "inlay") {
				if (widget.pos.x >= endWidgetColumn) {
					widget.pos.x = widget.pos.x - endColumn + startColumn;
					widget.pos.y = startWidgetLine;
				}
			} else if (widget.type === "full") widget.pos.y = startWidgetLine;
		} else if (widget.pos.y > endWidgetLine) widget.pos.y -= deletedCount;
		if (endLine > startLine + 1) adjustWidgetsOnLineDeleteRange(doc, startLine + 1, endLine - 1);
		doc.errors = doc.errors.map((error$1) => adjustError(error$1, (x$4, y$5) => {
			if (y$5 === endLine + 1) {
				const [errorStartCol, errorEndCol] = [x$4[0] - 1, x$4[1] - 1];
				if (errorStartCol >= endColumn) return {
					x: [errorStartCol - endColumn + startColumn + 1, errorEndCol - endColumn + startColumn + 1],
					y: startLine + 1
				};
				if (errorEndCol > endColumn) return {
					x: [startColumn + 1, errorEndCol - endColumn + startColumn + 1],
					y: startLine + 1
				};
				return null;
			}
			if (y$5 > endLine + 1) return {
				x: x$4,
				y: y$5 - deletedCount
			};
			return null;
		}));
	} else adjustWidgetsOnLineDeleteRange(doc, startLine + 1, endLine);
}
function adjustWidgetsOnColumnDelete(doc, line, column, length) {
	const widgetLine = line + 1;
	const widgetColumn = column + 1;
	for (const widget of doc.widgets) if (widget.pos.y === widgetLine) {
		if (widget.type === "above" || widget.type === "below" || widget.type === "overlay") {
			const [startColumn, endColumn] = widget.pos.x;
			if (startColumn >= widgetColumn + length) {
				widget.pos.x[0] = startColumn - length;
				widget.pos.x[1] = endColumn - length;
			} else if (startColumn >= widgetColumn) {
				widget.pos.x[0] = widgetColumn;
				if (endColumn >= widgetColumn + length) widget.pos.x[1] = endColumn - length;
				else widget.pos.x[1] = widgetColumn;
			} else if (endColumn >= widgetColumn + length) widget.pos.x[1] = endColumn - length;
			else if (endColumn > widgetColumn) widget.pos.x[1] = widgetColumn;
		} else if (widget.type === "before" || widget.type === "after" || widget.type === "inlay") {
			if (widget.pos.x >= widgetColumn + length) widget.pos.x -= length;
			else if (widget.pos.x >= widgetColumn) widget.pos.x = widgetColumn;
		}
	}
	const col1 = column + 1;
	doc.errors = doc.errors.map((error$1) => adjustError(error$1, (x$4, y$5) => {
		if (y$5 !== line + 1) return null;
		const [startColumn, endColumn] = [x$4[0] - 1, x$4[1] - 1];
		if (startColumn >= column + length) return {
			x: [startColumn - length + 1, endColumn - length + 1],
			y: y$5
		};
		if (startColumn >= column) return {
			x: [col1, endColumn >= column + length ? endColumn - length + 1 : col1],
			y: y$5
		};
		if (endColumn >= column + length) return {
			x: [x$4[0], endColumn - length + 1],
			y: y$5
		};
		if (endColumn > column) return {
			x: [x$4[0], col1],
			y: y$5
		};
		return null;
	}));
}
function createKeyboard(doc, canvas, scroll, lines, metrics, settings$1, caret, caches, selection, blocks, header, mouse, clearPinnedError, activeEditorOpts) {
	const shiftKey = c$3(false);
	const ctrlKey = c$3(false);
	const metaKey = c$3(false);
	const altKey = c$3(false);
	function insertText(text) {
		if (selection.hasSelection.value) {
			const ordered = selection.getOrdered.value;
			if (ordered) {
				const startLine = ordered.start.line;
				const endLine = ordered.end.line;
				const startColumn = ordered.start.column;
				const endColumn = ordered.end.column;
				const selectionDirection = selection.direction.value;
				const linesBeforeReplace = doc.lines.length;
				const deletedLineCount = endLine > startLine ? endLine - startLine : 0;
				const selectionDir = selectionDirection === "forward" || selectionDirection === "backward" ? selectionDirection : void 0;
				const selectionObj = selectionDir && ordered ? {
					start: {
						line: startLine,
						column: startColumn
					},
					end: {
						line: endLine,
						column: endColumn
					},
					direction: selectionDir
				} : void 0;
				doc.buffer.replaceSelection({
					line: startLine,
					column: startColumn
				}, {
					line: endLine,
					column: endColumn
				}, text, selectionObj);
				const linesAfterReplace = doc.lines.length;
				const newlineCount$1 = (text.match(/\n/g) || []).length;
				const insertedLineCount = newlineCount$1 > 0 ? newlineCount$1 : 0;
				linesAfterReplace - linesBeforeReplace;
				if (deletedLineCount > 0) {
					caches.adjustWrapTokensCacheOnLineDeleteRange(startLine + 1, endLine);
					blocks.adjustOnLineDeleteRange(startLine + 1, endLine);
				}
				if (insertedLineCount > 0) {
					const insertStartLine = startLine + 1;
					const insertEndLine = startLine + insertedLineCount;
					caches.adjustWrapTokensCacheOnLineInsertRange(insertStartLine, insertEndLine);
					blocks.adjustOnLineInsertRange(insertStartLine, insertEndLine);
				} else if (deletedLineCount === 0) caches.invalidateWrapTokensCacheForLine(startLine);
				if (newlineCount$1 > 0) {
					const lastNewlineIndex = text.lastIndexOf("\n");
					caret.line.value = startLine + newlineCount$1;
					caret.column.value = lastNewlineIndex >= 0 ? text.length - lastNewlineIndex - 1 : startColumn + text.length;
				} else {
					caret.line.value = startLine;
					caret.column.value = startColumn + text.length;
				}
				caret.columnIntent.value = caret.column.value;
				selection.clear();
				return;
			}
		}
		const newlineCount = (text.match(/\n/g) || []).length;
		if (newlineCount > 0) {
			const insertLine = caret.line.value;
			const insertColumn = caret.column.value;
			const linesBeforeInsert = doc.lines.length;
			adjustWidgetsOnLineSplit(doc, insertLine, insertColumn, newlineCount);
			caches.invalidateWrapTokensCacheForLine(insertLine);
			for (const [lineNum] of caches.wrapTokensCacheByLine.entries()) if (lineNum > insertLine) caches.invalidateWrapTokensCacheForLine(lineNum);
			doc.buffer.insert(insertLine, insertColumn, text);
			const insertedLineCount = doc.lines.length - linesBeforeInsert;
			if (insertedLineCount > 0) blocks.adjustOnLineInsertRange(insertLine + 1, insertLine + insertedLineCount);
			const lastNewlineIndex = text.lastIndexOf("\n");
			if (lastNewlineIndex >= 0) {
				caret.line.value = insertLine + newlineCount;
				caret.column.value = text.length - lastNewlineIndex - 1;
			} else {
				caret.line.value++;
				caret.column.value = 0;
			}
		} else {
			const currentLine = doc.lines[caret.line.value] || "";
			const newLine = currentLine.slice(0, caret.column.value) + text + currentLine.slice(caret.column.value);
			adjustWidgetsOnColumnInsert(doc, caret.line.value, caret.column.value, text.length, newLine.length);
			caches.invalidateWrapTokensCacheForLine(caret.line.value);
			doc.buffer.insert(caret.line.value, caret.column.value, text);
			caret.column.value += text.length;
		}
		caret.columnIntent.value = caret.column.value;
		caret.isTyping.value = true;
		caret.lastInputTime.value = Date.now();
	}
	function deleteSelection() {
		const ordered = selection.getOrdered.value;
		if (!ordered) return false;
		const startLine = ordered.start.line;
		const endLine = ordered.end.line;
		const startColumn = ordered.start.column;
		const endColumn = ordered.end.column;
		const selectionDirection = selection.direction.value;
		const selectionDir = selectionDirection === "forward" || selectionDirection === "backward" ? selectionDirection : void 0;
		const selectionObj = selectionDir ? {
			start: {
				line: startLine,
				column: startColumn
			},
			end: {
				line: endLine,
				column: endColumn
			},
			direction: selectionDir
		} : void 0;
		adjustWidgetsOnMultiLineDelete(doc, startLine, startColumn, endLine, endColumn, doc.lines[startLine]?.length ?? 0);
		doc.buffer.deleteSelection({
			line: startLine,
			column: startColumn
		}, {
			line: endLine,
			column: endColumn
		}, selectionObj);
		if (endLine > startLine) {
			caches.adjustWrapTokensCacheOnLineDeleteRange(startLine + 1, endLine);
			blocks.adjustOnLineDeleteRange(startLine + 1, endLine);
		} else caches.invalidateWrapTokensCacheForLine(startLine);
		caret.line.value = startLine;
		caret.column.value = startColumn;
		caret.columnIntent.value = caret.column.value;
		selection.clear();
		return true;
	}
	function deleteLine() {
		if (selection.hasSelection.value) {
			deleteSelection();
			return;
		}
		const codeLines = doc.lines;
		const currentLineNum = caret.line.value;
		const currentColumn = caret.column.value;
		const currentLine = codeLines[currentLineNum] || "";
		const caretPositionBefore = {
			line: currentLineNum,
			column: currentColumn
		};
		if (codeLines.length === 1) {
			adjustWidgetsOnColumnDelete(doc, currentLineNum, 0, currentLine.length);
			caches.invalidateWrapTokensCacheForLine(currentLineNum);
			const caretPositionAfter = {
				line: currentLineNum,
				column: 0
			};
			doc.buffer.replaceSelection({
				line: currentLineNum,
				column: 0
			}, {
				line: currentLineNum,
				column: currentLine.length
			}, "", void 0, caretPositionBefore, void 0, caretPositionAfter);
			caret.column.value = 0;
		} else if (currentLineNum < codeLines.length - 1) {
			const nextLineLength = (codeLines[currentLineNum + 1] || "").length;
			const preservedColumn = Math.min(currentColumn, nextLineLength);
			adjustWidgetsOnNextLineMerge(doc, currentLineNum, currentLine.length);
			caches.invalidateWrapTokensCacheForLine(currentLineNum);
			const caretPositionAfter = {
				line: currentLineNum,
				column: preservedColumn
			};
			doc.buffer.replaceSelection({
				line: currentLineNum,
				column: 0
			}, {
				line: currentLineNum + 1,
				column: 0
			}, "", void 0, caretPositionBefore, void 0, caretPositionAfter);
			caches.adjustWrapTokensCacheOnLineDelete(currentLineNum + 1);
			blocks.adjustOnLineDelete(currentLineNum + 1);
			caret.column.value = preservedColumn;
		} else {
			const prevLineNum = currentLineNum - 1;
			const prevLineLength = (codeLines[prevLineNum] || "").length;
			const preservedColumn = Math.min(currentColumn, prevLineLength);
			adjustWidgetsOnLineMerge(doc, currentLineNum, prevLineLength);
			caches.invalidateWrapTokensCacheForLine(prevLineNum);
			const caretPositionAfter = {
				line: prevLineNum,
				column: preservedColumn
			};
			doc.buffer.replaceSelection({
				line: currentLineNum,
				column: 0
			}, {
				line: currentLineNum,
				column: currentLine.length
			}, "", void 0, caretPositionBefore, void 0, caretPositionAfter);
			caches.adjustWrapTokensCacheOnLineDelete(currentLineNum);
			blocks.adjustOnLineDelete(currentLineNum);
			caret.line.value = prevLineNum;
			caret.column.value = preservedColumn;
		}
		caret.columnIntent.value = caret.column.value;
		caret.lastInputTime.value = Date.now();
	}
	function deleteChar() {
		if (selection.hasSelection.value) {
			deleteSelection();
			return;
		}
		const codeLines = doc.lines;
		const currentLine = codeLines[caret.line.value] || "";
		if (caret.column.value < currentLine.length) {
			adjustWidgetsOnColumnDelete(doc, caret.line.value, caret.column.value, 1);
			caches.invalidateWrapTokensCacheForLine(caret.line.value);
			doc.buffer.del(caret.line.value, caret.column.value);
		} else if (caret.line.value < codeLines.length - 1) {
			adjustWidgetsOnNextLineMerge(doc, caret.line.value, currentLine.length);
			caches.invalidateWrapTokensCacheForLine(caret.line.value);
			doc.buffer.del(caret.line.value, caret.column.value);
			caches.adjustWrapTokensCacheOnLineDelete(caret.line.value + 1);
			blocks.adjustOnLineDelete(caret.line.value + 1);
		}
		caret.columnIntent.value = caret.column.value;
		caret.lastInputTime.value = Date.now();
	}
	function backspace() {
		if (selection.hasSelection.value) {
			deleteSelection();
			return;
		}
		const codeLines = doc.lines;
		const currentLine = codeLines[caret.line.value] || "";
		if (caret.column.value > 0) if (caret.column.value % 2 === 0 && caret.column.value >= 2 && currentLine[caret.column.value - 2] === " " && currentLine[caret.column.value - 1] === " ") {
			adjustWidgetsOnColumnDelete(doc, caret.line.value, caret.column.value - 2, 2);
			caches.invalidateWrapTokensCacheForLine(caret.line.value);
			doc.buffer.replaceSelection({
				line: caret.line.value,
				column: caret.column.value - 2
			}, {
				line: caret.line.value,
				column: caret.column.value
			}, "");
			caret.column.value -= 2;
		} else {
			const charBefore = currentLine[caret.column.value - 1];
			const bracePairs = {
				"{": "}",
				"[": "]",
				"(": ")"
			};
			const stringDelimiters = new Set([
				"'",
				"\"",
				"`"
			]);
			const matchingClose = charBefore && bracePairs[charBefore] ? bracePairs[charBefore] : null;
			const isStringDelimiter = charBefore && stringDelimiters.has(charBefore);
			if (matchingClose && caret.column.value < currentLine.length && currentLine[caret.column.value] === matchingClose || isStringDelimiter && caret.column.value < currentLine.length && currentLine[caret.column.value] === charBefore) {
				const caretPositionBefore = {
					line: caret.line.value,
					column: caret.column.value
				};
				const caretPositionAfter = {
					line: caret.line.value,
					column: caret.column.value - 1
				};
				adjustWidgetsOnColumnDelete(doc, caret.line.value, caret.column.value - 1, 2);
				caches.invalidateWrapTokensCacheForLine(caret.line.value);
				doc.buffer.replaceSelection({
					line: caret.line.value,
					column: caret.column.value - 1
				}, {
					line: caret.line.value,
					column: caret.column.value + 1
				}, "", void 0, caretPositionBefore, void 0, caretPositionAfter);
				caret.column.value--;
			} else {
				adjustWidgetsOnColumnDelete(doc, caret.line.value, caret.column.value - 1, 1);
				caches.invalidateWrapTokensCacheForLine(caret.line.value);
				doc.buffer.backspace(caret.line.value, caret.column.value);
				caret.column.value--;
			}
		}
		else if (caret.line.value > 0) {
			const prevLine = codeLines[caret.line.value - 1] || "";
			const newColumn = prevLine.length;
			adjustWidgetsOnLineMerge(doc, caret.line.value, prevLine.length);
			caches.invalidateWrapTokensCacheForLine(caret.line.value - 1);
			doc.buffer.backspace(caret.line.value, caret.column.value);
			caches.adjustWrapTokensCacheOnLineDelete(caret.line.value);
			blocks.adjustOnLineDelete(caret.line.value);
			caret.line.value--;
			caret.column.value = newColumn;
		}
		caret.columnIntent.value = caret.column.value;
		caret.lastInputTime.value = Date.now();
	}
	function findWordStart(line, column) {
		const codeLines = doc.lines;
		const currentLine = codeLines[line] || "";
		const currentColumn = column;
		if (currentColumn > 0) {
			let newColumn = currentColumn - 1;
			if (newColumn >= 0) {
				const char = currentLine[newColumn];
				const isWordChar$1 = /[a-zA-Z0-9_]/.test(char);
				const isPunct = /[^\s\w]/.test(char);
				if (isWordChar$1) while (newColumn > 0 && /[a-zA-Z0-9_]/.test(currentLine[newColumn - 1])) newColumn--;
				else if (isPunct) while (newColumn > 0 && /[^\s\w]/.test(currentLine[newColumn - 1])) newColumn--;
				else while (newColumn > 0 && /\s/.test(currentLine[newColumn - 1])) newColumn--;
			}
			return {
				line,
				column: newColumn
			};
		} else if (line > 0) {
			const prevLine = codeLines[line - 1] || "";
			return {
				line: line - 1,
				column: prevLine.length
			};
		}
		return {
			line,
			column: 0
		};
	}
	function findWordEnd(line, column) {
		const codeLines = doc.lines;
		const currentLine = codeLines[line] || "";
		const currentLineLength = currentLine.length;
		const currentColumn = column;
		if (currentColumn < currentLineLength) {
			let newColumn = currentColumn;
			if (newColumn < currentLineLength) {
				const char = currentLine[newColumn];
				const isWordChar$1 = /[a-zA-Z0-9_]/.test(char);
				const isPunct = /[^\s\w]/.test(char);
				if (isWordChar$1) while (newColumn < currentLineLength && /[a-zA-Z0-9_]/.test(currentLine[newColumn])) newColumn++;
				else if (isPunct) while (newColumn < currentLineLength && /[^\s\w]/.test(currentLine[newColumn])) newColumn++;
				else while (newColumn < currentLineLength && /\s/.test(currentLine[newColumn])) newColumn++;
			}
			return {
				line,
				column: newColumn
			};
		} else if (line < codeLines.length - 1) return {
			line: line + 1,
			column: 0
		};
		return {
			line,
			column: currentLineLength
		};
	}
	function deleteWordLeft() {
		if (selection.hasSelection.value) {
			deleteSelection();
			return;
		}
		doc.lines;
		const currentLine = caret.line.value;
		const currentColumn = caret.column.value;
		const wordStart = findWordStart(currentLine, currentColumn);
		const startLine = wordStart.line;
		const startColumn = wordStart.column;
		const endLine = currentLine;
		const endColumn = currentColumn;
		if (startLine === endLine && startColumn === endColumn) return;
		adjustWidgetsOnMultiLineDelete(doc, startLine, startColumn, endLine, endColumn, doc.lines[startLine]?.length ?? 0);
		if (startLine === endLine) caches.invalidateWrapTokensCacheForLine(startLine);
		else {
			caches.invalidateWrapTokensCacheForLine(startLine);
			if (endLine > startLine) {
				caches.adjustWrapTokensCacheOnLineDeleteRange(startLine + 1, endLine);
				blocks.adjustOnLineDeleteRange(startLine + 1, endLine);
			}
		}
		doc.buffer.deleteSelection({
			line: startLine,
			column: startColumn
		}, {
			line: endLine,
			column: endColumn
		}, void 0, true, {
			line: endLine,
			column: endColumn
		});
		caret.line.value = startLine;
		caret.column.value = startColumn;
		caret.columnIntent.value = startColumn;
		caret.lastInputTime.value = Date.now();
	}
	function deleteWordRight() {
		if (selection.hasSelection.value) {
			deleteSelection();
			return;
		}
		doc.lines;
		const currentLine = caret.line.value;
		const currentColumn = caret.column.value;
		const wordEnd = findWordEnd(currentLine, currentColumn);
		const startLine = currentLine;
		const startColumn = currentColumn;
		const endLine = wordEnd.line;
		const endColumn = wordEnd.column;
		if (startLine === endLine && startColumn === endColumn) return;
		adjustWidgetsOnMultiLineDelete(doc, startLine, startColumn, endLine, endColumn, doc.lines[startLine]?.length ?? 0);
		if (startLine === endLine) caches.invalidateWrapTokensCacheForLine(startLine);
		else {
			caches.invalidateWrapTokensCacheForLine(startLine);
			if (endLine > startLine) {
				caches.adjustWrapTokensCacheOnLineDeleteRange(startLine + 1, endLine);
				blocks.adjustOnLineDeleteRange(startLine + 1, endLine);
			}
		}
		doc.buffer.deleteSelection({
			line: startLine,
			column: startColumn
		}, {
			line: endLine,
			column: endColumn
		}, void 0, true, {
			line: startLine,
			column: startColumn
		});
		caret.columnIntent.value = caret.column.value;
		caret.lastInputTime.value = Date.now();
	}
	function moveLeft(shift) {
		const originalLine = caret.line.value;
		const originalColumn = caret.column.value;
		if (shift) {
			if (!selection.hasSelection.value) selection.setStart(originalLine, originalColumn);
		} else selection.clear();
		if (caret.column.value > 0) caret.column.value--;
		else if (caret.line.value > 0) {
			caret.line.value--;
			const codeLines = doc.lines;
			caret.column.value = codeLines[caret.line.value]?.length || 0;
		}
		caret.columnIntent.value = caret.column.value;
		if (shift) selection.setEnd(caret.line.value, caret.column.value);
	}
	function moveRight(shift) {
		const originalLine = caret.line.value;
		const originalColumn = caret.column.value;
		if (shift) {
			if (!selection.hasSelection.value) selection.setStart(originalLine, originalColumn);
		} else selection.clear();
		const codeLines = doc.lines;
		const currentLineLength = codeLines[caret.line.value]?.length || 0;
		if (caret.column.value < currentLineLength) caret.column.value++;
		else if (caret.line.value < codeLines.length - 1) {
			caret.line.value++;
			caret.column.value = 0;
		}
		caret.columnIntent.value = caret.column.value;
		if (shift) selection.setEnd(caret.line.value, caret.column.value);
	}
	function moveWordLeft(shift) {
		const originalLine = caret.line.value;
		const originalColumn = caret.column.value;
		if (shift) {
			if (!selection.hasSelection.value) selection.setStart(originalLine, originalColumn);
		} else selection.clear();
		const codeLines = doc.lines;
		const currentLine = codeLines[caret.line.value] || "";
		const currentColumn = caret.column.value;
		if (currentColumn > 0) {
			let newColumn = currentColumn - 1;
			if (newColumn >= 0) {
				const char = currentLine[newColumn];
				const isWordChar$1 = /[a-zA-Z0-9_]/.test(char);
				const isPunct = /[^\s\w]/.test(char);
				if (isWordChar$1) while (newColumn > 0 && /[a-zA-Z0-9_]/.test(currentLine[newColumn - 1])) newColumn--;
				else if (isPunct) while (newColumn > 0 && /[^\s\w]/.test(currentLine[newColumn - 1])) newColumn--;
				else while (newColumn > 0 && /\s/.test(currentLine[newColumn - 1])) newColumn--;
			}
			caret.column.value = newColumn;
		} else if (caret.line.value > 0) {
			caret.line.value--;
			const prevLine = codeLines[caret.line.value] || "";
			caret.column.value = prevLine.length;
		}
		caret.columnIntent.value = caret.column.value;
		if (shift) selection.setEnd(caret.line.value, caret.column.value);
	}
	function moveWordRight(shift) {
		const originalLine = caret.line.value;
		const originalColumn = caret.column.value;
		if (shift) {
			if (!selection.hasSelection.value) selection.setStart(originalLine, originalColumn);
		} else selection.clear();
		const codeLines = doc.lines;
		const currentLine = codeLines[caret.line.value] || "";
		const currentLineLength = currentLine.length;
		const currentColumn = caret.column.value;
		if (currentColumn < currentLineLength) {
			let newColumn = currentColumn;
			if (newColumn < currentLineLength) {
				const char = currentLine[newColumn];
				const isWordChar$1 = /[a-zA-Z0-9_]/.test(char);
				const isPunct = /[^\s\w]/.test(char);
				if (isWordChar$1) while (newColumn < currentLineLength && /[a-zA-Z0-9_]/.test(currentLine[newColumn])) newColumn++;
				else if (isPunct) while (newColumn < currentLineLength && /[^\s\w]/.test(currentLine[newColumn])) newColumn++;
				else while (newColumn < currentLineLength && /\s/.test(currentLine[newColumn])) newColumn++;
			}
			caret.column.value = newColumn;
		} else if (caret.line.value < codeLines.length - 1) {
			caret.line.value++;
			caret.column.value = 0;
		}
		caret.columnIntent.value = caret.column.value;
		if (shift) selection.setEnd(caret.line.value, caret.column.value);
	}
	function getVisualLineColumnRange(visualLine, tokenLines, visualLines) {
		const logicalLineTokens = tokenLines[visualLine.logicalLine] || [];
		let lineStartColumn = 0;
		for (let i$6 = 0; i$6 < visualLine.tokenOffset; i$6++) lineStartColumn += logicalLineTokens[i$6]?.text.length || 0;
		let lineEndColumn = lineStartColumn;
		for (const visualToken of visualLine.tokens) lineEndColumn += visualToken.token.text.length;
		return [lineStartColumn, lineEndColumn];
	}
	function moveUp(shift) {
		const originalLine = caret.line.value;
		const originalColumn = caret.column.value;
		if (shift) {
			if (!selection.hasSelection.value) selection.setStart(originalLine, originalColumn);
		} else selection.clear();
		const tokenLines = doc.tokenLines;
		const codeLines = doc.lines;
		const intendedColumn = caret.columnIntent.value;
		const visualLines = lines.visualLines.value;
		if (visualLines.length === 0) return;
		const sourceVisualLine = findVisualLineForColumn(lines, caret.line.value, caret.column.value, tokenLines, caches);
		if (!sourceVisualLine) return;
		const sourceIndex = visualLines.indexOf(sourceVisualLine);
		if (sourceIndex <= 0) return;
		const targetVisualLine = visualLines[sourceIndex - 1];
		const [targetStartColumn, targetEndColumn] = getVisualLineColumnRange(targetVisualLine, tokenLines, visualLines);
		let targetColumn;
		if (intendedColumn >= targetStartColumn && intendedColumn <= targetEndColumn) targetColumn = intendedColumn;
		else targetColumn = getColumnFromVisualPosition(lines, targetVisualLine, getXFromColumn(lines, sourceVisualLine, intendedColumn, tokenLines, canvas, settings$1, caches), tokenLines, codeLines, canvas, settings$1, caches);
		const targetLineLength = codeLines[targetVisualLine.logicalLine]?.length ?? 0;
		if (targetColumn > targetLineLength) targetColumn = targetLineLength;
		caret.line.value = targetVisualLine.logicalLine;
		caret.column.value = targetColumn;
		if (shift) selection.setEnd(caret.line.value, caret.column.value);
	}
	function moveDown(shift) {
		const originalLine = caret.line.value;
		const originalColumn = caret.column.value;
		if (shift) {
			if (!selection.hasSelection.value) selection.setStart(originalLine, originalColumn);
		} else selection.clear();
		const tokenLines = doc.tokenLines;
		const codeLines = doc.lines;
		const intendedColumn = caret.columnIntent.value;
		const visualLines = lines.visualLines.value;
		if (visualLines.length === 0) return;
		const sourceVisualLine = findVisualLineForColumn(lines, caret.line.value, caret.column.value, tokenLines, caches);
		if (!sourceVisualLine) return;
		const sourceIndex = visualLines.indexOf(sourceVisualLine);
		if (sourceIndex < 0 || sourceIndex >= visualLines.length - 1) return;
		const targetVisualLine = visualLines[sourceIndex + 1];
		const [targetStartColumn, targetEndColumn] = getVisualLineColumnRange(targetVisualLine, tokenLines, visualLines);
		let targetColumn;
		if (intendedColumn >= targetStartColumn && intendedColumn <= targetEndColumn) targetColumn = intendedColumn;
		else targetColumn = getColumnFromVisualPosition(lines, targetVisualLine, getXFromColumn(lines, sourceVisualLine, intendedColumn, tokenLines, canvas, settings$1, caches), tokenLines, codeLines, canvas, settings$1, caches);
		const targetLineLength = codeLines[targetVisualLine.logicalLine]?.length ?? 0;
		if (targetColumn > targetLineLength) targetColumn = targetLineLength;
		caret.line.value = targetVisualLine.logicalLine;
		caret.column.value = targetColumn;
		if (shift) selection.setEnd(caret.line.value, caret.column.value);
	}
	function moveHome(shift) {
		const originalLine = caret.line.value;
		const originalColumn = caret.column.value;
		if (shift) {
			if (!selection.hasSelection.value) selection.setStart(originalLine, originalColumn);
		} else selection.clear();
		const codeLines = doc.lines;
		const currentLine = caret.line.value;
		const currentColumn = caret.column.value;
		const textStartIndex = (codeLines[currentLine] || "").search(/\S/);
		const textStartColumn = textStartIndex >= 0 ? textStartIndex : 0;
		let targetColumn;
		if (currentColumn === 0) targetColumn = textStartColumn;
		else if (currentColumn === textStartColumn) targetColumn = 0;
		else targetColumn = textStartColumn;
		caret.column.value = targetColumn;
		caret.columnIntent.value = targetColumn;
		if (shift) selection.setEnd(caret.line.value, caret.column.value);
	}
	function moveEnd(shift) {
		const originalLine = caret.line.value;
		const originalColumn = caret.column.value;
		if (shift) {
			if (!selection.hasSelection.value) selection.setStart(originalLine, originalColumn);
		} else selection.clear();
		const codeLines = doc.lines;
		const visualLines = lines.visualLines.value;
		const tokenLines = doc.tokenLines;
		const currentLine = caret.line.value;
		const currentColumn = caret.column.value;
		const currentVisualLine = findVisualLineForColumn(lines, currentLine, currentColumn, tokenLines, caches);
		if (currentVisualLine) {
			const [, endColumn] = getVisualLineColumnRange(currentVisualLine, tokenLines, visualLines);
			if (currentColumn === endColumn) caret.column.value = codeLines[currentLine]?.length || 0;
			else caret.column.value = endColumn;
		} else caret.column.value = codeLines[currentLine]?.length || 0;
		caret.columnIntent.value = caret.column.value;
		if (shift) selection.setEnd(caret.line.value, caret.column.value);
	}
	function movePageUp(shift) {
		const originalLine = caret.line.value;
		const originalColumn = caret.column.value;
		if (shift) {
			if (!selection.hasSelection.value) selection.setStart(originalLine, originalColumn);
		} else selection.clear();
		const tokenLines = doc.tokenLines;
		const codeLines = doc.lines;
		const currentLine = caret.line.value;
		const currentColumn = caret.column.value;
		const intendedColumn = caret.columnIntent.value;
		const currentVisualLine = findVisualLineForColumn(lines, currentLine, currentColumn, tokenLines, caches);
		if (!currentVisualLine) {
			if (caret.line.value > 0) {
				caret.line.value = 0;
				const firstLineLength = codeLines[0]?.length || 0;
				caret.column.value = Math.min(intendedColumn, firstLineLength);
			}
			if (shift) selection.setEnd(caret.line.value, caret.column.value);
			return;
		}
		const visualLines = lines.visualLines.value;
		const currentVisualLineIndex = visualLines.findIndex((line) => line === currentVisualLine);
		if (currentVisualLineIndex < 0) {
			if (shift) selection.setEnd(caret.line.value, caret.column.value);
			return;
		}
		const headerHeight = header.value?.height ?? 0;
		const needsVertical = lines.totalHeight.value > canvas.size.height.value - headerHeight - settings$1.paddingTop - settings$1.paddingBottom;
		const availableWidth = canvas.size.width.value - settings$1.paddingLeft - metrics.gutterWidth.value - (needsVertical ? 12 : 0);
		const needsHorizontal = !settings$1.wordWrap && lines.totalWidth.value > availableWidth;
		const availableHeight = canvas.size.height.value - headerHeight - settings$1.paddingTop - settings$1.paddingBottom - (needsHorizontal ? 3 : 0);
		const viewportHeight = Math.max(1, Math.floor(availableHeight / settings$1.lineHeight));
		const targetVisualLineIndex = Math.max(0, currentVisualLineIndex - viewportHeight);
		if (targetVisualLineIndex === 0 && currentVisualLineIndex < viewportHeight) if (caret.line.value === 0) caret.column.value = 0;
		else {
			const firstLineLength = codeLines[0]?.length || 0;
			caret.line.value = 0;
			caret.column.value = Math.min(intendedColumn, firstLineLength);
		}
		else if (targetVisualLineIndex < visualLines.length) {
			const targetVisualLine = visualLines[targetVisualLineIndex];
			const [targetStartColumn, targetEndColumn] = getVisualLineColumnRange(targetVisualLine, tokenLines, visualLines);
			if (intendedColumn >= targetStartColumn && intendedColumn <= targetEndColumn) {
				caret.line.value = targetVisualLine.logicalLine;
				caret.column.value = intendedColumn;
			} else {
				const targetColumn = getColumnFromVisualPosition(lines, targetVisualLine, getXFromColumn(lines, currentVisualLine, currentColumn, tokenLines, canvas, settings$1, caches), tokenLines, codeLines, canvas, settings$1, caches);
				caret.line.value = targetVisualLine.logicalLine;
				caret.column.value = targetColumn;
			}
		} else if (caret.line.value > 0) {
			caret.line.value = 0;
			const firstLineLength = codeLines[0]?.length || 0;
			caret.column.value = Math.min(intendedColumn, firstLineLength);
		}
		if (shift) selection.setEnd(caret.line.value, caret.column.value);
	}
	function movePageDown(shift) {
		const originalLine = caret.line.value;
		const originalColumn = caret.column.value;
		if (shift) {
			if (!selection.hasSelection.value) selection.setStart(originalLine, originalColumn);
		} else selection.clear();
		const tokenLines = doc.tokenLines;
		const codeLines = doc.lines;
		const currentLine = caret.line.value;
		const currentColumn = caret.column.value;
		const intendedColumn = caret.columnIntent.value;
		const currentVisualLine = findVisualLineForColumn(lines, currentLine, currentColumn, tokenLines, caches);
		if (!currentVisualLine) {
			if (caret.line.value < codeLines.length - 1) {
				caret.line.value = codeLines.length - 1;
				const lastLineLength = codeLines[codeLines.length - 1]?.length || 0;
				caret.column.value = Math.min(intendedColumn, lastLineLength);
			}
			if (shift) selection.setEnd(caret.line.value, caret.column.value);
			return;
		}
		const visualLines = lines.visualLines.value;
		const currentVisualLineIndex = visualLines.findIndex((line) => line === currentVisualLine);
		if (currentVisualLineIndex < 0) {
			if (shift) selection.setEnd(caret.line.value, caret.column.value);
			return;
		}
		const headerHeight = header.value?.height ?? 0;
		const needsVertical = lines.totalHeight.value > canvas.size.height.value - headerHeight - settings$1.paddingTop - settings$1.paddingBottom;
		const availableWidth = canvas.size.width.value - settings$1.paddingLeft - metrics.gutterWidth.value - (needsVertical ? 12 : 0);
		const needsHorizontal = lines.totalWidth.value > availableWidth;
		const availableHeight = canvas.size.height.value - headerHeight - settings$1.paddingTop - settings$1.paddingBottom - (needsHorizontal ? 3 : 0);
		const viewportHeight = Math.max(1, Math.floor(availableHeight / settings$1.lineHeight));
		const lastVisualLineIndex = visualLines.length - 1;
		const targetVisualLineIndex = Math.min(lastVisualLineIndex, currentVisualLineIndex + viewportHeight);
		if (targetVisualLineIndex === lastVisualLineIndex && currentVisualLineIndex + viewportHeight > lastVisualLineIndex) {
			const lastLineIndex = codeLines.length - 1;
			if (caret.line.value === lastLineIndex) {
				const lastLineLength = codeLines[lastLineIndex]?.length || 0;
				caret.column.value = lastLineLength;
			} else {
				const lastLineLength = codeLines[lastLineIndex]?.length || 0;
				caret.line.value = lastLineIndex;
				caret.column.value = Math.min(intendedColumn, lastLineLength);
			}
		} else if (targetVisualLineIndex >= 0 && targetVisualLineIndex < visualLines.length) {
			const targetVisualLine = visualLines[targetVisualLineIndex];
			const [targetStartColumn, targetEndColumn] = getVisualLineColumnRange(targetVisualLine, tokenLines, visualLines);
			if (intendedColumn >= targetStartColumn && intendedColumn <= targetEndColumn) {
				caret.line.value = targetVisualLine.logicalLine;
				caret.column.value = intendedColumn;
			} else {
				const targetColumn = getColumnFromVisualPosition(lines, targetVisualLine, getXFromColumn(lines, currentVisualLine, currentColumn, tokenLines, canvas, settings$1, caches), tokenLines, codeLines, canvas, settings$1, caches);
				caret.line.value = targetVisualLine.logicalLine;
				caret.column.value = targetColumn;
			}
		} else if (caret.line.value < codeLines.length - 1) {
			caret.line.value = codeLines.length - 1;
			const lastLineLength = codeLines[codeLines.length - 1]?.length || 0;
			caret.column.value = Math.min(intendedColumn, lastLineLength);
		}
		if (shift) selection.setEnd(caret.line.value, caret.column.value);
	}
	function moveLineUp() {
		const codeLines = doc.lines;
		let startLine;
		let endLine;
		const caretPositionBefore = {
			line: caret.line.value,
			column: caret.column.value
		};
		const hadSelection = selection.hasSelection.value;
		if (hadSelection) {
			const ordered = selection.getOrdered.value;
			if (!ordered) return;
			startLine = ordered.start.line;
			endLine = ordered.end.line;
		} else {
			startLine = caret.line.value;
			endLine = caret.line.value;
		}
		if (startLine === 0) return;
		const linesToMove = endLine - startLine + 1;
		const targetLine = startLine - 1;
		const linesText = [];
		for (let i$6 = startLine; i$6 <= endLine; i$6++) linesText.push(codeLines[i$6] || "");
		const movedText = linesText.join("\n");
		const targetText = codeLines[targetLine] || "";
		const newText = movedText + "\n" + targetText;
		caches.adjustWrapTokensCacheOnLineDeleteRange(targetLine, endLine);
		blocks.adjustOnLineDeleteRange(targetLine, endLine);
		const endColumn = codeLines[endLine]?.length || 0;
		let caretPositionAfter;
		let selectionBefore;
		let selectionAfter;
		if (hadSelection) {
			const ordered = selection.getOrdered.value;
			if (ordered) {
				const startColumn = ordered.start.column;
				const endColumn$1 = ordered.end.column;
				const selectionDirection = selection.direction.value;
				if (selectionDirection === "forward" || selectionDirection === "backward") {
					selectionBefore = {
						start: {
							line: startLine,
							column: startColumn
						},
						end: {
							line: endLine,
							column: endColumn$1
						},
						direction: selectionDirection
					};
					if (selectionDirection === "backward") {
						caretPositionAfter = {
							line: targetLine,
							column: startColumn
						};
						selectionAfter = {
							start: {
								line: targetLine + linesToMove - 1,
								column: endColumn$1
							},
							end: {
								line: targetLine,
								column: startColumn
							},
							direction: selectionDirection
						};
					} else {
						caretPositionAfter = {
							line: targetLine + linesToMove - 1,
							column: endColumn$1
						};
						selectionAfter = {
							start: {
								line: targetLine,
								column: startColumn
							},
							end: {
								line: targetLine + linesToMove - 1,
								column: endColumn$1
							},
							direction: selectionDirection
						};
					}
				} else caretPositionAfter = caretPositionBefore;
			} else caretPositionAfter = caretPositionBefore;
		} else caretPositionAfter = {
			line: targetLine,
			column: caret.column.value
		};
		doc.buffer.replaceSelection({
			line: targetLine,
			column: 0
		}, {
			line: endLine,
			column: endColumn
		}, newText, selectionBefore, caretPositionBefore, selectionAfter, caretPositionAfter);
		caches.adjustWrapTokensCacheOnLineInsertRange(targetLine, targetLine + linesToMove);
		blocks.adjustOnLineInsertRange(targetLine, targetLine + linesToMove);
		if (selection.hasSelection.value) {
			const ordered = selection.getOrdered.value;
			if (ordered) {
				const startColumn = ordered.start.column;
				const endColumn$1 = ordered.end.column;
				if (selection.direction.value === "backward") {
					caret.line.value = targetLine;
					caret.column.value = startColumn;
					selection.setStart(targetLine + linesToMove - 1, endColumn$1);
					selection.setEnd(targetLine, startColumn);
				} else {
					caret.line.value = targetLine + linesToMove - 1;
					caret.column.value = endColumn$1;
					selection.setStart(targetLine, startColumn);
					selection.setEnd(targetLine + linesToMove - 1, endColumn$1);
				}
			}
		} else caret.line.value = targetLine;
		caret.columnIntent.value = caret.column.value;
	}
	function moveLineDown() {
		const codeLines = doc.lines;
		let startLine;
		let endLine;
		const caretPositionBefore = {
			line: caret.line.value,
			column: caret.column.value
		};
		const hadSelection = selection.hasSelection.value;
		if (hadSelection) {
			const ordered = selection.getOrdered.value;
			if (!ordered) return;
			startLine = ordered.start.line;
			endLine = ordered.end.line;
		} else {
			startLine = caret.line.value;
			endLine = caret.line.value;
		}
		if (endLine >= codeLines.length - 1) return;
		const linesToMove = endLine - startLine + 1;
		const targetLine = endLine + 1;
		const linesText = [];
		for (let i$6 = startLine; i$6 <= endLine; i$6++) linesText.push(codeLines[i$6] || "");
		const movedText = linesText.join("\n");
		const newText = (codeLines[targetLine] || "") + "\n" + movedText;
		caches.adjustWrapTokensCacheOnLineDeleteRange(startLine, targetLine);
		blocks.adjustOnLineDeleteRange(startLine, targetLine);
		const targetColumn = codeLines[targetLine]?.length || 0;
		let caretPositionAfter;
		let selectionBefore;
		let selectionAfter;
		if (hadSelection) {
			const ordered = selection.getOrdered.value;
			if (ordered) {
				const startColumn = ordered.start.column;
				const endColumn = ordered.end.column;
				const selectionDirection = selection.direction.value;
				if (selectionDirection === "forward" || selectionDirection === "backward") {
					selectionBefore = {
						start: {
							line: startLine,
							column: startColumn
						},
						end: {
							line: endLine,
							column: endColumn
						},
						direction: selectionDirection
					};
					if (selectionDirection === "backward") {
						caretPositionAfter = {
							line: startLine + 1,
							column: startColumn
						};
						selectionAfter = {
							start: {
								line: startLine + linesToMove,
								column: endColumn
							},
							end: {
								line: startLine + 1,
								column: startColumn
							},
							direction: selectionDirection
						};
					} else {
						caretPositionAfter = {
							line: startLine + linesToMove,
							column: endColumn
						};
						selectionAfter = {
							start: {
								line: startLine + 1,
								column: startColumn
							},
							end: {
								line: startLine + linesToMove,
								column: endColumn
							},
							direction: selectionDirection
						};
					}
				} else caretPositionAfter = caretPositionBefore;
			} else caretPositionAfter = caretPositionBefore;
		} else caretPositionAfter = {
			line: startLine + 1,
			column: caret.column.value
		};
		doc.buffer.replaceSelection({
			line: startLine,
			column: 0
		}, {
			line: targetLine,
			column: targetColumn
		}, newText, selectionBefore, caretPositionBefore, selectionAfter, caretPositionAfter);
		caches.adjustWrapTokensCacheOnLineInsertRange(startLine, startLine + linesToMove);
		blocks.adjustOnLineInsertRange(startLine, startLine + linesToMove);
		if (selection.hasSelection.value) {
			const ordered = selection.getOrdered.value;
			if (ordered) {
				const startColumn = ordered.start.column;
				const endColumn = ordered.end.column;
				if (selection.direction.value === "backward") {
					caret.line.value = startLine + 1;
					caret.column.value = startColumn;
					selection.setStart(startLine + linesToMove, endColumn);
					selection.setEnd(startLine + 1, startColumn);
				} else {
					caret.line.value = startLine + linesToMove;
					caret.column.value = endColumn;
					selection.setStart(startLine + 1, startColumn);
					selection.setEnd(startLine + linesToMove, endColumn);
				}
			}
		} else caret.line.value = startLine + 1;
		caret.columnIntent.value = caret.column.value;
	}
	function duplicateLine() {
		const codeLines = doc.lines;
		let startLine;
		let endLine;
		if (selection.hasSelection.value) {
			const ordered = selection.getOrdered.value;
			if (!ordered) return;
			startLine = ordered.start.line;
			endLine = ordered.end.line;
		} else {
			startLine = caret.line.value;
			endLine = caret.line.value;
		}
		const linesText = [];
		for (let i$6 = startLine; i$6 <= endLine; i$6++) linesText.push(codeLines[i$6] || "");
		const textToDuplicate = linesText.join("\n");
		const linesBeforeInsert = doc.lines.length;
		const newlineCount = (textToDuplicate.match(/\n/g) || []).length;
		const insertedLineCount = newlineCount > 0 ? newlineCount : 0;
		const endColumn = codeLines[endLine]?.length || 0;
		const textToInsert = "\n" + textToDuplicate;
		const insertLine = endLine;
		const insertColumn = endColumn;
		adjustWidgetsOnLineSplit(doc, insertLine, insertColumn, insertedLineCount + 1);
		doc.buffer.insert(insertLine, insertColumn, textToInsert);
		const actualInsertedLineCount = doc.lines.length - linesBeforeInsert;
		const newStartLine = insertLine + 1;
		if (actualInsertedLineCount > 0) {
			const insertEndLine = newStartLine + actualInsertedLineCount - 1;
			caches.adjustWrapTokensCacheOnLineInsertRange(newStartLine, insertEndLine);
			blocks.adjustOnLineInsertRange(newStartLine, insertEndLine);
		}
		if (selection.hasSelection.value) {
			const ordered = selection.getOrdered.value;
			if (ordered) {
				const newEndLine = newStartLine + (endLine - startLine);
				caret.line.value = newEndLine;
				caret.column.value = ordered.end.column;
				selection.setStart(newStartLine, ordered.start.column);
				selection.setEnd(newEndLine, ordered.end.column);
			}
		} else {
			const originalColumn = caret.column.value;
			caret.line.value = newStartLine;
			caret.column.value = originalColumn;
		}
		caret.columnIntent.value = caret.column.value;
	}
	function ensureCaretVisible() {
		if (caret.suppressAutoScroll) return;
		const currentLine = caret.line.value;
		const currentColumn = caret.column.value;
		const codeLines = doc.lines;
		if (currentLine < 0 || currentLine >= codeLines.length) return;
		let visualLine = findVisualLineForColumn(lines, currentLine, currentColumn, doc.tokenLines, caches);
		if (!visualLine) {
			const visualLines = lines.visualLines.value;
			const relevantLines = lines.visualLinesByLogicalLine.value.get(currentLine) ?? [];
			if (relevantLines.length > 0) visualLine = relevantLines[0];
			else {
				const lastVisualLine = visualLines[visualLines.length - 1];
				if (lastVisualLine && currentLine === lastVisualLine.logicalLine + 1) visualLine = {
					tokens: [],
					logicalLine: currentLine,
					tokenOffset: 0,
					y: lastVisualLine.y + lastVisualLine.height,
					width: 0,
					height: settings$1.lineHeight,
					widgets: {
						above: [],
						below: [],
						full: [],
						overlay: [],
						inlay: [],
						beforeAfter: []
					},
					errors: []
				};
				else return;
			}
		}
		const targetY = visualLine.y + settings$1.lineHeight + 1.5;
		const canvasHeight = canvas.size.height.value;
		const caretY = targetY + scroll.pos.y;
		const needsVertical = lines.totalHeight.value > canvas.size.height.value;
		const availableWidth = canvas.size.width.value - settings$1.paddingLeft - metrics.gutterWidth.value - (needsVertical ? 12 : 0);
		const needsHorizontal = !settings$1.wordWrap && lines.totalWidth.value > availableWidth;
		const headerHeight = header.value?.height ?? 0;
		const rightMargin = settings$1.caretMarginX;
		const topMargin = Math.max(0, settings$1.caretMarginY + settings$1.lineHeight);
		const bottomMargin = canvasHeight - (settings$1.caretMarginY + (needsHorizontal ? 3 : 0) + headerHeight);
		if (caretY < topMargin) scroll.targetY.value = -targetY + topMargin;
		else if (caretY > bottomMargin) scroll.targetY.value = -targetY + bottomMargin;
		const caretX = getXFromColumn(lines, visualLine, currentColumn, doc.tokenLines, canvas, settings$1, caches);
		const contentWidth = availableWidth;
		const caretXInView = caretX + scroll.pos.x;
		if (caretXInView - 1 < settings$1.caretMarginX) scroll.targetX.value = -(caretX - 1) + settings$1.caretMarginX;
		else if (caretXInView + 1.5 > contentWidth - rightMargin) scroll.targetX.value = -(caretX + 1.5 - contentWidth + rightMargin);
	}
	function toggleLineComment() {
		if (!settings$1.lineComment) return;
		const codeLines = doc.lines;
		let startLine;
		let endLine;
		let originalStartColumn;
		let originalEndColumn;
		if (selection.hasSelection.value) {
			const ordered = selection.getOrdered.value;
			if (!ordered) return;
			startLine = ordered.start.line;
			endLine = ordered.end.line;
			originalStartColumn = ordered.start.column;
			originalEndColumn = ordered.end.column;
		} else {
			startLine = caret.line.value;
			endLine = caret.line.value;
		}
		const escapedComment = settings$1.lineComment.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
		const commentWithSpace = `${settings$1.lineComment} `;
		let minIndent = Infinity;
		let allCommented = true;
		let hasCommentedLines = false;
		let hasNonEmptyLines = false;
		const lineData = [];
		for (let i$6 = startLine; i$6 <= endLine; i$6++) {
			const line = codeLines[i$6] || "";
			const indentMatch = line.match(/^(\s*)/);
			const indentStr = indentMatch ? indentMatch[1] : "";
			const indent = indentStr.length;
			const trimmed = line.trimStart();
			const isEmpty = trimmed.length === 0;
			const isCommented = !isEmpty && trimmed.startsWith(settings$1.lineComment);
			const textContent = trimmed.replace(/* @__PURE__ */ new RegExp(`^${escapedComment} ?`), "");
			lineData.push({
				line,
				indent,
				indentStr,
				textContent,
				isEmpty,
				isCommented
			});
			if (!isEmpty) {
				hasNonEmptyLines = true;
				if (indent < minIndent) minIndent = indent;
				if (isCommented) hasCommentedLines = true;
				else allCommented = false;
			}
		}
		if (!hasNonEmptyLines || minIndent === Infinity) return;
		const minIndentStr = " ".repeat(minIndent);
		const linesToToggle = [];
		const hasSomeCommented = hasCommentedLines && !allCommented;
		for (const { line, indent, indentStr, textContent, isEmpty, isCommented } of lineData) if (isEmpty) linesToToggle.push(indentStr);
		else if (allCommented) linesToToggle.push(indentStr + textContent);
		else if (hasSomeCommented) {
			const relativeIndent = indent - minIndent;
			const relativeIndentStr = " ".repeat(Math.max(0, relativeIndent));
			if (isCommented) linesToToggle.push(minIndentStr + commentWithSpace + relativeIndentStr + line.trimStart());
			else linesToToggle.push(minIndentStr + commentWithSpace + relativeIndentStr + textContent);
		} else {
			const relativeIndent = indent - minIndent;
			const relativeIndentStr = " ".repeat(Math.max(0, relativeIndent));
			linesToToggle.push(minIndentStr + commentWithSpace + relativeIndentStr + textContent);
		}
		const newText = linesToToggle.join("\n");
		const lastLineOriginalLength = codeLines[endLine]?.length || 0;
		const lastNewLineLength = (linesToToggle[linesToToggle.length - 1] || "").length;
		const originalCaretPosition = {
			line: caret.line.value,
			column: caret.column.value
		};
		const hadSelection = selection.hasSelection.value;
		const originalSelectionDirection = selection.direction.value;
		let caretPosition;
		let newStartColumn;
		let newEndColumn;
		if (hadSelection && originalStartColumn !== void 0 && originalEndColumn !== void 0) {
			const firstLineData = lineData[0];
			const lastLineData = lineData[lineData.length - 1];
			if (!allCommented) {
				const firstLineIndent = firstLineData ? firstLineData.indent : 0;
				const lastLineIndent = lastLineData ? lastLineData.indent : 0;
				const firstLineRelativeIndent = firstLineIndent - minIndent;
				const lastLineRelativeIndent = lastLineIndent - minIndent;
				if (originalStartColumn <= firstLineIndent) newStartColumn = originalStartColumn;
				else newStartColumn = minIndent + commentWithSpace.length + firstLineRelativeIndent + (originalStartColumn - firstLineIndent);
				if (originalEndColumn <= lastLineIndent) newEndColumn = originalEndColumn;
				else newEndColumn = minIndent + commentWithSpace.length + lastLineRelativeIndent + (originalEndColumn - lastLineIndent);
			} else {
				const firstLineTrimmed = codeLines[startLine]?.trimStart() || "";
				const firstLineCommentStart = firstLineData ? firstLineData.indent : 0;
				const firstLineHasSpace = firstLineTrimmed.startsWith(settings$1.lineComment + " ");
				const firstLineCommentLength = settings$1.lineComment.length + (firstLineHasSpace ? 1 : 0);
				if (originalStartColumn < firstLineCommentStart) newStartColumn = originalStartColumn;
				else if (originalStartColumn >= firstLineCommentStart + firstLineCommentLength) newStartColumn = originalStartColumn - firstLineCommentLength;
				else newStartColumn = firstLineCommentStart;
				const lastLineTrimmed = codeLines[endLine]?.trimStart() || "";
				const lastLineCommentStart = lastLineData ? lastLineData.indent : 0;
				const lastLineHasSpace = lastLineTrimmed.startsWith(settings$1.lineComment + " ");
				const lastLineCommentLength = settings$1.lineComment.length + (lastLineHasSpace ? 1 : 0);
				if (originalEndColumn < lastLineCommentStart) newEndColumn = originalEndColumn;
				else if (originalEndColumn >= lastLineCommentStart + lastLineCommentLength) newEndColumn = originalEndColumn - lastLineCommentLength;
				else newEndColumn = lastLineCommentStart;
			}
			if (originalSelectionDirection === "backward") caretPosition = {
				line: startLine,
				column: newStartColumn ?? 0
			};
			else caretPosition = {
				line: endLine,
				column: newEndColumn ?? lastNewLineLength
			};
		} else {
			const originalColumn = caret.column.value;
			const originalLine = codeLines[startLine] || "";
			const newLine = linesToToggle[0] || "";
			const firstLineData = lineData[0];
			let newColumn = originalColumn;
			if (!allCommented) {
				if (firstLineData && !firstLineData.isEmpty) if (originalColumn <= firstLineData.indent) newColumn = originalColumn;
				else {
					const relativeIndent = firstLineData.indent - minIndent;
					const relativeIndentLength = Math.max(0, relativeIndent);
					newColumn = originalColumn + commentWithSpace.length + relativeIndentLength;
				}
			} else if (firstLineData && !firstLineData.isEmpty) {
				const trimmed = originalLine.trimStart();
				const commentStartInLine = firstLineData.indent;
				const hasSpaceAfter = trimmed.startsWith(settings$1.lineComment + " ");
				const commentLength = settings$1.lineComment.length + (hasSpaceAfter ? 1 : 0);
				const commentEndInLine = commentStartInLine + commentLength;
				if (originalColumn < commentStartInLine) newColumn = originalColumn;
				else if (originalColumn >= commentEndInLine) newColumn = originalColumn - commentLength;
				else newColumn = commentStartInLine;
			}
			caretPosition = {
				line: startLine,
				column: Math.min(newColumn, newLine.length)
			};
		}
		caches.adjustWrapTokensCacheOnLineDeleteRange(startLine, endLine);
		blocks.adjustOnLineDeleteRange(startLine, endLine);
		const selectionBefore = hadSelection && originalStartColumn !== void 0 && originalEndColumn !== void 0 && (originalSelectionDirection === "forward" || originalSelectionDirection === "backward") ? {
			start: {
				line: startLine,
				column: originalStartColumn
			},
			end: {
				line: endLine,
				column: originalEndColumn
			},
			direction: originalSelectionDirection
		} : void 0;
		const selectionAfter = hadSelection && newStartColumn !== void 0 && newEndColumn !== void 0 && (originalSelectionDirection === "forward" || originalSelectionDirection === "backward") ? {
			start: {
				line: startLine,
				column: newStartColumn
			},
			end: {
				line: endLine,
				column: newEndColumn
			},
			direction: originalSelectionDirection
		} : void 0;
		doc.buffer.replaceSelection({
			line: startLine,
			column: 0
		}, {
			line: endLine,
			column: lastLineOriginalLength
		}, newText, selectionBefore, originalCaretPosition, selectionAfter, caretPosition);
		caches.adjustWrapTokensCacheOnLineInsertRange(startLine, endLine);
		blocks.adjustOnLineInsertRange(startLine, endLine);
		if (hadSelection && newStartColumn !== void 0 && newEndColumn !== void 0) {
			if (selection.getOrdered.value) if (originalSelectionDirection === "backward") {
				caret.line.value = startLine;
				caret.column.value = newStartColumn;
				caret.columnIntent.value = newStartColumn;
				selection.setStart(endLine, newEndColumn);
				selection.setEnd(startLine, newStartColumn);
			} else {
				caret.line.value = endLine;
				caret.column.value = newEndColumn;
				caret.columnIntent.value = newEndColumn;
				selection.setStart(startLine, newStartColumn);
				selection.setEnd(endLine, newEndColumn);
			}
		} else if (caretPosition) {
			caret.line.value = caretPosition.line;
			caret.column.value = caretPosition.column;
			caret.columnIntent.value = caretPosition.column;
		}
		caret.columnIntent.value = caret.column.value;
	}
	function toggleBlockComment() {
		const [startComment, endComment] = settings$1.blockComment;
		if (!startComment || !endComment) return;
		const codeLines = doc.lines;
		const hadSelection = selection.hasSelection.value;
		let startLine;
		let endLine;
		let startColumn;
		let endColumn;
		if (hadSelection) {
			const ordered = selection.getOrdered.value;
			if (!ordered) return;
			startLine = ordered.start.line;
			endLine = ordered.end.line;
			startColumn = ordered.start.column;
			endColumn = ordered.end.column;
		} else {
			startLine = caret.line.value;
			endLine = caret.line.value;
			startColumn = caret.column.value;
			endColumn = caret.column.value;
		}
		const selectedText = (() => {
			if (startLine === endLine) return (codeLines[startLine] || "").slice(startColumn, endColumn);
			let text = "";
			for (let line = startLine; line <= endLine; line++) {
				const lineText = codeLines[line] || "";
				if (line === startLine) text += lineText.slice(startColumn);
				else if (line === endLine) text += lineText.slice(0, endColumn);
				else text += lineText;
				if (line < endLine) text += "\n";
			}
			return text;
		})();
		const isCommented = selectedText.startsWith(startComment) && selectedText.endsWith(endComment);
		let newText;
		let newStartColumn;
		let newEndColumn;
		if (isCommented) {
			newText = selectedText.slice(startComment.length, -endComment.length);
			newStartColumn = startColumn;
			if (startLine === endLine) newEndColumn = startColumn + newText.length;
			else newEndColumn = endColumn - endComment.length;
		} else {
			newText = startComment + selectedText + endComment;
			newStartColumn = startColumn;
			if (startLine === endLine) newEndColumn = endColumn + startComment.length + endComment.length;
			else {
				codeLines[endLine]?.length;
				newEndColumn = endColumn + endComment.length;
			}
		}
		const originalSelectionDirection = selection.direction.value;
		const originalStartColumn = selection.start.value.column;
		const originalEndColumn = selection.end.value.column;
		const selectionObj = hadSelection && originalSelectionDirection && (originalSelectionDirection === "forward" || originalSelectionDirection === "backward") && originalStartColumn !== void 0 && originalEndColumn !== void 0 ? {
			start: {
				line: startLine,
				column: originalStartColumn
			},
			end: {
				line: endLine,
				column: originalEndColumn
			},
			direction: originalSelectionDirection
		} : void 0;
		doc.buffer.replaceSelection({
			line: startLine,
			column: startColumn
		}, {
			line: endLine,
			column: endColumn
		}, newText, selectionObj);
		if (endLine > startLine) {
			caches.adjustWrapTokensCacheOnLineDeleteRange(startLine + 1, endLine);
			blocks.adjustOnLineDeleteRange(startLine + 1, endLine);
		}
		const newlineCount = (newText.match(/\n/g) || []).length;
		if (newlineCount > 0) {
			const insertStartLine = startLine + 1;
			const insertEndLine = startLine + newlineCount;
			caches.adjustWrapTokensCacheOnLineInsertRange(insertStartLine, insertEndLine);
			blocks.adjustOnLineInsertRange(insertStartLine, insertEndLine);
		}
		if (hadSelection) if (originalSelectionDirection === "backward") {
			caret.line.value = startLine;
			caret.column.value = newStartColumn;
			caret.columnIntent.value = newStartColumn;
			selection.setStart(endLine, newEndColumn);
			selection.setEnd(startLine, newStartColumn);
		} else {
			caret.line.value = endLine;
			caret.column.value = newEndColumn;
			caret.columnIntent.value = newEndColumn;
			selection.setStart(startLine, newStartColumn);
			selection.setEnd(endLine, newEndColumn);
		}
		else {
			caret.line.value = startLine;
			caret.column.value = newStartColumn;
			selection.clear();
		}
		caret.columnIntent.value = caret.column.value;
	}
	let clipboard;
	function indentLines() {
		const tabSize = 2;
		const indentStr = " ".repeat(tabSize);
		if (selection.hasSelection.value) {
			const ordered = selection.getOrdered.value;
			if (!ordered) return;
			const startLine = ordered.start.line;
			const endLine = ordered.end.line;
			const startColumn = ordered.start.column;
			const endColumn = ordered.end.column;
			const selectionDirection = selection.direction.value;
			const actualEndLine = endColumn === 0 && endLine > startLine ? endLine - 1 : endLine;
			const selectionDir = selectionDirection === "forward" || selectionDirection === "backward" ? selectionDirection : "forward";
			const selectionBefore = ordered ? {
				start: {
					line: startLine,
					column: startColumn
				},
				end: {
					line: endLine,
					column: endColumn
				},
				direction: selectionDir
			} : void 0;
			const originalCaretPosition = {
				line: caret.line.value,
				column: caret.column.value
			};
			const newStartColumn = startColumn + tabSize;
			const newEndColumn = endColumn === 0 && endLine > startLine ? 0 : endColumn + tabSize;
			const newEndLine = endColumn === 0 && endLine > startLine ? endLine : endLine;
			const caretPositionAfter = selectionDirection === "backward" ? {
				line: startLine,
				column: newStartColumn
			} : {
				line: newEndLine,
				column: newEndColumn
			};
			const selectionAfter = ordered ? {
				start: {
					line: startLine,
					column: newStartColumn
				},
				end: {
					line: newEndLine,
					column: newEndColumn
				},
				direction: selectionDir
			} : void 0;
			caches.adjustWrapTokensCacheOnLineDeleteRange(startLine, actualEndLine);
			blocks.adjustOnLineDeleteRange(startLine, actualEndLine);
			const codeLines = doc.lines;
			const linesToIndent = [];
			for (let i$6 = startLine; i$6 <= actualEndLine; i$6++) {
				const line = codeLines[i$6] || "";
				linesToIndent.push(indentStr + line);
			}
			const newText = linesToIndent.join("\n");
			const lastLineOriginalLength = codeLines[actualEndLine]?.length || 0;
			doc.buffer.replaceSelection({
				line: startLine,
				column: 0
			}, {
				line: actualEndLine,
				column: lastLineOriginalLength
			}, newText, selectionBefore, originalCaretPosition, selectionAfter, caretPositionAfter);
			caches.adjustWrapTokensCacheOnLineInsertRange(startLine, actualEndLine);
			blocks.adjustOnLineInsertRange(startLine, actualEndLine);
			for (let i$6 = startLine; i$6 <= actualEndLine; i$6++) {
				const newLineLength = doc.lines[i$6]?.length || 0;
				adjustWidgetsOnColumnInsert(doc, i$6, 0, tabSize, newLineLength);
			}
			if (selectionDirection === "backward") {
				caret.line.value = startLine;
				caret.column.value = newStartColumn;
				caret.columnIntent.value = newStartColumn;
				selection.setStart(endLine, newEndColumn);
				selection.setEnd(startLine, newStartColumn);
			} else {
				caret.line.value = endLine;
				caret.column.value = newEndColumn;
				caret.columnIntent.value = newEndColumn;
				selection.setStart(startLine, newStartColumn);
				selection.setEnd(endLine, newEndColumn);
			}
		} else {
			const currentLine = caret.line.value;
			caret.column.value;
			doc.lines[currentLine];
			insertText(indentStr);
		}
	}
	function unindentLines() {
		const tabSize = 2;
		if (selection.hasSelection.value) {
			const ordered = selection.getOrdered.value;
			if (!ordered) return;
			const startLine = ordered.start.line;
			const endLine = ordered.end.line;
			const startColumn = ordered.start.column;
			const endColumn = ordered.end.column;
			const selectionDirection = selection.direction.value;
			const actualEndLine = endColumn === 0 && endLine > startLine ? endLine - 1 : endLine;
			const selectionDir = selectionDirection === "forward" || selectionDirection === "backward" ? selectionDirection : "forward";
			const selectionBefore = ordered ? {
				start: {
					line: startLine,
					column: startColumn
				},
				end: {
					line: endLine,
					column: endColumn
				},
				direction: selectionDir
			} : void 0;
			const originalCaretPosition = {
				line: caret.line.value,
				column: caret.column.value
			};
			caches.adjustWrapTokensCacheOnLineDeleteRange(startLine, actualEndLine);
			blocks.adjustOnLineDeleteRange(startLine, actualEndLine);
			const codeLines = doc.lines;
			const linesToUnindent = [];
			let minUnindent = Infinity;
			for (let i$6 = startLine; i$6 <= actualEndLine; i$6++) {
				const indentMatch = (codeLines[i$6] || "").match(/^(\s*)/);
				const indent = (indentMatch ? indentMatch[1] : "").length;
				const unindent = Math.min(indent, tabSize);
				if (unindent > 0) {
					if (unindent < minUnindent) minUnindent = unindent;
				}
			}
			if (minUnindent === Infinity || minUnindent === 0) return;
			for (let i$6 = startLine; i$6 <= actualEndLine; i$6++) {
				const line = codeLines[i$6] || "";
				linesToUnindent.push(line.slice(minUnindent));
			}
			const newText = linesToUnindent.join("\n");
			const lastLineOriginalLength = codeLines[actualEndLine]?.length || 0;
			for (let i$6 = startLine; i$6 <= actualEndLine; i$6++) adjustWidgetsOnColumnDelete(doc, i$6, 0, minUnindent);
			const newStartColumn = Math.max(0, startColumn - minUnindent);
			const newEndColumn = endColumn === 0 && endLine > startLine ? 0 : Math.max(0, endColumn - minUnindent);
			const newEndLine = endColumn === 0 && endLine > startLine ? endLine : endLine;
			const caretPositionAfter = selectionDirection === "backward" ? {
				line: startLine,
				column: newStartColumn
			} : {
				line: newEndLine,
				column: newEndColumn
			};
			const selectionAfter = ordered ? {
				start: {
					line: startLine,
					column: newStartColumn
				},
				end: {
					line: newEndLine,
					column: newEndColumn
				},
				direction: selectionDir
			} : void 0;
			doc.buffer.replaceSelection({
				line: startLine,
				column: 0
			}, {
				line: actualEndLine,
				column: lastLineOriginalLength
			}, newText, selectionBefore, originalCaretPosition, selectionAfter, caretPositionAfter);
			caches.adjustWrapTokensCacheOnLineInsertRange(startLine, actualEndLine);
			blocks.adjustOnLineInsertRange(startLine, actualEndLine);
			if (selectionDirection === "backward") {
				caret.line.value = startLine;
				caret.column.value = newStartColumn;
				caret.columnIntent.value = newStartColumn;
				selection.setStart(endLine, newEndColumn);
				selection.setEnd(startLine, newStartColumn);
			} else {
				caret.line.value = endLine;
				caret.column.value = newEndColumn;
				caret.columnIntent.value = newEndColumn;
				selection.setStart(startLine, newStartColumn);
				selection.setEnd(endLine, newEndColumn);
			}
		} else {
			const currentLine = caret.line.value;
			const currentColumn = caret.column.value;
			const line = doc.lines[currentLine] || "";
			const indentMatch = line.match(/^(\s*)/);
			const indent = (indentMatch ? indentMatch[1] : "").length;
			const unindent = Math.min(indent, tabSize);
			if (unindent > 0) {
				const newLine = line.slice(unindent);
				const newColumn = Math.max(0, currentColumn - unindent);
				const originalCaretPosition = {
					line: currentLine,
					column: currentColumn
				};
				const caretPositionAfter = {
					line: currentLine,
					column: newColumn
				};
				caches.invalidateWrapTokensCacheForLine(currentLine);
				doc.buffer.replaceSelection({
					line: currentLine,
					column: 0
				}, {
					line: currentLine,
					column: line.length
				}, newLine, void 0, originalCaretPosition, void 0, caretPositionAfter);
				caret.column.value = newColumn;
				caret.columnIntent.value = newColumn;
			}
		}
	}
	function handleKeyAction(key, shift, ctrl, meta, alt) {
		caret.resetBlink();
		const normalizedKey = key.toLowerCase();
		if ((ctrl || meta) && normalizedKey === "a") {
			const codeLines = doc.lines;
			if (codeLines.length === 0) {
				selection.clear();
				caret.line.value = 0;
				caret.column.value = 0;
				caret.columnIntent.value = 0;
				ensureCaretVisible();
				return;
			}
			const lastLine = codeLines.length - 1;
			const lastColumn = codeLines[lastLine]?.length || 0;
			selection.setStart(0, 0);
			selection.setEnd(lastLine, lastColumn);
			caret.line.value = lastLine;
			caret.column.value = lastColumn;
			ensureCaretVisible();
			return;
		} else if ((ctrl || meta) && normalizedKey === "b") {
			const matchingBrace = blocks.findMatchingBrace(caret.line.value, caret.column.value);
			if (!matchingBrace) {
				ensureCaretVisible();
				return;
			}
			const tokenLines = doc.tokenLines;
			let openColumn = 0;
			const openLineTokens = tokenLines[matchingBrace.line] || [];
			for (let i$6 = 0; i$6 < matchingBrace.tokenIndex; i$6++) openColumn += openLineTokens[i$6]?.text.length || 0;
			openColumn += matchingBrace.charIndex;
			let closeColumn = 0;
			const closeLineTokens = tokenLines[matchingBrace.matchingLine] || [];
			for (let i$6 = 0; i$6 < matchingBrace.matchingTokenIndex; i$6++) closeColumn += closeLineTokens[i$6]?.text.length || 0;
			closeColumn += matchingBrace.matchingCharIndex + 1;
			selection.setStart(matchingBrace.line, openColumn);
			selection.setEnd(matchingBrace.matchingLine, closeColumn);
			caret.line.value = matchingBrace.matchingLine;
			caret.column.value = closeColumn;
			caret.columnIntent.value = closeColumn;
			ensureCaretVisible();
			return;
		} else if ((ctrl || meta) && normalizedKey === "c") {
			clipboard.copy();
			return;
		} else if ((ctrl || meta) && normalizedKey === "x") {
			clipboard.cut();
			ensureCaretVisible();
			return;
		} else if ((ctrl || meta) && key === "z" && !shift) {
			const result = doc.buffer.undo();
			if (result) {
				caret.line.value = result.line;
				caret.column.value = result.column;
				caret.columnIntent.value = result.column;
				if (result.selection) {
					if (result.selection.direction === "backward") {
						selection.start.value = result.selection.end;
						selection.end.value = result.selection.start;
					} else {
						selection.start.value = result.selection.start;
						selection.end.value = result.selection.end;
					}
					selection.direction.value = result.selection.direction;
				} else selection.clear();
			}
			ensureCaretVisible();
			return;
		} else if ((ctrl || meta) && (key === "y" || key === "z" && shift)) {
			const result = doc.buffer.redo();
			if (result) {
				caret.line.value = result.line;
				caret.column.value = result.column;
				caret.columnIntent.value = result.column;
				if (result.selection) {
					if (result.selection.direction === "backward") {
						selection.start.value = result.selection.end;
						selection.end.value = result.selection.start;
					} else {
						selection.start.value = result.selection.start;
						selection.end.value = result.selection.end;
					}
					selection.direction.value = result.selection.direction;
				} else selection.clear();
			} else selection.clear();
			ensureCaretVisible();
			return;
		} else if ((ctrl || meta) && shift && normalizedKey === "d") {
			duplicateLine();
			ensureCaretVisible();
			return;
		} else if ((ctrl || meta) && !shift && (key === "/" || normalizedKey === "slash")) {
			toggleLineComment();
			ensureCaretVisible();
			return;
		} else if ((ctrl || meta) && shift && (key === "/" || key === "?" || normalizedKey === "slash")) {
			toggleBlockComment();
			ensureCaretVisible();
			return;
		}
		if (key === "ArrowLeft") {
			caret.isTyping.value = false;
			caret.caretToken = null;
			if (ctrl || meta) moveWordLeft(shift);
			else moveLeft(shift);
			ensureCaretVisible();
		} else if (key === "ArrowRight") {
			caret.isTyping.value = false;
			caret.caretToken = null;
			if (ctrl || meta) moveWordRight(shift);
			else moveRight(shift);
			ensureCaretVisible();
		} else if (key === "ArrowUp") {
			caret.isTyping.value = false;
			caret.caretToken = null;
			if (alt) {
				moveLineUp();
				ensureCaretVisible();
			} else {
				moveUp(shift);
				ensureCaretVisible();
			}
		} else if (key === "ArrowDown") {
			caret.isTyping.value = false;
			caret.caretToken = null;
			if (alt) {
				moveLineDown();
				ensureCaretVisible();
			} else {
				moveDown(shift);
				ensureCaretVisible();
			}
		} else if (key === "Home") {
			caret.isTyping.value = false;
			caret.caretToken = null;
			moveHome(shift);
			ensureCaretVisible();
		} else if (key === "End") {
			caret.isTyping.value = false;
			caret.caretToken = null;
			moveEnd(shift);
			ensureCaretVisible();
		} else if (key === "PageUp") {
			caret.isTyping.value = false;
			caret.caretToken = null;
			movePageUp(shift);
			ensureCaretVisible();
		} else if (key === "PageDown") {
			caret.isTyping.value = false;
			caret.caretToken = null;
			movePageDown(shift);
			ensureCaretVisible();
		} else if (key === "Backspace") {
			if (ctrl || meta) deleteWordLeft();
			else backspace();
			ensureCaretVisible();
		} else if (key === "Delete") {
			if (ctrl || meta) deleteWordRight();
			else if (shift) deleteLine();
			else deleteChar();
			ensureCaretVisible();
		} else if (key === "Escape") {
			caret.isTyping.value = false;
			caret.caretToken = null;
			mouse.clearHoverToken();
			clearPinnedError();
			return;
		} else if (key === "Tab") {
			if (shift) unindentLines();
			else indentLines();
			ensureCaretVisible();
		} else if (key === "Enter") {
			const currentLine = doc.lines[caret.line.value] || "";
			if (caret.column.value === 0) {
				insertText("\n");
				ensureCaretVisible();
				return;
			}
			const beforeCursor = currentLine.slice(0, caret.column.value);
			const afterCursor = currentLine.slice(caret.column.value);
			const lastChar = beforeCursor.trimEnd().slice(-1);
			const isBrace = lastChar === "{" || lastChar === "[" || lastChar === "(";
			const indentMatch = currentLine.match(/^(\s*)/);
			const currentIndent = indentMatch ? indentMatch[1] : "";
			const bracePairs = {
				"{": "}",
				"[": "]",
				"(": ")"
			};
			const firstAfterCursor = afterCursor.trimStart()[0];
			const closingBrace = lastChar ? bracePairs[lastChar] : null;
			if (lastChar && closingBrace && firstAfterCursor === closingBrace) {
				const newIndent = currentIndent + " ".repeat(2);
				const closeBraceIndex = afterCursor.indexOf(closingBrace);
				const afterCloseBrace = afterCursor.slice(closeBraceIndex + 1);
				const newText = "\n" + newIndent + "\n" + currentIndent + closingBrace + afterCloseBrace;
				const startColumn = caret.column.value;
				const endColumn = currentLine.length;
				const caretPositionBefore = {
					line: caret.line.value,
					column: caret.column.value
				};
				const caretPositionAfter = {
					line: caret.line.value + 1,
					column: newIndent.length
				};
				const linesBeforeInsert = doc.lines.length;
				adjustWidgetsOnLineSplit(doc, caret.line.value, startColumn, 2);
				caches.invalidateWrapTokensCacheForLine(caret.line.value);
				for (const [lineNum] of caches.wrapTokensCacheByLine.entries()) if (lineNum > caret.line.value) caches.invalidateWrapTokensCacheForLine(lineNum);
				doc.buffer.replaceSelection({
					line: caret.line.value,
					column: startColumn
				}, {
					line: caret.line.value,
					column: endColumn
				}, newText, void 0, caretPositionBefore, void 0, caretPositionAfter);
				const insertedLineCount = doc.lines.length - linesBeforeInsert;
				if (insertedLineCount > 0) blocks.adjustOnLineInsertRange(caret.line.value + 1, caret.line.value + insertedLineCount);
				caret.line.value = caretPositionAfter.line;
				caret.column.value = caretPositionAfter.column;
				caret.columnIntent.value = caret.column.value;
				ensureCaretVisible();
				return;
			}
			const matchingBrace = blocks.findMatchingBrace(caret.line.value, caret.column.value);
			if (matchingBrace && matchingBrace.line === matchingBrace.matchingLine && caret.line.value === matchingBrace.line) {
				const tokenLines = doc.tokenLines;
				let openColumn = 0;
				const openLineTokens = tokenLines[matchingBrace.line] || [];
				for (let i$6 = 0; i$6 < matchingBrace.tokenIndex; i$6++) openColumn += openLineTokens[i$6]?.text.length || 0;
				openColumn += matchingBrace.charIndex;
				let closeColumn = 0;
				const closeLineTokens = tokenLines[matchingBrace.matchingLine] || [];
				for (let i$6 = 0; i$6 < matchingBrace.matchingTokenIndex; i$6++) closeColumn += closeLineTokens[i$6]?.text.length || 0;
				closeColumn += matchingBrace.matchingCharIndex;
				if (caret.column.value > openColumn && caret.column.value < closeColumn) {
					const openIndentMatch = (doc.lines[matchingBrace.line] || "").match(/^(\s*)/);
					const openIndent = openIndentMatch ? openIndentMatch[1] : "";
					const newIndent = openIndent + " ".repeat(2);
					const closeLine = doc.lines[matchingBrace.matchingLine] || "";
					const textBetweenCaretAndClose = closeLine.slice(caret.column.value, closeColumn);
					const closingBraceChar = closeLine[closeColumn];
					const newText = "\n" + newIndent + textBetweenCaretAndClose + "\n" + openIndent + closingBraceChar;
					const startColumn = caret.column.value;
					const endColumn = closeColumn + 1;
					const caretPositionBefore = {
						line: caret.line.value,
						column: caret.column.value
					};
					const caretPositionAfter = {
						line: caret.line.value + 1,
						column: newIndent.length
					};
					const linesBeforeInsert = doc.lines.length;
					adjustWidgetsOnLineSplit(doc, caret.line.value, startColumn, 2);
					caches.invalidateWrapTokensCacheForLine(caret.line.value);
					for (const [lineNum] of caches.wrapTokensCacheByLine.entries()) if (lineNum > caret.line.value) caches.invalidateWrapTokensCacheForLine(lineNum);
					doc.buffer.replaceSelection({
						line: caret.line.value,
						column: startColumn
					}, {
						line: caret.line.value,
						column: endColumn
					}, newText, void 0, caretPositionBefore, void 0, caretPositionAfter);
					const insertedLineCount = doc.lines.length - linesBeforeInsert;
					if (insertedLineCount > 0) blocks.adjustOnLineInsertRange(caret.line.value + 1, caret.line.value + insertedLineCount);
					caret.line.value = caretPositionAfter.line;
					caret.column.value = caretPositionAfter.column;
					caret.columnIntent.value = caret.column.value;
					ensureCaretVisible();
					return;
				}
			}
			if (isBrace) insertText("\n" + (currentIndent + " ".repeat(2)));
			else insertText("\n" + currentIndent);
			ensureCaretVisible();
		} else if (key.length === 1 && !ctrl && !meta && !alt) {
			const skipOverChars = new Set([
				"[",
				"(",
				"{",
				"]",
				")",
				"}",
				"'",
				"\"",
				"`"
			]);
			const currentLine = doc.lines[caret.line.value] ?? "";
			const charRight = currentLine[caret.column.value];
			if (skipOverChars.has(key) && charRight === key) {
				const line = caret.line.value;
				const column = caret.column.value;
				doc.buffer.replaceSelection({
					line,
					column
				}, {
					line,
					column: column + 1
				}, key, void 0, {
					line,
					column
				}, void 0, {
					line,
					column: column + 1
				});
				caches.invalidateWrapTokensCacheForLine(line);
				caret.column.value = column + 1;
				caret.columnIntent.value = caret.column.value;
				caret.isTyping.value = true;
				caret.lastInputTime.value = Date.now();
			} else {
				const bracePairs = {
					"{": "}",
					"[": "]",
					"(": ")"
				};
				const stringDelimiters = new Set([
					"'",
					"\"",
					"`"
				]);
				const closingBrace = bracePairs[key];
				const isStringDelimiter = stringDelimiters.has(key);
				const nextChar = currentLine[caret.column.value];
				if ((closingBrace || isStringDelimiter) && (!nextChar || /\s/.test(nextChar))) {
					const pair = closingBrace ? key + closingBrace : key + key;
					if (selection.hasSelection.value) {
						const ordered = selection.getOrdered.value;
						if (ordered) {
							const startLine = ordered.start.line;
							const endLine = ordered.end.line;
							const startColumn = ordered.start.column;
							const endColumn = ordered.end.column;
							const selectionDirection = selection.direction.value;
							doc.lines.length;
							const deletedLineCount = endLine > startLine ? endLine - startLine : 0;
							const selectionDir = selectionDirection === "forward" || selectionDirection === "backward" ? selectionDirection : void 0;
							const selectionObj = selectionDir && ordered ? {
								start: {
									line: startLine,
									column: startColumn
								},
								end: {
									line: endLine,
									column: endColumn
								},
								direction: selectionDir
							} : void 0;
							doc.buffer.replaceSelection({
								line: startLine,
								column: startColumn
							}, {
								line: endLine,
								column: endColumn
							}, pair, selectionObj);
							doc.lines.length;
							const newlineCount = 0;
							const insertedLineCount = newlineCount > 0 ? newlineCount : 0;
							if (deletedLineCount > 0) {
								caches.adjustWrapTokensCacheOnLineDeleteRange(startLine + 1, endLine);
								blocks.adjustOnLineDeleteRange(startLine + 1, endLine);
							}
							if (insertedLineCount > 0) {
								const insertStartLine = startLine + 1;
								const insertEndLine = startLine + insertedLineCount;
								caches.adjustWrapTokensCacheOnLineInsertRange(insertStartLine, insertEndLine);
								blocks.adjustOnLineInsertRange(insertStartLine, insertEndLine);
							} else if (deletedLineCount === 0) caches.invalidateWrapTokensCacheForLine(startLine);
							caret.line.value = startLine;
							caret.column.value = startColumn + 1;
							caret.columnIntent.value = caret.column.value;
							selection.clear();
						}
					} else {
						const currentLine$1 = doc.lines[caret.line.value] || "";
						const newLine = currentLine$1.slice(0, caret.column.value) + pair + currentLine$1.slice(caret.column.value);
						adjustWidgetsOnColumnInsert(doc, caret.line.value, caret.column.value, 2, newLine.length);
						caches.invalidateWrapTokensCacheForLine(caret.line.value);
						doc.buffer.insert(caret.line.value, caret.column.value, pair);
						caret.column.value += 1;
						caret.columnIntent.value = caret.column.value;
					}
					caret.isTyping.value = true;
					caret.lastInputTime.value = Date.now();
				} else insertText(key);
			}
			ensureCaretVisible();
		}
	}
	const NON_KEYS = new Set([
		"Alt",
		"Control",
		"Meta",
		"Shift"
	]);
	const handleKeyDown = (event) => {
		n(() => {
			if (event.defaultPrevented) return;
			shiftKey.value = event.shiftKey;
			ctrlKey.value = event.ctrlKey;
			metaKey.value = event.metaKey;
			altKey.value = event.altKey;
			if (NON_KEYS.has(event.key)) return;
			handleKeyAction(event.key, event.shiftKey, event.ctrlKey, event.metaKey, event.altKey);
			if (event.key === "ArrowLeft" || event.key === "ArrowRight" || event.key === "ArrowUp" || event.key === "ArrowDown" || event.key === "Home" || event.key === "End" || event.key === "PageUp" || event.key === "PageDown" || event.key === "Backspace" || event.key === "Delete" || event.key === "Enter" || event.key === "Escape" || event.key === "Tab" || (event.ctrlKey || event.metaKey) && (event.key.toLowerCase() === "a" || event.key.toLowerCase() === "b" || event.key.toLowerCase() === "z" || event.key.toLowerCase() === "y" || event.key.toLowerCase() === "c" || event.key.toLowerCase() === "x" || event.shiftKey && event.key.toLowerCase() === "d" || !event.shiftKey && (event.key === "/" || event.key.toLowerCase() === "slash") || event.shiftKey && (event.key === "/" || event.key === "?" || event.key.toLowerCase() === "slash") || event.key === "ArrowLeft" || event.key === "ArrowRight") || event.key.length === 1 && !event.ctrlKey && !event.metaKey && !event.altKey) event.preventDefault();
		});
	};
	const handleKeyUp = (event) => {
		n(() => {
			if (event.defaultPrevented) return;
			shiftKey.value = event.shiftKey;
			ctrlKey.value = event.ctrlKey;
			metaKey.value = event.metaKey;
			altKey.value = event.altKey;
		});
	};
	clipboard = createClipboard(doc, selection, insertText, deleteSelection, ensureCaretVisible, handleKeyDown, handleKeyUp, canvas);
	const textarea$1 = getTextareaElement();
	const handleTextareaFocus = () => {
		if (getActiveCanvas() === canvas.el) clipboard.activate();
	};
	const handleTextareaBlur = () => {
		setTimeout(() => {
			const activeElement = document.activeElement;
			if (activeElement !== getTextareaElement() && activeElement?.tagName !== "CANVAS" && getActiveCanvas() !== canvas.el) clipboard.deactivate();
		}, 0);
	};
	const activate = () => {
		activeEditorOpts?.setActiveEditor(activeEditorOpts.editorRef.current);
		clipboard.activate();
		caret.resetBlink();
	};
	textarea$1.addEventListener("focus", handleTextareaFocus);
	textarea$1.addEventListener("blur", handleTextareaBlur);
	const dispose = () => {
		textarea$1.removeEventListener("focus", handleTextareaFocus);
		textarea$1.removeEventListener("blur", handleTextareaBlur);
		clipboard.dispose();
	};
	return {
		dispose,
		clipboard,
		activate
	};
}
function createTokenColumnPrefix(tokens) {
	const prefix = new Array(tokens.length + 1);
	prefix[0] = 0;
	for (let i$6 = 0; i$6 < tokens.length; i$6++) prefix[i$6 + 1] = prefix[i$6] + tokens[i$6].text.length;
	return prefix;
}
function applyAboveWidgetSpace(doc, visualLines, widgetsByLogicalLine) {
	const aboveSpaceByLogicalLine = /* @__PURE__ */ new Map();
	let consecutiveEmptyHeight = 0;
	for (let i$6 = 0; i$6 < visualLines.length; i$6++) {
		const line = visualLines[i$6];
		if (line.tokenOffset === 0 && !aboveSpaceByLogicalLine.has(line.logicalLine)) {
			const aboveHeight = consecutiveEmptyHeight;
			if (aboveHeight > 0) {
				const lineWidgets = widgetsByLogicalLine.get(line.logicalLine);
				if (lineWidgets && lineWidgets.length > 0) {
					let hasAboveOrFull = false;
					for (let j$4 = 0; j$4 < lineWidgets.length; j$4++) {
						const t$12 = lineWidgets[j$4].type;
						if (t$12 === "above" || t$12 === "full") {
							hasAboveOrFull = true;
							break;
						}
					}
					if (hasAboveOrFull) aboveSpaceByLogicalLine.set(line.logicalLine, aboveHeight);
				}
			}
		}
		if (isLineEmpty(line)) consecutiveEmptyHeight += line.height;
		else consecutiveEmptyHeight = 0;
	}
	if (aboveSpaceByLogicalLine.size === 0) return visualLines;
	const result = [];
	let currentY = 0;
	for (let i$6 = 0; i$6 < visualLines.length; i$6++) {
		const line = visualLines[i$6];
		const aboveHeight = aboveSpaceByLogicalLine.get(line.logicalLine) || 0;
		let newHeight = line.height;
		if (aboveHeight > 0 && line.tokenOffset > 0 && line.widgets.above.length > 0) {
			const tokenLines = doc.tokenLines;
			const lineStartColumn = getCharOffsetForVisualLine(line.logicalLine, line, tokenLines, void 0);
			let lineEndColumn = lineStartColumn;
			for (let j$4 = 0; j$4 < line.tokens.length; j$4++) lineEndColumn += line.tokens[j$4].token.text.length;
			if (line.widgets.above.some((widget) => {
				const [startColumn, endColumn] = widget.pos.x;
				const startCol0 = startColumn - 1;
				const endCol0 = endColumn - 1;
				return startCol0 < lineEndColumn && endCol0 > lineStartColumn;
			})) newHeight = line.height + aboveHeight;
		}
		result.push({
			...line,
			y: currentY,
			height: newHeight
		});
		currentY += newHeight;
	}
	return result;
}
function createVisualLineFromCurrent(currentLine, tokenOffset, y$5, logicalLine, c$7, settings$1, caches, lineWidgets, lineErrors, inlineWidgetWidthIndex, logicalColumnPrefix, logicalTokenIndices, currentLineTokenWidths) {
	const lineStartColumn = logicalColumnPrefix[tokenOffset] ?? 0;
	let lineEndColumn = lineStartColumn;
	for (let i$6 = 0; i$6 < currentLine.length; i$6++) lineEndColumn += currentLine[i$6].text.length;
	const visualTokens = calculateVisualTokens(c$7, settings$1, caches, currentLine, tokenOffset, inlineWidgetWidthIndex, logicalColumnPrefix, logicalTokenIndices, currentLineTokenWidths);
	const calculatedWidth = visualTokens.length > 0 ? visualTokens[visualTokens.length - 1]?.endX || 0 : 0;
	const aboveWidgets = [];
	const belowWidgets = [];
	const overlayWidgets = [];
	const fullWidgets = [];
	const beforeAfterWidgets = [];
	const inlayWidgets = [];
	for (let i$6 = 0; i$6 < lineWidgets.length; i$6++) {
		const widget = lineWidgets[i$6];
		if (widget.type === "above") {
			const [startColumn] = widget.pos.x;
			const startCol0 = startColumn - 1;
			if (startCol0 >= lineStartColumn && startCol0 < lineEndColumn) aboveWidgets.push(widget);
		} else if (widget.type === "below") {
			const [startColumn] = widget.pos.x;
			const startCol0 = startColumn - 1;
			if (startCol0 >= lineStartColumn && startCol0 < lineEndColumn) belowWidgets.push(widget);
		} else if (widget.type === "overlay") {
			const [startColumn] = widget.pos.x;
			const startCol0 = startColumn - 1;
			if (startCol0 >= lineStartColumn && startCol0 < lineEndColumn) overlayWidgets.push(widget);
		} else if (widget.type === "full") fullWidgets.push(widget);
		else if (widget.type === "before" || widget.type === "after") {
			const widgetColumn = widget.pos.x - 1;
			if (widgetColumn >= lineStartColumn && widgetColumn <= lineEndColumn) beforeAfterWidgets.push(widget);
		} else if (widget.type === "inlay") {
			const widgetColumn = widget.pos.x - 1;
			if (widgetColumn >= lineStartColumn && widgetColumn <= lineEndColumn) inlayWidgets.push(widget);
		}
	}
	const lineHeight$1 = settings$1.lineHeight * (belowWidgets.length > 0 ? 2 : 1);
	const filteredErrors = [];
	for (let i$6 = 0; i$6 < lineErrors.length; i$6++) {
		const error$1 = lineErrors[i$6];
		const [errorStartColumn, errorEndColumn] = [error$1.x[0] - 1, error$1.x[1] - 1];
		if (errorStartColumn <= lineEndColumn && errorEndColumn > lineStartColumn) filteredErrors.push(error$1);
	}
	return {
		tokens: visualTokens,
		logicalLine,
		tokenOffset,
		y: y$5,
		width: calculatedWidth,
		height: lineHeight$1,
		widgets: {
			above: aboveWidgets,
			below: belowWidgets,
			overlay: overlayWidgets,
			inlay: inlayWidgets,
			beforeAfter: beforeAfterWidgets,
			full: fullWidgets
		},
		errors: filteredErrors
	};
}
function filterErrorsFromLine(lineErrors, tokenOffset, lineLength, logicalLineTokens) {
	const logicalColumnPrefix = createTokenColumnPrefix(logicalLineTokens);
	const lineStartColumn = logicalColumnPrefix[tokenOffset] ?? 0;
	const lineEndColumn = logicalColumnPrefix[tokenOffset + lineLength] ?? lineStartColumn;
	const out = [];
	for (let i$6 = 0; i$6 < lineErrors.length; i$6++) {
		const error$1 = lineErrors[i$6];
		const [errorStartColumn, errorEndColumn] = [error$1.x[0] - 1, error$1.x[1] - 1];
		if (errorStartColumn <= lineEndColumn && errorEndColumn > lineStartColumn) out.push(error$1);
	}
	return out;
}
function calculateVisualTokens(c$7, settings$1, caches, tokens, tokenOffset, inlineWidgetWidthIndex, logicalColumnPrefix, logicalTokenIndices, tokenWidths) {
	const visualTokens = [];
	let x$4 = 0;
	for (let i$6 = 0; i$6 < tokens.length; i$6++) {
		const token = tokens[i$6];
		const logicalTokenIndex = logicalTokenIndices ? logicalTokenIndices[i$6] : tokenOffset + i$6;
		const tokenStartColumn = logicalColumnPrefix[logicalTokenIndex] ?? 0;
		const tokenEndColumn = logicalColumnPrefix[logicalTokenIndex + 1] ?? tokenStartColumn;
		const beforeWidth = inlineWidgetWidthIndex.before.get(tokenStartColumn) ?? 0;
		const afterWidth = inlineWidgetWidthIndex.after.get(tokenEndColumn) ?? 0;
		const inlayWidth = inlineWidgetWidthIndex.inlay.get(tokenEndColumn) ?? 0;
		const tokenStartX = x$4 + beforeWidth;
		const tokenEndX = tokenStartX + (tokenWidths ? tokenWidths[i$6] : measureText(c$7, settings$1, caches, token).width);
		x$4 = tokenEndX + afterWidth + inlayWidth;
		visualTokens.push({
			token,
			x: tokenStartX,
			tokenEndX,
			endX: x$4,
			logicalTokenIndex
		});
	}
	return visualTokens;
}
function createInlineWidgetWidthIndex(c$7, settings$1, caches, widgets) {
	const before = /* @__PURE__ */ new Map();
	const after = /* @__PURE__ */ new Map();
	const inlay = /* @__PURE__ */ new Map();
	for (const widget of widgets) {
		const column = widget.pos.x - 1;
		if (widget.type === "before") before.set(column, (before.get(column) ?? 0) + widget.pos.width);
		else if (widget.type === "after") after.set(column, (after.get(column) ?? 0) + widget.pos.width);
		else if (widget.type === "inlay") {
			const { width: widgetWidth } = measureText(c$7, settings$1, caches, {
				text: widget.content,
				type: "text"
			});
			inlay.set(column, (inlay.get(column) ?? 0) + widgetWidth);
		}
	}
	return {
		before,
		after,
		inlay
	};
}
function breakToken(c$7, settings$1, caches, token, maxWidth) {
	if (measureText(c$7, settings$1, caches, token).width <= maxWidth) return [token];
	const text = token.text;
	const parts = [];
	let start = 0;
	const { fontSize: fontSize$1, fontFamilyName: fontFamilyName$1, theme: { [token.type]: { style, weight } } } = settings$1;
	const punct = ".,;:!?-_/\\|()[]{}<>=+*&%$#@^~`\"'";
	const isBreakPunct = (ch) => punct.includes(ch);
	c$7.save();
	c$7.font = `${weight === "bold" ? 700 : 400} ${style} ${fontSize$1} '${fontFamilyName$1}', monospace`;
	const measureWidth = (from, to) => c$7.measureText(text.slice(from, to)).width;
	while (start < text.length) {
		let best = start;
		if (measureWidth(start, start + 1) <= maxWidth) {
			let lo = start + 1;
			let hi = text.length;
			while (lo <= hi) {
				const mid = lo + hi >> 1;
				if (measureWidth(start, mid) <= maxWidth) {
					best = mid;
					lo = mid + 1;
				} else hi = mid - 1;
			}
		}
		if (best === start) best = start + 1;
		let breakPos = best;
		for (let i$6 = best - 1; i$6 >= start; i$6--) {
			const ch = text[i$6];
			if (ch === " " || ch === "	") {
				breakPos = i$6 + 1;
				break;
			}
		}
		if (breakPos === best) {
			for (let i$6 = start; i$6 < best; i$6++) if (isBreakPunct(text[i$6])) {
				breakPos = i$6 + 1;
				break;
			}
		}
		if (breakPos === start) breakPos = start + 1;
		parts.push({
			type: token.type,
			text: text.slice(start, breakPos)
		});
		start = breakPos;
	}
	c$7.restore();
	return parts.length > 0 ? parts : [token];
}
function applyCachedY(cached, y$5) {
	const yOffset = y$5 - (cached[0]?.y ?? y$5);
	if (yOffset === 0) return cached;
	return cached.map((line) => ({
		...line,
		y: line.y + yOffset
	}));
}
function wrapTokens(c$7, settings$1, caches, tokenLines, tokens, logicalLine, y$5, maxWidth, lineWidgets, lineErrors) {
	const { wrapTokensCache, wrapTokensCacheByLine } = caches;
	const cacheKey = getWrapTokensCacheKey(tokens, logicalLine, maxWidth, lineWidgets, lineErrors, settings$1);
	if (wrapTokensCache) {
		if (wrapTokensCacheByLine) {
			const existingKey = wrapTokensCacheByLine.get(logicalLine);
			if (existingKey === cacheKey) {
				const cached$1 = wrapTokensCache.get(existingKey);
				if (cached$1) return applyCachedY(cached$1, y$5);
			}
		}
		const cached = wrapTokensCache.get(cacheKey);
		if (cached) {
			if (wrapTokensCacheByLine) wrapTokensCacheByLine.set(logicalLine, cacheKey);
			return applyCachedY(cached, y$5);
		}
	}
	if (tokens.length === 0) {
		const aboveWidgets = lineWidgets.filter((w$5) => w$5.type === "above").filter((widget) => {
			const [startColumn, endColumn] = widget.pos.x;
			const startCol0 = startColumn - 1;
			const endCol0 = endColumn - 1;
			return startCol0 <= 0 && endCol0 > 0;
		});
		const result$1 = [{
			tokens: [],
			logicalLine,
			tokenOffset: 0,
			y: y$5,
			width: 0,
			height: settings$1.lineHeight,
			widgets: {
				above: aboveWidgets,
				below: [],
				overlay: [],
				inlay: [],
				beforeAfter: [],
				full: []
			},
			errors: filterErrorsFromLine(lineErrors, 0, 0, tokenLines[logicalLine] ?? [])
		}];
		if (wrapTokensCache) {
			wrapTokensCache.set(cacheKey, result$1);
			if (wrapTokensCacheByLine) wrapTokensCacheByLine.set(logicalLine, cacheKey);
		}
		return result$1;
	}
	const visualLines = [];
	const currentLine = [];
	const currentLineLogicalIndices = [];
	const inlineWidgetWidthIndex = createInlineWidgetWidthIndex(c$7, settings$1, caches, lineWidgets.filter((w$5) => w$5.type === "before" || w$5.type === "after" || w$5.type === "inlay"));
	let currentY = y$5;
	let currentLineWidth = 0;
	const currentLineTokenWidths = [];
	const logicalColumnPrefix = createTokenColumnPrefix(tokenLines[logicalLine] ?? []);
	function flushCurrentLine() {
		if (currentLine.length === 0) return;
		const visualLine = createVisualLineFromCurrent(currentLine, currentLineLogicalIndices[0] ?? 0, currentY, logicalLine, c$7, settings$1, caches, lineWidgets, lineErrors, inlineWidgetWidthIndex, logicalColumnPrefix, currentLineLogicalIndices, currentLineTokenWidths);
		visualLines.push(visualLine);
		currentY += visualLine.height;
		currentLine.length = 0;
		currentLineLogicalIndices.length = 0;
		currentLineTokenWidths.length = 0;
		currentLineWidth = 0;
	}
	function tryAddTokenToCurrentLine(token, logicalTokenIndex, tokenWidth) {
		const tokenStartColumn = logicalColumnPrefix[logicalTokenIndex] ?? 0;
		const tokenEndColumn = logicalColumnPrefix[logicalTokenIndex + 1] ?? tokenStartColumn;
		const beforeWidth = inlineWidgetWidthIndex.before.get(tokenStartColumn) ?? 0;
		const afterWidth = inlineWidgetWidthIndex.after.get(tokenEndColumn) ?? 0;
		const inlayWidth = inlineWidgetWidthIndex.inlay.get(tokenEndColumn) ?? 0;
		const addedWidth = beforeWidth + tokenWidth + afterWidth + inlayWidth;
		const newWidth = currentLineWidth + addedWidth;
		if (newWidth > maxWidth && currentLine.length > 0) {
			flushCurrentLine();
			currentLineWidth = beforeWidth + tokenWidth + afterWidth + inlayWidth;
			currentLine.push(token);
			currentLineLogicalIndices.push(logicalTokenIndex);
			currentLineTokenWidths.push(tokenWidth);
			return currentLineWidth;
		}
		currentLineWidth = newWidth;
		currentLine.push(token);
		currentLineLogicalIndices.push(logicalTokenIndex);
		currentLineTokenWidths.push(tokenWidth);
		return currentLineWidth;
	}
	for (let logicalIndex = 0; logicalIndex < tokens.length; logicalIndex++) {
		const token = tokens[logicalIndex];
		const tokenWidth = measureText(c$7, settings$1, caches, token).width;
		if (tokenWidth > maxWidth) {
			const brokenTokens = breakToken(c$7, settings$1, caches, token, maxWidth);
			for (let i$6 = 0; i$6 < brokenTokens.length; i$6++) {
				const brokenToken = brokenTokens[i$6];
				const brokenTokenWidth = measureText(c$7, settings$1, caches, brokenToken).width;
				tryAddTokenToCurrentLine(brokenToken, logicalIndex, brokenTokenWidth);
			}
		} else tryAddTokenToCurrentLine(token, logicalIndex, tokenWidth);
	}
	flushCurrentLine();
	const result = visualLines.length > 0 ? visualLines : [{
		tokens: [],
		logicalLine,
		tokenOffset: 0,
		y: y$5,
		width: 0,
		height: settings$1.lineHeight,
		widgets: {
			above: lineWidgets.filter((w$5) => w$5.type === "above"),
			below: [],
			overlay: [],
			inlay: [],
			beforeAfter: [],
			full: lineWidgets.filter((w$5) => w$5.type === "full")
		},
		errors: filterErrorsFromLine(lineErrors, 0, 0, tokenLines[logicalLine] ?? [])
	}];
	if (wrapTokensCache) {
		wrapTokensCache.set(cacheKey, result);
		if (wrapTokensCacheByLine) wrapTokensCacheByLine.set(logicalLine, cacheKey);
	}
	return result;
}
function createLines(doc, canvas, metrics, settings$1, caches, blocks, header) {
	const totalWidth = c$3(0);
	const totalHeight = c$3(0);
	const visualLines = b(() => {
		const tokenLines = doc.tokenLines;
		header.value;
		const baseAvailableWidth = canvas.size.width.value - settings$1.paddingLeft - settings$1.paddingRight - metrics.gutterWidth.value;
		const maxWidth = settings$1.wordWrap ? baseAvailableWidth - 12 : Infinity;
		const widgetsByLogicalLine = /* @__PURE__ */ new Map();
		for (const widget of doc.widgets) {
			const line = widget.pos.y - 1;
			const existing = widgetsByLogicalLine.get(line);
			if (existing) existing.push(widget);
			else widgetsByLogicalLine.set(line, [widget]);
		}
		const errorsByLogicalLine = /* @__PURE__ */ new Map();
		for (const error$1 of doc.errors) {
			const line = error$1.y - 1;
			const existing = errorsByLogicalLine.get(line);
			if (existing) existing.push(error$1);
			else errorsByLogicalLine.set(line, [error$1]);
		}
		const visualLines$1 = [];
		let logicalLine = 0;
		let maxLineWidth = 0;
		let y$5 = 0;
		const collapsedLines = doc.collapsed;
		let skipUntil = -1;
		for (const tokens of tokenLines) {
			if (logicalLine > skipUntil) {
				const lineWidgets = widgetsByLogicalLine.get(logicalLine) ?? [];
				const lineErrors = errorsByLogicalLine.get(logicalLine) ?? [];
				const wrapped = wrapTokens(canvas.c, settings$1, caches, tokenLines, tokens, logicalLine, y$5, maxWidth, lineWidgets, lineErrors);
				for (let i$6 = 0; i$6 < wrapped.length; i$6++) visualLines$1.push(wrapped[i$6]);
				const last = wrapped[wrapped.length - 1];
				y$5 = (last?.y ?? y$5) + (last?.height ?? 0);
				for (let i$6 = 0; i$6 < wrapped.length; i$6++) if (wrapped[i$6].width > maxLineWidth) maxLineWidth = wrapped[i$6].width;
				if (collapsedLines.has(logicalLine)) skipUntil = blocks.blockEnds.value.get(logicalLine) ?? -1;
			}
			logicalLine++;
		}
		if (settings$1.wordWrap) totalWidth.value = Math.min(maxLineWidth, baseAvailableWidth - 12);
		else totalWidth.value = maxLineWidth;
		const processedLines = applyAboveWidgetSpace(doc, visualLines$1, widgetsByLogicalLine);
		totalHeight.value = processedLines.length > 0 ? processedLines[processedLines.length - 1].y + processedLines[processedLines.length - 1].height : y$5;
		return processedLines;
	});
	const visualLinesByLogicalLine = b(() => {
		const map = /* @__PURE__ */ new Map();
		for (const line of visualLines.value) {
			const existing = map.get(line.logicalLine);
			if (existing) existing.push(line);
			else map.set(line.logicalLine, [line]);
		}
		return map;
	});
	m(() => {
		settings$1.wordWrap;
		totalWidth.value = 0;
	});
	return {
		visualLines,
		visualLinesByLogicalLine,
		totalWidth,
		totalHeight
	};
}
function createMetrics() {
	return {
		gutterWidth: c$3(0),
		visibleLines: c$3({
			start: 0,
			end: 0
		})
	};
}
function createScrollbars(canvas, scroll, lines, settings$1, gutter, header) {
	const isDragging = c$3(false);
	let dragType = null;
	let dragStartX = 0;
	let dragStartY = 0;
	let dragStartScrollX = 0;
	let dragStartScrollY = 0;
	const handleMouseMove = (x$4, y$5) => {
		if (!isDragging.value || !dragType) return;
		const width = canvas.size.width.value;
		const height = canvas.size.height.value;
		const totalWidth = lines.totalWidth.value;
		const totalHeight = lines.totalHeight.value;
		const headerHeight = header.value?.height ?? 0;
		const availableHeightForVertical = height - headerHeight - settings$1.paddingTop - settings$1.paddingBottom;
		if (dragType === "vertical") {
			const availableHeight = availableHeightForVertical;
			const trackHeight = height - headerHeight;
			const thumbHeight = Math.max(20, availableHeight / totalHeight * trackHeight);
			const dragDelta = y$5 - dragStartY;
			const trackLength = trackHeight - thumbHeight;
			const scrollRange = -scroll.scrollHeight.value;
			if (trackLength > 0 && scrollRange > 0) {
				const scrollRatio = dragDelta / trackLength;
				scroll.targetY.value = dragStartScrollY - scrollRatio * scrollRange;
			}
		} else if (dragType === "horizontal") {
			const availableWidth = width - settings$1.paddingLeft - settings$1.paddingRight - gutter.width.value;
			const trackWidth = width - (totalHeight > availableHeightForVertical ? 12 : 0);
			const thumbWidth = Math.max(20, availableWidth / totalWidth * trackWidth);
			const dragDelta = x$4 - dragStartX;
			const trackLength = trackWidth - thumbWidth;
			const scrollRange = -scroll.scrollWidth.value;
			if (trackLength > 0 && scrollRange > 0) {
				const scrollRatio = dragDelta / trackLength;
				scroll.targetX.value = dragStartScrollX - scrollRatio * scrollRange;
			}
		}
	};
	const handleMouseDown = (x$4, y$5) => {
		const headerHeight = header.value?.height ?? 0;
		const hit = hitTestScrollbar(canvas, scroll, lines, settings$1, gutter, header, x$4, y$5);
		if (!hit.type) return false;
		const width = canvas.size.width.value;
		const height = canvas.size.height.value;
		const totalWidth = lines.totalWidth.value;
		const totalHeight = lines.totalHeight.value;
		const scrollWidth = scroll.scrollWidth.value;
		const scrollHeight = scroll.scrollHeight.value;
		if (hit.type && hit.thumb) {
			isDragging.value = true;
			dragType = hit.type;
			dragStartX = x$4;
			dragStartY = y$5;
			dragStartScrollX = scroll.targetX.value;
			dragStartScrollY = scroll.targetY.value;
			return true;
		} else if (hit.type && !hit.thumb) {
			if (hit.type === "vertical") {
				const availableHeight = height - headerHeight - settings$1.paddingTop - settings$1.paddingBottom;
				const trackHeight = height - headerHeight;
				const thumbHeight = Math.max(20, availableHeight / totalHeight * trackHeight);
				const trackLength = trackHeight - thumbHeight;
				const scrollRange = -scrollHeight;
				if (trackLength > 0 && scrollRange > 0) {
					const clickRatio = (y$5 - headerHeight - thumbHeight / 2) / trackLength;
					const newScrollY = -Math.max(0, Math.min(1, clickRatio)) * scrollRange;
					scroll.targetY.value = newScrollY;
					isDragging.value = true;
					dragType = "vertical";
					dragStartX = x$4;
					dragStartY = y$5;
					dragStartScrollX = scroll.targetX.value;
					dragStartScrollY = newScrollY;
					return true;
				}
			} else if (hit.type === "horizontal") {
				const availableHeight = height - headerHeight - settings$1.paddingTop - settings$1.paddingBottom;
				const availableWidth = width - settings$1.paddingLeft - settings$1.paddingRight - gutter.width.value;
				const trackWidth = width - (totalHeight > availableHeight ? 12 : 0);
				const thumbWidth = Math.max(20, availableWidth / totalWidth * trackWidth);
				const trackLength = trackWidth - thumbWidth;
				const scrollRange = -scrollWidth;
				if (trackLength > 0 && scrollRange > 0) {
					const clickRatio = (x$4 - thumbWidth / 2) / trackLength;
					const newScrollX = -Math.max(0, Math.min(1, clickRatio)) * scrollRange;
					scroll.targetX.value = newScrollX;
					isDragging.value = true;
					dragType = "horizontal";
					dragStartX = x$4;
					dragStartY = y$5;
					dragStartScrollX = newScrollX;
					dragStartScrollY = scroll.targetY.value;
					return true;
				}
			}
		}
		return false;
	};
	const handleMouseUp = (x$4, y$5) => {
		if (!isDragging.value) return null;
		isDragging.value = false;
		dragType = null;
		return hitTestScrollbar(canvas, scroll, lines, settings$1, gutter, header, x$4, y$5).type;
	};
	return {
		isDragging,
		handleMouseMove,
		handleMouseDown,
		handleMouseUp
	};
}
function createSelection() {
	const start = c$3({
		line: -1,
		column: -1
	});
	const end = c$3({
		line: -1,
		column: -1
	});
	const direction = c$3(null);
	const isSelecting = c$3(false);
	let offscreen = null;
	const clear = () => {
		start.value = {
			line: -1,
			column: -1
		};
		end.value = {
			line: -1,
			column: -1
		};
		direction.value = null;
	};
	const setStart = (line, column) => {
		start.value = {
			line,
			column
		};
		end.value = {
			line,
			column
		};
		direction.value = null;
	};
	const setEnd = (line, column) => {
		if (start.value.line === -1 || start.value.column === -1) start.value = {
			line,
			column
		};
		end.value = {
			line,
			column
		};
		if (start.value.line !== -1 && start.value.column !== -1) if (line > start.value.line || line === start.value.line && column > start.value.column) direction.value = "forward";
		else if (line < start.value.line || line === start.value.line && column < start.value.column) direction.value = "backward";
		else direction.value = null;
	};
	const hasSelection = b(() => {
		if (start.value.line === -1 || start.value.column === -1 || end.value.line === -1 || end.value.column === -1) return false;
		return start.value.line !== end.value.line || start.value.line === end.value.line && start.value.column !== end.value.column;
	});
	const getOrdered = b(() => {
		if (start.value.line === -1 || start.value.column === -1 || end.value.line === -1 || end.value.column === -1) return null;
		if (!hasSelection.value) return null;
		if (start.value.line < end.value.line || start.value.line === end.value.line && start.value.column < end.value.column) return {
			start: start.value,
			end: end.value
		};
		return {
			start: end.value,
			end: start.value
		};
	});
	const getOffscreenCanvas = (width, height, dpr) => {
		const validWidth = Math.max(1, Math.floor(width)) || 1;
		const validHeight = Math.max(1, Math.floor(height)) || 1;
		const validDpr = Math.max(1, dpr) || 1;
		const scaledWidth = Math.floor(validWidth * validDpr);
		const scaledHeight = Math.floor(validHeight * validDpr);
		if (!offscreen) {
			const canvas = new OffscreenCanvas(scaledWidth, scaledHeight);
			const c$7 = canvas.getContext("2d");
			if (!c$7) throw new Error("Could not get 2D context from OffscreenCanvas");
			c$7.scale(validDpr, validDpr);
			offscreen = {
				canvas,
				c: c$7
			};
			return offscreen;
		}
		if (offscreen.canvas.width !== scaledWidth || offscreen.canvas.height !== scaledHeight) {
			offscreen.canvas.width = scaledWidth;
			offscreen.canvas.height = scaledHeight;
			offscreen.c.setTransform(1, 0, 0, 1, 0, 0);
			offscreen.c.scale(validDpr, validDpr);
		}
		return offscreen;
	};
	return {
		start,
		end,
		direction,
		isSelecting,
		clear,
		setStart,
		setEnd,
		hasSelection,
		getOrdered,
		getOffscreenCanvas
	};
}
function memoizeByRef$1(fn$1, map = /* @__PURE__ */ new Map()) {
	function wrapped(arg, ...args) {
		if (map.has(arg)) return map.get(arg);
		let res;
		map.set(arg, res = fn$1.call(this, arg, ...args));
		return res;
	}
	return wrapped;
}
function isObject(v$4) {
	return typeof v$4 === "object" && v$4 !== null && !Array.isArray(v$4);
}
var typedArrayCtor = Int8Array.__proto__;
function isArrayLike(v$4) {
	return Array.isArray(v$4) || v$4 instanceof typedArrayCtor;
}
function isFunction(x$4) {
	return typeof x$4 === "function";
}
memoizeByRef$1(function isCtor$1(v$4) {
	return isFunction(v$4) && v$4.toString().startsWith("class");
});
function deepMerge(dst, src, depth = Infinity, exclude) {
	src ??= {};
	for (const key in src) {
		let value = src[key];
		let current = dst[key];
		if (isObject(value) && isObject(current) && !isArrayLike(current) && !exclude?.(value)) if (!depth) dst[key] = value;
		else if (depth === 1) Object.assign(current, value);
		else deepMerge(current, value, depth - 1, exclude);
		else dst[key] = value;
	}
	return dst;
}
var lineHeight = 18;
var fontSize = "11pt";
var fontFamilyName = "LigaSpaceMono";
var fontFamilies = [
	{
		name: fontFamilyName,
		url: "/LigaSpaceMono-Regular.ttf",
		weight: "normal",
		style: "normal"
	},
	{
		name: fontFamilyName,
		url: "/LigaSpaceMono-Bold.ttf",
		weight: "bold",
		style: "normal"
	},
	{
		name: fontFamilyName,
		url: "/LigaSpaceMono-Italic.ttf",
		weight: "normal",
		style: "italic"
	},
	{
		name: fontFamilyName,
		url: "/LigaSpaceMono-BoldItalic.ttf",
		weight: "bold",
		style: "italic"
	}
];
const defaultColors = {
	black: "#000000",
	red: "#ff0000",
	green: "#00ff00",
	yellow: "#ffff00",
	blue: "#0000ff",
	purple: "#ff00ff",
	cyan: "#00ffff",
	white: "#eeeeee",
	gray: "#808080",
	brightBlack: "#666666",
	brightRed: "#ff7777",
	brightGreen: "#77ff77",
	brightYellow: "#ffff77",
	brightBlue: "#7777ff",
	brightPurple: "#ff77ff",
	brightCyan: "#77ffff",
	brightWhite: "#ffffff"
};
var defaultSyntax = (c$7) => ({
	keyword: {
		color: c$7.brightBlue,
		style: "italic",
		weight: "regular"
	},
	function: {
		color: c$7.green,
		style: "normal",
		weight: "regular"
	},
	identifier: {
		color: c$7.white,
		style: "normal",
		weight: "regular"
	},
	string: {
		color: c$7.yellow,
		style: "normal",
		weight: "regular"
	},
	number: {
		color: c$7.cyan,
		style: "normal",
		weight: "regular"
	},
	boolean: {
		color: c$7.red,
		style: "normal",
		weight: "regular"
	},
	null: {
		color: c$7.blue,
		style: "normal",
		weight: "regular"
	},
	operator: {
		color: c$7.purple,
		style: "normal",
		weight: "regular"
	},
	punctuation: {
		color: c$7.white,
		style: "normal",
		weight: "regular"
	},
	comment: {
		color: c$7.gray,
		style: "normal",
		weight: "regular"
	},
	text: {
		color: c$7.white,
		style: "normal",
		weight: "regular"
	}
});
var defaultSettings = {
	lineHeight,
	fontSize,
	fontFamilyName,
	fontFamilies,
	wordWrap: false,
	autoHeight: false,
	rect: null,
	paddingLeft: 20,
	paddingTop: 20,
	paddingRight: 20,
	paddingBottom: 20,
	caretMarginY: 100,
	caretMarginX: 100,
	caretPhaseCoeff: 1,
	colors: signalify$1(defaultColors),
	syntax: defaultSyntax,
	lineComment: "//",
	blockComment: ["/*", "*/"],
	minGutterDigits: 2,
	showGutter: true
};
function createSettings(editorSettings$1 = {}) {
	return signalify$1({
		...deepMerge(deepMerge({}, defaultSettings), editorSettings$1),
		get ui() {
			return {
				background: this.colors.black,
				blockColors: [
					this.colors.brightYellow,
					this.colors.brightBlue,
					this.colors.brightPurple
				]
			};
		},
		get theme() {
			return this.syntax(this.colors);
		}
	});
}
let Position = /* @__PURE__ */ function(Position$1) {
	Position$1[Position$1["TopLeft"] = 0] = "TopLeft";
	Position$1[Position$1["TopRight"] = 1] = "TopRight";
	Position$1[Position$1["BottomLeft"] = 2] = "BottomLeft";
	Position$1[Position$1["BottomRight"] = 3] = "BottomRight";
	return Position$1;
}({});
function createContext(editorSettings$1, doc, activeEditorOpts) {
	let onHoverToken = null;
	let onCaretToken = null;
	const settings$1 = createSettings(editorSettings$1);
	const canvas = createCanvas(settings$1);
	const caches = createCaches(canvas, settings$1, doc);
	const metrics = createMetrics();
	const blocks = createBlocks(doc, caches);
	const header = c$3(null);
	const lines = createLines(doc, canvas, metrics, settings$1, caches, blocks, header);
	const gutter = createGutter(doc, canvas, metrics, settings$1, caches, blocks, lines);
	const scroll = createScroll(canvas, lines, settings$1, gutter, header, metrics);
	const scrollbars = createScrollbars(canvas, scroll, lines, settings$1, gutter, header);
	const caret = createCaret(settings$1);
	const selection = createSelection();
	let pinnedError = null;
	let tooltipDismissed = false;
	const notifyActivated = () => activeEditorOpts?.setActiveEditor(activeEditorOpts.editorRef.current);
	const mouse = createMouse(canvas, scroll, lines, settings$1, caches, doc, caret, scrollbars, selection, gutter, blocks, header, notifyActivated);
	const keyboard = createKeyboard(doc, canvas, scroll, lines, metrics, settings$1, caret, caches, selection, blocks, header, mouse, () => {
		pinnedError = null;
		tooltipDismissed = true;
	}, activeEditorOpts);
	const reset$2 = () => {
		n(() => {
			scroll.pos.x = Infinity;
			scroll.pos.y = Infinity;
			scroll.targetX.value = Infinity;
			scroll.targetY.value = Infinity;
		});
	};
	const dispose = () => {
		canvas.dispose();
		caches.dispose();
		keyboard.dispose();
		mouse.dispose();
	};
	return {
		settings: settings$1,
		doc,
		get pinnedError() {
			return pinnedError;
		},
		set pinnedError(v$4) {
			pinnedError = v$4;
		},
		get tooltipDismissed() {
			return tooltipDismissed;
		},
		set tooltipDismissed(v$4) {
			tooltipDismissed = v$4;
		},
		canvas,
		scroll,
		scrollbars,
		mouse,
		keyboard,
		caret,
		selection,
		lines,
		caches,
		metrics,
		gutter,
		blocks,
		header,
		get onHoverToken() {
			return onHoverToken;
		},
		set onHoverToken(value) {
			onHoverToken = value;
		},
		get onCaretToken() {
			return onCaretToken;
		},
		set onCaretToken(value) {
			onCaretToken = value;
		},
		reset: reset$2,
		dispose
	};
}
function debounce$1(ms, fn$1, options$2) {
	let resolving = false;
	let timeToResolve;
	let now;
	let delta;
	let callThis;
	let callArgs;
	function resolver() {
		now = performance.now();
		delta = timeToResolve - now;
		if (delta > 5) setTimeout(resolver, delta);
		else if (callArgs) {
			fn$1.apply(callThis, callArgs);
			resolving = false;
		}
	}
	function wrapper(...args) {
		callThis = this;
		callArgs = args;
		timeToResolve = performance.now() + ms;
		if (resolving) return;
		if (options$2?.first) {
			fn$1.apply(callThis, callArgs);
			if (!options$2.last) callArgs = void 0;
		}
		resolving = true;
		setTimeout(resolver, ms);
	}
	return wrapper;
}
function tokenize$3(code) {
	return code.split("\n").map((x$4) => [...x$4.matchAll(/\s+|.+/g)].filter((x$5) => x$5[0] !== "").map((text) => ({
		text: text[0],
		type: "text"
	})));
}
function createDoc(tokenize$4 = tokenize$3) {
	const buffer = createBuffer("");
	const doc = signalify$1({
		epoch: 0,
		get code() {
			return buffer.code.value;
		},
		set code(value) {
			buffer.code.value = value;
		},
		buffer,
		onChange: buffer.onChange,
		caret: signalify$1({
			line: 0,
			column: 0,
			columnIntent: 0
		}),
		scroll: signalify$1({
			x: 0,
			y: 0
		}),
		collapsed: /* @__PURE__ */ new Set(),
		selection: signalify$1({
			start: signalify$1({
				line: 0,
				column: 0
			}),
			end: signalify$1({
				line: 0,
				column: 0
			}),
			direction: null
		}),
		errors: [],
		widgets: [],
		tokenize: tokenize$4,
		get lines() {
			return buffer.lines.value;
		},
		get tokenLines() {
			return this.tokenize(buffer.code.value);
		},
		replace(index, length, text) {
			buffer.replace(index, length, text);
		}
	});
	m(() => {
		doc.code;
		o$24(() => doc.epoch++);
	});
	return doc;
}
var debouncedSetItem$1 = debounce$1(50, (key, json) => {
	localStorage.setItem(key, JSON.stringify(json()));
});
function persist$1(key, watch, json, read) {
	o$24(() => n(() => read(JSON.parse(localStorage.getItem(key) || "{}"))));
	m(() => {
		watch();
		debouncedSetItem$1(key, json);
	});
}
function createPersistedDoc(key, tokenize$4 = tokenize$3, doc = createDoc(tokenize$4)) {
	persist$1(key, () => {
		doc.code;
		doc.caret.line;
		doc.caret.column;
		doc.scroll.x;
		doc.scroll.y;
		doc.collapsed;
		doc.selection.start.line;
		doc.selection.start.column;
		doc.selection.end.line;
		doc.selection.end.column;
		doc.selection.direction;
	}, () => ({
		buffer: doc.buffer.pack(),
		caret: doc.caret,
		scroll: doc.scroll,
		collapsed: [...doc.collapsed],
		selection: doc.selection
	}), (data) => {
		if (data.buffer) {
			const restoredBuffer = unpack(data.buffer);
			doc.buffer.code.value = restoredBuffer.code.value;
			doc.buffer.history.value = restoredBuffer.history.value;
			doc.buffer.index.value = restoredBuffer.index.value;
		}
		Object.assign(doc.caret, data.caret ?? {
			line: 0,
			column: 0,
			columnIntent: 0
		});
		Object.assign(doc.scroll, data.scroll ?? {
			x: 0,
			y: 0
		});
		doc.collapsed = new Set(data.collapsed ?? []);
		Object.assign(doc.selection, data.selection ?? {
			start: {
				line: 0,
				column: 0
			},
			end: {
				line: 0,
				column: 0
			},
			direction: null
		});
	});
	return doc;
}
function disposables() {
	const effects = [];
	const dispose = () => {
		effects.forEach((dispose$1) => dispose$1());
		effects.length = 0;
		return effects;
	};
	dispose.dispose = dispose;
	return dispose;
}
function createRender(context) {
	renderManager.register(context);
	return { dispose: () => renderManager.unregister(context) };
}
var loadedUrls = /* @__PURE__ */ new Map();
async function loadFonts(fontFamilies$1) {
	let promises = [];
	for (const font of fontFamilies$1) {
		if (!loadedUrls.has(font.url)) {
			loadedUrls.set(font.url, Deferred$2());
			const fontFace = new FontFace(font.name, `url(${font.url})`, {
				weight: font.weight,
				style: font.style,
				display: "block"
			});
			fontFace.load().then(() => {
				document.fonts.add(fontFace);
				loadedUrls.get(font.url).resolve();
			});
		}
		promises.push(loadedUrls.get(font.url).promise);
	}
	await Promise.all(promises);
}
async function warmupLigatures(context, tokenLines) {
	const tokens = tokenLines.flat().filter((token) => ligatures.has(token.text));
	const c$7 = new OffscreenCanvas(1, 1).getContext("2d");
	for (const token of tokens) {
		const { promise } = drawToken(c$7, context, token, 0, 0);
		if (promise) await promise;
	}
}
async function warmup(context, tokenLines) {
	await Promise.all([
		loadFonts(context.settings.fontFamilies),
		document.fonts.ready,
		warmupLigatures(context, tokenLines)
	]);
}
const activeEditor = activeEditor$1;
function createEditor(settings$1 = {}) {
	const doc = createDoc(tokenize$3);
	const editorRef = { current: null };
	const context = createContext(settings$1, doc, {
		editorRef,
		setActiveEditor
	});
	let onHoverToken = null;
	let onCaretToken = null;
	let isEditorReady = false;
	let pendingDoc = null;
	const docEffects = disposables();
	const setDoc = async (newDoc) => {
		const effects = docEffects();
		if (!isEditorReady) {
			pendingDoc = newDoc;
			return;
		}
		await warmup(context, newDoc.tokenLines);
		n(() => {
			doc.tokenize = newDoc.tokenize;
			doc.buffer.code.value = newDoc.buffer.code.value;
			doc.buffer.history.value = newDoc.buffer.history.value;
			doc.buffer.index.value = newDoc.buffer.index.value;
		});
		effects.push((() => {
			let applyingFromDoc = false;
			let applyingFromNewDoc = false;
			const applyTo = (target, change) => {
				if (change.deletedText.length) target.buffer.apply({
					type: BufferOpType.Delete,
					start: change.start,
					end: change.start + change.deletedText.length,
					text: change.deletedText
				}, true);
				if (change.insertedText.length) target.buffer.apply({
					type: BufferOpType.Insert,
					index: change.start,
					text: change.insertedText
				}, true);
			};
			const unsubDoc = doc.buffer.onChange((change) => {
				if (applyingFromNewDoc) return;
				if (change.type === "splice") {
					applyingFromDoc = true;
					applyTo(newDoc, change);
					newDoc.buffer.history.value = doc.buffer.history.value;
					newDoc.buffer.index.value = doc.buffer.index.value;
					applyingFromDoc = false;
					return;
				}
				applyingFromDoc = true;
				newDoc.buffer.code.value = change.nextCode;
				newDoc.buffer.history.value = doc.buffer.history.value;
				newDoc.buffer.index.value = doc.buffer.index.value;
				applyingFromDoc = false;
			});
			const unsubNewDoc = newDoc.buffer.onChange((change) => {
				if (applyingFromDoc) return;
				if (change.type === "splice") {
					applyingFromNewDoc = true;
					applyTo(doc, change);
					doc.buffer.history.value = newDoc.buffer.history.value;
					doc.buffer.index.value = newDoc.buffer.index.value;
					applyingFromNewDoc = false;
					return;
				}
				applyingFromNewDoc = true;
				doc.buffer.code.value = change.nextCode;
				doc.buffer.history.value = newDoc.buffer.history.value;
				doc.buffer.index.value = newDoc.buffer.index.value;
				applyingFromNewDoc = false;
			});
			return () => {
				unsubDoc();
				unsubNewDoc();
			};
		})(), m(() => {
			doc.widgets = newDoc.widgets;
		}), m(() => {
			doc.errors = newDoc.errors;
			context.pinnedError = newDoc.errors[0] ?? null;
		}), m(() => {
			doc.collapsed = newDoc.collapsed;
		}), m(() => {
			newDoc.collapsed = doc.collapsed;
		}), m(() => {
			Object.assign(doc.caret, newDoc.caret);
		}), m(() => {
			Object.assign(newDoc.caret, doc.caret);
		}), m(() => {
			Object.assign(doc.scroll, newDoc.scroll);
		}), m(() => {
			Object.assign(newDoc.scroll, doc.scroll);
		}), m(() => {
			Object.assign(doc.selection, newDoc.selection);
		}), m(() => {
			Object.assign(newDoc.selection, doc.selection);
		}));
		context.reset();
	};
	let render;
	const start = async () => {
		try {
			await warmup(context, doc.tokenLines);
			render = createRender(context);
			isEditorReady = true;
		} catch (error$1) {
			console.error(error$1);
		}
	};
	const editorEffects = disposables();
	start().then(() => {
		if (pendingDoc) {
			setDoc(pendingDoc);
			pendingDoc = null;
		}
		editorEffects().push(m(() => {
			context.caret.line.value = doc.caret.line;
			context.caret.column.value = doc.caret.column;
			context.caret.columnIntent.value = doc.caret.columnIntent;
		}), m(() => {
			doc.caret.line = context.caret.line.value;
			doc.caret.column = context.caret.column.value;
			doc.caret.columnIntent = context.caret.columnIntent.value;
		}), m(() => {
			if (context.scroll.targetX.value === Infinity || context.scroll.targetY.value === Infinity) {
				context.scroll.pos.x = doc.scroll.x;
				context.scroll.pos.y = doc.scroll.y;
				context.scroll.targetX.value = doc.scroll.x;
				context.scroll.targetY.value = doc.scroll.y;
			}
		}), m(() => {
			if (context.scroll.targetX.value === Infinity || context.scroll.targetY.value === Infinity) return;
			doc.scroll.x = context.scroll.targetX.value;
			doc.scroll.y = context.scroll.targetY.value;
		}), m(() => {
			context.selection.start.value = doc.selection.start;
			context.selection.end.value = doc.selection.end;
			context.selection.direction.value = doc.selection.direction;
		}), m(() => {
			doc.selection.start = context.selection.start.value;
			doc.selection.end = context.selection.end.value;
			doc.selection.direction = context.selection.direction.value;
		}), m(() => {
			if (context.settings.autoHeight) {
				const availableWidth = context.canvas.size.width.value - context.settings.paddingLeft - context.settings.paddingRight - context.gutter.width.value;
				const scrollbarHeight = !context.settings.wordWrap && context.lines.totalWidth.value > availableWidth ? 3 : 0;
				context.canvas.size.height.value = context.lines.totalHeight.value + (context.header.value?.height ?? 0) + context.settings.paddingTop + context.settings.paddingBottom + scrollbarHeight;
			}
		}));
	});
	const dispose = () => {
		if (activeEditor.value === editor$1) setActiveEditor(null);
		docEffects.dispose();
		editorEffects.dispose();
		render?.dispose();
		context.dispose();
	};
	const editor$1 = {
		canvas: context.canvas.el,
		size: context.canvas.size,
		caret: context.caret,
		setDoc,
		focus: () => {
			activeEditor.value = editor$1;
			context.keyboard.activate();
		},
		settings: context.settings,
		get header() {
			return context.header.value;
		},
		set header(value) {
			context.header.value = value;
		},
		get onHoverToken() {
			return onHoverToken;
		},
		set onHoverToken(value) {
			onHoverToken = value;
			context.onHoverToken = value;
		},
		get onCaretToken() {
			return onCaretToken;
		},
		set onCaretToken(value) {
			onCaretToken = value;
			context.onCaretToken = value;
		},
		dispose
	};
	editorRef.current = editor$1;
	return editor$1;
}
let AudioVmOp = /* @__PURE__ */ function(AudioVmOp$1) {
	AudioVmOp$1[AudioVmOp$1["Out"] = 0] = "Out";
	AudioVmOp$1[AudioVmOp$1["Solo"] = 1] = "Solo";
	AudioVmOp$1[AudioVmOp$1["Post"] = 2] = "Post";
	AudioVmOp$1[AudioVmOp$1["PushScalar"] = 3] = "PushScalar";
	AudioVmOp$1[AudioVmOp$1["PushAudio"] = 4] = "PushAudio";
	AudioVmOp$1[AudioVmOp$1["PushUndefined"] = 5] = "PushUndefined";
	AudioVmOp$1[AudioVmOp$1["SetBpm"] = 6] = "SetBpm";
	AudioVmOp$1[AudioVmOp$1["Time"] = 7] = "Time";
	AudioVmOp$1[AudioVmOp$1["TableLookup"] = 8] = "TableLookup";
	AudioVmOp$1[AudioVmOp$1["Alloc"] = 9] = "Alloc";
	AudioVmOp$1[AudioVmOp$1["Write"] = 10] = "Write";
	AudioVmOp$1[AudioVmOp$1["Read"] = 11] = "Read";
	AudioVmOp$1[AudioVmOp$1["Tram"] = 12] = "Tram";
	AudioVmOp$1[AudioVmOp$1["Mini"] = 13] = "Mini";
	AudioVmOp$1[AudioVmOp$1["Timeline"] = 14] = "Timeline";
	AudioVmOp$1[AudioVmOp$1["Oversample"] = 15] = "Oversample";
	AudioVmOp$1[AudioVmOp$1["MakeArray"] = 16] = "MakeArray";
	AudioVmOp$1[AudioVmOp$1["ArrayGet"] = 17] = "ArrayGet";
	AudioVmOp$1[AudioVmOp$1["ArraySet"] = 18] = "ArraySet";
	AudioVmOp$1[AudioVmOp$1["ArrayLen"] = 19] = "ArrayLen";
	AudioVmOp$1[AudioVmOp$1["ArrayPush"] = 20] = "ArrayPush";
	AudioVmOp$1[AudioVmOp$1["Walk"] = 21] = "Walk";
	AudioVmOp$1[AudioVmOp$1["Glide"] = 22] = "Glide";
	AudioVmOp$1[AudioVmOp$1["Step"] = 23] = "Step";
	AudioVmOp$1[AudioVmOp$1["Random"] = 24] = "Random";
	AudioVmOp$1[AudioVmOp$1["GetSystem"] = 25] = "GetSystem";
	AudioVmOp$1[AudioVmOp$1["GetGlobal"] = 26] = "GetGlobal";
	AudioVmOp$1[AudioVmOp$1["GetLocal"] = 27] = "GetLocal";
	AudioVmOp$1[AudioVmOp$1["SetGlobal"] = 28] = "SetGlobal";
	AudioVmOp$1[AudioVmOp$1["SetLocal"] = 29] = "SetLocal";
	AudioVmOp$1[AudioVmOp$1["GetClosure"] = 30] = "GetClosure";
	AudioVmOp$1[AudioVmOp$1["SetClosure"] = 31] = "SetClosure";
	AudioVmOp$1[AudioVmOp$1["GetCellRefLocal"] = 32] = "GetCellRefLocal";
	AudioVmOp$1[AudioVmOp$1["GetCellRefGlobal"] = 33] = "GetCellRefGlobal";
	AudioVmOp$1[AudioVmOp$1["GetCellRefClosure"] = 34] = "GetCellRefClosure";
	AudioVmOp$1[AudioVmOp$1["DefineFunction"] = 35] = "DefineFunction";
	AudioVmOp$1[AudioVmOp$1["CallFunction"] = 36] = "CallFunction";
	AudioVmOp$1[AudioVmOp$1["Return"] = 37] = "Return";
	AudioVmOp$1[AudioVmOp$1["Throw"] = 38] = "Throw";
	AudioVmOp$1[AudioVmOp$1["PushTryBlock"] = 39] = "PushTryBlock";
	AudioVmOp$1[AudioVmOp$1["PopTryBlock"] = 40] = "PopTryBlock";
	AudioVmOp$1[AudioVmOp$1["Jump"] = 41] = "Jump";
	AudioVmOp$1[AudioVmOp$1["JumpIfFalse"] = 42] = "JumpIfFalse";
	AudioVmOp$1[AudioVmOp$1["JumpIfTrue"] = 43] = "JumpIfTrue";
	AudioVmOp$1[AudioVmOp$1["PushClosure"] = 44] = "PushClosure";
	AudioVmOp$1[AudioVmOp$1["PopScope"] = 45] = "PopScope";
	AudioVmOp$1[AudioVmOp$1["Dup"] = 46] = "Dup";
	AudioVmOp$1[AudioVmOp$1["Pop"] = 47] = "Pop";
	AudioVmOp$1[AudioVmOp$1["Neg"] = 48] = "Neg";
	AudioVmOp$1[AudioVmOp$1["Not"] = 49] = "Not";
	AudioVmOp$1[AudioVmOp$1["BitNot"] = 50] = "BitNot";
	AudioVmOp$1[AudioVmOp$1["Add"] = 51] = "Add";
	AudioVmOp$1[AudioVmOp$1["Sub"] = 52] = "Sub";
	AudioVmOp$1[AudioVmOp$1["Mul"] = 53] = "Mul";
	AudioVmOp$1[AudioVmOp$1["Div"] = 54] = "Div";
	AudioVmOp$1[AudioVmOp$1["Mod"] = 55] = "Mod";
	AudioVmOp$1[AudioVmOp$1["Pow"] = 56] = "Pow";
	AudioVmOp$1[AudioVmOp$1["Greater"] = 57] = "Greater";
	AudioVmOp$1[AudioVmOp$1["Less"] = 58] = "Less";
	AudioVmOp$1[AudioVmOp$1["GreaterEqual"] = 59] = "GreaterEqual";
	AudioVmOp$1[AudioVmOp$1["LessEqual"] = 60] = "LessEqual";
	AudioVmOp$1[AudioVmOp$1["Equal"] = 61] = "Equal";
	AudioVmOp$1[AudioVmOp$1["NotEqual"] = 62] = "NotEqual";
	AudioVmOp$1[AudioVmOp$1["And"] = 63] = "And";
	AudioVmOp$1[AudioVmOp$1["Or"] = 64] = "Or";
	AudioVmOp$1[AudioVmOp$1["BitAnd"] = 65] = "BitAnd";
	AudioVmOp$1[AudioVmOp$1["BitOr"] = 66] = "BitOr";
	AudioVmOp$1[AudioVmOp$1["BitXor"] = 67] = "BitXor";
	AudioVmOp$1[AudioVmOp$1["ShiftLeft"] = 68] = "ShiftLeft";
	AudioVmOp$1[AudioVmOp$1["ShiftRight"] = 69] = "ShiftRight";
	AudioVmOp$1[AudioVmOp$1["IsUndefined"] = 70] = "IsUndefined";
	AudioVmOp$1[AudioVmOp$1["IsScalar"] = 71] = "IsScalar";
	AudioVmOp$1[AudioVmOp$1["IsAudio"] = 72] = "IsAudio";
	AudioVmOp$1[AudioVmOp$1["IsArray"] = 73] = "IsArray";
	AudioVmOp$1[AudioVmOp$1["IsFunction"] = 74] = "IsFunction";
	AudioVmOp$1[AudioVmOp$1["MathUnary"] = 75] = "MathUnary";
	AudioVmOp$1[AudioVmOp$1["MathBinary"] = 76] = "MathBinary";
	AudioVmOp$1[AudioVmOp$1["MathTernary"] = 77] = "MathTernary";
	AudioVmOp$1[AudioVmOp$1["GenPhasor_default"] = 78] = "GenPhasor_default";
	AudioVmOp$1[AudioVmOp$1["GenEvery_default"] = 79] = "GenEvery_default";
	AudioVmOp$1[AudioVmOp$1["GenWhite_default"] = 80] = "GenWhite_default";
	AudioVmOp$1[AudioVmOp$1["GenLfosqr_default"] = 81] = "GenLfosqr_default";
	AudioVmOp$1[AudioVmOp$1["GenLfosah_default"] = 82] = "GenLfosah_default";
	AudioVmOp$1[AudioVmOp$1["GenDc_default"] = 83] = "GenDc_default";
	AudioVmOp$1[AudioVmOp$1["GenGauss_default"] = 84] = "GenGauss_default";
	AudioVmOp$1[AudioVmOp$1["GenImpulse_default"] = 85] = "GenImpulse_default";
	AudioVmOp$1[AudioVmOp$1["GenTestGain_default"] = 86] = "GenTestGain_default";
	AudioVmOp$1[AudioVmOp$1["GenFreeverb_default"] = 87] = "GenFreeverb_default";
	AudioVmOp$1[AudioVmOp$1["GenSaw_default"] = 88] = "GenSaw_default";
	AudioVmOp$1[AudioVmOp$1["GenTestOversample_default"] = 89] = "GenTestOversample_default";
	AudioVmOp$1[AudioVmOp$1["GenSine_default"] = 90] = "GenSine_default";
	AudioVmOp$1[AudioVmOp$1["GenLfosine_default"] = 91] = "GenLfosine_default";
	AudioVmOp$1[AudioVmOp$1["GenSlicer_default"] = 92] = "GenSlicer_default";
	AudioVmOp$1[AudioVmOp$1["GenBrown_default"] = 93] = "GenBrown_default";
	AudioVmOp$1[AudioVmOp$1["GenEuclid_default"] = 94] = "GenEuclid_default";
	AudioVmOp$1[AudioVmOp$1["GenPwm_default"] = 95] = "GenPwm_default";
	AudioVmOp$1[AudioVmOp$1["GenAd_default"] = 96] = "GenAd_default";
	AudioVmOp$1[AudioVmOp$1["GenOnepole_lp1"] = 97] = "GenOnepole_lp1";
	AudioVmOp$1[AudioVmOp$1["GenOnepole_hp1"] = 98] = "GenOnepole_hp1";
	AudioVmOp$1[AudioVmOp$1["GenSqr_default"] = 99] = "GenSqr_default";
	AudioVmOp$1[AudioVmOp$1["GenHold_default"] = 100] = "GenHold_default";
	AudioVmOp$1[AudioVmOp$1["GenLfosaw_default"] = 101] = "GenLfosaw_default";
	AudioVmOp$1[AudioVmOp$1["GenCompressor_default"] = 102] = "GenCompressor_default";
	AudioVmOp$1[AudioVmOp$1["GenEmit_default"] = 103] = "GenEmit_default";
	AudioVmOp$1[AudioVmOp$1["GenFractal_default"] = 104] = "GenFractal_default";
	AudioVmOp$1[AudioVmOp$1["GenLforamp_default"] = 105] = "GenLforamp_default";
	AudioVmOp$1[AudioVmOp$1["GenTri_default"] = 106] = "GenTri_default";
	AudioVmOp$1[AudioVmOp$1["GenPitchshift_default"] = 107] = "GenPitchshift_default";
	AudioVmOp$1[AudioVmOp$1["GenZerox_default"] = 108] = "GenZerox_default";
	AudioVmOp$1[AudioVmOp$1["GenLimiter_default"] = 109] = "GenLimiter_default";
	AudioVmOp$1[AudioVmOp$1["GenAt_default"] = 110] = "GenAt_default";
	AudioVmOp$1[AudioVmOp$1["GenDiodeladder_default"] = 111] = "GenDiodeladder_default";
	AudioVmOp$1[AudioVmOp$1["GenRamp_default"] = 112] = "GenRamp_default";
	AudioVmOp$1[AudioVmOp$1["GenSmooth_default"] = 113] = "GenSmooth_default";
	AudioVmOp$1[AudioVmOp$1["GenLfotri_default"] = 114] = "GenLfotri_default";
	AudioVmOp$1[AudioVmOp$1["GenAdsr_default"] = 115] = "GenAdsr_default";
	AudioVmOp$1[AudioVmOp$1["GenAnalyser_default"] = 116] = "GenAnalyser_default";
	AudioVmOp$1[AudioVmOp$1["GenBiquad_lp"] = 117] = "GenBiquad_lp";
	AudioVmOp$1[AudioVmOp$1["GenBiquad_hp"] = 118] = "GenBiquad_hp";
	AudioVmOp$1[AudioVmOp$1["GenBiquad_bp"] = 119] = "GenBiquad_bp";
	AudioVmOp$1[AudioVmOp$1["GenBiquad_bs"] = 120] = "GenBiquad_bs";
	AudioVmOp$1[AudioVmOp$1["GenBiquad_ap"] = 121] = "GenBiquad_ap";
	AudioVmOp$1[AudioVmOp$1["GenEnvfollow_default"] = 122] = "GenEnvfollow_default";
	AudioVmOp$1[AudioVmOp$1["GenSah_default"] = 123] = "GenSah_default";
	AudioVmOp$1[AudioVmOp$1["GenVelvet_default"] = 124] = "GenVelvet_default";
	AudioVmOp$1[AudioVmOp$1["GenFdn_default"] = 125] = "GenFdn_default";
	AudioVmOp$1[AudioVmOp$1["GenPink_default"] = 126] = "GenPink_default";
	AudioVmOp$1[AudioVmOp$1["GenDattorro_default"] = 127] = "GenDattorro_default";
	AudioVmOp$1[AudioVmOp$1["GenRandom_default"] = 128] = "GenRandom_default";
	AudioVmOp$1[AudioVmOp$1["GenSlew_default"] = 129] = "GenSlew_default";
	AudioVmOp$1[AudioVmOp$1["GenInc_default"] = 130] = "GenInc_default";
	AudioVmOp$1[AudioVmOp$1["GenBiquadshelf_ls"] = 131] = "GenBiquadshelf_ls";
	AudioVmOp$1[AudioVmOp$1["GenBiquadshelf_hs"] = 132] = "GenBiquadshelf_hs";
	AudioVmOp$1[AudioVmOp$1["GenBiquadshelf_peak"] = 133] = "GenBiquadshelf_peak";
	AudioVmOp$1[AudioVmOp$1["GenSampler_default"] = 134] = "GenSampler_default";
	AudioVmOp$1[AudioVmOp$1["GenMoog_lpm"] = 135] = "GenMoog_lpm";
	AudioVmOp$1[AudioVmOp$1["GenMoog_hpm"] = 136] = "GenMoog_hpm";
	AudioVmOp$1[AudioVmOp$1["GenSvf_lps"] = 137] = "GenSvf_lps";
	AudioVmOp$1[AudioVmOp$1["GenSvf_hps"] = 138] = "GenSvf_hps";
	AudioVmOp$1[AudioVmOp$1["GenSvf_bps"] = 139] = "GenSvf_bps";
	AudioVmOp$1[AudioVmOp$1["GenSvf_bss"] = 140] = "GenSvf_bss";
	AudioVmOp$1[AudioVmOp$1["GenSvf_peaks"] = 141] = "GenSvf_peaks";
	AudioVmOp$1[AudioVmOp$1["GenSvf_aps"] = 142] = "GenSvf_aps";
	return AudioVmOp$1;
}({});
const genSpecs = [
	{
		id: 0,
		genName: "Phasor",
		variantName: "default",
		className: "Phasor_default_hz_scalar_offset_scalar_trig_scalar",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 1,
		genName: "Phasor",
		variantName: "default",
		className: "Phasor_default_hz_scalar_offset_scalar_trig_audio",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 2,
		genName: "Phasor",
		variantName: "default",
		className: "Phasor_default_hz_scalar_offset_audio_trig_scalar",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 3,
		genName: "Phasor",
		variantName: "default",
		className: "Phasor_default_hz_scalar_offset_audio_trig_audio",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 4,
		genName: "Phasor",
		variantName: "default",
		className: "Phasor_default_hz_audio_offset_scalar_trig_scalar",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 5,
		genName: "Phasor",
		variantName: "default",
		className: "Phasor_default_hz_audio_offset_scalar_trig_audio",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 6,
		genName: "Phasor",
		variantName: "default",
		className: "Phasor_default_hz_audio_offset_audio_trig_scalar",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 7,
		genName: "Phasor",
		variantName: "default",
		className: "Phasor_default_hz_audio_offset_audio_trig_audio",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 8,
		genName: "Every",
		variantName: "default",
		className: "Every_default_bars_scalar",
		paramNames: ["bars"],
		paramModes: ["scalar"],
		emitNames: ["fired"],
		usesInput: false
	},
	{
		id: 9,
		genName: "Every",
		variantName: "default",
		className: "Every_default_bars_audio",
		paramNames: ["bars"],
		paramModes: ["audio"],
		emitNames: ["fired"],
		usesInput: false
	},
	{
		id: 10,
		genName: "White",
		variantName: "default",
		className: "White_default_seed_scalar_trig_scalar",
		paramNames: ["seed", "trig"],
		paramModes: ["scalar", "scalar"],
		emitNames: [],
		usesInput: false
	},
	{
		id: 11,
		genName: "White",
		variantName: "default",
		className: "White_default_seed_scalar_trig_audio",
		paramNames: ["seed", "trig"],
		paramModes: ["scalar", "audio"],
		emitNames: [],
		usesInput: false
	},
	{
		id: 12,
		genName: "Lfosqr",
		variantName: "default",
		className: "Lfosqr_default_bar_scalar_offset_scalar_trig_scalar",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 13,
		genName: "Lfosqr",
		variantName: "default",
		className: "Lfosqr_default_bar_scalar_offset_scalar_trig_audio",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 14,
		genName: "Lfosqr",
		variantName: "default",
		className: "Lfosqr_default_bar_scalar_offset_audio_trig_scalar",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 15,
		genName: "Lfosqr",
		variantName: "default",
		className: "Lfosqr_default_bar_scalar_offset_audio_trig_audio",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 16,
		genName: "Lfosqr",
		variantName: "default",
		className: "Lfosqr_default_bar_audio_offset_scalar_trig_scalar",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 17,
		genName: "Lfosqr",
		variantName: "default",
		className: "Lfosqr_default_bar_audio_offset_scalar_trig_audio",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 18,
		genName: "Lfosqr",
		variantName: "default",
		className: "Lfosqr_default_bar_audio_offset_audio_trig_scalar",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 19,
		genName: "Lfosqr",
		variantName: "default",
		className: "Lfosqr_default_bar_audio_offset_audio_trig_audio",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 20,
		genName: "Lfosah",
		variantName: "default",
		className: "Lfosah_default_bar_scalar_offset_scalar_seed_scalar_trig_scalar",
		paramNames: [
			"bar",
			"offset",
			"seed",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 21,
		genName: "Lfosah",
		variantName: "default",
		className: "Lfosah_default_bar_scalar_offset_scalar_seed_scalar_trig_audio",
		paramNames: [
			"bar",
			"offset",
			"seed",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 22,
		genName: "Lfosah",
		variantName: "default",
		className: "Lfosah_default_bar_scalar_offset_scalar_seed_audio_trig_scalar",
		paramNames: [
			"bar",
			"offset",
			"seed",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 23,
		genName: "Lfosah",
		variantName: "default",
		className: "Lfosah_default_bar_scalar_offset_scalar_seed_audio_trig_audio",
		paramNames: [
			"bar",
			"offset",
			"seed",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 24,
		genName: "Lfosah",
		variantName: "default",
		className: "Lfosah_default_bar_scalar_offset_audio_seed_scalar_trig_scalar",
		paramNames: [
			"bar",
			"offset",
			"seed",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 25,
		genName: "Lfosah",
		variantName: "default",
		className: "Lfosah_default_bar_scalar_offset_audio_seed_scalar_trig_audio",
		paramNames: [
			"bar",
			"offset",
			"seed",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 26,
		genName: "Lfosah",
		variantName: "default",
		className: "Lfosah_default_bar_scalar_offset_audio_seed_audio_trig_scalar",
		paramNames: [
			"bar",
			"offset",
			"seed",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 27,
		genName: "Lfosah",
		variantName: "default",
		className: "Lfosah_default_bar_scalar_offset_audio_seed_audio_trig_audio",
		paramNames: [
			"bar",
			"offset",
			"seed",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 28,
		genName: "Lfosah",
		variantName: "default",
		className: "Lfosah_default_bar_audio_offset_scalar_seed_scalar_trig_scalar",
		paramNames: [
			"bar",
			"offset",
			"seed",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 29,
		genName: "Lfosah",
		variantName: "default",
		className: "Lfosah_default_bar_audio_offset_scalar_seed_scalar_trig_audio",
		paramNames: [
			"bar",
			"offset",
			"seed",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 30,
		genName: "Lfosah",
		variantName: "default",
		className: "Lfosah_default_bar_audio_offset_scalar_seed_audio_trig_scalar",
		paramNames: [
			"bar",
			"offset",
			"seed",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 31,
		genName: "Lfosah",
		variantName: "default",
		className: "Lfosah_default_bar_audio_offset_scalar_seed_audio_trig_audio",
		paramNames: [
			"bar",
			"offset",
			"seed",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 32,
		genName: "Lfosah",
		variantName: "default",
		className: "Lfosah_default_bar_audio_offset_audio_seed_scalar_trig_scalar",
		paramNames: [
			"bar",
			"offset",
			"seed",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 33,
		genName: "Lfosah",
		variantName: "default",
		className: "Lfosah_default_bar_audio_offset_audio_seed_scalar_trig_audio",
		paramNames: [
			"bar",
			"offset",
			"seed",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 34,
		genName: "Lfosah",
		variantName: "default",
		className: "Lfosah_default_bar_audio_offset_audio_seed_audio_trig_scalar",
		paramNames: [
			"bar",
			"offset",
			"seed",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 35,
		genName: "Lfosah",
		variantName: "default",
		className: "Lfosah_default_bar_audio_offset_audio_seed_audio_trig_audio",
		paramNames: [
			"bar",
			"offset",
			"seed",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 36,
		genName: "Dc",
		variantName: "default",
		className: "Dc_default_",
		paramNames: [],
		paramModes: [],
		emitNames: [],
		usesInput: true
	},
	{
		id: 37,
		genName: "Gauss",
		variantName: "default",
		className: "Gauss_default_seed_scalar_trig_scalar",
		paramNames: ["seed", "trig"],
		paramModes: ["scalar", "scalar"],
		emitNames: [],
		usesInput: false
	},
	{
		id: 38,
		genName: "Gauss",
		variantName: "default",
		className: "Gauss_default_seed_scalar_trig_audio",
		paramNames: ["seed", "trig"],
		paramModes: ["scalar", "audio"],
		emitNames: [],
		usesInput: false
	},
	{
		id: 39,
		genName: "Impulse",
		variantName: "default",
		className: "Impulse_default_hz_scalar_offset_scalar_trig_scalar",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 40,
		genName: "Impulse",
		variantName: "default",
		className: "Impulse_default_hz_scalar_offset_scalar_trig_audio",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 41,
		genName: "Impulse",
		variantName: "default",
		className: "Impulse_default_hz_scalar_offset_audio_trig_scalar",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 42,
		genName: "Impulse",
		variantName: "default",
		className: "Impulse_default_hz_scalar_offset_audio_trig_audio",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 43,
		genName: "Impulse",
		variantName: "default",
		className: "Impulse_default_hz_audio_offset_scalar_trig_scalar",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 44,
		genName: "Impulse",
		variantName: "default",
		className: "Impulse_default_hz_audio_offset_scalar_trig_audio",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 45,
		genName: "Impulse",
		variantName: "default",
		className: "Impulse_default_hz_audio_offset_audio_trig_scalar",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 46,
		genName: "Impulse",
		variantName: "default",
		className: "Impulse_default_hz_audio_offset_audio_trig_audio",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 47,
		genName: "TestGain",
		variantName: "default",
		className: "TestGain_default_amount_scalar",
		paramNames: ["amount"],
		paramModes: ["scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 48,
		genName: "TestGain",
		variantName: "default",
		className: "TestGain_default_amount_audio",
		paramNames: ["amount"],
		paramModes: ["audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 49,
		genName: "TestGain",
		variantName: "default",
		className: "TestGain_default_amount_scalar_stereo",
		paramNames: ["amount"],
		paramModes: ["scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 50,
		genName: "TestGain",
		variantName: "default",
		className: "TestGain_default_amount_audio_stereo",
		paramNames: ["amount"],
		paramModes: ["audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 51,
		genName: "Freeverb",
		variantName: "default",
		className: "Freeverb_default_room_scalar_damping_scalar",
		paramNames: ["room", "damping"],
		paramModes: ["scalar", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 52,
		genName: "Freeverb",
		variantName: "default",
		className: "Freeverb_default_room_scalar_damping_audio",
		paramNames: ["room", "damping"],
		paramModes: ["scalar", "audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 53,
		genName: "Freeverb",
		variantName: "default",
		className: "Freeverb_default_room_audio_damping_scalar",
		paramNames: ["room", "damping"],
		paramModes: ["audio", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 54,
		genName: "Freeverb",
		variantName: "default",
		className: "Freeverb_default_room_audio_damping_audio",
		paramNames: ["room", "damping"],
		paramModes: ["audio", "audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 55,
		genName: "Freeverb",
		variantName: "default",
		className: "Freeverb_default_room_scalar_damping_scalar_stereo",
		paramNames: ["room", "damping"],
		paramModes: ["scalar", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 56,
		genName: "Freeverb",
		variantName: "default",
		className: "Freeverb_default_room_scalar_damping_audio_stereo",
		paramNames: ["room", "damping"],
		paramModes: ["scalar", "audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 57,
		genName: "Freeverb",
		variantName: "default",
		className: "Freeverb_default_room_audio_damping_scalar_stereo",
		paramNames: ["room", "damping"],
		paramModes: ["audio", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 58,
		genName: "Freeverb",
		variantName: "default",
		className: "Freeverb_default_room_audio_damping_audio_stereo",
		paramNames: ["room", "damping"],
		paramModes: ["audio", "audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 59,
		genName: "Saw",
		variantName: "default",
		className: "Saw_default_hz_scalar_offset_scalar_trig_scalar",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 60,
		genName: "Saw",
		variantName: "default",
		className: "Saw_default_hz_scalar_offset_scalar_trig_audio",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 61,
		genName: "Saw",
		variantName: "default",
		className: "Saw_default_hz_scalar_offset_audio_trig_scalar",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 62,
		genName: "Saw",
		variantName: "default",
		className: "Saw_default_hz_scalar_offset_audio_trig_audio",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 63,
		genName: "Saw",
		variantName: "default",
		className: "Saw_default_hz_audio_offset_scalar_trig_scalar",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 64,
		genName: "Saw",
		variantName: "default",
		className: "Saw_default_hz_audio_offset_scalar_trig_audio",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 65,
		genName: "Saw",
		variantName: "default",
		className: "Saw_default_hz_audio_offset_audio_trig_scalar",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 66,
		genName: "Saw",
		variantName: "default",
		className: "Saw_default_hz_audio_offset_audio_trig_audio",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 67,
		genName: "TestOversample",
		variantName: "default",
		className: "TestOversample_default_",
		paramNames: [],
		paramModes: [],
		emitNames: [],
		usesInput: false
	},
	{
		id: 68,
		genName: "TestOversample",
		variantName: "default",
		className: "TestOversample_default__stereo",
		paramNames: [],
		paramModes: [],
		emitNames: [],
		usesInput: false
	},
	{
		id: 69,
		genName: "Sine",
		variantName: "default",
		className: "Sine_default_hz_scalar_offset_scalar_trig_scalar",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 70,
		genName: "Sine",
		variantName: "default",
		className: "Sine_default_hz_scalar_offset_scalar_trig_audio",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 71,
		genName: "Sine",
		variantName: "default",
		className: "Sine_default_hz_scalar_offset_audio_trig_scalar",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 72,
		genName: "Sine",
		variantName: "default",
		className: "Sine_default_hz_scalar_offset_audio_trig_audio",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 73,
		genName: "Sine",
		variantName: "default",
		className: "Sine_default_hz_audio_offset_scalar_trig_scalar",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 74,
		genName: "Sine",
		variantName: "default",
		className: "Sine_default_hz_audio_offset_scalar_trig_audio",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 75,
		genName: "Sine",
		variantName: "default",
		className: "Sine_default_hz_audio_offset_audio_trig_scalar",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 76,
		genName: "Sine",
		variantName: "default",
		className: "Sine_default_hz_audio_offset_audio_trig_audio",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 77,
		genName: "Lfosine",
		variantName: "default",
		className: "Lfosine_default_bar_scalar_offset_scalar_trig_scalar",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 78,
		genName: "Lfosine",
		variantName: "default",
		className: "Lfosine_default_bar_scalar_offset_scalar_trig_audio",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 79,
		genName: "Lfosine",
		variantName: "default",
		className: "Lfosine_default_bar_scalar_offset_audio_trig_scalar",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 80,
		genName: "Lfosine",
		variantName: "default",
		className: "Lfosine_default_bar_scalar_offset_audio_trig_audio",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 81,
		genName: "Lfosine",
		variantName: "default",
		className: "Lfosine_default_bar_audio_offset_scalar_trig_scalar",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 82,
		genName: "Lfosine",
		variantName: "default",
		className: "Lfosine_default_bar_audio_offset_scalar_trig_audio",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 83,
		genName: "Lfosine",
		variantName: "default",
		className: "Lfosine_default_bar_audio_offset_audio_trig_scalar",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 84,
		genName: "Lfosine",
		variantName: "default",
		className: "Lfosine_default_bar_audio_offset_audio_trig_audio",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 85,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_scalar_slice_scalar_threshold_scalar_repeat_scalar_trig_scalar",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 86,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_scalar_slice_scalar_threshold_scalar_repeat_scalar_trig_audio",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 87,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_scalar_slice_scalar_threshold_scalar_repeat_audio_trig_scalar",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 88,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_scalar_slice_scalar_threshold_scalar_repeat_audio_trig_audio",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 89,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_scalar_slice_audio_threshold_scalar_repeat_scalar_trig_scalar",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 90,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_scalar_slice_audio_threshold_scalar_repeat_scalar_trig_audio",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 91,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_scalar_slice_audio_threshold_scalar_repeat_audio_trig_scalar",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 92,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_scalar_slice_audio_threshold_scalar_repeat_audio_trig_audio",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 93,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_audio_slice_scalar_threshold_scalar_repeat_scalar_trig_scalar",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 94,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_audio_slice_scalar_threshold_scalar_repeat_scalar_trig_audio",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 95,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_audio_slice_scalar_threshold_scalar_repeat_audio_trig_scalar",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 96,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_audio_slice_scalar_threshold_scalar_repeat_audio_trig_audio",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 97,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_audio_slice_audio_threshold_scalar_repeat_scalar_trig_scalar",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"audio",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 98,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_audio_slice_audio_threshold_scalar_repeat_scalar_trig_audio",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"audio",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 99,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_audio_slice_audio_threshold_scalar_repeat_audio_trig_scalar",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"audio",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 100,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_audio_slice_audio_threshold_scalar_repeat_audio_trig_audio",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"audio",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 101,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_scalar_slice_scalar_threshold_scalar_repeat_scalar_trig_scalar",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 102,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_scalar_slice_scalar_threshold_scalar_repeat_scalar_trig_audio",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 103,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_scalar_slice_scalar_threshold_scalar_repeat_audio_trig_scalar",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 104,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_scalar_slice_scalar_threshold_scalar_repeat_audio_trig_audio",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 105,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_scalar_slice_audio_threshold_scalar_repeat_scalar_trig_scalar",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 106,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_scalar_slice_audio_threshold_scalar_repeat_scalar_trig_audio",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 107,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_scalar_slice_audio_threshold_scalar_repeat_audio_trig_scalar",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"audio",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 108,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_scalar_slice_audio_threshold_scalar_repeat_audio_trig_audio",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"audio",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 109,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_audio_slice_scalar_threshold_scalar_repeat_scalar_trig_scalar",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 110,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_audio_slice_scalar_threshold_scalar_repeat_scalar_trig_audio",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 111,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_audio_slice_scalar_threshold_scalar_repeat_audio_trig_scalar",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"scalar",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 112,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_audio_slice_scalar_threshold_scalar_repeat_audio_trig_audio",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"scalar",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 113,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_audio_slice_audio_threshold_scalar_repeat_scalar_trig_scalar",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"audio",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 114,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_audio_slice_audio_threshold_scalar_repeat_scalar_trig_audio",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"audio",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 115,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_audio_slice_audio_threshold_scalar_repeat_audio_trig_scalar",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"audio",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 116,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_audio_slice_audio_threshold_scalar_repeat_audio_trig_audio",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"audio",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 117,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_scalar_slice_scalar_threshold_scalar_repeat_scalar_trig_scalar_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 118,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_scalar_slice_scalar_threshold_scalar_repeat_scalar_trig_audio_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 119,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_scalar_slice_scalar_threshold_scalar_repeat_audio_trig_scalar_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 120,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_scalar_slice_scalar_threshold_scalar_repeat_audio_trig_audio_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 121,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_scalar_slice_audio_threshold_scalar_repeat_scalar_trig_scalar_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 122,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_scalar_slice_audio_threshold_scalar_repeat_scalar_trig_audio_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 123,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_scalar_slice_audio_threshold_scalar_repeat_audio_trig_scalar_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 124,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_scalar_slice_audio_threshold_scalar_repeat_audio_trig_audio_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 125,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_audio_slice_scalar_threshold_scalar_repeat_scalar_trig_scalar_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 126,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_audio_slice_scalar_threshold_scalar_repeat_scalar_trig_audio_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 127,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_audio_slice_scalar_threshold_scalar_repeat_audio_trig_scalar_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 128,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_audio_slice_scalar_threshold_scalar_repeat_audio_trig_audio_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 129,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_audio_slice_audio_threshold_scalar_repeat_scalar_trig_scalar_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"audio",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 130,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_audio_slice_audio_threshold_scalar_repeat_scalar_trig_audio_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"audio",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 131,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_audio_slice_audio_threshold_scalar_repeat_audio_trig_scalar_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"audio",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 132,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_scalar_offset_audio_slice_audio_threshold_scalar_repeat_audio_trig_audio_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"audio",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 133,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_scalar_slice_scalar_threshold_scalar_repeat_scalar_trig_scalar_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 134,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_scalar_slice_scalar_threshold_scalar_repeat_scalar_trig_audio_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 135,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_scalar_slice_scalar_threshold_scalar_repeat_audio_trig_scalar_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 136,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_scalar_slice_scalar_threshold_scalar_repeat_audio_trig_audio_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 137,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_scalar_slice_audio_threshold_scalar_repeat_scalar_trig_scalar_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 138,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_scalar_slice_audio_threshold_scalar_repeat_scalar_trig_audio_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 139,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_scalar_slice_audio_threshold_scalar_repeat_audio_trig_scalar_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"audio",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 140,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_scalar_slice_audio_threshold_scalar_repeat_audio_trig_audio_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"audio",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 141,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_audio_slice_scalar_threshold_scalar_repeat_scalar_trig_scalar_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 142,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_audio_slice_scalar_threshold_scalar_repeat_scalar_trig_audio_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 143,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_audio_slice_scalar_threshold_scalar_repeat_audio_trig_scalar_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"scalar",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 144,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_audio_slice_scalar_threshold_scalar_repeat_audio_trig_audio_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"scalar",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 145,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_audio_slice_audio_threshold_scalar_repeat_scalar_trig_scalar_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"audio",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 146,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_audio_slice_audio_threshold_scalar_repeat_scalar_trig_audio_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"audio",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 147,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_audio_slice_audio_threshold_scalar_repeat_audio_trig_scalar_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"audio",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 148,
		genName: "Slicer",
		variantName: "default",
		className: "Slicer_default_sample_scalar_speed_audio_offset_audio_slice_audio_threshold_scalar_repeat_audio_trig_audio_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"slice",
			"threshold",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"audio",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [
			"slicePosition",
			"slicePlaying",
			"currentSlice"
		],
		usesInput: false
	},
	{
		id: 149,
		genName: "Brown",
		variantName: "default",
		className: "Brown_default_seed_scalar_trig_scalar",
		paramNames: ["seed", "trig"],
		paramModes: ["scalar", "scalar"],
		emitNames: [],
		usesInput: false
	},
	{
		id: 150,
		genName: "Brown",
		variantName: "default",
		className: "Brown_default_seed_scalar_trig_audio",
		paramNames: ["seed", "trig"],
		paramModes: ["scalar", "audio"],
		emitNames: [],
		usesInput: false
	},
	{
		id: 151,
		genName: "Euclid",
		variantName: "default",
		className: "Euclid_default_pulses_scalar_steps_scalar_offset_scalar_bar_scalar",
		paramNames: [
			"pulses",
			"steps",
			"offset",
			"bar"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 152,
		genName: "Euclid",
		variantName: "default",
		className: "Euclid_default_pulses_scalar_steps_scalar_offset_scalar_bar_audio",
		paramNames: [
			"pulses",
			"steps",
			"offset",
			"bar"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 153,
		genName: "Euclid",
		variantName: "default",
		className: "Euclid_default_pulses_scalar_steps_scalar_offset_audio_bar_scalar",
		paramNames: [
			"pulses",
			"steps",
			"offset",
			"bar"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 154,
		genName: "Euclid",
		variantName: "default",
		className: "Euclid_default_pulses_scalar_steps_scalar_offset_audio_bar_audio",
		paramNames: [
			"pulses",
			"steps",
			"offset",
			"bar"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 155,
		genName: "Euclid",
		variantName: "default",
		className: "Euclid_default_pulses_scalar_steps_audio_offset_scalar_bar_scalar",
		paramNames: [
			"pulses",
			"steps",
			"offset",
			"bar"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 156,
		genName: "Euclid",
		variantName: "default",
		className: "Euclid_default_pulses_scalar_steps_audio_offset_scalar_bar_audio",
		paramNames: [
			"pulses",
			"steps",
			"offset",
			"bar"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 157,
		genName: "Euclid",
		variantName: "default",
		className: "Euclid_default_pulses_scalar_steps_audio_offset_audio_bar_scalar",
		paramNames: [
			"pulses",
			"steps",
			"offset",
			"bar"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 158,
		genName: "Euclid",
		variantName: "default",
		className: "Euclid_default_pulses_scalar_steps_audio_offset_audio_bar_audio",
		paramNames: [
			"pulses",
			"steps",
			"offset",
			"bar"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 159,
		genName: "Euclid",
		variantName: "default",
		className: "Euclid_default_pulses_audio_steps_scalar_offset_scalar_bar_scalar",
		paramNames: [
			"pulses",
			"steps",
			"offset",
			"bar"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 160,
		genName: "Euclid",
		variantName: "default",
		className: "Euclid_default_pulses_audio_steps_scalar_offset_scalar_bar_audio",
		paramNames: [
			"pulses",
			"steps",
			"offset",
			"bar"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 161,
		genName: "Euclid",
		variantName: "default",
		className: "Euclid_default_pulses_audio_steps_scalar_offset_audio_bar_scalar",
		paramNames: [
			"pulses",
			"steps",
			"offset",
			"bar"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 162,
		genName: "Euclid",
		variantName: "default",
		className: "Euclid_default_pulses_audio_steps_scalar_offset_audio_bar_audio",
		paramNames: [
			"pulses",
			"steps",
			"offset",
			"bar"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 163,
		genName: "Euclid",
		variantName: "default",
		className: "Euclid_default_pulses_audio_steps_audio_offset_scalar_bar_scalar",
		paramNames: [
			"pulses",
			"steps",
			"offset",
			"bar"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 164,
		genName: "Euclid",
		variantName: "default",
		className: "Euclid_default_pulses_audio_steps_audio_offset_scalar_bar_audio",
		paramNames: [
			"pulses",
			"steps",
			"offset",
			"bar"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 165,
		genName: "Euclid",
		variantName: "default",
		className: "Euclid_default_pulses_audio_steps_audio_offset_audio_bar_scalar",
		paramNames: [
			"pulses",
			"steps",
			"offset",
			"bar"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 166,
		genName: "Euclid",
		variantName: "default",
		className: "Euclid_default_pulses_audio_steps_audio_offset_audio_bar_audio",
		paramNames: [
			"pulses",
			"steps",
			"offset",
			"bar"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 167,
		genName: "Pwm",
		variantName: "default",
		className: "Pwm_default_hz_scalar_width_scalar_offset_scalar_trig_scalar",
		paramNames: [
			"hz",
			"width",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 168,
		genName: "Pwm",
		variantName: "default",
		className: "Pwm_default_hz_scalar_width_scalar_offset_scalar_trig_audio",
		paramNames: [
			"hz",
			"width",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 169,
		genName: "Pwm",
		variantName: "default",
		className: "Pwm_default_hz_scalar_width_scalar_offset_audio_trig_scalar",
		paramNames: [
			"hz",
			"width",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 170,
		genName: "Pwm",
		variantName: "default",
		className: "Pwm_default_hz_scalar_width_scalar_offset_audio_trig_audio",
		paramNames: [
			"hz",
			"width",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 171,
		genName: "Pwm",
		variantName: "default",
		className: "Pwm_default_hz_scalar_width_audio_offset_scalar_trig_scalar",
		paramNames: [
			"hz",
			"width",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 172,
		genName: "Pwm",
		variantName: "default",
		className: "Pwm_default_hz_scalar_width_audio_offset_scalar_trig_audio",
		paramNames: [
			"hz",
			"width",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 173,
		genName: "Pwm",
		variantName: "default",
		className: "Pwm_default_hz_scalar_width_audio_offset_audio_trig_scalar",
		paramNames: [
			"hz",
			"width",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 174,
		genName: "Pwm",
		variantName: "default",
		className: "Pwm_default_hz_scalar_width_audio_offset_audio_trig_audio",
		paramNames: [
			"hz",
			"width",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 175,
		genName: "Pwm",
		variantName: "default",
		className: "Pwm_default_hz_audio_width_scalar_offset_scalar_trig_scalar",
		paramNames: [
			"hz",
			"width",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 176,
		genName: "Pwm",
		variantName: "default",
		className: "Pwm_default_hz_audio_width_scalar_offset_scalar_trig_audio",
		paramNames: [
			"hz",
			"width",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 177,
		genName: "Pwm",
		variantName: "default",
		className: "Pwm_default_hz_audio_width_scalar_offset_audio_trig_scalar",
		paramNames: [
			"hz",
			"width",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 178,
		genName: "Pwm",
		variantName: "default",
		className: "Pwm_default_hz_audio_width_scalar_offset_audio_trig_audio",
		paramNames: [
			"hz",
			"width",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 179,
		genName: "Pwm",
		variantName: "default",
		className: "Pwm_default_hz_audio_width_audio_offset_scalar_trig_scalar",
		paramNames: [
			"hz",
			"width",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 180,
		genName: "Pwm",
		variantName: "default",
		className: "Pwm_default_hz_audio_width_audio_offset_scalar_trig_audio",
		paramNames: [
			"hz",
			"width",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 181,
		genName: "Pwm",
		variantName: "default",
		className: "Pwm_default_hz_audio_width_audio_offset_audio_trig_scalar",
		paramNames: [
			"hz",
			"width",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 182,
		genName: "Pwm",
		variantName: "default",
		className: "Pwm_default_hz_audio_width_audio_offset_audio_trig_audio",
		paramNames: [
			"hz",
			"width",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 183,
		genName: "Ad",
		variantName: "default",
		className: "Ad_default_attack_scalar_decay_scalar_exponent_scalar_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 184,
		genName: "Ad",
		variantName: "default",
		className: "Ad_default_attack_scalar_decay_scalar_exponent_scalar_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 185,
		genName: "Ad",
		variantName: "default",
		className: "Ad_default_attack_scalar_decay_scalar_exponent_audio_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 186,
		genName: "Ad",
		variantName: "default",
		className: "Ad_default_attack_scalar_decay_scalar_exponent_audio_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 187,
		genName: "Ad",
		variantName: "default",
		className: "Ad_default_attack_scalar_decay_audio_exponent_scalar_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 188,
		genName: "Ad",
		variantName: "default",
		className: "Ad_default_attack_scalar_decay_audio_exponent_scalar_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 189,
		genName: "Ad",
		variantName: "default",
		className: "Ad_default_attack_scalar_decay_audio_exponent_audio_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 190,
		genName: "Ad",
		variantName: "default",
		className: "Ad_default_attack_scalar_decay_audio_exponent_audio_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 191,
		genName: "Ad",
		variantName: "default",
		className: "Ad_default_attack_audio_decay_scalar_exponent_scalar_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 192,
		genName: "Ad",
		variantName: "default",
		className: "Ad_default_attack_audio_decay_scalar_exponent_scalar_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 193,
		genName: "Ad",
		variantName: "default",
		className: "Ad_default_attack_audio_decay_scalar_exponent_audio_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 194,
		genName: "Ad",
		variantName: "default",
		className: "Ad_default_attack_audio_decay_scalar_exponent_audio_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 195,
		genName: "Ad",
		variantName: "default",
		className: "Ad_default_attack_audio_decay_audio_exponent_scalar_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 196,
		genName: "Ad",
		variantName: "default",
		className: "Ad_default_attack_audio_decay_audio_exponent_scalar_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 197,
		genName: "Ad",
		variantName: "default",
		className: "Ad_default_attack_audio_decay_audio_exponent_audio_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 198,
		genName: "Ad",
		variantName: "default",
		className: "Ad_default_attack_audio_decay_audio_exponent_audio_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 199,
		genName: "Onepole",
		variantName: "lp1",
		className: "Onepole_lp1_cutoff_scalar",
		paramNames: ["cutoff"],
		paramModes: ["scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 200,
		genName: "Onepole",
		variantName: "lp1",
		className: "Onepole_lp1_cutoff_audio",
		paramNames: ["cutoff"],
		paramModes: ["audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 201,
		genName: "Onepole",
		variantName: "hp1",
		className: "Onepole_hp1_cutoff_scalar",
		paramNames: ["cutoff"],
		paramModes: ["scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 202,
		genName: "Onepole",
		variantName: "hp1",
		className: "Onepole_hp1_cutoff_audio",
		paramNames: ["cutoff"],
		paramModes: ["audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 203,
		genName: "Sqr",
		variantName: "default",
		className: "Sqr_default_hz_scalar_offset_scalar_trig_scalar",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 204,
		genName: "Sqr",
		variantName: "default",
		className: "Sqr_default_hz_scalar_offset_scalar_trig_audio",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 205,
		genName: "Sqr",
		variantName: "default",
		className: "Sqr_default_hz_scalar_offset_audio_trig_scalar",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 206,
		genName: "Sqr",
		variantName: "default",
		className: "Sqr_default_hz_scalar_offset_audio_trig_audio",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 207,
		genName: "Sqr",
		variantName: "default",
		className: "Sqr_default_hz_audio_offset_scalar_trig_scalar",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 208,
		genName: "Sqr",
		variantName: "default",
		className: "Sqr_default_hz_audio_offset_scalar_trig_audio",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 209,
		genName: "Sqr",
		variantName: "default",
		className: "Sqr_default_hz_audio_offset_audio_trig_scalar",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 210,
		genName: "Sqr",
		variantName: "default",
		className: "Sqr_default_hz_audio_offset_audio_trig_audio",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 211,
		genName: "Hold",
		variantName: "default",
		className: "Hold_default_",
		paramNames: [],
		paramModes: [],
		emitNames: [],
		usesInput: true
	},
	{
		id: 212,
		genName: "Lfosaw",
		variantName: "default",
		className: "Lfosaw_default_bar_scalar_offset_scalar_trig_scalar",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 213,
		genName: "Lfosaw",
		variantName: "default",
		className: "Lfosaw_default_bar_scalar_offset_scalar_trig_audio",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 214,
		genName: "Lfosaw",
		variantName: "default",
		className: "Lfosaw_default_bar_scalar_offset_audio_trig_scalar",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 215,
		genName: "Lfosaw",
		variantName: "default",
		className: "Lfosaw_default_bar_scalar_offset_audio_trig_audio",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 216,
		genName: "Lfosaw",
		variantName: "default",
		className: "Lfosaw_default_bar_audio_offset_scalar_trig_scalar",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 217,
		genName: "Lfosaw",
		variantName: "default",
		className: "Lfosaw_default_bar_audio_offset_scalar_trig_audio",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 218,
		genName: "Lfosaw",
		variantName: "default",
		className: "Lfosaw_default_bar_audio_offset_audio_trig_scalar",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 219,
		genName: "Lfosaw",
		variantName: "default",
		className: "Lfosaw_default_bar_audio_offset_audio_trig_audio",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 220,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_scalar_threshold_scalar_ratio_scalar_knee_scalar_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 221,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_scalar_threshold_scalar_ratio_scalar_knee_scalar_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 222,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_scalar_threshold_scalar_ratio_scalar_knee_audio_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 223,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_scalar_threshold_scalar_ratio_scalar_knee_audio_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 224,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_scalar_threshold_scalar_ratio_audio_knee_scalar_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 225,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_scalar_threshold_scalar_ratio_audio_knee_scalar_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 226,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_scalar_threshold_scalar_ratio_audio_knee_audio_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 227,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_scalar_threshold_scalar_ratio_audio_knee_audio_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"audio",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 228,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_scalar_threshold_audio_ratio_scalar_knee_scalar_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 229,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_scalar_threshold_audio_ratio_scalar_knee_scalar_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 230,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_scalar_threshold_audio_ratio_scalar_knee_audio_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 231,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_scalar_threshold_audio_ratio_scalar_knee_audio_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 232,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_scalar_threshold_audio_ratio_audio_knee_scalar_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 233,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_scalar_threshold_audio_ratio_audio_knee_scalar_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 234,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_scalar_threshold_audio_ratio_audio_knee_audio_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 235,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_scalar_threshold_audio_ratio_audio_knee_audio_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"audio",
			"audio",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 236,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_audio_threshold_scalar_ratio_scalar_knee_scalar_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 237,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_audio_threshold_scalar_ratio_scalar_knee_scalar_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 238,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_audio_threshold_scalar_ratio_scalar_knee_audio_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 239,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_audio_threshold_scalar_ratio_scalar_knee_audio_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 240,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_audio_threshold_scalar_ratio_audio_knee_scalar_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 241,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_audio_threshold_scalar_ratio_audio_knee_scalar_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 242,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_audio_threshold_scalar_ratio_audio_knee_audio_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 243,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_audio_threshold_scalar_ratio_audio_knee_audio_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"audio",
			"audio",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 244,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_audio_threshold_audio_ratio_scalar_knee_scalar_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 245,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_audio_threshold_audio_ratio_scalar_knee_scalar_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 246,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_audio_threshold_audio_ratio_scalar_knee_audio_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 247,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_audio_threshold_audio_ratio_scalar_knee_audio_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 248,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_audio_threshold_audio_ratio_audio_knee_scalar_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 249,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_audio_threshold_audio_ratio_audio_knee_scalar_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 250,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_audio_threshold_audio_ratio_audio_knee_audio_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 251,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_scalar_release_audio_threshold_audio_ratio_audio_knee_audio_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"audio",
			"audio",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 252,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_scalar_threshold_scalar_ratio_scalar_knee_scalar_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 253,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_scalar_threshold_scalar_ratio_scalar_knee_scalar_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 254,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_scalar_threshold_scalar_ratio_scalar_knee_audio_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 255,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_scalar_threshold_scalar_ratio_scalar_knee_audio_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 256,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_scalar_threshold_scalar_ratio_audio_knee_scalar_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 257,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_scalar_threshold_scalar_ratio_audio_knee_scalar_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 258,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_scalar_threshold_scalar_ratio_audio_knee_audio_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 259,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_scalar_threshold_scalar_ratio_audio_knee_audio_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"audio",
			"audio",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 260,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_scalar_threshold_audio_ratio_scalar_knee_scalar_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 261,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_scalar_threshold_audio_ratio_scalar_knee_scalar_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 262,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_scalar_threshold_audio_ratio_scalar_knee_audio_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 263,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_scalar_threshold_audio_ratio_scalar_knee_audio_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 264,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_scalar_threshold_audio_ratio_audio_knee_scalar_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 265,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_scalar_threshold_audio_ratio_audio_knee_scalar_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 266,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_scalar_threshold_audio_ratio_audio_knee_audio_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 267,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_scalar_threshold_audio_ratio_audio_knee_audio_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"audio",
			"audio",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 268,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_audio_threshold_scalar_ratio_scalar_knee_scalar_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 269,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_audio_threshold_scalar_ratio_scalar_knee_scalar_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 270,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_audio_threshold_scalar_ratio_scalar_knee_audio_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 271,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_audio_threshold_scalar_ratio_scalar_knee_audio_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 272,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_audio_threshold_scalar_ratio_audio_knee_scalar_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 273,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_audio_threshold_scalar_ratio_audio_knee_scalar_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 274,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_audio_threshold_scalar_ratio_audio_knee_audio_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 275,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_audio_threshold_scalar_ratio_audio_knee_audio_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"audio",
			"audio",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 276,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_audio_threshold_audio_ratio_scalar_knee_scalar_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 277,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_audio_threshold_audio_ratio_scalar_knee_scalar_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 278,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_audio_threshold_audio_ratio_scalar_knee_audio_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 279,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_audio_threshold_audio_ratio_scalar_knee_audio_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 280,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_audio_threshold_audio_ratio_audio_knee_scalar_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 281,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_audio_threshold_audio_ratio_audio_knee_scalar_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 282,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_audio_threshold_audio_ratio_audio_knee_audio_key_scalar",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 283,
		genName: "Compressor",
		variantName: "default",
		className: "Compressor_default_attack_audio_release_audio_threshold_audio_ratio_audio_knee_audio_key_audio",
		paramNames: [
			"attack",
			"release",
			"threshold",
			"ratio",
			"knee",
			"key"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"audio",
			"audio",
			"audio"
		],
		emitNames: ["inputLevel", "gainReduction"],
		usesInput: true
	},
	{
		id: 284,
		genName: "Emit",
		variantName: "default",
		className: "Emit_default_value_scalar",
		paramNames: ["value"],
		paramModes: ["scalar"],
		emitNames: [],
		usesInput: false
	},
	{
		id: 285,
		genName: "Emit",
		variantName: "default",
		className: "Emit_default_value_audio",
		paramNames: ["value"],
		paramModes: ["audio"],
		emitNames: [],
		usesInput: false
	},
	{
		id: 286,
		genName: "Fractal",
		variantName: "default",
		className: "Fractal_default_seed_scalar_rate_scalar_octaves_scalar_gain_scalar_trig_scalar",
		paramNames: [
			"seed",
			"rate",
			"octaves",
			"gain",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 287,
		genName: "Fractal",
		variantName: "default",
		className: "Fractal_default_seed_scalar_rate_scalar_octaves_scalar_gain_scalar_trig_audio",
		paramNames: [
			"seed",
			"rate",
			"octaves",
			"gain",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 288,
		genName: "Fractal",
		variantName: "default",
		className: "Fractal_default_seed_scalar_rate_scalar_octaves_scalar_gain_audio_trig_scalar",
		paramNames: [
			"seed",
			"rate",
			"octaves",
			"gain",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 289,
		genName: "Fractal",
		variantName: "default",
		className: "Fractal_default_seed_scalar_rate_scalar_octaves_scalar_gain_audio_trig_audio",
		paramNames: [
			"seed",
			"rate",
			"octaves",
			"gain",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 290,
		genName: "Fractal",
		variantName: "default",
		className: "Fractal_default_seed_scalar_rate_scalar_octaves_audio_gain_scalar_trig_scalar",
		paramNames: [
			"seed",
			"rate",
			"octaves",
			"gain",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 291,
		genName: "Fractal",
		variantName: "default",
		className: "Fractal_default_seed_scalar_rate_scalar_octaves_audio_gain_scalar_trig_audio",
		paramNames: [
			"seed",
			"rate",
			"octaves",
			"gain",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 292,
		genName: "Fractal",
		variantName: "default",
		className: "Fractal_default_seed_scalar_rate_scalar_octaves_audio_gain_audio_trig_scalar",
		paramNames: [
			"seed",
			"rate",
			"octaves",
			"gain",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 293,
		genName: "Fractal",
		variantName: "default",
		className: "Fractal_default_seed_scalar_rate_scalar_octaves_audio_gain_audio_trig_audio",
		paramNames: [
			"seed",
			"rate",
			"octaves",
			"gain",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"audio",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 294,
		genName: "Fractal",
		variantName: "default",
		className: "Fractal_default_seed_scalar_rate_audio_octaves_scalar_gain_scalar_trig_scalar",
		paramNames: [
			"seed",
			"rate",
			"octaves",
			"gain",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 295,
		genName: "Fractal",
		variantName: "default",
		className: "Fractal_default_seed_scalar_rate_audio_octaves_scalar_gain_scalar_trig_audio",
		paramNames: [
			"seed",
			"rate",
			"octaves",
			"gain",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 296,
		genName: "Fractal",
		variantName: "default",
		className: "Fractal_default_seed_scalar_rate_audio_octaves_scalar_gain_audio_trig_scalar",
		paramNames: [
			"seed",
			"rate",
			"octaves",
			"gain",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 297,
		genName: "Fractal",
		variantName: "default",
		className: "Fractal_default_seed_scalar_rate_audio_octaves_scalar_gain_audio_trig_audio",
		paramNames: [
			"seed",
			"rate",
			"octaves",
			"gain",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 298,
		genName: "Fractal",
		variantName: "default",
		className: "Fractal_default_seed_scalar_rate_audio_octaves_audio_gain_scalar_trig_scalar",
		paramNames: [
			"seed",
			"rate",
			"octaves",
			"gain",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 299,
		genName: "Fractal",
		variantName: "default",
		className: "Fractal_default_seed_scalar_rate_audio_octaves_audio_gain_scalar_trig_audio",
		paramNames: [
			"seed",
			"rate",
			"octaves",
			"gain",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 300,
		genName: "Fractal",
		variantName: "default",
		className: "Fractal_default_seed_scalar_rate_audio_octaves_audio_gain_audio_trig_scalar",
		paramNames: [
			"seed",
			"rate",
			"octaves",
			"gain",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 301,
		genName: "Fractal",
		variantName: "default",
		className: "Fractal_default_seed_scalar_rate_audio_octaves_audio_gain_audio_trig_audio",
		paramNames: [
			"seed",
			"rate",
			"octaves",
			"gain",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"audio",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 302,
		genName: "Lforamp",
		variantName: "default",
		className: "Lforamp_default_bar_scalar_offset_scalar_trig_scalar",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 303,
		genName: "Lforamp",
		variantName: "default",
		className: "Lforamp_default_bar_scalar_offset_scalar_trig_audio",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 304,
		genName: "Lforamp",
		variantName: "default",
		className: "Lforamp_default_bar_scalar_offset_audio_trig_scalar",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 305,
		genName: "Lforamp",
		variantName: "default",
		className: "Lforamp_default_bar_scalar_offset_audio_trig_audio",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 306,
		genName: "Lforamp",
		variantName: "default",
		className: "Lforamp_default_bar_audio_offset_scalar_trig_scalar",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 307,
		genName: "Lforamp",
		variantName: "default",
		className: "Lforamp_default_bar_audio_offset_scalar_trig_audio",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 308,
		genName: "Lforamp",
		variantName: "default",
		className: "Lforamp_default_bar_audio_offset_audio_trig_scalar",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 309,
		genName: "Lforamp",
		variantName: "default",
		className: "Lforamp_default_bar_audio_offset_audio_trig_audio",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 310,
		genName: "Tri",
		variantName: "default",
		className: "Tri_default_hz_scalar_offset_scalar_trig_scalar",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 311,
		genName: "Tri",
		variantName: "default",
		className: "Tri_default_hz_scalar_offset_scalar_trig_audio",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 312,
		genName: "Tri",
		variantName: "default",
		className: "Tri_default_hz_scalar_offset_audio_trig_scalar",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 313,
		genName: "Tri",
		variantName: "default",
		className: "Tri_default_hz_scalar_offset_audio_trig_audio",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 314,
		genName: "Tri",
		variantName: "default",
		className: "Tri_default_hz_audio_offset_scalar_trig_scalar",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 315,
		genName: "Tri",
		variantName: "default",
		className: "Tri_default_hz_audio_offset_scalar_trig_audio",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 316,
		genName: "Tri",
		variantName: "default",
		className: "Tri_default_hz_audio_offset_audio_trig_scalar",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 317,
		genName: "Tri",
		variantName: "default",
		className: "Tri_default_hz_audio_offset_audio_trig_audio",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 318,
		genName: "Pitchshift",
		variantName: "default",
		className: "Pitchshift_default_ratio_scalar",
		paramNames: ["ratio"],
		paramModes: ["scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 319,
		genName: "Pitchshift",
		variantName: "default",
		className: "Pitchshift_default_ratio_audio",
		paramNames: ["ratio"],
		paramModes: ["audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 320,
		genName: "Zerox",
		variantName: "default",
		className: "Zerox_default_",
		paramNames: [],
		paramModes: [],
		emitNames: [],
		usesInput: true
	},
	{
		id: 321,
		genName: "Limiter",
		variantName: "default",
		className: "Limiter_default_threshold_scalar_release_scalar",
		paramNames: ["threshold", "release"],
		paramModes: ["scalar", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 322,
		genName: "Limiter",
		variantName: "default",
		className: "Limiter_default_threshold_scalar_release_audio",
		paramNames: ["threshold", "release"],
		paramModes: ["scalar", "audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 323,
		genName: "Limiter",
		variantName: "default",
		className: "Limiter_default_threshold_audio_release_scalar",
		paramNames: ["threshold", "release"],
		paramModes: ["audio", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 324,
		genName: "Limiter",
		variantName: "default",
		className: "Limiter_default_threshold_audio_release_audio",
		paramNames: ["threshold", "release"],
		paramModes: ["audio", "audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 325,
		genName: "At",
		variantName: "default",
		className: "At_default_bar_scalar_every_scalar_prob_scalar_seed_scalar",
		paramNames: [
			"bar",
			"every",
			"prob",
			"seed"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["fired"],
		usesInput: false
	},
	{
		id: 326,
		genName: "At",
		variantName: "default",
		className: "At_default_bar_scalar_every_scalar_prob_audio_seed_scalar",
		paramNames: [
			"bar",
			"every",
			"prob",
			"seed"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["fired"],
		usesInput: false
	},
	{
		id: 327,
		genName: "At",
		variantName: "default",
		className: "At_default_bar_scalar_every_audio_prob_scalar_seed_scalar",
		paramNames: [
			"bar",
			"every",
			"prob",
			"seed"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["fired"],
		usesInput: false
	},
	{
		id: 328,
		genName: "At",
		variantName: "default",
		className: "At_default_bar_scalar_every_audio_prob_audio_seed_scalar",
		paramNames: [
			"bar",
			"every",
			"prob",
			"seed"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["fired"],
		usesInput: false
	},
	{
		id: 329,
		genName: "At",
		variantName: "default",
		className: "At_default_bar_audio_every_scalar_prob_scalar_seed_scalar",
		paramNames: [
			"bar",
			"every",
			"prob",
			"seed"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["fired"],
		usesInput: false
	},
	{
		id: 330,
		genName: "At",
		variantName: "default",
		className: "At_default_bar_audio_every_scalar_prob_audio_seed_scalar",
		paramNames: [
			"bar",
			"every",
			"prob",
			"seed"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["fired"],
		usesInput: false
	},
	{
		id: 331,
		genName: "At",
		variantName: "default",
		className: "At_default_bar_audio_every_audio_prob_scalar_seed_scalar",
		paramNames: [
			"bar",
			"every",
			"prob",
			"seed"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["fired"],
		usesInput: false
	},
	{
		id: 332,
		genName: "At",
		variantName: "default",
		className: "At_default_bar_audio_every_audio_prob_audio_seed_scalar",
		paramNames: [
			"bar",
			"every",
			"prob",
			"seed"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["fired"],
		usesInput: false
	},
	{
		id: 333,
		genName: "Diodeladder",
		variantName: "default",
		className: "Diodeladder_default_cutoff_scalar_q_scalar_k_scalar_sat_scalar",
		paramNames: [
			"cutoff",
			"q",
			"k",
			"sat"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 334,
		genName: "Diodeladder",
		variantName: "default",
		className: "Diodeladder_default_cutoff_scalar_q_scalar_k_scalar_sat_audio",
		paramNames: [
			"cutoff",
			"q",
			"k",
			"sat"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 335,
		genName: "Diodeladder",
		variantName: "default",
		className: "Diodeladder_default_cutoff_scalar_q_scalar_k_audio_sat_scalar",
		paramNames: [
			"cutoff",
			"q",
			"k",
			"sat"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 336,
		genName: "Diodeladder",
		variantName: "default",
		className: "Diodeladder_default_cutoff_scalar_q_scalar_k_audio_sat_audio",
		paramNames: [
			"cutoff",
			"q",
			"k",
			"sat"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 337,
		genName: "Diodeladder",
		variantName: "default",
		className: "Diodeladder_default_cutoff_scalar_q_audio_k_scalar_sat_scalar",
		paramNames: [
			"cutoff",
			"q",
			"k",
			"sat"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 338,
		genName: "Diodeladder",
		variantName: "default",
		className: "Diodeladder_default_cutoff_scalar_q_audio_k_scalar_sat_audio",
		paramNames: [
			"cutoff",
			"q",
			"k",
			"sat"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 339,
		genName: "Diodeladder",
		variantName: "default",
		className: "Diodeladder_default_cutoff_scalar_q_audio_k_audio_sat_scalar",
		paramNames: [
			"cutoff",
			"q",
			"k",
			"sat"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 340,
		genName: "Diodeladder",
		variantName: "default",
		className: "Diodeladder_default_cutoff_scalar_q_audio_k_audio_sat_audio",
		paramNames: [
			"cutoff",
			"q",
			"k",
			"sat"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 341,
		genName: "Diodeladder",
		variantName: "default",
		className: "Diodeladder_default_cutoff_audio_q_scalar_k_scalar_sat_scalar",
		paramNames: [
			"cutoff",
			"q",
			"k",
			"sat"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 342,
		genName: "Diodeladder",
		variantName: "default",
		className: "Diodeladder_default_cutoff_audio_q_scalar_k_scalar_sat_audio",
		paramNames: [
			"cutoff",
			"q",
			"k",
			"sat"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 343,
		genName: "Diodeladder",
		variantName: "default",
		className: "Diodeladder_default_cutoff_audio_q_scalar_k_audio_sat_scalar",
		paramNames: [
			"cutoff",
			"q",
			"k",
			"sat"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 344,
		genName: "Diodeladder",
		variantName: "default",
		className: "Diodeladder_default_cutoff_audio_q_scalar_k_audio_sat_audio",
		paramNames: [
			"cutoff",
			"q",
			"k",
			"sat"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 345,
		genName: "Diodeladder",
		variantName: "default",
		className: "Diodeladder_default_cutoff_audio_q_audio_k_scalar_sat_scalar",
		paramNames: [
			"cutoff",
			"q",
			"k",
			"sat"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 346,
		genName: "Diodeladder",
		variantName: "default",
		className: "Diodeladder_default_cutoff_audio_q_audio_k_scalar_sat_audio",
		paramNames: [
			"cutoff",
			"q",
			"k",
			"sat"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 347,
		genName: "Diodeladder",
		variantName: "default",
		className: "Diodeladder_default_cutoff_audio_q_audio_k_audio_sat_scalar",
		paramNames: [
			"cutoff",
			"q",
			"k",
			"sat"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 348,
		genName: "Diodeladder",
		variantName: "default",
		className: "Diodeladder_default_cutoff_audio_q_audio_k_audio_sat_audio",
		paramNames: [
			"cutoff",
			"q",
			"k",
			"sat"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 349,
		genName: "Ramp",
		variantName: "default",
		className: "Ramp_default_hz_scalar_offset_scalar_trig_scalar",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 350,
		genName: "Ramp",
		variantName: "default",
		className: "Ramp_default_hz_scalar_offset_scalar_trig_audio",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 351,
		genName: "Ramp",
		variantName: "default",
		className: "Ramp_default_hz_scalar_offset_audio_trig_scalar",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 352,
		genName: "Ramp",
		variantName: "default",
		className: "Ramp_default_hz_scalar_offset_audio_trig_audio",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 353,
		genName: "Ramp",
		variantName: "default",
		className: "Ramp_default_hz_audio_offset_scalar_trig_scalar",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 354,
		genName: "Ramp",
		variantName: "default",
		className: "Ramp_default_hz_audio_offset_scalar_trig_audio",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 355,
		genName: "Ramp",
		variantName: "default",
		className: "Ramp_default_hz_audio_offset_audio_trig_scalar",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 356,
		genName: "Ramp",
		variantName: "default",
		className: "Ramp_default_hz_audio_offset_audio_trig_audio",
		paramNames: [
			"hz",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: false
	},
	{
		id: 357,
		genName: "Smooth",
		variantName: "default",
		className: "Smooth_default_seed_scalar_rate_scalar_curve_scalar_trig_scalar",
		paramNames: [
			"seed",
			"rate",
			"curve",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 358,
		genName: "Smooth",
		variantName: "default",
		className: "Smooth_default_seed_scalar_rate_scalar_curve_scalar_trig_audio",
		paramNames: [
			"seed",
			"rate",
			"curve",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 359,
		genName: "Smooth",
		variantName: "default",
		className: "Smooth_default_seed_scalar_rate_scalar_curve_audio_trig_scalar",
		paramNames: [
			"seed",
			"rate",
			"curve",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 360,
		genName: "Smooth",
		variantName: "default",
		className: "Smooth_default_seed_scalar_rate_scalar_curve_audio_trig_audio",
		paramNames: [
			"seed",
			"rate",
			"curve",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 361,
		genName: "Smooth",
		variantName: "default",
		className: "Smooth_default_seed_scalar_rate_audio_curve_scalar_trig_scalar",
		paramNames: [
			"seed",
			"rate",
			"curve",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 362,
		genName: "Smooth",
		variantName: "default",
		className: "Smooth_default_seed_scalar_rate_audio_curve_scalar_trig_audio",
		paramNames: [
			"seed",
			"rate",
			"curve",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 363,
		genName: "Smooth",
		variantName: "default",
		className: "Smooth_default_seed_scalar_rate_audio_curve_audio_trig_scalar",
		paramNames: [
			"seed",
			"rate",
			"curve",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 364,
		genName: "Smooth",
		variantName: "default",
		className: "Smooth_default_seed_scalar_rate_audio_curve_audio_trig_audio",
		paramNames: [
			"seed",
			"rate",
			"curve",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 365,
		genName: "Lfotri",
		variantName: "default",
		className: "Lfotri_default_bar_scalar_offset_scalar_trig_scalar",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 366,
		genName: "Lfotri",
		variantName: "default",
		className: "Lfotri_default_bar_scalar_offset_scalar_trig_audio",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 367,
		genName: "Lfotri",
		variantName: "default",
		className: "Lfotri_default_bar_scalar_offset_audio_trig_scalar",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 368,
		genName: "Lfotri",
		variantName: "default",
		className: "Lfotri_default_bar_scalar_offset_audio_trig_audio",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 369,
		genName: "Lfotri",
		variantName: "default",
		className: "Lfotri_default_bar_audio_offset_scalar_trig_scalar",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 370,
		genName: "Lfotri",
		variantName: "default",
		className: "Lfotri_default_bar_audio_offset_scalar_trig_audio",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 371,
		genName: "Lfotri",
		variantName: "default",
		className: "Lfotri_default_bar_audio_offset_audio_trig_scalar",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 372,
		genName: "Lfotri",
		variantName: "default",
		className: "Lfotri_default_bar_audio_offset_audio_trig_audio",
		paramNames: [
			"bar",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 373,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_scalar_sustain_scalar_release_scalar_exponent_scalar_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 374,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_scalar_sustain_scalar_release_scalar_exponent_scalar_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 375,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_scalar_sustain_scalar_release_scalar_exponent_audio_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 376,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_scalar_sustain_scalar_release_scalar_exponent_audio_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 377,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_scalar_sustain_scalar_release_audio_exponent_scalar_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 378,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_scalar_sustain_scalar_release_audio_exponent_scalar_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 379,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_scalar_sustain_scalar_release_audio_exponent_audio_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 380,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_scalar_sustain_scalar_release_audio_exponent_audio_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"audio",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 381,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_scalar_sustain_audio_release_scalar_exponent_scalar_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 382,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_scalar_sustain_audio_release_scalar_exponent_scalar_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 383,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_scalar_sustain_audio_release_scalar_exponent_audio_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 384,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_scalar_sustain_audio_release_scalar_exponent_audio_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 385,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_scalar_sustain_audio_release_audio_exponent_scalar_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 386,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_scalar_sustain_audio_release_audio_exponent_scalar_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 387,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_scalar_sustain_audio_release_audio_exponent_audio_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 388,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_scalar_sustain_audio_release_audio_exponent_audio_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"audio",
			"audio",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 389,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_audio_sustain_scalar_release_scalar_exponent_scalar_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 390,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_audio_sustain_scalar_release_scalar_exponent_scalar_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 391,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_audio_sustain_scalar_release_scalar_exponent_audio_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 392,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_audio_sustain_scalar_release_scalar_exponent_audio_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 393,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_audio_sustain_scalar_release_audio_exponent_scalar_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 394,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_audio_sustain_scalar_release_audio_exponent_scalar_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 395,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_audio_sustain_scalar_release_audio_exponent_audio_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 396,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_audio_sustain_scalar_release_audio_exponent_audio_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"audio",
			"audio",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 397,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_audio_sustain_audio_release_scalar_exponent_scalar_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 398,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_audio_sustain_audio_release_scalar_exponent_scalar_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 399,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_audio_sustain_audio_release_scalar_exponent_audio_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 400,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_audio_sustain_audio_release_scalar_exponent_audio_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 401,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_audio_sustain_audio_release_audio_exponent_scalar_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 402,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_audio_sustain_audio_release_audio_exponent_scalar_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 403,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_audio_sustain_audio_release_audio_exponent_audio_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 404,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_scalar_decay_audio_sustain_audio_release_audio_exponent_audio_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"audio",
			"audio",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 405,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_scalar_sustain_scalar_release_scalar_exponent_scalar_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 406,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_scalar_sustain_scalar_release_scalar_exponent_scalar_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 407,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_scalar_sustain_scalar_release_scalar_exponent_audio_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 408,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_scalar_sustain_scalar_release_scalar_exponent_audio_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 409,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_scalar_sustain_scalar_release_audio_exponent_scalar_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 410,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_scalar_sustain_scalar_release_audio_exponent_scalar_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 411,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_scalar_sustain_scalar_release_audio_exponent_audio_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 412,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_scalar_sustain_scalar_release_audio_exponent_audio_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"audio",
			"audio",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 413,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_scalar_sustain_audio_release_scalar_exponent_scalar_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 414,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_scalar_sustain_audio_release_scalar_exponent_scalar_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 415,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_scalar_sustain_audio_release_scalar_exponent_audio_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 416,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_scalar_sustain_audio_release_scalar_exponent_audio_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 417,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_scalar_sustain_audio_release_audio_exponent_scalar_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 418,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_scalar_sustain_audio_release_audio_exponent_scalar_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 419,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_scalar_sustain_audio_release_audio_exponent_audio_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 420,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_scalar_sustain_audio_release_audio_exponent_audio_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"audio",
			"audio",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 421,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_audio_sustain_scalar_release_scalar_exponent_scalar_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 422,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_audio_sustain_scalar_release_scalar_exponent_scalar_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 423,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_audio_sustain_scalar_release_scalar_exponent_audio_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 424,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_audio_sustain_scalar_release_scalar_exponent_audio_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 425,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_audio_sustain_scalar_release_audio_exponent_scalar_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 426,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_audio_sustain_scalar_release_audio_exponent_scalar_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 427,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_audio_sustain_scalar_release_audio_exponent_audio_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 428,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_audio_sustain_scalar_release_audio_exponent_audio_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"audio",
			"audio",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 429,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_audio_sustain_audio_release_scalar_exponent_scalar_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 430,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_audio_sustain_audio_release_scalar_exponent_scalar_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 431,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_audio_sustain_audio_release_scalar_exponent_audio_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 432,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_audio_sustain_audio_release_scalar_exponent_audio_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 433,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_audio_sustain_audio_release_audio_exponent_scalar_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 434,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_audio_sustain_audio_release_audio_exponent_scalar_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 435,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_audio_sustain_audio_release_audio_exponent_audio_trig_scalar",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 436,
		genName: "Adsr",
		variantName: "default",
		className: "Adsr_default_attack_audio_decay_audio_sustain_audio_release_audio_exponent_audio_trig_audio",
		paramNames: [
			"attack",
			"decay",
			"sustain",
			"release",
			"exponent",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"audio",
			"audio",
			"audio"
		],
		emitNames: ["stage", "env"],
		usesInput: false
	},
	{
		id: 437,
		genName: "Analyser",
		variantName: "default",
		className: "Analyser_default_",
		paramNames: [],
		paramModes: [],
		emitNames: [],
		usesInput: true
	},
	{
		id: 438,
		genName: "Biquad",
		variantName: "lp",
		className: "Biquad_lp_cutoff_scalar_q_scalar",
		paramNames: ["cutoff", "q"],
		paramModes: ["scalar", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 439,
		genName: "Biquad",
		variantName: "lp",
		className: "Biquad_lp_cutoff_scalar_q_audio",
		paramNames: ["cutoff", "q"],
		paramModes: ["scalar", "audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 440,
		genName: "Biquad",
		variantName: "lp",
		className: "Biquad_lp_cutoff_audio_q_scalar",
		paramNames: ["cutoff", "q"],
		paramModes: ["audio", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 441,
		genName: "Biquad",
		variantName: "lp",
		className: "Biquad_lp_cutoff_audio_q_audio",
		paramNames: ["cutoff", "q"],
		paramModes: ["audio", "audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 442,
		genName: "Biquad",
		variantName: "hp",
		className: "Biquad_hp_cutoff_scalar_q_scalar",
		paramNames: ["cutoff", "q"],
		paramModes: ["scalar", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 443,
		genName: "Biquad",
		variantName: "hp",
		className: "Biquad_hp_cutoff_scalar_q_audio",
		paramNames: ["cutoff", "q"],
		paramModes: ["scalar", "audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 444,
		genName: "Biquad",
		variantName: "hp",
		className: "Biquad_hp_cutoff_audio_q_scalar",
		paramNames: ["cutoff", "q"],
		paramModes: ["audio", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 445,
		genName: "Biquad",
		variantName: "hp",
		className: "Biquad_hp_cutoff_audio_q_audio",
		paramNames: ["cutoff", "q"],
		paramModes: ["audio", "audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 446,
		genName: "Biquad",
		variantName: "bp",
		className: "Biquad_bp_cutoff_scalar_q_scalar",
		paramNames: ["cutoff", "q"],
		paramModes: ["scalar", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 447,
		genName: "Biquad",
		variantName: "bp",
		className: "Biquad_bp_cutoff_scalar_q_audio",
		paramNames: ["cutoff", "q"],
		paramModes: ["scalar", "audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 448,
		genName: "Biquad",
		variantName: "bp",
		className: "Biquad_bp_cutoff_audio_q_scalar",
		paramNames: ["cutoff", "q"],
		paramModes: ["audio", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 449,
		genName: "Biquad",
		variantName: "bp",
		className: "Biquad_bp_cutoff_audio_q_audio",
		paramNames: ["cutoff", "q"],
		paramModes: ["audio", "audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 450,
		genName: "Biquad",
		variantName: "bs",
		className: "Biquad_bs_cutoff_scalar_q_scalar",
		paramNames: ["cutoff", "q"],
		paramModes: ["scalar", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 451,
		genName: "Biquad",
		variantName: "bs",
		className: "Biquad_bs_cutoff_scalar_q_audio",
		paramNames: ["cutoff", "q"],
		paramModes: ["scalar", "audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 452,
		genName: "Biquad",
		variantName: "bs",
		className: "Biquad_bs_cutoff_audio_q_scalar",
		paramNames: ["cutoff", "q"],
		paramModes: ["audio", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 453,
		genName: "Biquad",
		variantName: "bs",
		className: "Biquad_bs_cutoff_audio_q_audio",
		paramNames: ["cutoff", "q"],
		paramModes: ["audio", "audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 454,
		genName: "Biquad",
		variantName: "ap",
		className: "Biquad_ap_cutoff_scalar_q_scalar",
		paramNames: ["cutoff", "q"],
		paramModes: ["scalar", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 455,
		genName: "Biquad",
		variantName: "ap",
		className: "Biquad_ap_cutoff_scalar_q_audio",
		paramNames: ["cutoff", "q"],
		paramModes: ["scalar", "audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 456,
		genName: "Biquad",
		variantName: "ap",
		className: "Biquad_ap_cutoff_audio_q_scalar",
		paramNames: ["cutoff", "q"],
		paramModes: ["audio", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 457,
		genName: "Biquad",
		variantName: "ap",
		className: "Biquad_ap_cutoff_audio_q_audio",
		paramNames: ["cutoff", "q"],
		paramModes: ["audio", "audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 458,
		genName: "Envfollow",
		variantName: "default",
		className: "Envfollow_default_attack_scalar_release_scalar",
		paramNames: ["attack", "release"],
		paramModes: ["scalar", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 459,
		genName: "Envfollow",
		variantName: "default",
		className: "Envfollow_default_attack_scalar_release_audio",
		paramNames: ["attack", "release"],
		paramModes: ["scalar", "audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 460,
		genName: "Envfollow",
		variantName: "default",
		className: "Envfollow_default_attack_audio_release_scalar",
		paramNames: ["attack", "release"],
		paramModes: ["audio", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 461,
		genName: "Envfollow",
		variantName: "default",
		className: "Envfollow_default_attack_audio_release_audio",
		paramNames: ["attack", "release"],
		paramModes: ["audio", "audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 462,
		genName: "Sah",
		variantName: "default",
		className: "Sah_default_trig_scalar",
		paramNames: ["trig"],
		paramModes: ["scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 463,
		genName: "Sah",
		variantName: "default",
		className: "Sah_default_trig_audio",
		paramNames: ["trig"],
		paramModes: ["audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 464,
		genName: "Velvet",
		variantName: "default",
		className: "Velvet_default_room_scalar_damping_scalar_decay_scalar",
		paramNames: [
			"room",
			"damping",
			"decay"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 465,
		genName: "Velvet",
		variantName: "default",
		className: "Velvet_default_room_scalar_damping_scalar_decay_audio",
		paramNames: [
			"room",
			"damping",
			"decay"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 466,
		genName: "Velvet",
		variantName: "default",
		className: "Velvet_default_room_scalar_damping_audio_decay_scalar",
		paramNames: [
			"room",
			"damping",
			"decay"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 467,
		genName: "Velvet",
		variantName: "default",
		className: "Velvet_default_room_scalar_damping_audio_decay_audio",
		paramNames: [
			"room",
			"damping",
			"decay"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 468,
		genName: "Velvet",
		variantName: "default",
		className: "Velvet_default_room_audio_damping_scalar_decay_scalar",
		paramNames: [
			"room",
			"damping",
			"decay"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 469,
		genName: "Velvet",
		variantName: "default",
		className: "Velvet_default_room_audio_damping_scalar_decay_audio",
		paramNames: [
			"room",
			"damping",
			"decay"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 470,
		genName: "Velvet",
		variantName: "default",
		className: "Velvet_default_room_audio_damping_audio_decay_scalar",
		paramNames: [
			"room",
			"damping",
			"decay"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 471,
		genName: "Velvet",
		variantName: "default",
		className: "Velvet_default_room_audio_damping_audio_decay_audio",
		paramNames: [
			"room",
			"damping",
			"decay"
		],
		paramModes: [
			"audio",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 472,
		genName: "Velvet",
		variantName: "default",
		className: "Velvet_default_room_scalar_damping_scalar_decay_scalar_stereo",
		paramNames: [
			"room",
			"damping",
			"decay"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 473,
		genName: "Velvet",
		variantName: "default",
		className: "Velvet_default_room_scalar_damping_scalar_decay_audio_stereo",
		paramNames: [
			"room",
			"damping",
			"decay"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 474,
		genName: "Velvet",
		variantName: "default",
		className: "Velvet_default_room_scalar_damping_audio_decay_scalar_stereo",
		paramNames: [
			"room",
			"damping",
			"decay"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 475,
		genName: "Velvet",
		variantName: "default",
		className: "Velvet_default_room_scalar_damping_audio_decay_audio_stereo",
		paramNames: [
			"room",
			"damping",
			"decay"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 476,
		genName: "Velvet",
		variantName: "default",
		className: "Velvet_default_room_audio_damping_scalar_decay_scalar_stereo",
		paramNames: [
			"room",
			"damping",
			"decay"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 477,
		genName: "Velvet",
		variantName: "default",
		className: "Velvet_default_room_audio_damping_scalar_decay_audio_stereo",
		paramNames: [
			"room",
			"damping",
			"decay"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 478,
		genName: "Velvet",
		variantName: "default",
		className: "Velvet_default_room_audio_damping_audio_decay_scalar_stereo",
		paramNames: [
			"room",
			"damping",
			"decay"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 479,
		genName: "Velvet",
		variantName: "default",
		className: "Velvet_default_room_audio_damping_audio_decay_audio_stereo",
		paramNames: [
			"room",
			"damping",
			"decay"
		],
		paramModes: [
			"audio",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 480,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_scalar_damping_scalar_decay_scalar_depth_scalar",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 481,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_scalar_damping_scalar_decay_scalar_depth_audio",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 482,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_scalar_damping_scalar_decay_audio_depth_scalar",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 483,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_scalar_damping_scalar_decay_audio_depth_audio",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 484,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_scalar_damping_audio_decay_scalar_depth_scalar",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 485,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_scalar_damping_audio_decay_scalar_depth_audio",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 486,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_scalar_damping_audio_decay_audio_depth_scalar",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 487,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_scalar_damping_audio_decay_audio_depth_audio",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 488,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_audio_damping_scalar_decay_scalar_depth_scalar",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 489,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_audio_damping_scalar_decay_scalar_depth_audio",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 490,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_audio_damping_scalar_decay_audio_depth_scalar",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 491,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_audio_damping_scalar_decay_audio_depth_audio",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 492,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_audio_damping_audio_decay_scalar_depth_scalar",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 493,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_audio_damping_audio_decay_scalar_depth_audio",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 494,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_audio_damping_audio_decay_audio_depth_scalar",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 495,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_audio_damping_audio_decay_audio_depth_audio",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 496,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_scalar_damping_scalar_decay_scalar_depth_scalar_stereo",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 497,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_scalar_damping_scalar_decay_scalar_depth_audio_stereo",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 498,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_scalar_damping_scalar_decay_audio_depth_scalar_stereo",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 499,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_scalar_damping_scalar_decay_audio_depth_audio_stereo",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 500,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_scalar_damping_audio_decay_scalar_depth_scalar_stereo",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 501,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_scalar_damping_audio_decay_scalar_depth_audio_stereo",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 502,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_scalar_damping_audio_decay_audio_depth_scalar_stereo",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 503,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_scalar_damping_audio_decay_audio_depth_audio_stereo",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 504,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_audio_damping_scalar_decay_scalar_depth_scalar_stereo",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 505,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_audio_damping_scalar_decay_scalar_depth_audio_stereo",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 506,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_audio_damping_scalar_decay_audio_depth_scalar_stereo",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 507,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_audio_damping_scalar_decay_audio_depth_audio_stereo",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 508,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_audio_damping_audio_decay_scalar_depth_scalar_stereo",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 509,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_audio_damping_audio_decay_scalar_depth_audio_stereo",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 510,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_audio_damping_audio_decay_audio_depth_scalar_stereo",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 511,
		genName: "Fdn",
		variantName: "default",
		className: "Fdn_default_room_audio_damping_audio_decay_audio_depth_audio_stereo",
		paramNames: [
			"room",
			"damping",
			"decay",
			"depth"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 512,
		genName: "Pink",
		variantName: "default",
		className: "Pink_default_seed_scalar_trig_scalar",
		paramNames: ["seed", "trig"],
		paramModes: ["scalar", "scalar"],
		emitNames: [],
		usesInput: false
	},
	{
		id: 513,
		genName: "Pink",
		variantName: "default",
		className: "Pink_default_seed_scalar_trig_audio",
		paramNames: ["seed", "trig"],
		paramModes: ["scalar", "audio"],
		emitNames: [],
		usesInput: false
	},
	{
		id: 514,
		genName: "Dattorro",
		variantName: "default",
		className: "Dattorro_default_room_scalar_damping_scalar_bandwidth_scalar_indiff1_scalar_indiff2_scalar_decdiff1_scalar_decdiff2_scalar_excrate_scalar_excdepth_scalar_predelay_scalar",
		paramNames: [
			"room",
			"damping",
			"bandwidth",
			"indiff1",
			"indiff2",
			"decdiff1",
			"decdiff2",
			"excrate",
			"excdepth",
			"predelay"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 515,
		genName: "Dattorro",
		variantName: "default",
		className: "Dattorro_default_room_scalar_damping_scalar_bandwidth_audio_indiff1_scalar_indiff2_scalar_decdiff1_scalar_decdiff2_scalar_excrate_scalar_excdepth_scalar_predelay_scalar",
		paramNames: [
			"room",
			"damping",
			"bandwidth",
			"indiff1",
			"indiff2",
			"decdiff1",
			"decdiff2",
			"excrate",
			"excdepth",
			"predelay"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 516,
		genName: "Dattorro",
		variantName: "default",
		className: "Dattorro_default_room_scalar_damping_audio_bandwidth_scalar_indiff1_scalar_indiff2_scalar_decdiff1_scalar_decdiff2_scalar_excrate_scalar_excdepth_scalar_predelay_scalar",
		paramNames: [
			"room",
			"damping",
			"bandwidth",
			"indiff1",
			"indiff2",
			"decdiff1",
			"decdiff2",
			"excrate",
			"excdepth",
			"predelay"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 517,
		genName: "Dattorro",
		variantName: "default",
		className: "Dattorro_default_room_scalar_damping_audio_bandwidth_audio_indiff1_scalar_indiff2_scalar_decdiff1_scalar_decdiff2_scalar_excrate_scalar_excdepth_scalar_predelay_scalar",
		paramNames: [
			"room",
			"damping",
			"bandwidth",
			"indiff1",
			"indiff2",
			"decdiff1",
			"decdiff2",
			"excrate",
			"excdepth",
			"predelay"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 518,
		genName: "Dattorro",
		variantName: "default",
		className: "Dattorro_default_room_audio_damping_scalar_bandwidth_scalar_indiff1_scalar_indiff2_scalar_decdiff1_scalar_decdiff2_scalar_excrate_scalar_excdepth_scalar_predelay_scalar",
		paramNames: [
			"room",
			"damping",
			"bandwidth",
			"indiff1",
			"indiff2",
			"decdiff1",
			"decdiff2",
			"excrate",
			"excdepth",
			"predelay"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 519,
		genName: "Dattorro",
		variantName: "default",
		className: "Dattorro_default_room_audio_damping_scalar_bandwidth_audio_indiff1_scalar_indiff2_scalar_decdiff1_scalar_decdiff2_scalar_excrate_scalar_excdepth_scalar_predelay_scalar",
		paramNames: [
			"room",
			"damping",
			"bandwidth",
			"indiff1",
			"indiff2",
			"decdiff1",
			"decdiff2",
			"excrate",
			"excdepth",
			"predelay"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 520,
		genName: "Dattorro",
		variantName: "default",
		className: "Dattorro_default_room_audio_damping_audio_bandwidth_scalar_indiff1_scalar_indiff2_scalar_decdiff1_scalar_decdiff2_scalar_excrate_scalar_excdepth_scalar_predelay_scalar",
		paramNames: [
			"room",
			"damping",
			"bandwidth",
			"indiff1",
			"indiff2",
			"decdiff1",
			"decdiff2",
			"excrate",
			"excdepth",
			"predelay"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 521,
		genName: "Dattorro",
		variantName: "default",
		className: "Dattorro_default_room_audio_damping_audio_bandwidth_audio_indiff1_scalar_indiff2_scalar_decdiff1_scalar_decdiff2_scalar_excrate_scalar_excdepth_scalar_predelay_scalar",
		paramNames: [
			"room",
			"damping",
			"bandwidth",
			"indiff1",
			"indiff2",
			"decdiff1",
			"decdiff2",
			"excrate",
			"excdepth",
			"predelay"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 522,
		genName: "Dattorro",
		variantName: "default",
		className: "Dattorro_default_room_scalar_damping_scalar_bandwidth_scalar_indiff1_scalar_indiff2_scalar_decdiff1_scalar_decdiff2_scalar_excrate_scalar_excdepth_scalar_predelay_scalar_stereo",
		paramNames: [
			"room",
			"damping",
			"bandwidth",
			"indiff1",
			"indiff2",
			"decdiff1",
			"decdiff2",
			"excrate",
			"excdepth",
			"predelay"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 523,
		genName: "Dattorro",
		variantName: "default",
		className: "Dattorro_default_room_scalar_damping_scalar_bandwidth_audio_indiff1_scalar_indiff2_scalar_decdiff1_scalar_decdiff2_scalar_excrate_scalar_excdepth_scalar_predelay_scalar_stereo",
		paramNames: [
			"room",
			"damping",
			"bandwidth",
			"indiff1",
			"indiff2",
			"decdiff1",
			"decdiff2",
			"excrate",
			"excdepth",
			"predelay"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 524,
		genName: "Dattorro",
		variantName: "default",
		className: "Dattorro_default_room_scalar_damping_audio_bandwidth_scalar_indiff1_scalar_indiff2_scalar_decdiff1_scalar_decdiff2_scalar_excrate_scalar_excdepth_scalar_predelay_scalar_stereo",
		paramNames: [
			"room",
			"damping",
			"bandwidth",
			"indiff1",
			"indiff2",
			"decdiff1",
			"decdiff2",
			"excrate",
			"excdepth",
			"predelay"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 525,
		genName: "Dattorro",
		variantName: "default",
		className: "Dattorro_default_room_scalar_damping_audio_bandwidth_audio_indiff1_scalar_indiff2_scalar_decdiff1_scalar_decdiff2_scalar_excrate_scalar_excdepth_scalar_predelay_scalar_stereo",
		paramNames: [
			"room",
			"damping",
			"bandwidth",
			"indiff1",
			"indiff2",
			"decdiff1",
			"decdiff2",
			"excrate",
			"excdepth",
			"predelay"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 526,
		genName: "Dattorro",
		variantName: "default",
		className: "Dattorro_default_room_audio_damping_scalar_bandwidth_scalar_indiff1_scalar_indiff2_scalar_decdiff1_scalar_decdiff2_scalar_excrate_scalar_excdepth_scalar_predelay_scalar_stereo",
		paramNames: [
			"room",
			"damping",
			"bandwidth",
			"indiff1",
			"indiff2",
			"decdiff1",
			"decdiff2",
			"excrate",
			"excdepth",
			"predelay"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 527,
		genName: "Dattorro",
		variantName: "default",
		className: "Dattorro_default_room_audio_damping_scalar_bandwidth_audio_indiff1_scalar_indiff2_scalar_decdiff1_scalar_decdiff2_scalar_excrate_scalar_excdepth_scalar_predelay_scalar_stereo",
		paramNames: [
			"room",
			"damping",
			"bandwidth",
			"indiff1",
			"indiff2",
			"decdiff1",
			"decdiff2",
			"excrate",
			"excdepth",
			"predelay"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 528,
		genName: "Dattorro",
		variantName: "default",
		className: "Dattorro_default_room_audio_damping_audio_bandwidth_scalar_indiff1_scalar_indiff2_scalar_decdiff1_scalar_decdiff2_scalar_excrate_scalar_excdepth_scalar_predelay_scalar_stereo",
		paramNames: [
			"room",
			"damping",
			"bandwidth",
			"indiff1",
			"indiff2",
			"decdiff1",
			"decdiff2",
			"excrate",
			"excdepth",
			"predelay"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 529,
		genName: "Dattorro",
		variantName: "default",
		className: "Dattorro_default_room_audio_damping_audio_bandwidth_audio_indiff1_scalar_indiff2_scalar_decdiff1_scalar_decdiff2_scalar_excrate_scalar_excdepth_scalar_predelay_scalar_stereo",
		paramNames: [
			"room",
			"damping",
			"bandwidth",
			"indiff1",
			"indiff2",
			"decdiff1",
			"decdiff2",
			"excrate",
			"excdepth",
			"predelay"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 530,
		genName: "Random",
		variantName: "default",
		className: "Random_default_seed_scalar",
		paramNames: ["seed"],
		paramModes: ["scalar"],
		emitNames: [],
		usesInput: false
	},
	{
		id: 531,
		genName: "Slew",
		variantName: "default",
		className: "Slew_default_up_scalar_down_scalar_exp_scalar",
		paramNames: [
			"up",
			"down",
			"exp"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 532,
		genName: "Slew",
		variantName: "default",
		className: "Slew_default_up_scalar_down_scalar_exp_audio",
		paramNames: [
			"up",
			"down",
			"exp"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 533,
		genName: "Slew",
		variantName: "default",
		className: "Slew_default_up_scalar_down_audio_exp_scalar",
		paramNames: [
			"up",
			"down",
			"exp"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 534,
		genName: "Slew",
		variantName: "default",
		className: "Slew_default_up_scalar_down_audio_exp_audio",
		paramNames: [
			"up",
			"down",
			"exp"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 535,
		genName: "Slew",
		variantName: "default",
		className: "Slew_default_up_audio_down_scalar_exp_scalar",
		paramNames: [
			"up",
			"down",
			"exp"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 536,
		genName: "Slew",
		variantName: "default",
		className: "Slew_default_up_audio_down_scalar_exp_audio",
		paramNames: [
			"up",
			"down",
			"exp"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 537,
		genName: "Slew",
		variantName: "default",
		className: "Slew_default_up_audio_down_audio_exp_scalar",
		paramNames: [
			"up",
			"down",
			"exp"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 538,
		genName: "Slew",
		variantName: "default",
		className: "Slew_default_up_audio_down_audio_exp_audio",
		paramNames: [
			"up",
			"down",
			"exp"
		],
		paramModes: [
			"audio",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 539,
		genName: "Inc",
		variantName: "default",
		className: "Inc_default_hz_scalar_ceil_scalar_offset_scalar_trig_scalar",
		paramNames: [
			"hz",
			"ceil",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 540,
		genName: "Inc",
		variantName: "default",
		className: "Inc_default_hz_scalar_ceil_scalar_offset_scalar_trig_audio",
		paramNames: [
			"hz",
			"ceil",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 541,
		genName: "Inc",
		variantName: "default",
		className: "Inc_default_hz_scalar_ceil_scalar_offset_audio_trig_scalar",
		paramNames: [
			"hz",
			"ceil",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 542,
		genName: "Inc",
		variantName: "default",
		className: "Inc_default_hz_scalar_ceil_scalar_offset_audio_trig_audio",
		paramNames: [
			"hz",
			"ceil",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 543,
		genName: "Inc",
		variantName: "default",
		className: "Inc_default_hz_scalar_ceil_audio_offset_scalar_trig_scalar",
		paramNames: [
			"hz",
			"ceil",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 544,
		genName: "Inc",
		variantName: "default",
		className: "Inc_default_hz_scalar_ceil_audio_offset_scalar_trig_audio",
		paramNames: [
			"hz",
			"ceil",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 545,
		genName: "Inc",
		variantName: "default",
		className: "Inc_default_hz_scalar_ceil_audio_offset_audio_trig_scalar",
		paramNames: [
			"hz",
			"ceil",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 546,
		genName: "Inc",
		variantName: "default",
		className: "Inc_default_hz_scalar_ceil_audio_offset_audio_trig_audio",
		paramNames: [
			"hz",
			"ceil",
			"offset",
			"trig"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 547,
		genName: "Inc",
		variantName: "default",
		className: "Inc_default_hz_audio_ceil_scalar_offset_scalar_trig_scalar",
		paramNames: [
			"hz",
			"ceil",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 548,
		genName: "Inc",
		variantName: "default",
		className: "Inc_default_hz_audio_ceil_scalar_offset_scalar_trig_audio",
		paramNames: [
			"hz",
			"ceil",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 549,
		genName: "Inc",
		variantName: "default",
		className: "Inc_default_hz_audio_ceil_scalar_offset_audio_trig_scalar",
		paramNames: [
			"hz",
			"ceil",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 550,
		genName: "Inc",
		variantName: "default",
		className: "Inc_default_hz_audio_ceil_scalar_offset_audio_trig_audio",
		paramNames: [
			"hz",
			"ceil",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 551,
		genName: "Inc",
		variantName: "default",
		className: "Inc_default_hz_audio_ceil_audio_offset_scalar_trig_scalar",
		paramNames: [
			"hz",
			"ceil",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 552,
		genName: "Inc",
		variantName: "default",
		className: "Inc_default_hz_audio_ceil_audio_offset_scalar_trig_audio",
		paramNames: [
			"hz",
			"ceil",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 553,
		genName: "Inc",
		variantName: "default",
		className: "Inc_default_hz_audio_ceil_audio_offset_audio_trig_scalar",
		paramNames: [
			"hz",
			"ceil",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"scalar"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 554,
		genName: "Inc",
		variantName: "default",
		className: "Inc_default_hz_audio_ceil_audio_offset_audio_trig_audio",
		paramNames: [
			"hz",
			"ceil",
			"offset",
			"trig"
		],
		paramModes: [
			"audio",
			"audio",
			"audio",
			"audio"
		],
		emitNames: ["phase"],
		usesInput: false
	},
	{
		id: 555,
		genName: "Biquadshelf",
		variantName: "ls",
		className: "Biquadshelf_ls_cutoff_scalar_q_scalar_gain_scalar",
		paramNames: [
			"cutoff",
			"q",
			"gain"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 556,
		genName: "Biquadshelf",
		variantName: "ls",
		className: "Biquadshelf_ls_cutoff_scalar_q_scalar_gain_audio",
		paramNames: [
			"cutoff",
			"q",
			"gain"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 557,
		genName: "Biquadshelf",
		variantName: "ls",
		className: "Biquadshelf_ls_cutoff_scalar_q_audio_gain_scalar",
		paramNames: [
			"cutoff",
			"q",
			"gain"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 558,
		genName: "Biquadshelf",
		variantName: "ls",
		className: "Biquadshelf_ls_cutoff_scalar_q_audio_gain_audio",
		paramNames: [
			"cutoff",
			"q",
			"gain"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 559,
		genName: "Biquadshelf",
		variantName: "ls",
		className: "Biquadshelf_ls_cutoff_audio_q_scalar_gain_scalar",
		paramNames: [
			"cutoff",
			"q",
			"gain"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 560,
		genName: "Biquadshelf",
		variantName: "ls",
		className: "Biquadshelf_ls_cutoff_audio_q_scalar_gain_audio",
		paramNames: [
			"cutoff",
			"q",
			"gain"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 561,
		genName: "Biquadshelf",
		variantName: "ls",
		className: "Biquadshelf_ls_cutoff_audio_q_audio_gain_scalar",
		paramNames: [
			"cutoff",
			"q",
			"gain"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 562,
		genName: "Biquadshelf",
		variantName: "ls",
		className: "Biquadshelf_ls_cutoff_audio_q_audio_gain_audio",
		paramNames: [
			"cutoff",
			"q",
			"gain"
		],
		paramModes: [
			"audio",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 563,
		genName: "Biquadshelf",
		variantName: "hs",
		className: "Biquadshelf_hs_cutoff_scalar_q_scalar_gain_scalar",
		paramNames: [
			"cutoff",
			"q",
			"gain"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 564,
		genName: "Biquadshelf",
		variantName: "hs",
		className: "Biquadshelf_hs_cutoff_scalar_q_scalar_gain_audio",
		paramNames: [
			"cutoff",
			"q",
			"gain"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 565,
		genName: "Biquadshelf",
		variantName: "hs",
		className: "Biquadshelf_hs_cutoff_scalar_q_audio_gain_scalar",
		paramNames: [
			"cutoff",
			"q",
			"gain"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 566,
		genName: "Biquadshelf",
		variantName: "hs",
		className: "Biquadshelf_hs_cutoff_scalar_q_audio_gain_audio",
		paramNames: [
			"cutoff",
			"q",
			"gain"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 567,
		genName: "Biquadshelf",
		variantName: "hs",
		className: "Biquadshelf_hs_cutoff_audio_q_scalar_gain_scalar",
		paramNames: [
			"cutoff",
			"q",
			"gain"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 568,
		genName: "Biquadshelf",
		variantName: "hs",
		className: "Biquadshelf_hs_cutoff_audio_q_scalar_gain_audio",
		paramNames: [
			"cutoff",
			"q",
			"gain"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 569,
		genName: "Biquadshelf",
		variantName: "hs",
		className: "Biquadshelf_hs_cutoff_audio_q_audio_gain_scalar",
		paramNames: [
			"cutoff",
			"q",
			"gain"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 570,
		genName: "Biquadshelf",
		variantName: "hs",
		className: "Biquadshelf_hs_cutoff_audio_q_audio_gain_audio",
		paramNames: [
			"cutoff",
			"q",
			"gain"
		],
		paramModes: [
			"audio",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 571,
		genName: "Biquadshelf",
		variantName: "peak",
		className: "Biquadshelf_peak_cutoff_scalar_q_scalar_gain_scalar",
		paramNames: [
			"cutoff",
			"q",
			"gain"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 572,
		genName: "Biquadshelf",
		variantName: "peak",
		className: "Biquadshelf_peak_cutoff_scalar_q_scalar_gain_audio",
		paramNames: [
			"cutoff",
			"q",
			"gain"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 573,
		genName: "Biquadshelf",
		variantName: "peak",
		className: "Biquadshelf_peak_cutoff_scalar_q_audio_gain_scalar",
		paramNames: [
			"cutoff",
			"q",
			"gain"
		],
		paramModes: [
			"scalar",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 574,
		genName: "Biquadshelf",
		variantName: "peak",
		className: "Biquadshelf_peak_cutoff_scalar_q_audio_gain_audio",
		paramNames: [
			"cutoff",
			"q",
			"gain"
		],
		paramModes: [
			"scalar",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 575,
		genName: "Biquadshelf",
		variantName: "peak",
		className: "Biquadshelf_peak_cutoff_audio_q_scalar_gain_scalar",
		paramNames: [
			"cutoff",
			"q",
			"gain"
		],
		paramModes: [
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 576,
		genName: "Biquadshelf",
		variantName: "peak",
		className: "Biquadshelf_peak_cutoff_audio_q_scalar_gain_audio",
		paramNames: [
			"cutoff",
			"q",
			"gain"
		],
		paramModes: [
			"audio",
			"scalar",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 577,
		genName: "Biquadshelf",
		variantName: "peak",
		className: "Biquadshelf_peak_cutoff_audio_q_audio_gain_scalar",
		paramNames: [
			"cutoff",
			"q",
			"gain"
		],
		paramModes: [
			"audio",
			"audio",
			"scalar"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 578,
		genName: "Biquadshelf",
		variantName: "peak",
		className: "Biquadshelf_peak_cutoff_audio_q_audio_gain_audio",
		paramNames: [
			"cutoff",
			"q",
			"gain"
		],
		paramModes: [
			"audio",
			"audio",
			"audio"
		],
		emitNames: [],
		usesInput: true
	},
	{
		id: 579,
		genName: "Sampler",
		variantName: "default",
		className: "Sampler_default_sample_scalar_speed_scalar_offset_scalar_repeat_scalar_trig_scalar",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["position", "playing"],
		usesInput: false
	},
	{
		id: 580,
		genName: "Sampler",
		variantName: "default",
		className: "Sampler_default_sample_scalar_speed_scalar_offset_scalar_repeat_scalar_trig_audio",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["position", "playing"],
		usesInput: false
	},
	{
		id: 581,
		genName: "Sampler",
		variantName: "default",
		className: "Sampler_default_sample_scalar_speed_scalar_offset_audio_repeat_scalar_trig_scalar",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["position", "playing"],
		usesInput: false
	},
	{
		id: 582,
		genName: "Sampler",
		variantName: "default",
		className: "Sampler_default_sample_scalar_speed_scalar_offset_audio_repeat_scalar_trig_audio",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["position", "playing"],
		usesInput: false
	},
	{
		id: 583,
		genName: "Sampler",
		variantName: "default",
		className: "Sampler_default_sample_scalar_speed_scalar_offset_scalar_repeat_scalar_trig_scalar_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"scalar"
		],
		emitNames: ["position", "playing"],
		usesInput: false
	},
	{
		id: 584,
		genName: "Sampler",
		variantName: "default",
		className: "Sampler_default_sample_scalar_speed_scalar_offset_scalar_repeat_scalar_trig_audio_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"scalar",
			"scalar",
			"audio"
		],
		emitNames: ["position", "playing"],
		usesInput: false
	},
	{
		id: 585,
		genName: "Sampler",
		variantName: "default",
		className: "Sampler_default_sample_scalar_speed_scalar_offset_audio_repeat_scalar_trig_scalar_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"scalar"
		],
		emitNames: ["position", "playing"],
		usesInput: false
	},
	{
		id: 586,
		genName: "Sampler",
		variantName: "default",
		className: "Sampler_default_sample_scalar_speed_scalar_offset_audio_repeat_scalar_trig_audio_stereo",
		paramNames: [
			"sample",
			"speed",
			"offset",
			"repeat",
			"trig"
		],
		paramModes: [
			"scalar",
			"scalar",
			"audio",
			"scalar",
			"audio"
		],
		emitNames: ["position", "playing"],
		usesInput: false
	},
	{
		id: 587,
		genName: "Moog",
		variantName: "lpm",
		className: "Moog_lpm_cutoff_scalar_q_scalar",
		paramNames: ["cutoff", "q"],
		paramModes: ["scalar", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 588,
		genName: "Moog",
		variantName: "lpm",
		className: "Moog_lpm_cutoff_audio_q_scalar",
		paramNames: ["cutoff", "q"],
		paramModes: ["audio", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 589,
		genName: "Moog",
		variantName: "hpm",
		className: "Moog_hpm_cutoff_scalar_q_scalar",
		paramNames: ["cutoff", "q"],
		paramModes: ["scalar", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 590,
		genName: "Moog",
		variantName: "hpm",
		className: "Moog_hpm_cutoff_audio_q_scalar",
		paramNames: ["cutoff", "q"],
		paramModes: ["audio", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 591,
		genName: "Svf",
		variantName: "lps",
		className: "Svf_lps_cutoff_scalar_q_scalar",
		paramNames: ["cutoff", "q"],
		paramModes: ["scalar", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 592,
		genName: "Svf",
		variantName: "lps",
		className: "Svf_lps_cutoff_scalar_q_audio",
		paramNames: ["cutoff", "q"],
		paramModes: ["scalar", "audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 593,
		genName: "Svf",
		variantName: "lps",
		className: "Svf_lps_cutoff_audio_q_scalar",
		paramNames: ["cutoff", "q"],
		paramModes: ["audio", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 594,
		genName: "Svf",
		variantName: "lps",
		className: "Svf_lps_cutoff_audio_q_audio",
		paramNames: ["cutoff", "q"],
		paramModes: ["audio", "audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 595,
		genName: "Svf",
		variantName: "hps",
		className: "Svf_hps_cutoff_scalar_q_scalar",
		paramNames: ["cutoff", "q"],
		paramModes: ["scalar", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 596,
		genName: "Svf",
		variantName: "hps",
		className: "Svf_hps_cutoff_scalar_q_audio",
		paramNames: ["cutoff", "q"],
		paramModes: ["scalar", "audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 597,
		genName: "Svf",
		variantName: "hps",
		className: "Svf_hps_cutoff_audio_q_scalar",
		paramNames: ["cutoff", "q"],
		paramModes: ["audio", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 598,
		genName: "Svf",
		variantName: "hps",
		className: "Svf_hps_cutoff_audio_q_audio",
		paramNames: ["cutoff", "q"],
		paramModes: ["audio", "audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 599,
		genName: "Svf",
		variantName: "bps",
		className: "Svf_bps_cutoff_scalar_q_scalar",
		paramNames: ["cutoff", "q"],
		paramModes: ["scalar", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 600,
		genName: "Svf",
		variantName: "bps",
		className: "Svf_bps_cutoff_scalar_q_audio",
		paramNames: ["cutoff", "q"],
		paramModes: ["scalar", "audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 601,
		genName: "Svf",
		variantName: "bps",
		className: "Svf_bps_cutoff_audio_q_scalar",
		paramNames: ["cutoff", "q"],
		paramModes: ["audio", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 602,
		genName: "Svf",
		variantName: "bps",
		className: "Svf_bps_cutoff_audio_q_audio",
		paramNames: ["cutoff", "q"],
		paramModes: ["audio", "audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 603,
		genName: "Svf",
		variantName: "bss",
		className: "Svf_bss_cutoff_scalar_q_scalar",
		paramNames: ["cutoff", "q"],
		paramModes: ["scalar", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 604,
		genName: "Svf",
		variantName: "bss",
		className: "Svf_bss_cutoff_scalar_q_audio",
		paramNames: ["cutoff", "q"],
		paramModes: ["scalar", "audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 605,
		genName: "Svf",
		variantName: "bss",
		className: "Svf_bss_cutoff_audio_q_scalar",
		paramNames: ["cutoff", "q"],
		paramModes: ["audio", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 606,
		genName: "Svf",
		variantName: "bss",
		className: "Svf_bss_cutoff_audio_q_audio",
		paramNames: ["cutoff", "q"],
		paramModes: ["audio", "audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 607,
		genName: "Svf",
		variantName: "peaks",
		className: "Svf_peaks_cutoff_scalar_q_scalar",
		paramNames: ["cutoff", "q"],
		paramModes: ["scalar", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 608,
		genName: "Svf",
		variantName: "peaks",
		className: "Svf_peaks_cutoff_scalar_q_audio",
		paramNames: ["cutoff", "q"],
		paramModes: ["scalar", "audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 609,
		genName: "Svf",
		variantName: "peaks",
		className: "Svf_peaks_cutoff_audio_q_scalar",
		paramNames: ["cutoff", "q"],
		paramModes: ["audio", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 610,
		genName: "Svf",
		variantName: "peaks",
		className: "Svf_peaks_cutoff_audio_q_audio",
		paramNames: ["cutoff", "q"],
		paramModes: ["audio", "audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 611,
		genName: "Svf",
		variantName: "aps",
		className: "Svf_aps_cutoff_scalar_q_scalar",
		paramNames: ["cutoff", "q"],
		paramModes: ["scalar", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 612,
		genName: "Svf",
		variantName: "aps",
		className: "Svf_aps_cutoff_scalar_q_audio",
		paramNames: ["cutoff", "q"],
		paramModes: ["scalar", "audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 613,
		genName: "Svf",
		variantName: "aps",
		className: "Svf_aps_cutoff_audio_q_scalar",
		paramNames: ["cutoff", "q"],
		paramModes: ["audio", "scalar"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 614,
		genName: "Svf",
		variantName: "aps",
		className: "Svf_aps_cutoff_audio_q_audio",
		paramNames: ["cutoff", "q"],
		paramModes: ["audio", "audio"],
		emitNames: [],
		usesInput: true
	},
	{
		id: 615,
		genName: "Table",
		variantName: "lookup",
		className: "Table_lookup",
		paramNames: ["len", "index"],
		paramModes: ["scalar", "scalar"],
		emitNames: [],
		usesInput: false
	},
	{
		id: 616,
		genName: "Tram",
		variantName: "default",
		className: "TramKernel",
		paramNames: [],
		paramModes: [],
		emitNames: ["fired"],
		usesInput: false
	},
	{
		id: 617,
		genName: "Mini",
		variantName: "default",
		className: "MiniKernel",
		paramNames: ["bars"],
		paramModes: ["scalar"],
		emitNames: [],
		usesInput: false
	},
	{
		id: 618,
		genName: "Timeline",
		variantName: "default",
		className: "TimelineKernel",
		paramNames: [],
		paramModes: [],
		emitNames: [],
		usesInput: false
	},
	{
		id: 619,
		genName: "Out",
		variantName: "default",
		className: "Out",
		paramNames: [],
		paramModes: [],
		emitNames: [],
		usesInput: false
	},
	{
		id: 620,
		genName: "Mix",
		variantName: "default",
		className: "Mix",
		paramNames: [],
		paramModes: [],
		emitNames: [],
		usesInput: false
	},
	{
		id: 621,
		genName: "ArrayGet",
		variantName: "default",
		className: "ArrayGet",
		paramNames: ["index"],
		paramModes: ["scalar"],
		emitNames: ["index"],
		usesInput: false
	},
	{
		id: 622,
		genName: "Solo",
		variantName: "default",
		className: "Solo",
		paramNames: [],
		paramModes: [],
		emitNames: [],
		usesInput: false
	}
];
const SCALE_INTERVALS = {
	major: [
		0,
		2,
		4,
		5,
		7,
		9,
		11
	],
	minor: [
		0,
		2,
		3,
		5,
		7,
		8,
		10
	],
	pentatonic: [
		0,
		3,
		5,
		7,
		10
	],
	pent: [
		0,
		3,
		5,
		7,
		10
	],
	minorpentatonic: [
		0,
		3,
		5,
		7,
		10
	],
	minorpent: [
		0,
		3,
		5,
		7,
		10
	],
	majorpentatonic: [
		0,
		2,
		4,
		7,
		9
	],
	majorpent: [
		0,
		2,
		4,
		7,
		9
	],
	ritusen: [
		0,
		2,
		4,
		6,
		9
	],
	kumai: [
		0,
		2,
		3,
		7,
		9
	],
	hirajoshi: [
		0,
		2,
		3,
		7,
		8
	],
	iwato: [
		0,
		1,
		5,
		6,
		10
	],
	chinese: [
		0,
		4,
		6,
		7,
		11
	],
	indian: [
		0,
		4,
		5,
		7,
		9,
		11
	],
	pelog: [
		0,
		1,
		3,
		7,
		8
	],
	prometheus: [
		0,
		2,
		4,
		6,
		9,
		10
	],
	scriabin: [
		0,
		1,
		4,
		7,
		9
	],
	gong: [
		0,
		2,
		4,
		7,
		9
	],
	shang: [
		0,
		2,
		5,
		7,
		10
	],
	jiao: [
		0,
		3,
		5,
		8,
		10
	],
	zhi: [
		0,
		2,
		4,
		6,
		9
	],
	yu: [
		0,
		3,
		5,
		7,
		9
	],
	whole: [
		0,
		2,
		4,
		6,
		8,
		10
	],
	wholetone: [
		0,
		2,
		4,
		6,
		8,
		10
	],
	augmented: [
		0,
		3,
		4,
		7,
		8,
		11
	],
	augmented2: [
		0,
		1,
		4,
		5,
		8,
		9
	],
	hexmajor7: [
		0,
		2,
		4,
		7,
		9,
		11
	],
	hexdorian: [
		0,
		2,
		3,
		5,
		7,
		9
	],
	hexphrygian: [
		0,
		1,
		4,
		5,
		7,
		10
	],
	hexsus: [
		0,
		2,
		5,
		7,
		9,
		10
	],
	hexmajor6: [
		0,
		2,
		4,
		5,
		7,
		9
	],
	hexaeolian: [
		0,
		2,
		3,
		5,
		7,
		8
	],
	ionian: [
		0,
		2,
		4,
		5,
		7,
		9,
		11
	],
	dorian: [
		0,
		2,
		3,
		5,
		7,
		9,
		10
	],
	phrygian: [
		0,
		1,
		3,
		5,
		7,
		8,
		10
	],
	lydian: [
		0,
		2,
		4,
		6,
		7,
		9,
		11
	],
	mixolydian: [
		0,
		2,
		4,
		5,
		7,
		9,
		10
	],
	aeolian: [
		0,
		2,
		3,
		5,
		7,
		8,
		10
	],
	locrian: [
		0,
		1,
		3,
		5,
		6,
		8,
		10
	],
	harmonicminor: [
		0,
		2,
		3,
		5,
		7,
		8,
		11
	],
	harmonicmajor: [
		0,
		2,
		4,
		5,
		7,
		8,
		11
	],
	melodicminor: [
		0,
		2,
		3,
		5,
		7,
		9,
		11
	],
	melodicminordesc: [
		0,
		2,
		3,
		5,
		7,
		8,
		10
	],
	melodicmajor: [
		0,
		2,
		4,
		6,
		7,
		9,
		11
	],
	bartok: [
		0,
		2,
		4,
		5,
		7,
		8,
		10
	],
	hindu: [
		0,
		2,
		5,
		7,
		8,
		10
	],
	todi: [
		0,
		1,
		3,
		6,
		7,
		8,
		11
	],
	purvi: [
		0,
		1,
		4,
		6,
		7,
		8,
		11
	],
	marva: [
		0,
		1,
		4,
		6,
		7,
		9,
		11
	],
	bhairav: [
		0,
		1,
		4,
		5,
		7,
		8,
		11
	],
	ahirbhairav: [
		0,
		1,
		4,
		5,
		7,
		9,
		10
	],
	superlocrian: [
		0,
		1,
		3,
		4,
		6,
		8,
		10
	],
	romanianminor: [
		0,
		2,
		3,
		6,
		7,
		9,
		10
	],
	hungarianminor: [
		0,
		2,
		3,
		6,
		7,
		8,
		11
	],
	neapolitanminor: [
		0,
		1,
		3,
		5,
		7,
		8,
		11
	],
	enigmatic: [
		0,
		1,
		4,
		6,
		8,
		10,
		11
	],
	spanish: [
		0,
		1,
		3,
		4,
		5,
		7,
		8,
		10
	],
	leadingwhole: [
		0,
		2,
		4,
		6,
		8,
		9,
		11
	],
	lydianminor: [
		0,
		2,
		4,
		6,
		7,
		8,
		10
	],
	neapolitanmajor: [
		0,
		1,
		3,
		5,
		7,
		9,
		11
	],
	locrianmajor: [
		0,
		2,
		4,
		5,
		6,
		8,
		10
	],
	diminished: [
		0,
		2,
		3,
		5,
		6,
		8,
		9,
		11
	],
	octatonic: [
		0,
		1,
		3,
		4,
		6,
		7,
		9,
		10
	],
	diminished2: [
		0,
		1,
		3,
		4,
		6,
		7,
		9,
		10
	],
	octatonic2: [
		0,
		2,
		3,
		5,
		6,
		8,
		9,
		11
	],
	messiaen1: [
		0,
		2,
		4,
		6,
		8,
		10
	],
	messiaen2: [
		0,
		1,
		2,
		5,
		6,
		7,
		10,
		11
	],
	messiaen3: [
		0,
		2,
		3,
		4,
		6,
		7,
		8,
		11
	],
	messiaen4: [
		0,
		1,
		2,
		5,
		6,
		7,
		9,
		10
	],
	messiaen5: [
		0,
		1,
		5,
		6,
		7,
		11
	],
	messiaen6: [
		0,
		2,
		4,
		5,
		6,
		8,
		10,
		11
	],
	messiaen7: [
		0,
		1,
		2,
		3,
		5,
		6,
		7,
		8,
		9,
		11
	],
	chromatic: [
		0,
		1,
		2,
		3,
		4,
		5,
		6,
		7,
		8,
		9,
		10,
		11
	],
	bayati: [
		0,
		1,
		4,
		5,
		7,
		8,
		10
	],
	hijaz: [
		0,
		1,
		4,
		5,
		7,
		8,
		10
	],
	sikah: [
		0,
		1,
		4,
		5,
		7,
		8,
		10
	],
	rast: [
		0,
		2,
		4,
		5,
		7,
		9,
		10
	],
	saba: [
		0,
		1,
		3,
		4,
		6,
		7,
		9,
		10
	],
	iraq: [
		0,
		1,
		4,
		5,
		7,
		8,
		10
	]
};
const SCALE_KEY_TO_INDEX = {};
{
	const sigToIndex = /* @__PURE__ */ new Map();
	let next = 0;
	for (const [name, intervals] of Object.entries(SCALE_INTERVALS)) {
		const sig = intervals.join(",");
		let idx = sigToIndex.get(sig);
		if (idx === void 0) {
			idx = next++;
			sigToIndex.set(sig, idx);
		}
		SCALE_KEY_TO_INDEX[name] = idx;
	}
}
function findScaleIndex(scaleName) {
	if (!scaleName) return void 0;
	const q$5 = scaleName.toLowerCase();
	for (const name of Object.keys(SCALE_INTERVALS)) if (name.startsWith(q$5)) return SCALE_KEY_TO_INDEX[name];
}
var SCALE_INDEX_TO_INTERVALS = [];
{
	const seen$1 = /* @__PURE__ */ new Set();
	for (const [name, intervals] of Object.entries(SCALE_INTERVALS)) {
		const idx = SCALE_KEY_TO_INDEX[name];
		if (idx !== void 0 && !seen$1.has(idx)) {
			seen$1.add(idx);
			SCALE_INDEX_TO_INTERVALS[idx] = intervals;
		}
	}
}
function getScaleIntervalsByIndex(scaleIndex) {
	return SCALE_INDEX_TO_INTERVALS[scaleIndex];
}
function degreeToMidiTs(rootMidi, scaleIndex, degree, semitoneAdjust = 0) {
	const intervals = getScaleIntervalsByIndex(scaleIndex);
	if (!intervals || intervals.length === 0 || degree <= 0) return -1;
	const step = degree - 1;
	const octave = Math.floor(step / intervals.length);
	return rootMidi + (intervals[(step % intervals.length + intervals.length) % intervals.length] + octave * 12 + semitoneAdjust);
}
const TIMELINE_MAGIC = 1e3;
var numRe = "[+-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)";
var pointTokenRe = /* @__PURE__ */ new RegExp(`^(${numRe}),(${numRe})(?:([e])(${numRe})?)?$`);
function tokenizeTimelineNotation(input) {
	const tokens = [];
	let index = 0;
	let i$6 = 0;
	while (i$6 < input.length) {
		while (i$6 < input.length && /\s/.test(input[i$6])) i$6++;
		if (i$6 >= input.length) break;
		const start = i$6;
		while (i$6 < input.length && !/\s/.test(input[i$6])) i$6++;
		const end = i$6;
		tokens.push({
			index,
			start,
			length: end - start,
			text: input.slice(start, end)
		});
		index++;
	}
	return tokens;
}
function parseTimelineNotation(tokens) {
	const points = [];
	for (const t$12 of tokens) {
		const m$5 = pointTokenRe.exec(t$12.text);
		if (!m$5) continue;
		const barUser = Number(m$5[1] ?? 0);
		const bar = barUser >= 1 ? barUser - 1 : 0;
		const value = Number(m$5[2] ?? 0);
		const curveKind = m$5[3] ?? null;
		const curveValue = Number(m$5[4] ?? 0);
		const exp = curveKind === "e" ? curveValue : null;
		if (!Number.isFinite(bar) || !Number.isFinite(value)) continue;
		points.push({
			bar,
			value,
			exp,
			tokenIndex: t$12.index,
			tokenStart: t$12.start,
			tokenLength: t$12.length
		});
	}
	return points;
}
function compilePoints(points) {
	if (points.length === 0) return {
		segments: [],
		totalBars: 0,
		endValue: 0,
		endTokenIndex: -1,
		endTokenStart: -1,
		endTokenLength: -1
	};
	const pts = points.map((p$6) => ({
		...p$6,
		bar: p$6.bar
	})).filter((p$6) => p$6.bar >= 0);
	if (pts.length === 0) return {
		segments: [],
		totalBars: 0,
		endValue: 0,
		endTokenIndex: -1,
		endTokenStart: -1,
		endTokenLength: -1
	};
	if (!pts.some((p$6) => p$6.bar === 0)) pts.unshift({
		bar: 0,
		value: 0,
		exp: null,
		tokenIndex: -1,
		tokenStart: -1,
		tokenLength: -1
	});
	const segments = [];
	let i$6 = 0;
	let t$12 = 0;
	let v$4 = pts[0].value;
	let activeTokenIndex = pts[0].tokenIndex;
	let activeTokenStart = pts[0].tokenStart;
	let activeTokenLength = pts[0].tokenLength;
	while (i$6 < pts.length && pts[i$6].bar === 0) {
		v$4 = pts[i$6].value;
		activeTokenIndex = pts[i$6].tokenIndex;
		activeTokenStart = pts[i$6].tokenStart;
		activeTokenLength = pts[i$6].tokenLength;
		i$6++;
	}
	let endTokenIndex = activeTokenIndex;
	let endTokenStart = activeTokenStart;
	let endTokenLength = activeTokenLength;
	for (; i$6 < pts.length; i$6++) {
		const p$6 = pts[i$6];
		const nextT = p$6.bar;
		const nextV = p$6.value;
		const dt = nextT - t$12;
		if (dt < 0) continue;
		if (dt === 0) {
			t$12 = nextT;
			v$4 = nextV;
			activeTokenIndex = p$6.tokenIndex;
			activeTokenStart = p$6.tokenStart;
			activeTokenLength = p$6.tokenLength;
			endTokenIndex = activeTokenIndex;
			endTokenStart = activeTokenStart;
			endTokenLength = activeTokenLength;
			continue;
		}
		const exp = p$6.exp ?? 1;
		const kind = v$4 === nextV ? 0 : 1;
		segments.push({
			kind,
			durBars: dt,
			startValue: v$4,
			endValue: nextV,
			exp,
			fromTokenIndex: activeTokenIndex,
			fromTokenStart: activeTokenStart,
			fromTokenLength: activeTokenLength,
			toTokenIndex: p$6.tokenIndex,
			toTokenStart: p$6.tokenStart,
			toTokenLength: p$6.tokenLength
		});
		t$12 = nextT;
		v$4 = nextV;
		activeTokenIndex = p$6.tokenIndex;
		activeTokenStart = p$6.tokenStart;
		activeTokenLength = p$6.tokenLength;
		endTokenIndex = activeTokenIndex;
		endTokenStart = activeTokenStart;
		endTokenLength = activeTokenLength;
	}
	let totalBars = t$12;
	if (totalBars <= 0) {
		totalBars = 1;
		segments.push({
			kind: 0,
			durBars: 1,
			startValue: v$4,
			endValue: v$4,
			exp: 1,
			fromTokenIndex: activeTokenIndex,
			fromTokenStart: activeTokenStart,
			fromTokenLength: activeTokenLength,
			toTokenIndex: activeTokenIndex,
			toTokenStart: activeTokenStart,
			toTokenLength: activeTokenLength
		});
	}
	return {
		segments,
		totalBars,
		endValue: v$4,
		endTokenIndex,
		endTokenStart,
		endTokenLength
	};
}
var cacheBySequence = /* @__PURE__ */ new Map();
function compileTimelineNotation(input, initialBeatDiv = 4) {
	const cached = cacheBySequence.get(input);
	if (cached) return cached;
	if (cacheBySequence.size > 1e3) cacheBySequence.clear();
	const tokens = tokenizeTimelineNotation(input);
	const noWrap = tokens.some((t$12) => t$12.text === "-");
	const compiled = compilePoints(parseTimelineNotation(tokens));
	const segments = compiled.segments;
	let totalBars = compiled.totalBars;
	if (noWrap && segments.length > 0) {
		const last = segments[segments.length - 1];
		if ((last.kind === 1 ? last.endValue : last.startValue) !== compiled.endValue) segments.push({
			kind: 0,
			durBars: 1,
			startValue: compiled.endValue,
			endValue: compiled.endValue,
			exp: 1,
			fromTokenIndex: compiled.endTokenIndex,
			fromTokenStart: compiled.endTokenStart,
			fromTokenLength: compiled.endTokenLength,
			toTokenIndex: compiled.endTokenIndex,
			toTokenStart: compiled.endTokenStart,
			toTokenLength: compiled.endTokenLength
		});
	}
	const beatsPerBar = initialBeatDiv > 0 ? initialBeatDiv : 4;
	const segCount = segments.length;
	const opLength = 4 + segCount * 5;
	const bytecode$1 = new Float32Array(1 + opLength);
	bytecode$1[0] = opLength;
	bytecode$1[1] = TIMELINE_MAGIC;
	bytecode$1[2] = segCount;
	bytecode$1[3] = noWrap ? -totalBars : totalBars;
	bytecode$1[4] = beatsPerBar;
	let o$34 = 5;
	for (const s$4 of segments) {
		bytecode$1[o$34++] = s$4.kind;
		bytecode$1[o$34++] = s$4.durBars;
		bytecode$1[o$34++] = s$4.startValue;
		bytecode$1[o$34++] = s$4.endValue;
		bytecode$1[o$34++] = s$4.exp;
	}
	const result = {
		bytecode: bytecode$1,
		tokens: segments.map((s$4) => ({
			fromTokenIndex: s$4.fromTokenIndex,
			fromTokenStart: s$4.fromTokenStart,
			fromTokenLength: s$4.fromTokenLength,
			toTokenIndex: s$4.toTokenIndex,
			toTokenStart: s$4.toTokenStart,
			toTokenLength: s$4.toTokenLength
		})),
		segments
	};
	cacheBySequence.set(input, result);
	return result;
}
function applyCurve$1(t$12, curve) {
	if (curve > 0) return Math.pow(t$12, curve);
	if (curve < 0) {
		const base = -curve;
		if (base > 0) return 1 - Math.pow(1 - t$12, base);
	}
	return t$12;
}
function parseCompiledTimeline(bytecode$1) {
	const opLength = bytecode$1[0];
	if (!opLength || opLength <= 0) return null;
	if (bytecode$1[1] !== 1e3) return null;
	const segCount = Math.floor(bytecode$1[2]);
	if (!Number.isFinite(segCount) || segCount <= 0) return null;
	const totalBarsRaw = bytecode$1[3];
	const noWrap = totalBarsRaw < 0;
	const totalBars = Math.abs(totalBarsRaw);
	const beatDiv = bytecode$1[4];
	if (!Number.isFinite(totalBars) || !Number.isFinite(beatDiv) || totalBars <= 0 || beatDiv <= 0) return null;
	const segs = [];
	const segBase = 5;
	for (let si = 0; si < segCount; si++) {
		const o$34 = segBase + si * 5;
		const kind = bytecode$1[o$34];
		const durBars = bytecode$1[o$34 + 1];
		const startValue = bytecode$1[o$34 + 2];
		const endValue = bytecode$1[o$34 + 3];
		const exp = bytecode$1[o$34 + 4];
		if (!durBars || durBars <= 0) continue;
		segs.push({
			kind,
			durBars,
			startValue,
			endValue,
			exp
		});
	}
	if (segs.length === 0) return null;
	const cycleBeats = totalBars * beatDiv;
	if (!Number.isFinite(cycleBeats) || cycleBeats <= 0) return null;
	return {
		beatDiv,
		totalBars,
		cycleBeats,
		noWrap,
		segs
	};
}
function readTimelineSegsFromCompiledTimeline(arrayRaw, sampleRate, bpm$1, windowStartTimeSeconds, windowEndTimeSeconds) {
	const beatsPerSecond = bpm$1 / 60;
	if (!(beatsPerSecond > 0) || !Number.isFinite(beatsPerSecond)) return [];
	if (!Number.isFinite(windowStartTimeSeconds) || !Number.isFinite(windowEndTimeSeconds)) return [];
	const tl = parseCompiledTimeline(arrayRaw);
	if (!tl) return [];
	const startBeat = windowStartTimeSeconds * beatsPerSecond;
	const endBeat = windowEndTimeSeconds * beatsPerSecond;
	if (!Number.isFinite(startBeat) || !Number.isFinite(endBeat)) return [];
	const segs = [];
	if (tl.noWrap) {
		let accBeats = 0;
		for (let i$6 = 0; i$6 < tl.segs.length; i$6++) {
			const s$4 = tl.segs[i$6];
			const durBeats = s$4.durBars * tl.beatDiv;
			if (!(durBeats > 0) || !Number.isFinite(durBeats)) continue;
			const segStartBeat = accBeats;
			const segEndBeat = segStartBeat + durBeats;
			accBeats += durBeats;
			const startTimeSeconds = segStartBeat / beatsPerSecond;
			const endTimeSeconds = segEndBeat / beatsPerSecond;
			if (endTimeSeconds < windowStartTimeSeconds || startTimeSeconds > windowEndTimeSeconds) continue;
			const startSample = startTimeSeconds * sampleRate;
			const endSample = endTimeSeconds * sampleRate;
			if (!Number.isFinite(startSample) || !Number.isFinite(endSample)) continue;
			segs.push({
				startSample,
				endSample,
				a: s$4.startValue,
				b: s$4.endValue,
				kind: s$4.kind,
				exp: s$4.exp
			});
		}
		const last = tl.segs[tl.segs.length - 1];
		const holdValue = last ? last.endValue : 0;
		const holdStartBeat = Math.max(0, Math.max(startBeat, tl.cycleBeats));
		if (endBeat > holdStartBeat && Number.isFinite(holdValue)) {
			const startTimeSeconds = holdStartBeat / beatsPerSecond;
			const endTimeSeconds = endBeat / beatsPerSecond;
			const startSample = startTimeSeconds * sampleRate;
			const endSample = endTimeSeconds * sampleRate;
			if (Number.isFinite(startSample) && Number.isFinite(endSample)) {
				const prev = segs[segs.length - 1];
				if (prev && prev.kind === 0 && prev.a === holdValue && prev.b === holdValue && Math.abs(prev.endSample - startSample) < 1e-4) prev.endSample = endSample;
				else segs.push({
					startSample,
					endSample,
					a: holdValue,
					b: holdValue,
					kind: 0,
					exp: 1
				});
			}
		}
	} else {
		const cycleBeats = tl.cycleBeats;
		if (!(cycleBeats > 0) || !Number.isFinite(cycleBeats)) return [];
		const firstCycle = Math.floor(startBeat / cycleBeats) - 1;
		const lastCycle = Math.floor(endBeat / cycleBeats) + 1;
		for (let cycle = firstCycle; cycle <= lastCycle; cycle++) {
			const cycleStartBeat = cycle * cycleBeats;
			let accBeats = 0;
			for (let i$6 = 0; i$6 < tl.segs.length; i$6++) {
				const s$4 = tl.segs[i$6];
				const durBeats = s$4.durBars * tl.beatDiv;
				if (!(durBeats > 0) || !Number.isFinite(durBeats)) continue;
				const segStartBeat = cycleStartBeat + accBeats;
				const segEndBeat = segStartBeat + durBeats;
				accBeats += durBeats;
				const startTimeSeconds = segStartBeat / beatsPerSecond;
				const endTimeSeconds = segEndBeat / beatsPerSecond;
				if (endTimeSeconds < windowStartTimeSeconds || startTimeSeconds > windowEndTimeSeconds) continue;
				const startSample = startTimeSeconds * sampleRate;
				const endSample = endTimeSeconds * sampleRate;
				if (!Number.isFinite(startSample) || !Number.isFinite(endSample)) continue;
				segs.push({
					startSample,
					endSample,
					a: s$4.startValue,
					b: s$4.endValue,
					kind: s$4.kind,
					exp: s$4.exp
				});
			}
		}
	}
	segs.sort((x$4, y$5) => x$4.startSample - y$5.startSample);
	return segs;
}
function getTimelineValue(segs, si, sample) {
	while (si < segs.length && sample >= segs[si].endSample) si++;
	const s$4 = segs[si];
	if (!s$4) {
		const last = segs[segs.length - 1];
		if (!last) return {
			v: 0,
			si
		};
		return {
			v: last.kind === 1 ? last.b : last.a,
			si
		};
	}
	if (sample < s$4.startSample) {
		const prev = segs[si - 1];
		if (prev) return {
			v: prev.kind === 1 ? prev.b : prev.a,
			si
		};
		return {
			v: s$4.a,
			si
		};
	}
	if (s$4.kind !== 1 || s$4.endSample <= s$4.startSample) return {
		v: s$4.a,
		si
	};
	const p$6 = applyCurve$1((sample - s$4.startSample) / (s$4.endSample - s$4.startSample), s$4.exp);
	return {
		v: s$4.a + (s$4.b - s$4.a) * p$6,
		si
	};
}
function getTimelineValueAtSample(segs, sample) {
	for (let k$4 = 0; k$4 < segs.length; k$4++) {
		const ss = segs[k$4];
		if (sample >= ss.startSample && sample < ss.endSample) {
			if (ss.kind !== 1 || ss.endSample <= ss.startSample) return ss.a;
			const p$6 = applyCurve$1((sample - ss.startSample) / (ss.endSample - ss.startSample), ss.exp);
			return ss.a + (ss.b - ss.a) * p$6;
		}
	}
	for (let k$4 = 0; k$4 < segs.length; k$4++) {
		const ss = segs[k$4];
		if (ss.startSample === sample) {
			if (ss.kind !== 1 || ss.endSample <= ss.startSample) return ss.a;
			return ss.a + (ss.b - ss.a) * applyCurve$1(0, ss.exp);
		}
	}
	for (let k$4 = 0; k$4 < segs.length; k$4++) {
		const ss = segs[k$4];
		if (ss.endSample === sample) return ss.kind === 1 ? ss.b : ss.a;
	}
	const first = segs[0];
	if (!first) return 0;
	if (sample < first.startSample) return first.a;
	let prev = null;
	for (let k$4 = 0; k$4 < segs.length; k$4++) {
		const ss = segs[k$4];
		if (sample < ss.startSample) break;
		prev = ss;
	}
	if (prev) return prev.kind === 1 ? prev.b : prev.a;
	const last = segs[segs.length - 1];
	return last.kind === 1 ? last.b : last.a;
}
function getActiveTimelineSegIndex(arrayRaw, sampleCount, sampleRate, bpm$1) {
	const base = 0;
	const opLength = arrayRaw[base];
	if (!opLength || opLength <= 0) return null;
	if (arrayRaw[base + 1] !== 1e3) return null;
	const segCount = Math.floor(arrayRaw[base + 2]);
	if (!Number.isFinite(segCount) || segCount <= 0) return null;
	const totalBarsRaw = arrayRaw[base + 3];
	const noWrap = totalBarsRaw < 0;
	const totalBars = Math.abs(totalBarsRaw);
	const beatDiv = arrayRaw[base + 4];
	if (!Number.isFinite(totalBars) || !Number.isFinite(beatDiv) || totalBars <= 0 || beatDiv <= 0) return null;
	const cycleBeats = totalBars * beatDiv;
	const beatAbs = sampleCount * (bpm$1 / 60 / sampleRate);
	let localBeat = 0;
	if (noWrap) localBeat = Math.max(0, beatAbs);
	else {
		localBeat = beatAbs - Math.floor(beatAbs / cycleBeats) * cycleBeats;
		if (localBeat < 0) localBeat += cycleBeats;
	}
	const segBase = base + 1 + 4;
	let accBeats = 0;
	let lastValidSi = -1;
	for (let si = 0; si < segCount; si++) {
		const durBars = arrayRaw[segBase + si * 5 + 1];
		if (!durBars || durBars <= 0) continue;
		lastValidSi = si;
		const durBeats = durBars * beatDiv;
		if (localBeat < accBeats + durBeats) {
			const tt = durBeats > 0 ? (localBeat - accBeats) / durBeats : 0;
			return {
				si,
				tt: Math.max(0, Math.min(1, tt))
			};
		}
		accBeats += durBeats;
	}
	if (noWrap && lastValidSi >= 0) return {
		si: lastValidSi,
		tt: 1
	};
	return null;
}
const gens = {
	Phasor: {
		name: "Phasor",
		description: "Phase ramp 0..1 with trigger reset",
		category: "generators",
		parameters: [
			{
				name: "hz",
				default: 440,
				min: 0,
				unit: "hz",
				description: "Frequency"
			},
			{
				name: "offset",
				min: 0,
				max: 1,
				description: "Offset phase"
			},
			{
				name: "trig",
				description: "Trigger impulse"
			}
		]
	},
	Every: {
		name: "Every",
		description: "Generates an impulse on a regular period in bars",
		category: "sequencers",
		parameters: [{
			name: "bars",
			default: .25,
			min: 1e-4,
			unit: "bars",
			description: "Number of bars per impulse"
		}]
	},
	White: {
		name: "White",
		description: "Uniform white noise with trigger reset",
		category: "generators",
		parameters: [{
			name: "seed",
			default: 0,
			description: "Seed (any value, float bits used)"
		}, {
			name: "trig",
			description: "Trigger resets phase"
		}]
	},
	Lfosqr: {
		name: "Lfosqr",
		description: "Tempo-synced LFO square 0..1",
		category: "generators",
		parameters: [
			{
				name: "bar",
				default: 1,
				min: 0,
				unit: "bars",
				description: "Cycle length in bars"
			},
			{
				name: "offset",
				default: 0,
				min: 0,
				description: "Phase offset in beats"
			},
			{
				name: "trig",
				description: "Trigger reset"
			}
		]
	},
	Lfosah: {
		name: "Lfosah",
		description: "Tempo-synced LFO sample-and-hold (random 0..1 per cycle)",
		category: "generators",
		parameters: [
			{
				name: "bar",
				default: 1,
				min: 0,
				unit: "bars",
				description: "Cycle length in bars"
			},
			{
				name: "offset",
				default: 0,
				min: 0,
				description: "Phase offset in beats"
			},
			{
				name: "seed",
				default: 0,
				description: "Seed (any value, float bits used)"
			},
			{
				name: "trig",
				description: "Trigger reset"
			}
		]
	},
	Dc: {
		name: "Dc",
		description: "DC blocker (~8 Hz highpass, removes offset)",
		category: "filters",
		parameters: [{
			name: "input",
			description: "Input signal"
		}]
	},
	Gauss: {
		name: "Gauss",
		description: "Gaussian (normal-ish) noise via CLT from 6 uniforms, trigger reset",
		category: "generators",
		parameters: [{
			name: "seed",
			default: 0,
			description: "Seed (any value, float bits used)"
		}, {
			name: "trig",
			description: "Trigger resets phase"
		}]
	},
	Impulse: {
		name: "Impulse",
		description: "Impulse train (1 at phase 0, 0 elsewhere)",
		category: "sequencers",
		parameters: [
			{
				name: "hz",
				default: 440,
				min: 0,
				unit: "hz",
				description: "Frequency"
			},
			{
				name: "offset",
				min: 0,
				max: 1,
				description: "Offset phase"
			},
			{
				name: "trig",
				description: "Trigger impulse"
			}
		]
	},
	TestGain: {
		name: "TestGain",
		description: "Simple gain/amplifier",
		category: "test",
		parameters: [{
			name: "input",
			description: "Input signal"
		}, {
			name: "amount",
			default: 1,
			min: 0,
			max: 2,
			description: "Gain amount"
		}]
	},
	Freeverb: {
		name: "Freeverb",
		description: "Freeverb reverb",
		category: "effects",
		parameters: [
			{
				name: "input",
				description: "Input signal"
			},
			{
				name: "room",
				default: .5,
				min: 0,
				max: 1,
				unit: "normal",
				description: "Room size"
			},
			{
				name: "damping",
				default: .5,
				min: 0,
				max: 1,
				unit: "normal",
				description: "Damping"
			}
		]
	},
	Saw: {
		name: "Saw",
		description: "Band-limited sawtooth oscillator",
		category: "generators",
		parameters: [
			{
				name: "hz",
				default: 440,
				min: 0,
				unit: "hz",
				description: "Frequency"
			},
			{
				name: "offset",
				min: 0,
				max: 1,
				description: "Offset phase"
			},
			{
				name: "trig",
				description: "Trigger impulse"
			}
		]
	},
	TestOversample: {
		name: "TestOversample",
		description: "Test generator that outputs sample rate dependent signal",
		category: "test",
		parameters: []
	},
	Sine: {
		name: "Sine",
		description: "Sine wave generator",
		category: "generators",
		parameters: [
			{
				name: "hz",
				default: 440,
				min: 0,
				unit: "hz",
				description: "Frequency"
			},
			{
				name: "offset",
				min: 0,
				max: 1,
				unit: "phase",
				description: "Offset phase"
			},
			{
				name: "trig",
				unit: "impulse",
				description: "Trigger impulse"
			}
		]
	},
	Lfosine: {
		name: "Lfosine",
		description: "Tempo-synced LFO sine 0..1",
		category: "generators",
		parameters: [
			{
				name: "bar",
				default: 1,
				min: 0,
				unit: "bars",
				description: "Cycle length in bars"
			},
			{
				name: "offset",
				default: 0,
				min: 0,
				description: "Phase offset in beats"
			},
			{
				name: "trig",
				description: "Trigger reset"
			}
		]
	},
	Slicer: {
		name: "Slicer",
		description: "Slice-based sample player",
		category: "samplers",
		parameters: [
			{
				name: "sample",
				unit: "handle",
				description: "Sample handle from freesound() or record()"
			},
			{
				name: "speed",
				default: 1,
				unit: "multiplier",
				description: "Playback speed (negative for reverse)"
			},
			{
				name: "offset",
				default: 0,
				min: 0,
				max: 1,
				unit: "phase",
				description: "Offset phase within slice"
			},
			{
				name: "slice",
				default: 0,
				min: 0,
				max: 1,
				unit: "fraction",
				description: "Slice index (0..1)"
			},
			{
				name: "threshold",
				default: 0,
				min: 0,
				max: 1,
				unit: "fraction",
				description: "Slice detection threshold"
			},
			{
				name: "repeat",
				default: 0,
				unit: "boolean",
				description: "Loop slice when not 0"
			},
			{
				name: "trig",
				description: "Trigger to restart playback"
			}
		]
	},
	Brown: {
		name: "Brown",
		description: "Brownian (random walk) noise",
		category: "generators",
		parameters: [{
			name: "seed",
			default: 0,
			description: "Seed"
		}, {
			name: "trig",
			description: "Trigger resets walk"
		}]
	},
	Euclid: {
		name: "Euclid",
		description: "Euclidean rhythm trigger (pulses over steps with offset)",
		category: "sequencers",
		parameters: [
			{
				name: "pulses",
				default: 4,
				min: 0,
				description: "Number of hits"
			},
			{
				name: "steps",
				default: 8,
				min: 1,
				description: "Number of steps"
			},
			{
				name: "offset",
				default: 0,
				min: 0,
				description: "Rotation offset"
			},
			{
				name: "bar",
				default: 1,
				min: 0,
				unit: "bars",
				description: "Pattern length in bars"
			}
		]
	},
	Pwm: {
		name: "Pwm",
		description: "Band-limited PWM oscillator",
		category: "generators",
		parameters: [
			{
				name: "hz",
				default: 440,
				min: 0,
				unit: "hz",
				description: "Frequency"
			},
			{
				name: "width",
				default: .5,
				min: 0,
				max: 1,
				description: "Pulse width"
			},
			{
				name: "offset",
				min: 0,
				max: 1,
				description: "Offset phase"
			},
			{
				name: "trig",
				description: "Trigger impulse"
			}
		]
	},
	Ad: {
		name: "Ad",
		description: "Attack/Decay envelope",
		category: "generators",
		parameters: [
			{
				name: "attack",
				default: .005,
				min: 1e-5,
				unit: "s",
				description: "Attack time"
			},
			{
				name: "decay",
				default: .2,
				min: 1e-5,
				unit: "s",
				description: "Decay time"
			},
			{
				name: "exponent",
				default: 1,
				description: "Curve (0=linear, >0=power, <0=mirrored)"
			},
			{
				name: "trig",
				description: "Trigger impulse"
			}
		]
	},
	Onepole: {
		name: "Onepole",
		description: "One-pole filter (lowpass / highpass)",
		category: "filters",
		variants: {
			lp1: "Lowpass filter (One-pole)",
			hp1: "Highpass filter (One-pole)"
		},
		parameters: [{
			name: "input",
			description: "Input signal"
		}, {
			name: "cutoff",
			default: 1e3,
			min: 20,
			max: 2e4,
			unit: "hz",
			description: "Cutoff frequency"
		}]
	},
	Sqr: {
		name: "Sqr",
		description: "Band-limited square oscillator",
		category: "generators",
		parameters: [
			{
				name: "hz",
				default: 440,
				min: 0,
				unit: "hz",
				description: "Frequency"
			},
			{
				name: "offset",
				min: 0,
				max: 1,
				description: "Offset phase"
			},
			{
				name: "trig",
				description: "Trigger impulse"
			}
		]
	},
	Hold: {
		name: "Hold",
		description: "Holds its input if zero is received",
		category: "utilities",
		parameters: [{
			name: "input",
			description: "Input signal"
		}]
	},
	Lfosaw: {
		name: "Lfosaw",
		description: "Tempo-synced LFO saw 0..1",
		category: "generators",
		parameters: [
			{
				name: "bar",
				default: 1,
				min: 0,
				unit: "bars",
				description: "Cycle length in bars"
			},
			{
				name: "offset",
				default: 0,
				min: 0,
				description: "Phase offset in beats"
			},
			{
				name: "trig",
				description: "Trigger reset"
			}
		]
	},
	Compressor: {
		name: "Compressor",
		description: "Dynamic range compressor with soft knee",
		category: "mixing",
		parameters: [
			{
				name: "input",
				description: "Input signal"
			},
			{
				name: "attack",
				default: .003,
				min: 1e-4,
				max: 1,
				unit: "s",
				description: "Attack time"
			},
			{
				name: "release",
				default: .1,
				min: 1e-4,
				max: 5,
				unit: "s",
				description: "Release time"
			},
			{
				name: "threshold",
				default: -12,
				min: -80,
				max: 0,
				unit: "dB",
				description: "Threshold in dB"
			},
			{
				name: "ratio",
				default: 4,
				min: 1,
				max: 20,
				description: "Compression ratio"
			},
			{
				name: "knee",
				default: 6,
				min: 0,
				max: 40,
				unit: "dB",
				description: "Knee width in dB"
			},
			{
				name: "key",
				description: "Key/sidechain input (unpatched = use input as key)"
			}
		]
	},
	Emit: {
		name: "Emit",
		description: "Emits a value",
		category: "test",
		parameters: [{
			name: "value",
			description: "Value to emit"
		}]
	},
	Fractal: {
		name: "Fractal",
		description: "Fractal (octave-sum) noise with rate, octaves, gain",
		category: "generators",
		parameters: [
			{
				name: "seed",
				default: 0,
				description: "Seed"
			},
			{
				name: "rate",
				default: 2,
				min: 0,
				unit: "hz",
				description: "Base rate"
			},
			{
				name: "octaves",
				default: 4,
				min: 1,
				max: 16,
				description: "Number of octaves"
			},
			{
				name: "gain",
				default: .5,
				min: 0,
				max: 1,
				description: "Octave amplitude decay"
			},
			{
				name: "trig",
				description: "Trigger resets phase"
			}
		]
	},
	Lforamp: {
		name: "Lforamp",
		description: "Tempo-synced LFO ramp 0..1",
		category: "generators",
		parameters: [
			{
				name: "bar",
				default: 1,
				min: 0,
				unit: "bars",
				description: "Cycle length in bars"
			},
			{
				name: "offset",
				default: 0,
				min: 0,
				description: "Phase offset in beats"
			},
			{
				name: "trig",
				description: "Trigger reset"
			}
		]
	},
	Tri: {
		name: "Tri",
		description: "Band-limited triangle oscillator",
		category: "generators",
		parameters: [
			{
				name: "hz",
				default: 440,
				min: 0,
				unit: "hz",
				description: "Frequency"
			},
			{
				name: "offset",
				min: 0,
				max: 1,
				description: "Offset phase"
			},
			{
				name: "trig",
				description: "Trigger impulse"
			}
		]
	},
	Pitchshift: {
		name: "Pitchshift",
		description: "Grain-based pitch shifter (overlap-add)",
		category: "effects",
		parameters: [{
			name: "input",
			description: "Input signal"
		}, {
			name: "ratio",
			default: 1,
			min: .01,
			max: 10,
			unit: "multiplier",
			description: "Pitch ratio (e.g. 2 = one octave up)"
		}]
	},
	Zerox: {
		name: "Zerox",
		description: "Positive zero-crossing detector (1 when input crosses from 0 to >0)",
		category: "utilities",
		parameters: [{
			name: "input",
			description: "Input signal"
		}]
	},
	Limiter: {
		name: "Limiter",
		description: "Peak limiter with release smoothing",
		category: "mixing",
		parameters: [
			{
				name: "input",
				description: "Input signal"
			},
			{
				name: "threshold",
				default: 0,
				min: -80,
				max: 0,
				unit: "dB",
				description: "Limit threshold in dB"
			},
			{
				name: "release",
				default: .1,
				min: 1e-4,
				max: 5,
				unit: "s",
				description: "Release time"
			}
		]
	},
	At: {
		name: "At",
		description: "Probabilistic trigger at bar start and/or every N bars",
		category: "sequencers",
		parameters: [
			{
				name: "bar",
				default: 0,
				min: 0,
				unit: "bars",
				description: "Start time in bars"
			},
			{
				name: "every",
				default: .25,
				min: 0,
				unit: "bars",
				description: "Interval in bars (0 = single trigger at start)"
			},
			{
				name: "prob",
				default: 1,
				min: 0,
				max: 1,
				unit: "factor",
				description: "Probability of 1 when trigger fires"
			},
			{
				name: "seed",
				default: 0,
				description: "Seed for deterministic random"
			}
		]
	},
	Diodeladder: {
		name: "Diodeladder",
		description: "Diode ladder filter (4-pole, with HPF and soft saturation)",
		category: "filters",
		parameters: [
			{
				name: "input",
				description: "Input signal"
			},
			{
				name: "cutoff",
				default: 1e3,
				min: 20,
				max: 2e4,
				unit: "hz",
				description: "Cutoff frequency"
			},
			{
				name: "q",
				default: .5,
				min: 0,
				max: 1,
				description: "Resonance"
			},
			{
				name: "k",
				default: 0,
				min: 0,
				max: 1,
				description: "HPF amount"
			},
			{
				name: "sat",
				default: 1,
				min: .1,
				max: 10,
				description: "Input saturation"
			}
		]
	},
	Ramp: {
		name: "Ramp",
		description: "Band-limited ramp (inverse saw) oscillator",
		category: "generators",
		parameters: [
			{
				name: "hz",
				default: 440,
				min: 0,
				unit: "hz",
				description: "Frequency"
			},
			{
				name: "offset",
				min: 0,
				max: 1,
				description: "Offset phase"
			},
			{
				name: "trig",
				description: "Trigger impulse"
			}
		]
	},
	Smooth: {
		name: "Smooth",
		description: "Smooth interpolated random steps with rate and curve",
		category: "generators",
		parameters: [
			{
				name: "seed",
				default: 0,
				description: "Seed"
			},
			{
				name: "rate",
				default: 2,
				min: 0,
				unit: "hz",
				description: "Step rate"
			},
			{
				name: "curve",
				default: 1,
				description: "Interpolation curve (0=linear, 1=smooth5)"
			},
			{
				name: "trig",
				description: "Trigger resets acc"
			}
		]
	},
	Lfotri: {
		name: "Lfotri",
		description: "Tempo-synced LFO triangle 0..1",
		category: "generators",
		parameters: [
			{
				name: "bar",
				default: 1,
				min: 0,
				unit: "bars",
				description: "Cycle length in bars"
			},
			{
				name: "offset",
				default: 0,
				min: 0,
				description: "Phase offset in beats"
			},
			{
				name: "trig",
				description: "Trigger reset"
			}
		]
	},
	Adsr: {
		name: "Adsr",
		description: "Attack/Decay/Sustain/Release envelope",
		category: "generators",
		parameters: [
			{
				name: "attack",
				default: .005,
				min: 1e-5,
				unit: "s",
				description: "Attack time"
			},
			{
				name: "decay",
				default: .2,
				min: 1e-5,
				unit: "s",
				description: "Decay time"
			},
			{
				name: "sustain",
				default: .7,
				min: 0,
				max: 1,
				description: "Sustain level (0..1)"
			},
			{
				name: "release",
				default: .3,
				min: 1e-5,
				unit: "s",
				description: "Release time"
			},
			{
				name: "exponent",
				default: 1,
				description: "Curve (0=linear, >0=power, <0=mirrored)"
			},
			{
				name: "trig",
				description: "Trigger (gate): high = hold sustain, low = release"
			}
		]
	},
	Analyser: {
		name: "Analyser",
		description: "Analyze the signal",
		category: "utilities",
		parameters: [{
			name: "input",
			description: "Input signal"
		}]
	},
	Biquad: {
		name: "Biquad",
		description: "Biquad filter",
		category: "filters",
		variants: {
			lp: "Lowpass filter (Biquad)",
			hp: "Highpass filter (Biquad)",
			bp: "Bandpass filter (Biquad)",
			bs: "Bandstop filter (Biquad)",
			ap: "Allpass filter (Biquad)"
		},
		parameters: [
			{
				name: "input",
				description: "Input signal"
			},
			{
				name: "cutoff",
				default: 1e3,
				min: 20,
				max: 2e4,
				unit: "hz",
				description: "Cutoff frequency"
			},
			{
				name: "q",
				default: .70710678,
				min: .01,
				max: 20,
				description: "Q factor"
			}
		]
	},
	Envfollow: {
		name: "Envfollow",
		description: "Envelope follower with attack and release time",
		category: "utilities",
		parameters: [
			{
				name: "input",
				description: "Input signal"
			},
			{
				name: "attack",
				default: .01,
				min: 1e-4,
				max: 10,
				unit: "s",
				description: "Attack time"
			},
			{
				name: "release",
				default: .1,
				min: 1e-4,
				max: 10,
				unit: "s",
				description: "Release time"
			}
		]
	},
	Sah: {
		name: "Sah",
		description: "Sample-and-hold: capture input on trigger rising edge",
		category: "utilities",
		parameters: [{
			name: "input",
			description: "Input signal"
		}, {
			name: "trig",
			description: "Trigger: on rising edge, hold current input"
		}]
	},
	Velvet: {
		name: "Velvet",
		description: "Velvet noise stereo reverb (prime-based delay lines)",
		category: "effects",
		parameters: [
			{
				name: "input",
				description: "Input signal"
			},
			{
				name: "room",
				default: .5,
				min: .05,
				max: 1,
				unit: "normal",
				description: "Room size"
			},
			{
				name: "damping",
				default: .5,
				min: 0,
				max: 1,
				unit: "normal",
				description: "High-frequency damping"
			},
			{
				name: "decay",
				default: .5,
				min: 0,
				max: 1,
				unit: "normal",
				description: "Decay / feedback"
			}
		]
	},
	Fdn: {
		name: "Fdn",
		description: "Feedback delay network reverb (8-line Hadamard, modulated)",
		category: "effects",
		parameters: [
			{
				name: "input",
				description: "Input signal"
			},
			{
				name: "room",
				default: .5,
				min: .05,
				max: 1,
				unit: "normal",
				description: "Room size"
			},
			{
				name: "damping",
				default: .5,
				min: 0,
				max: 1,
				unit: "normal",
				description: "High-frequency damping"
			},
			{
				name: "decay",
				default: .5,
				min: 0,
				max: 1,
				unit: "normal",
				description: "Decay / feedback"
			},
			{
				name: "depth",
				default: .5,
				min: 0,
				max: 1,
				unit: "normal",
				description: "Delay modulation depth"
			}
		]
	},
	Pink: {
		name: "Pink",
		description: "1/f pink noise (Voss-McCartney 8 rows)",
		category: "generators",
		parameters: [{
			name: "seed",
			default: 0,
			description: "Seed"
		}, {
			name: "trig",
			description: "Trigger resets"
		}]
	},
	Dattorro: {
		name: "Dattorro",
		description: "Dattorro-style stereo reverb (modulated tank)",
		category: "effects",
		parameters: [
			{
				name: "input",
				description: "Input signal"
			},
			{
				name: "room",
				default: .5,
				min: 0,
				max: 1,
				unit: "normal",
				description: "Room size / decay"
			},
			{
				name: "damping",
				default: .5,
				min: 0,
				max: 1,
				unit: "normal",
				description: "High-frequency damping"
			},
			{
				name: "bandwidth",
				default: .5,
				min: 0,
				max: 1,
				unit: "normal",
				description: "Input bandwidth"
			},
			{
				name: "indiff1",
				default: .75,
				min: 0,
				max: 1,
				unit: "normal",
				description: "Input diffusion 1"
			},
			{
				name: "indiff2",
				default: .625,
				min: 0,
				max: 1,
				unit: "normal",
				description: "Input diffusion 2"
			},
			{
				name: "decdiff1",
				default: .7,
				min: 0,
				max: 1,
				unit: "normal",
				description: "Decay diffusion 1"
			},
			{
				name: "decdiff2",
				default: .5,
				min: 0,
				max: 1,
				unit: "normal",
				description: "Decay diffusion 2"
			},
			{
				name: "excrate",
				default: .5,
				min: 0,
				max: 1,
				unit: "normal",
				description: "Modulation rate"
			},
			{
				name: "excdepth",
				default: .5,
				min: 0,
				max: 1,
				unit: "normal",
				description: "Modulation depth"
			},
			{
				name: "predelay",
				default: 0,
				min: 0,
				max: 1,
				unit: "s",
				description: "Pre-delay"
			}
		]
	},
	Random: {
		name: "Random",
		description: "Deterministic uniform [0,1] per sample from seed",
		category: "math",
		parameters: [{
			name: "seed",
			default: 0,
			description: "Seed"
		}]
	},
	Slew: {
		name: "Slew",
		description: "Slew rate limiter with separate rise/fall and curve",
		category: "utilities",
		parameters: [
			{
				name: "input",
				description: "Input signal"
			},
			{
				name: "up",
				default: .5,
				min: 0,
				max: 1,
				description: "Rise coefficient (0=slow, 1=instant)"
			},
			{
				name: "down",
				default: .5,
				min: 0,
				max: 1,
				description: "Fall coefficient (0=slow, 1=instant); 0 uses up"
			},
			{
				name: "exp",
				default: 1,
				description: "Curve exponent (0=linear, >0=power, <0=mirrored)"
			}
		]
	},
	Inc: {
		name: "Inc",
		description: "Ramp from offset to ceil at hz rate, trigger reset",
		category: "generators",
		parameters: [
			{
				name: "hz",
				default: 1,
				min: 0,
				unit: "hz",
				description: "Rate"
			},
			{
				name: "ceil",
				default: 1,
				min: 0,
				description: "Ceiling value"
			},
			{
				name: "offset",
				default: 0,
				min: 0,
				description: "Value on trigger"
			},
			{
				name: "trig",
				description: "Trigger impulse"
			}
		]
	},
	Biquadshelf: {
		name: "Biquadshelf",
		description: "Biquad shelf and peak filters (gain-based)",
		category: "filters",
		variants: {
			ls: "Low shelf (Biquad)",
			hs: "High shelf (Biquad)",
			peak: "Peak (notch) (Biquad)"
		},
		parameters: [
			{
				name: "input",
				description: "Input signal"
			},
			{
				name: "cutoff",
				default: 1e3,
				min: 20,
				max: 2e4,
				unit: "hz",
				description: "Cutoff frequency"
			},
			{
				name: "q",
				default: .70710678,
				min: .01,
				max: 20,
				description: "Q factor (peak only)"
			},
			{
				name: "gain",
				default: 0,
				min: -40,
				max: 40,
				unit: "dB",
				description: "Gain in dB"
			}
		]
	},
	Sampler: {
		name: "Sampler",
		description: "Sample player",
		category: "samplers",
		parameters: [
			{
				name: "sample",
				description: "Sample handle from freesound() or record()"
			},
			{
				name: "speed",
				default: 1,
				description: "Playback speed (negative for reverse)"
			},
			{
				name: "offset",
				default: 0,
				min: 0,
				max: 1,
				description: "Normalized start offset"
			},
			{
				name: "repeat",
				default: 0,
				description: "Loop sample when > 0"
			},
			{
				name: "trig",
				description: "Trigger to restart playback"
			}
		]
	},
	Moog: {
		name: "Moog",
		description: "Moog ladder filter (4-pole, nonlinear)",
		category: "filters",
		variants: {
			lpm: "Lowpass filter (Moog)",
			hpm: "Highpass filter (Moog)"
		},
		parameters: [
			{
				name: "input",
				description: "Input signal"
			},
			{
				name: "cutoff",
				default: 1e3,
				min: 50,
				max: 22040,
				unit: "hz",
				description: "Cutoff frequency"
			},
			{
				name: "q",
				default: .70710678,
				min: .01,
				max: .985,
				description: "Q factor"
			}
		]
	},
	Svf: {
		name: "Svf",
		description: "State variable filter (SVF)",
		category: "filters",
		variants: {
			lps: "Lowpass filter (SVF)",
			hps: "Highpass filter (SVF)",
			bps: "Bandpass filter (SVF)",
			bss: "Bandstop filter (SVF)",
			peaks: "Peak (notch) filter (SVF)",
			aps: "Allpass filter (SVF)"
		},
		parameters: [
			{
				name: "input",
				description: "Input signal"
			},
			{
				name: "cutoff",
				default: 1e3,
				min: 50,
				max: 2e4,
				unit: "hz",
				description: "Cutoff frequency"
			},
			{
				name: "q",
				default: .70710678,
				min: .01,
				max: .985,
				description: "Q factor"
			}
		]
	}
};
var allocations = /* @__PURE__ */ new Map();
function ensureCategory(byCategory, cat) {
	if (!byCategory[cat]) byCategory[cat] = {
		count: 0,
		bytes: 0,
		bySource: {}
	};
	return byCategory[cat];
}
function addToBySource(bySource, source, bytes) {
	const cur = bySource[source] ?? {
		count: 0,
		bytes: 0
	};
	cur.count += 1;
	cur.bytes += bytes;
	bySource[source] = cur;
}
function track(id, category, bytes, meta) {
	const source = meta?.source ?? "unknown";
	allocations.set(id, {
		id,
		category,
		bytes,
		meta: {
			...meta,
			source
		},
		at: Date.now()
	});
}
function untrack(id) {
	allocations.delete(id);
}
function getSnapshot() {
	const byCategory = {};
	let totalBytes = 0;
	const entries$1 = Array.from(allocations.values());
	for (const a$36 of entries$1) {
		const cat = ensureCategory(byCategory, a$36.category);
		cat.count += 1;
		cat.bytes += a$36.bytes;
		totalBytes += a$36.bytes;
		const src = a$36.meta?.source ?? "unknown";
		addToBySource(cat.bySource, src, a$36.bytes);
	}
	return {
		allocations: entries$1,
		byCategory,
		totalBytes
	};
}
function reset() {
	allocations.clear();
}
const HISTORY_META_SHARED_BYTE_LENGTH = 10242 * 4;
var _historyMetaId = 0;
function createHistoryMetaSharedBuffer() {
	track(`sab-history-meta-${++_historyMetaId}`, "SharedArrayBuffer", HISTORY_META_SHARED_BYTE_LENGTH, { source: "history-meta-shared" });
	return new SharedArrayBuffer(HISTORY_META_SHARED_BYTE_LENGTH);
}
function historyMetaMetaOffset(index) {
	return 2 + index * 20;
}
function createStaleMetaFacade() {
	const m$5 = new Uint32Array(20);
	m$5[12] = 4294967295;
	return m$5;
}
var AudioVmHistoryView = class AudioVmHistoryView {
	memory;
	metaOffset;
	infoPtr;
	metaSlice = null;
	constructor(memory, metaOffset, infoPtr, metaSlice) {
		this.memory = memory;
		this.metaOffset = metaOffset;
		this.infoPtr = infoPtr;
		this.metaSlice = metaSlice ?? null;
	}
	get meta() {
		if (this.metaSlice) return this.metaSlice;
		const info = new Uint32Array(this.memory.buffer, this.infoPtr, 29);
		const historyCount = info[6];
		if (this.metaOffset / 20 >= historyCount) {
			this.metaSlice = createStaleMetaFacade();
			return this.metaSlice;
		}
		const historyMetaPtr = info[5];
		return new Uint32Array(this.memory.buffer, historyMetaPtr + this.metaOffset * 4, 20);
	}
	static fromMeta(memory, historyIndex, metaU32, metaBaseOffset) {
		const slice = new Uint32Array(metaU32.buffer, metaU32.byteOffset + metaBaseOffset * 4, 20);
		return new AudioVmHistoryView(memory, historyIndex * 20, 0, slice);
	}
	get spec() {
		return genSpecs[this.meta[0]];
	}
	get id() {
		return this.meta[0];
	}
	get historyIndex() {
		return this.metaOffset / 20;
	}
	get genName() {
		return this.spec.genName;
	}
	get variantName() {
		return this.spec.variantName;
	}
	get className() {
		return this.spec.className;
	}
	get paramNames() {
		return this.spec.paramNames;
	}
	get paramModes() {
		return this.spec.paramModes;
	}
	get emitNames() {
		return this.spec.emitNames;
	}
	get paramCount() {
		return this.meta[1];
	}
	get size() {
		return this.meta[2];
	}
	get writeIndex() {
		return this.meta[3];
	}
	get sampleCounts() {
		const m$5 = this.meta;
		return new Int32Array(this.memory.buffer, m$5[4], m$5[2]);
	}
	get values() {
		const m$5 = this.meta;
		return new Float32Array(this.memory.buffer, m$5[5], m$5[2] * m$5[1]);
	}
	get inputPtr() {
		return this.meta[6];
	}
	get inputChunkPos() {
		return this.meta[7];
	}
	get outputPtr() {
		return this.meta[8];
	}
	get outputChunkPos() {
		return this.meta[9];
	}
	get chunkSamples() {
		return this.meta[10];
	}
	get ringChunks() {
		return this.meta[11];
	}
	get callStackFrames() {
		const frames = [];
		const m$5 = this.meta;
		for (let i$6 = 0; i$6 < 8; i$6++) {
			const frame = m$5[12 + i$6];
			if (frame === 4294967295) break;
			frames.push(frame);
		}
		return frames;
	}
	getInputBuffer(bufferLength) {
		const ptr = this.meta[6];
		if (ptr === 0) return null;
		return new Float32Array(this.memory.buffer, ptr, bufferLength);
	}
	getOutputBuffer(bufferLength) {
		const ptr = this.meta[8];
		if (ptr === 0) return null;
		return new Float32Array(this.memory.buffer, ptr, bufferLength);
	}
	getInputRingView() {
		const ptr = this.meta[6];
		if (ptr === 0) return null;
		const chunkSamples = this.meta[10];
		const ringChunks = this.meta[11];
		return new Float32Array(this.memory.buffer, ptr, chunkSamples * ringChunks);
	}
	_outputRingView = null;
	getOutputRingView() {
		const ptr = this.meta[8];
		if (ptr === 0) return null;
		const chunkSamples = this.meta[10];
		const ringChunks = this.meta[11];
		if (!this._outputRingView || this._outputRingView.buffer !== this.memory.buffer) this._outputRingView = new Float32Array(this.memory.buffer, ptr, chunkSamples * ringChunks);
		return this._outputRingView;
	}
};
var AudioVmView = class {
	memory;
	infoPtr;
	constructor(memory, infoPtr) {
		if (!memory || !memory.buffer) throw new Error("Invalid memory: memory or memory.buffer is undefined");
		this.memory = memory;
		this.infoPtr = infoPtr;
	}
	get info() {
		return new Uint32Array(this.memory.buffer, this.infoPtr, 29);
	}
	get stackTop() {
		return this.info[3];
	}
	get stack() {
		const i$6 = this.info;
		return new Float64Array(this.memory.buffer, i$6[0], i$6[4]);
	}
	get histories() {
		const historyCount = this.info[6];
		return Array.from({ length: historyCount }, (_$5, i$6) => new AudioVmHistoryView(this.memory, i$6 * 20, this.infoPtr));
	}
	static fromHistoryMetaShared(memory, historyMetaU32) {
		const historyCount = historyMetaU32[1] ?? 0;
		const views = [];
		for (let i$6 = 0; i$6 < historyCount; i$6++) {
			const baseOffset = historyMetaMetaOffset(i$6);
			views.push(AudioVmHistoryView.fromMeta(memory, i$6, historyMetaU32, baseOffset));
		}
		return { histories: views };
	}
};
function createTypedParamAccessor(getValues, getWriteIndex, paramIndex, paramCount, size) {
	return new Proxy({
		get latest() {
			const values = getValues();
			const writeIndex = getWriteIndex();
			return values[(writeIndex > 0 ? (writeIndex - 1) % size : size - 1) * paramCount + paramIndex] ?? 0;
		},
		at(index) {
			return getValues()[index * paramCount + paramIndex] ?? 0;
		}
	}, { get(target, prop) {
		if (typeof prop === "string" && /^\d+$/.test(prop)) {
			const index = parseInt(prop, 10);
			return getValues()[index * paramCount + paramIndex] ?? 0;
		}
		return Reflect.get(target, prop);
	} });
}
function createTypedSampleCountsAccessor(getSampleCounts, getWriteIndex, size) {
	const arr = getSampleCounts();
	Object.defineProperty(arr, "latest", {
		get() {
			const sampleCounts = getSampleCounts();
			const writeIndex = getWriteIndex();
			return sampleCounts[writeIndex > 0 ? (writeIndex - 1) % size : size - 1] ?? 0;
		},
		enumerable: true
	});
	return arr;
}
function createTypedHistory(history$1, source) {
	const size = history$1.size;
	const mask = size - 1;
	const paramCount = history$1.paramCount;
	const paramNames = history$1.paramNames;
	const emitNames = history$1.emitNames || [];
	const getWriteIndex = () => history$1.writeIndex;
	const getValues = () => history$1.values;
	const getSampleCounts = () => history$1.sampleCounts;
	const sampleCounts = createTypedSampleCountsAccessor(getSampleCounts, getWriteIndex, size);
	const params = {};
	for (let i$6 = 0; i$6 < paramNames.length; i$6++) params[paramNames[i$6]] = createTypedParamAccessor(getValues, getWriteIndex, i$6, paramCount, size);
	const emit = {};
	if (emitNames.length > 0) for (let i$6 = 0; i$6 < emitNames.length; i$6++) {
		const emitIndex = paramNames.length + i$6;
		emit[emitNames[i$6]] = createTypedParamAccessor(getValues, getWriteIndex, emitIndex, paramCount, size);
	}
	return {
		id: history$1.id,
		genName: history$1.genName,
		variantName: history$1.variantName,
		className: history$1.className,
		source,
		view: history$1,
		index: history$1.historyIndex,
		params,
		emit,
		size,
		mask,
		get writeIndex() {
			return getWriteIndex();
		},
		get values() {
			return getValues();
		},
		sampleCounts
	};
}
function createTypedHistories(histories, sourceMap) {
	const framesByHistory = /* @__PURE__ */ new WeakMap();
	const getFrames = (h$5) => {
		const cached = framesByHistory.get(h$5);
		if (cached) return cached;
		const frames = h$5.callStackFrames;
		framesByHistory.set(h$5, frames);
		return frames;
	};
	const sourceMapByPc = /* @__PURE__ */ new Map();
	const callSiteByPc = /* @__PURE__ */ new Map();
	const callSiteEntries = [];
	for (const entry of sourceMap) {
		const arr = sourceMapByPc.get(entry.pc);
		if (arr) arr.push(entry);
		else sourceMapByPc.set(entry.pc, [entry]);
		if (entry.callSite && entry.funcName) {
			const e$59 = entry;
			callSiteByPc.set(entry.pc, e$59);
			callSiteEntries.push(e$59);
		}
	}
	const matches = [];
	const outSoloMatch = (eGen, hGen) => eGen === hGen || eGen === "Solo" && hGen === "Out" || eGen === "Out" && hGen === "Solo";
	for (const history$1 of histories) {
		const frames = getFrames(history$1);
		for (const pc of frames) {
			const sm = sourceMapByPc.get(pc)?.find((e$59) => !e$59.callSite && outSoloMatch(e$59.genName, history$1.genName));
			if (sm) {
				matches.push({
					history: history$1,
					sourceMap: sm
				});
				break;
			}
		}
	}
	const matchedHistoryViews = new Set(matches.map((m$5) => m$5.history));
	const typedHistories = matches.map(({ history: history$1, sourceMap: sourceMap$1 }) => {
		const typedHistory = createTypedHistory(history$1, {
			line: sourceMap$1.line,
			column: sourceMap$1.column
		});
		if (sourceMap$1.genName === "Out" || sourceMap$1.genName === "Solo") typedHistory.genName = sourceMap$1.genName;
		if (typedHistory.genName === "Tram") {
			if (sourceMap$1.tramBeatMapping === void 0) throw new Error("Tram history source map entry missing tramBeatMapping");
			typedHistory.beatMapping = sourceMap$1.tramBeatMapping;
		}
		if (typedHistory.genName === "Mini") {
			if (sourceMap$1.sequence === void 0 || sourceMap$1.compileResult === void 0) throw new Error("Mini history source map entry missing sequence or compileResult");
			typedHistory.sequence = sourceMap$1.sequence;
			typedHistory.compileResult = sourceMap$1.compileResult;
		}
		if (typedHistory.genName === "Timeline") {
			if (sourceMap$1.sequence === void 0) throw new Error("Timeline history source map entry missing sequence");
			typedHistory.sequence = sourceMap$1.sequence;
			typedHistory.segmentTokens = sourceMap$1.timelineSegmentTokens ?? [];
			if (sourceMap$1.timelineColorIndex !== void 0) typedHistory.colorIndex = sourceMap$1.timelineColorIndex;
		}
		if (typedHistory.genName === "ArrayGet" && sourceMap$1.arrayGetElementMapping !== void 0) typedHistory.elementMapping = sourceMap$1.arrayGetElementMapping;
		const frames = getFrames(history$1);
		const genPc = sourceMap$1.pc;
		for (const pc of frames) if (pc !== genPc) {
			const callSm = callSiteByPc.get(pc);
			if (callSm?.funcName) {
				typedHistory.callSiteSource = {
					line: callSm.line,
					column: callSm.column,
					funcName: callSm.funcName
				};
				break;
			}
		}
		return typedHistory;
	});
	const innerOnlyByCallSitePc = /* @__PURE__ */ new Map();
	for (const history$1 of histories) {
		if (matchedHistoryViews.has(history$1)) continue;
		const frames = getFrames(history$1);
		if (frames.length === 0 || frames[0] === 4294967295) continue;
		for (const pc of frames) {
			const callSm = callSiteByPc.get(pc);
			if (callSm?.funcName) {
				const typed = createTypedHistory(history$1, {
					line: callSm.line,
					column: callSm.column
				});
				const arr = innerOnlyByCallSitePc.get(pc) ?? [];
				arr.push(typed);
				innerOnlyByCallSitePc.set(pc, arr);
				break;
			}
		}
	}
	const fromTopLevelByCallSitePc = /* @__PURE__ */ new Map();
	for (const th of typedHistories) {
		const view = th.view;
		const frames = getFrames(view);
		for (const pc of frames) {
			if (!callSiteByPc.has(pc)) continue;
			const arr = fromTopLevelByCallSitePc.get(pc);
			if (arr) arr.push(th);
			else fromTopLevelByCallSitePc.set(pc, [th]);
		}
	}
	const userCallHistories = [];
	for (const entry of callSiteEntries) {
		const fromTopLevel = fromTopLevelByCallSitePc.get(entry.pc) ?? [];
		const fromPrelude = innerOnlyByCallSitePc.get(entry.pc) ?? [];
		const inner = [...fromTopLevel, ...fromPrelude];
		if (inner.length > 0) userCallHistories.push({
			source: {
				line: entry.line,
				column: entry.column
			},
			funcName: entry.funcName,
			inner
		});
	}
	return {
		typedHistories,
		userCallHistories
	};
}
function createHistoryReader(size, mask, state, clear, getLatency, getWriteIndex, getSampleCount, emit) {
	let lastReadIndex = 0;
	let lastReadSampleCount = -1;
	let lastEpoch = -1;
	let now = 0;
	const run = (epoch) => {
		if (epoch === lastEpoch) return;
		lastEpoch = epoch;
		now = getLatency().sampleCount;
		if (now < lastReadSampleCount) {
			clear(state);
			lastReadSampleCount = -1;
		}
		let distance = getWriteIndex() - lastReadIndex;
		if (distance < 0) distance += size;
		if (distance > size) distance = size;
		let nextReadIndex = lastReadIndex;
		for (let i$6 = 0; i$6 < distance; i$6++) {
			const idx = lastReadIndex + i$6 & mask;
			const sampleCount = getSampleCount(idx);
			if (sampleCount <= lastReadSampleCount) continue;
			if (sampleCount > now) continue;
			emit(state, idx, sampleCount);
			lastReadSampleCount = sampleCount;
			nextReadIndex = idx + 1 & mask;
		}
		lastReadIndex = nextReadIndex;
	};
	return {
		run,
		state,
		get now() {
			return now;
		}
	};
}
function getAudioLatencyParams(ctx$1) {
	const sampleRate = ctx$1.sampleRate;
	const latencySeconds = (ctx$1.outputLatency || 0) - (ctx$1.baseLatency || 0);
	return {
		sampleRate,
		latencySamples: latencySeconds * sampleRate,
		latencySeconds
	};
}
const ZERO_LATENCY = {
	latencySamples: 0,
	latencySeconds: 0,
	deltaTime: 0,
	sampleRate: 0,
	sampleCount: 0,
	rawSampleCount: 0,
	timeSeconds: 0
};
function computePredictionAndLatency(rawSampleCount, previousPredicted, ctx$1) {
	if (!ctx$1) return {
		predicted: rawSampleCount,
		latency: {
			latencySamples: 0,
			latencySeconds: 0,
			deltaTime: 0,
			sampleRate: 0,
			sampleCount: 0,
			rawSampleCount: 0,
			timeSeconds: 0
		}
	};
	const { isPlaying: isPlaying$1, sampleRate, latencySamples, latencySeconds, deltaTime } = ctx$1;
	const rawPlaybackPosition = rawSampleCount - (isPlaying$1 ? latencySamples : 0);
	let predicted = previousPredicted;
	if (predicted == null || !isPlaying$1) predicted = rawPlaybackPosition;
	else {
		const drift = rawPlaybackPosition - (predicted ?? 0);
		if (Math.abs(drift) > sampleRate) predicted = rawPlaybackPosition;
		else {
			predicted = (predicted ?? 0) + deltaTime * sampleRate;
			if (Math.abs(drift) > 100) predicted += drift * .5;
		}
	}
	predicted = Math.max(0, predicted ?? 0);
	const sampleCount = predicted;
	const latency = {
		latencySamples,
		latencySeconds,
		deltaTime,
		sampleRate,
		sampleCount,
		rawSampleCount,
		timeSeconds: sampleRate ? sampleCount / sampleRate : 0
	};
	return {
		predicted,
		latency
	};
}
function createDspLatency(opts) {
	let lastWallTime = null;
	let predictedSampleCount = null;
	let latency = { ...ZERO_LATENCY };
	const { audioContext: audioContext$1, getIsPlaying, getRawSampleCount } = opts;
	return {
		get state() {
			return latency;
		},
		update(updateOpts) {
			const isPlaying$1 = updateOpts?.isPlaying ?? getIsPlaying();
			const { sampleRate, latencySamples, latencySeconds } = getAudioLatencyParams(audioContext$1);
			const nowSec = performance.now() / 1e3;
			const lastWall = updateOpts?.reset ? nowSec : lastWallTime ?? nowSec;
			const deltaTime = Math.max(0, nowSec - lastWall);
			lastWallTime = nowSec;
			const ctx$1 = {
				isPlaying: isPlaying$1,
				sampleRate,
				latencySamples,
				latencySeconds,
				deltaTime
			};
			const { predicted, latency: next } = computePredictionAndLatency(getRawSampleCount(), updateOpts?.reset ? null : predictedSampleCount, ctx$1);
			predictedSampleCount = predicted;
			latency = next;
		}
	};
}
function Deferred$1() {
	const _onwhen = () => {
		deferred.hasSettled = true;
		deferred.resolve = deferred.reject = noop;
	};
	const noop = () => {};
	let onwhen = _onwhen;
	const deferred = {
		hasSettled: false,
		when: (fn$1) => {
			onwhen = () => {
				_onwhen();
				fn$1();
			};
		}
	};
	deferred.promise = new Promise((resolve, reject) => {
		deferred.resolve = (arg) => {
			onwhen();
			deferred.value = arg;
			resolve(arg);
		};
		deferred.reject = (error$1) => {
			onwhen();
			deferred.error = error$1;
			reject(error$1);
		};
	});
	return deferred;
}
function atomic(fn$1, { dropInbetween = false, timeout = null } = {}) {
	const queue = [];
	let isRunning = false;
	const apply = async (task) => {
		try {
			if (timeout) {
				const result = await Promise.race([fn$1.apply(task.context, task.args), new Promise((_$5, reject) => setTimeout(() => reject(/* @__PURE__ */ new Error("Timeout")), timeout))]);
				task.deferred.resolve(result);
			} else {
				const result = await fn$1.apply(task.context, task.args);
				task.deferred.resolve(result);
			}
		} catch (error$1) {
			task.deferred.reject(error$1);
		}
	};
	const drain = async () => {
		isRunning = true;
		if (dropInbetween) {
			const tasks = queue.splice(0);
			const last = tasks.pop();
			tasks.forEach((task) => task.deferred.reject(/* @__PURE__ */ new Error("Dropped")));
			await apply(last);
		} else await apply(queue.shift());
		if (queue.length) drain();
		else isRunning = false;
	};
	function cb(...args) {
		const task = {
			context: this,
			args,
			deferred: Deferred$1()
		};
		queue.push(task);
		if (!isRunning) drain();
		return task.deferred.promise;
	}
	return cb;
}
function hashF32Bits(arr) {
	const u32 = new Uint32Array(arr.buffer, arr.byteOffset, arr.byteLength / 4 | 0);
	let hash = 0;
	for (let i$6 = 0; i$6 < u32.length; i$6++) hash = hash * 31 + (u32[i$6] ?? 0) | 0;
	return hash;
}
function computePeaks(ch0, w$5) {
	const len = ch0.length | 0;
	const outW = Math.max(1, w$5 | 0);
	const out = new Float32Array(outW * 2);
	if (len <= 0) {
		out.fill(0);
		return out;
	}
	for (let i$6 = 0; i$6 < outW; i$6++) {
		const from = Math.floor(i$6 * len / outW);
		const to = Math.floor((i$6 + 1) * len / outW);
		const a$36 = Math.max(0, Math.min(len - 1, from));
		const b$4 = Math.max(a$36 + 1, Math.min(len, to));
		let mn = ch0[a$36] ?? 0;
		let mx = mn;
		for (let j$4 = a$36 + 1; j$4 < b$4; j$4++) {
			const v$4 = ch0[j$4] ?? 0;
			if (v$4 < mn) mn = v$4;
			if (v$4 > mx) mx = v$4;
		}
		const base = i$6 * 2;
		out[base] = mn;
		out[base + 1] = mx;
	}
	return out;
}
var clamp$2 = (v$4, lo, hi) => Math.max(lo, Math.min(hi, v$4));
function detectSlices(samples, threshold, max) {
	const m$5 = Math.max(1, max | 0);
	const points = new Int32Array(m$5);
	const len = samples.length | 0;
	if (len <= 0) return {
		points,
		count: 0
	};
	let count = 0;
	const thr = clamp$2(threshold, 0, 1);
	const desiredBuckets = Math.max(256, Math.min(16384, m$5 * 16 | 0));
	const maxBucketsByMinSize = Math.max(1, Math.floor(len / 32));
	const bucketCount = Math.max(1, Math.min(len, desiredBuckets, maxBucketsByMinSize));
	if (bucketCount <= 1) {
		points[0] = 0;
		return {
			points,
			count: 1
		};
	}
	const peaks = computePeaks(samples, bucketCount);
	const rise = new Float32Array(bucketCount);
	let riseMax = 0;
	let prevAmp = 0;
	for (let i$6 = 0; i$6 < bucketCount; i$6++) {
		const base = i$6 * 2;
		const mn = peaks[base] ?? 0;
		const mx = peaks[base + 1] ?? 0;
		const amp = Math.max(Math.abs(mn), Math.abs(mx));
		const d$5 = i$6 === 0 ? 0 : Math.max(0, amp - prevAmp);
		rise[i$6] = d$5;
		if (d$5 > riseMax) riseMax = d$5;
		prevAmp = amp;
	}
	if (riseMax <= 0) {
		points[0] = 0;
		return {
			points,
			count: 1
		};
	}
	const minRise = riseMax * (.02 + thr * .28);
	const noveltyMin = riseMax * (.01 + thr * .18);
	const ratioMin = thr * .9;
	const minDistanceBuckets = 1 + (thr * 24 | 0);
	const rearmLevel = riseMax * (.006 + thr * .06);
	const cooldownFrames = 1 + (thr * 10 | 0);
	const fastCoeff = .25;
	const slowCoeff = .02;
	let fast = rise[0] ?? 0;
	let slow = fast;
	let prev2 = 0;
	let prev1 = 0;
	let prevFast1 = fast;
	let prevSlow1 = slow;
	let lastPeakBucket = -1073741823;
	let armed = true;
	let cooldown = 0;
	let mg = 0;
	const bucketStart = (b$4) => Math.floor(b$4 * len / bucketCount);
	for (let frame = 1; frame < bucketCount && count < m$5; frame++) {
		const e$59 = rise[frame] ?? 0;
		fast += (e$59 - fast) * fastCoeff;
		slow += (e$59 - slow) * slowCoeff;
		const novelty = Math.max(0, fast - slow);
		const release = .995 + thr * .01;
		mg *= release;
		const mgMul = 1 + mg * (10 + thr * 12);
		const effMinRise = minRise * mgMul;
		const effNoveltyMin = noveltyMin * mgMul;
		const baseMinDistanceBuckets = Math.max(2, Math.floor(minDistanceBuckets * (1 + mg * 2)));
		const effMinDistanceBuckets = count <= 2 ? Math.max(baseMinDistanceBuckets, 4 + (thr * 8 | 0)) : baseMinDistanceBuckets;
		if (!armed && novelty <= rearmLevel) armed = true;
		if (cooldown > 0) cooldown--;
		if (frame >= 2) {
			if (prev1 > prev2 && prev1 >= novelty) {
				const posBucket = frame - 1 | 0;
				const bucketDelta = posBucket - lastPeakBucket;
				const base = Math.max(prevSlow1, riseMax * 1e-5);
				const ratio = prevFast1 / base;
				if (armed && cooldown <= 0 && bucketDelta >= effMinDistanceBuckets && prevFast1 >= effMinRise && ratio >= 1 + ratioMin && prev1 >= effNoveltyMin) {
					const s$4 = bucketStart(posBucket);
					if (s$4 > (count > 0 ? points[count - 1] ?? 0 : -1)) {
						points[count++] = s$4;
						lastPeakBucket = posBucket;
						armed = false;
						cooldown = cooldownFrames;
						mg = Math.min(1, mg + .75);
					}
				}
			}
		}
		prev2 = prev1;
		prev1 = novelty;
		prevFast1 = fast;
		prevSlow1 = slow;
	}
	if (count <= 0) {
		points[0] = 0;
		return {
			points,
			count: 1
		};
	}
	return {
		points,
		count
	};
}
var SampleManager = class {
	samples = /* @__PURE__ */ new Map();
	sampleVersion = /* @__PURE__ */ new Map();
	sliceCache = /* @__PURE__ */ new Map();
	freesoundIds = /* @__PURE__ */ new Map();
	recordRequests = /* @__PURE__ */ new Map();
	nextHandle = 1;
	getSampleVersion(handle) {
		return this.sampleVersion.get(handle) ?? 0;
	}
	bumpVersion(handle) {
		this.sampleVersion.set(handle, (this.sampleVersion.get(handle) ?? 0) + 1);
	}
	registerFreesound(id) {
		for (const [handle$1, fsId] of this.freesoundIds.entries()) if (fsId === id) return handle$1;
		const handle = this.nextHandle++;
		this.freesoundIds.set(handle, id);
		this.samples.set(handle, {
			id: handle,
			channels: [],
			length: 0,
			sampleRate: 44100,
			ready: false
		});
		return handle;
	}
	ensureFreesoundHandle(handle, freesoundId) {
		if (this.samples.has(handle)) return;
		this.freesoundIds.set(handle, freesoundId);
		this.samples.set(handle, {
			id: handle,
			channels: [],
			length: 0,
			sampleRate: 44100,
			ready: false
		});
	}
	registerRecord(projectId, seconds, callbackId) {
		const key = `${projectId ?? ""}\0${seconds}\0${callbackId}`;
		for (const [handle$1, req] of this.recordRequests.entries()) if (`${req.projectId ?? ""}\0${req.seconds}\0${req.callbackId}` === key) return handle$1;
		const handle = this.nextHandle++;
		this.recordRequests.set(handle, {
			projectId,
			seconds,
			callbackId
		});
		this.samples.set(handle, {
			id: handle,
			channels: [],
			length: 0,
			sampleRate: 44100,
			ready: false
		});
		return handle;
	}
	ensureRecordHandle(handle, seconds, callbackId, projectId = null) {
		if (this.samples.has(handle)) return;
		this.recordRequests.set(handle, {
			projectId,
			seconds,
			callbackId
		});
		this.samples.set(handle, {
			id: handle,
			channels: [],
			length: 0,
			sampleRate: 44100,
			ready: false
		});
	}
	getFreesoundId(handle) {
		return this.freesoundIds.get(handle);
	}
	ensureInlineHandle(handle) {
		if (this.samples.has(handle)) return;
		this.samples.set(handle, {
			id: handle,
			channels: [],
			length: 0,
			sampleRate: 44100,
			ready: false
		});
	}
	registerEspeak() {
		const handle = this.nextHandle++;
		this.samples.set(handle, {
			id: handle,
			channels: [],
			length: 0,
			sampleRate: 44100,
			ready: false
		});
		return handle;
	}
	registerInlineSample(channels, sampleRate) {
		const handle = this.nextHandle++;
		const copiedChannels = channels.map((ch) => new Float32Array(ch));
		this.samples.set(handle, {
			id: handle,
			channels: copiedChannels,
			length: copiedChannels[0]?.length ?? 0,
			sampleRate,
			ready: copiedChannels.length > 0 && (copiedChannels[0]?.length ?? 0) > 0
		});
		this.bumpVersion(handle);
		return handle;
	}
	getRecordRequest(handle) {
		return this.recordRequests.get(handle);
	}
	setSampleData(handle, channels, sampleRate) {
		const sample = this.samples.get(handle);
		if (!sample) return;
		sample.channels = channels;
		sample.length = channels[0]?.length ?? 0;
		sample.sampleRate = sampleRate;
		sample.ready = channels.length > 0 && sample.length > 0;
		sample.error = void 0;
		this.bumpVersion(handle);
	}
	setSampleError(handle, error$1) {
		const sample = this.samples.get(handle);
		if (!sample) return;
		sample.error = error$1;
		sample.ready = false;
		this.bumpVersion(handle);
	}
	recordSample(handle, audioData, sampleRate) {
		const sample = this.samples.get(handle);
		if (!sample) return;
		sample.channels = audioData.map((ch) => new Float32Array(ch));
		sample.length = audioData[0]?.length ?? 0;
		sample.sampleRate = sampleRate;
		sample.ready = sample.channels.length > 0 && sample.length > 0;
		this.bumpVersion(handle);
	}
	getSample(handle) {
		return this.samples.get(handle) ?? null;
	}
	getSlices(handle, threshold) {
		const sample = this.samples.get(handle);
		if (!sample || !sample.ready || sample.channels.length === 0) return {
			points: new Int32Array(1),
			count: 1
		};
		let cacheMap = this.sliceCache.get(handle);
		if (!cacheMap) {
			cacheMap = /* @__PURE__ */ new Map();
			this.sliceCache.set(handle, cacheMap);
		}
		const thresholdKey = Math.round(threshold * 1e3);
		let cached = cacheMap.get(thresholdKey);
		if (cached) return {
			points: cached.points,
			count: cached.count
		};
		const result = detectSlices(sample.channels[0], threshold, 256);
		cached = {
			threshold,
			points: result.points,
			count: result.count
		};
		cacheMap.set(thresholdKey, cached);
		return {
			points: result.points,
			count: result.count
		};
	}
	readChunk(handle, channel, offset, length) {
		const sample = this.samples.get(handle);
		if (!sample || !sample.ready) return new Float32Array(length);
		const ch = sample.channels[channel];
		if (!ch) return new Float32Array(length);
		const start = Math.max(0, Math.min(offset | 0, ch.length));
		const end = Math.max(start, Math.min(start + length, ch.length));
		if (end - start === 0) return new Float32Array(length);
		const result = new Float32Array(length);
		result.set(ch.subarray(start, end));
		return result;
	}
	areAllSamplesReady() {
		for (const sample of this.samples.values()) if (!sample.ready) return false;
		return true;
	}
	getRequiredSamples() {
		return Array.from(this.samples.keys()).filter((handle) => {
			const sample = this.samples.get(handle);
			return sample && !sample.ready;
		});
	}
	getSampleMemoryInfo() {
		let totalChannelBytes = 0;
		for (const sample of this.samples.values()) for (const ch of sample.channels) totalChannelBytes += ch.byteLength;
		return {
			handleCount: this.samples.size,
			totalChannelBytes
		};
	}
	clear() {
		this.samples.clear();
		this.sampleVersion.clear();
		this.sliceCache.clear();
		this.freesoundIds.clear();
		this.recordRequests.clear();
		this.nextHandle = 1;
	}
	clearHandle(handle) {
		const sample = this.samples.get(handle);
		if (sample) {
			sample.channels = [];
			sample.length = 0;
			sample.ready = false;
			sample.error = void 0;
		}
		this.bumpVersion(handle);
		this.sliceCache.delete(handle);
	}
};
const sampleManager = new SampleManager();
function collectParamNames(params) {
	const names = /* @__PURE__ */ new Set();
	for (const p$6 of params) if (p$6.type === "param") names.add(p$6.name);
	else if (p$6.type === "param-destructure") for (const n$4 of p$6.names) names.add(n$4);
	else if (p$6.type === "param-named-destructure") {
		names.add(p$6.paramName);
		for (const n$4 of p$6.names) names.add(n$4);
	}
	return names;
}
function collectClosureVarNames(fnExpr, outerLocals, opts) {
	const out = /* @__PURE__ */ new Set();
	const params = collectParamNames(fnExpr.params);
	const inOuterLocals = (name) => {
		for (const scope of outerLocals) if (scope.has(name)) return true;
		return false;
	};
	const walkExpr = (e$59) => {
		switch (e$59.type) {
			case "number":
			case "string": return;
			case "identifier":
				if (!params.has(e$59.name) && !opts.systemVars.has(e$59.name) && inOuterLocals(e$59.name)) out.add(e$59.name);
				return;
			case "array":
				for (const it$1 of e$59.items) walkExpr(it$1);
				return;
			case "index":
				walkExpr(e$59.object);
				walkExpr(e$59.index);
				return;
			case "member":
				walkExpr(e$59.object);
				return;
			case "unary":
				walkExpr(e$59.expr);
				return;
			case "binary":
				walkExpr(e$59.left);
				walkExpr(e$59.right);
				return;
			case "ternary":
				walkExpr(e$59.test);
				walkExpr(e$59.then);
				walkExpr(e$59.else);
				return;
			case "call":
				walkExpr(e$59.callee);
				for (const a$36 of e$59.args) if (a$36.type === "arg") walkExpr(a$36.value);
				return;
			case "assign":
				if (e$59.left.type === "identifier") {
					walkExpr(e$59.right);
					if (e$59.op !== ":=" && !params.has(e$59.left.name) && !opts.systemVars.has(e$59.left.name) && inOuterLocals(e$59.left.name)) out.add(e$59.left.name);
					return;
				}
				if (e$59.left.type === "destructure") {
					walkExpr(e$59.right);
					for (const name of e$59.left.names) if (e$59.op !== ":=" && !params.has(name) && !opts.systemVars.has(name) && inOuterLocals(name)) out.add(name);
					return;
				}
				walkExpr(e$59.left);
				walkExpr(e$59.right);
				return;
			case "destructure": return;
			case "fn":
				if (e$59.body.type === "block") walkStmt(e$59.body);
				else walkExpr(e$59.body);
				return;
		}
	};
	const walkStmt = (s$4) => {
		switch (s$4.type) {
			case "expr":
				walkExpr(s$4.expr);
				return;
			case "block":
				for (const it$1 of s$4.body) walkStmt(it$1);
				return;
			case "if":
				walkExpr(s$4.test);
				walkStmt(s$4.then);
				if (s$4.else) walkStmt(s$4.else);
				return;
			case "while":
				walkExpr(s$4.test);
				walkStmt(s$4.body);
				return;
			case "do":
				walkStmt(s$4.body);
				walkExpr(s$4.test);
				return;
			case "for":
				walkExpr(s$4.from);
				walkExpr(s$4.to);
				walkStmt(s$4.body);
				return;
			case "for-of":
				walkExpr(s$4.iterable);
				walkStmt(s$4.body);
				return;
			case "return":
				if (s$4.value) walkExpr(s$4.value);
				return;
			case "throw":
				if (s$4.value) walkExpr(s$4.value);
				return;
			case "try":
				walkStmt(s$4.body);
				if (s$4.catch) walkStmt(s$4.catch.body);
				if (s$4.finally) walkStmt(s$4.finally);
				return;
			case "label":
				walkStmt(s$4.stmt);
				return;
			case "break":
			case "continue": return;
		}
	};
	if (fnExpr.defaults) {
		for (const defaultExpr of fnExpr.defaults) if (defaultExpr) walkExpr(defaultExpr);
	}
	if (fnExpr.body.type === "block") walkStmt(fnExpr.body);
	else walkExpr(fnExpr.body);
	return Array.from(out);
}
function collectCapturedVarNames(body, opts) {
	const out = /* @__PURE__ */ new Set();
	const add = (name) => {
		if (name === "$") return;
		if (opts.systemVars.has(name)) return;
		out.add(name);
	};
	const walkExpr = (e$59) => {
		switch (e$59.type) {
			case "number":
			case "string": return;
			case "identifier":
				add(e$59.name);
				return;
			case "array":
				for (const it$1 of e$59.items) walkExpr(it$1);
				return;
			case "index":
				walkExpr(e$59.object);
				walkExpr(e$59.index);
				return;
			case "member":
				walkExpr(e$59.object);
				return;
			case "unary":
				walkExpr(e$59.expr);
				return;
			case "binary":
				walkExpr(e$59.left);
				walkExpr(e$59.right);
				return;
			case "ternary":
				walkExpr(e$59.test);
				walkExpr(e$59.then);
				walkExpr(e$59.else);
				return;
			case "call":
				walkExpr(e$59.callee);
				for (const a$36 of e$59.args) if (a$36.type === "arg") walkExpr(a$36.value);
				return;
			case "assign":
				if (e$59.left.type === "identifier" && e$59.op !== ":=") add(e$59.left.name);
				if (e$59.left.type === "destructure" && e$59.op !== ":=") for (const name of e$59.left.names) add(name);
				if (e$59.left.type !== "identifier" && e$59.left.type !== "destructure") walkExpr(e$59.left);
				walkExpr(e$59.right);
				return;
			case "destructure": return;
			case "fn": return;
		}
	};
	const walkStmt = (s$4) => {
		switch (s$4.type) {
			case "expr":
				walkExpr(s$4.expr);
				return;
			case "block":
				for (const it$1 of s$4.body) walkStmt(it$1);
				return;
			case "if":
				walkExpr(s$4.test);
				walkStmt(s$4.then);
				if (s$4.else) walkStmt(s$4.else);
				return;
			case "while":
				walkExpr(s$4.test);
				walkStmt(s$4.body);
				return;
			case "do":
				walkStmt(s$4.body);
				walkExpr(s$4.test);
				return;
			case "for":
				walkExpr(s$4.from);
				walkExpr(s$4.to);
				walkStmt(s$4.body);
				return;
			case "for-of":
				walkExpr(s$4.iterable);
				walkStmt(s$4.body);
				return;
			case "return":
				if (s$4.value) walkExpr(s$4.value);
				return;
			case "throw":
				if (s$4.value) walkExpr(s$4.value);
				return;
			case "try":
				walkStmt(s$4.body);
				if (s$4.catch) walkStmt(s$4.catch.body);
				if (s$4.finally) walkStmt(s$4.finally);
				return;
			case "label":
				walkStmt(s$4.stmt);
				return;
			case "break":
			case "continue": return;
		}
	};
	if ([
		"number",
		"string",
		"identifier",
		"fn",
		"array",
		"index",
		"unary",
		"binary",
		"ternary",
		"call",
		"member",
		"assign",
		"destructure"
	].includes(body.type)) {
		walkExpr(body);
		return Array.from(out);
	}
	walkStmt(body);
	return Array.from(out);
}
function assignRecordCallIds(program) {
	const recordCallIds = /* @__PURE__ */ new Map();
	let nextRecordId = 0;
	const getLocKey = (loc) => {
		return `${loc.line}:${loc.column}:${loc.start}:${loc.end}`;
	};
	const functionsWithRecord = /* @__PURE__ */ new Set();
	const functionToRecordCall = /* @__PURE__ */ new Map();
	const checkForRecord = (expr) => {
		if (expr.type === "call" && expr.callee.type === "identifier" && expr.callee.name === "record") return true;
		switch (expr.type) {
			case "number":
			case "string":
			case "identifier": return false;
			case "destructure": return false;
			case "array":
				for (const it$1 of expr.items) if (checkForRecord(it$1)) return true;
				return false;
			case "index": return checkForRecord(expr.object) || checkForRecord(expr.index);
			case "member": return checkForRecord(expr.object);
			case "unary": return checkForRecord(expr.expr);
			case "binary": return checkForRecord(expr.left) || checkForRecord(expr.right);
			case "ternary": return checkForRecord(expr.test) || checkForRecord(expr.then) || checkForRecord(expr.else);
			case "call":
				if (checkForRecord(expr.callee)) return true;
				for (const a$36 of expr.args) if (a$36.type === "arg" && checkForRecord(a$36.value)) return true;
				return false;
			case "assign": return checkForRecord(expr.left) || checkForRecord(expr.right);
			case "fn": return false;
		}
	};
	const checkStmtForRecord = (s$4) => {
		switch (s$4.type) {
			case "expr": return checkForRecord(s$4.expr);
			case "block":
				for (const it$1 of s$4.body) if (checkStmtForRecord(it$1)) return true;
				return false;
			case "if": return checkForRecord(s$4.test) || checkStmtForRecord(s$4.then) || (s$4.else ? checkStmtForRecord(s$4.else) : false);
			case "while": return checkForRecord(s$4.test) || checkStmtForRecord(s$4.body);
			case "do": return checkStmtForRecord(s$4.body) || checkForRecord(s$4.test);
			case "for": return checkForRecord(s$4.from) || checkForRecord(s$4.to) || checkStmtForRecord(s$4.body);
			case "for-of": return checkForRecord(s$4.iterable) || checkStmtForRecord(s$4.body);
			case "return": return s$4.value ? checkForRecord(s$4.value) : false;
			case "throw": return s$4.value ? checkForRecord(s$4.value) : false;
			case "try": return checkStmtForRecord(s$4.body) || (s$4.catch ? checkStmtForRecord(s$4.catch.body) : false) || (s$4.finally ? checkStmtForRecord(s$4.finally) : false);
			case "label": return checkStmtForRecord(s$4.stmt);
			case "break":
			case "continue": return false;
		}
	};
	const findRecordCallLoc = (expr) => {
		if (expr.type === "call" && expr.callee.type === "identifier" && expr.callee.name === "record") return getLocKey(expr.loc);
		switch (expr.type) {
			case "number":
			case "string":
			case "identifier": return null;
			case "array":
				for (const it$1 of expr.items) {
					const loc = findRecordCallLoc(it$1);
					if (loc) return loc;
				}
				return null;
			case "index": return findRecordCallLoc(expr.object) || findRecordCallLoc(expr.index);
			case "member": return findRecordCallLoc(expr.object);
			case "unary": return findRecordCallLoc(expr.expr);
			case "binary": return findRecordCallLoc(expr.left) || findRecordCallLoc(expr.right);
			case "ternary": return findRecordCallLoc(expr.test) || findRecordCallLoc(expr.then) || findRecordCallLoc(expr.else);
			case "call":
				const calleeLoc = findRecordCallLoc(expr.callee);
				if (calleeLoc) return calleeLoc;
				for (const a$36 of expr.args) if (a$36.type === "arg") {
					const argLoc = findRecordCallLoc(a$36.value);
					if (argLoc) return argLoc;
				}
				return null;
			case "assign": return findRecordCallLoc(expr.left) || findRecordCallLoc(expr.right);
			case "destructure": return null;
			case "fn": return null;
		}
	};
	const findRecordCallLocInStmt = (s$4) => {
		switch (s$4.type) {
			case "expr": return findRecordCallLoc(s$4.expr);
			case "block":
				for (const it$1 of s$4.body) {
					const loc = findRecordCallLocInStmt(it$1);
					if (loc) return loc;
				}
				return null;
			case "if": return findRecordCallLoc(s$4.test) || findRecordCallLocInStmt(s$4.then) || (s$4.else ? findRecordCallLocInStmt(s$4.else) : null);
			case "while": return findRecordCallLoc(s$4.test) || findRecordCallLocInStmt(s$4.body);
			case "do": return findRecordCallLocInStmt(s$4.body) || findRecordCallLoc(s$4.test);
			case "for": return findRecordCallLoc(s$4.from) || findRecordCallLoc(s$4.to) || findRecordCallLocInStmt(s$4.body);
			case "for-of": return findRecordCallLoc(s$4.iterable) || findRecordCallLocInStmt(s$4.body);
			case "return": return s$4.value ? findRecordCallLoc(s$4.value) : null;
			case "throw": return s$4.value ? findRecordCallLoc(s$4.value) : null;
			case "try": return findRecordCallLocInStmt(s$4.body) || (s$4.catch ? findRecordCallLocInStmt(s$4.catch.body) : null) || (s$4.finally ? findRecordCallLocInStmt(s$4.finally) : null);
			case "label": return findRecordCallLocInStmt(s$4.stmt);
			case "break":
			case "continue": return null;
		}
	};
	const discoverRecordFunctions = () => {
		const walkExpr$1 = (e$59) => {
			if (e$59.type === "assign" && e$59.left.type === "identifier" && e$59.right.type === "fn") {
				const funcName = e$59.left.name;
				if (e$59.right.body.type === "block" ? checkStmtForRecord(e$59.right.body) : checkForRecord(e$59.right.body)) {
					functionsWithRecord.add(funcName);
					const recordLocKey = e$59.right.body.type === "block" ? findRecordCallLocInStmt(e$59.right.body) : findRecordCallLoc(e$59.right.body);
					if (recordLocKey) functionToRecordCall.set(funcName, recordLocKey);
				}
			}
			switch (e$59.type) {
				case "number":
				case "string":
				case "identifier":
				case "destructure": return;
				case "array":
					for (const it$1 of e$59.items) walkExpr$1(it$1);
					return;
				case "index":
					walkExpr$1(e$59.object);
					walkExpr$1(e$59.index);
					return;
				case "member":
					walkExpr$1(e$59.object);
					return;
				case "unary":
					walkExpr$1(e$59.expr);
					return;
				case "binary":
					walkExpr$1(e$59.left);
					walkExpr$1(e$59.right);
					return;
				case "ternary":
					walkExpr$1(e$59.test);
					walkExpr$1(e$59.then);
					walkExpr$1(e$59.else);
					return;
				case "call":
					walkExpr$1(e$59.callee);
					for (const a$36 of e$59.args) if (a$36.type === "arg") walkExpr$1(a$36.value);
					return;
				case "assign":
					walkExpr$1(e$59.left);
					walkExpr$1(e$59.right);
					return;
				case "fn":
					if (e$59.body.type === "block") walkStmt$1(e$59.body);
					else walkExpr$1(e$59.body);
					return;
			}
		};
		const walkStmt$1 = (s$4) => {
			switch (s$4.type) {
				case "expr":
					walkExpr$1(s$4.expr);
					return;
				case "block":
					for (const it$1 of s$4.body) walkStmt$1(it$1);
					return;
				case "if":
					walkExpr$1(s$4.test);
					walkStmt$1(s$4.then);
					if (s$4.else) walkStmt$1(s$4.else);
					return;
				case "while":
					walkExpr$1(s$4.test);
					walkStmt$1(s$4.body);
					return;
				case "do":
					walkStmt$1(s$4.body);
					walkExpr$1(s$4.test);
					return;
				case "for":
					walkExpr$1(s$4.from);
					walkExpr$1(s$4.to);
					walkStmt$1(s$4.body);
					return;
				case "for-of":
					walkExpr$1(s$4.iterable);
					walkStmt$1(s$4.body);
					return;
				case "return":
					if (s$4.value) walkExpr$1(s$4.value);
					return;
				case "throw":
					if (s$4.value) walkExpr$1(s$4.value);
					return;
				case "try":
					walkStmt$1(s$4.body);
					if (s$4.catch) walkStmt$1(s$4.catch.body);
					if (s$4.finally) walkStmt$1(s$4.finally);
					return;
				case "label":
					walkStmt$1(s$4.stmt);
					return;
				case "break":
				case "continue": return;
			}
		};
		for (const stmt of program.body) walkStmt$1(stmt);
	};
	discoverRecordFunctions();
	let inFunctionBody = false;
	const walkExpr = (e$59) => {
		switch (e$59.type) {
			case "number":
			case "string":
			case "identifier": return;
			case "array":
				for (const it$1 of e$59.items) walkExpr(it$1);
				return;
			case "index":
				walkExpr(e$59.object);
				walkExpr(e$59.index);
				return;
			case "member":
				walkExpr(e$59.object);
				return;
			case "unary":
				walkExpr(e$59.expr);
				return;
			case "binary":
				walkExpr(e$59.left);
				walkExpr(e$59.right);
				return;
			case "ternary":
				walkExpr(e$59.test);
				walkExpr(e$59.then);
				walkExpr(e$59.else);
				return;
			case "call":
				if (e$59.callee.type === "identifier") {
					if (e$59.callee.name === "record") {
						if (!inFunctionBody) {
							const locKey = getLocKey(e$59.loc);
							if (!recordCallIds.has(locKey)) recordCallIds.set(locKey, nextRecordId++);
						}
					} else if (functionsWithRecord.has(e$59.callee.name)) {
						const callSiteLocKey = getLocKey(e$59.loc);
						if (!recordCallIds.has(callSiteLocKey)) recordCallIds.set(callSiteLocKey, nextRecordId++);
					}
				}
				walkExpr(e$59.callee);
				for (const a$36 of e$59.args) if (a$36.type === "arg") walkExpr(a$36.value);
				return;
			case "assign":
				walkExpr(e$59.left);
				walkExpr(e$59.right);
				return;
			case "destructure": return;
			case "fn":
				const savedInFunctionBody = inFunctionBody;
				inFunctionBody = true;
				if (e$59.body.type === "block") walkStmt(e$59.body);
				else walkExpr(e$59.body);
				inFunctionBody = savedInFunctionBody;
				return;
		}
	};
	const walkStmt = (s$4) => {
		switch (s$4.type) {
			case "expr":
				walkExpr(s$4.expr);
				return;
			case "block":
				for (const it$1 of s$4.body) walkStmt(it$1);
				return;
			case "if":
				walkExpr(s$4.test);
				walkStmt(s$4.then);
				if (s$4.else) walkStmt(s$4.else);
				return;
			case "while":
				walkExpr(s$4.test);
				walkStmt(s$4.body);
				return;
			case "do":
				walkStmt(s$4.body);
				walkExpr(s$4.test);
				return;
			case "for":
				walkExpr(s$4.from);
				walkExpr(s$4.to);
				walkStmt(s$4.body);
				return;
			case "for-of":
				walkExpr(s$4.iterable);
				walkStmt(s$4.body);
				return;
			case "return":
				if (s$4.value) walkExpr(s$4.value);
				return;
			case "throw":
				if (s$4.value) walkExpr(s$4.value);
				return;
			case "try":
				walkStmt(s$4.body);
				if (s$4.catch) walkStmt(s$4.catch.body);
				if (s$4.finally) walkStmt(s$4.finally);
				return;
			case "label":
				walkStmt(s$4.stmt);
				return;
			case "break":
			case "continue": return;
		}
	};
	for (const stmt of program.body) walkStmt(stmt);
	return {
		recordCallIds,
		functionToRecordCall
	};
}
var Y = (H$3, A$3) => 0 != (H$3 & A$3), r$7 = (H$3) => {
	let E$4 = new Uint8Array(H$3.length);
	return H$3.split("").forEach((H$4, A$3) => {
		E$4[A$3] = H$4.charCodeAt(0);
	}), E$4;
}, t$8 = (H$3) => {
	var A$3 = new Uint8Array(4);
	return A$3[0] = H$3, A$3[1] = H$3 >> 8, A$3[2] = H$3 >> 16, A$3[3] = H$3 >> 24, A$3;
}, O$1 = (H$3) => {
	var A$3 = new Uint8Array(2);
	return A$3[0] = H$3, A$3[1] = H$3 >> 8, A$3;
}, I = null, R$1 = (H$3) => {
	let A$3 = new Uint8Array(44 + H$3.length), E$4 = 0, e$59 = (H$4) => {
		A$3.set(H$4, E$4), E$4 += H$4.length;
	};
	return e$59(r$7("RIFF")), e$59(t$8(H$3.length + 12 + 16 + 8 - 8)), e$59(r$7("WAVE")), e$59(r$7("fmt ")), e$59(t$8(16)), e$59(O$1(1)), e$59(O$1(1)), e$59(t$8(22050)), e$59(t$8(22050)), e$59(O$1(1)), e$59(O$1(8)), e$59(r$7("data")), e$59(t$8(H$3.length)), e$59(H$3), A$3;
}, l$6 = {
	" ": 0,
	"!": 2,
	"\"": 2,
	"#": 2,
	$: 2,
	"%": 2,
	"&": 2,
	"'": 130,
	"(": 0,
	")": 0,
	"*": 2,
	"+": 2,
	",": 2,
	"-": 2,
	".": 2,
	"/": 2,
	0: 3,
	1: 3,
	2: 3,
	3: 3,
	4: 3,
	5: 3,
	6: 3,
	7: 3,
	8: 3,
	9: 3,
	":": 2,
	";": 2,
	"<": 2,
	"=": 2,
	">": 2,
	"?": 2,
	"@": 2,
	A: 192,
	B: 168,
	C: 176,
	D: 172,
	E: 192,
	F: 160,
	G: 184,
	H: 160,
	I: 192,
	J: 188,
	K: 160,
	L: 172,
	M: 168,
	N: 172,
	O: 192,
	P: 160,
	Q: 160,
	R: 172,
	S: 180,
	T: 164,
	U: 192,
	V: 168,
	W: 168,
	X: 176,
	Y: 192,
	Z: 188,
	"[": 0,
	"\\": 0,
	"]": 0,
	"^": 2,
	_: 0,
	"`": 32
}, U$1 = 128, n$2 = (H$3, A$3) => 0 != (l$6[H$3] & A$3), N$1 = (H$3, A$3, E$4) => n$2(H$3[A$3], E$4), W$1 = (H$3, A$3) => -1 !== A$3.indexOf(H$3), E$1 = (H$3) => {
	let A$3 = H$3.split("="), e$59 = A$3.pop(), E$4 = A$3.join("=").split("("), r$11 = E$4.pop().split(")"), t$12 = E$4[0], O$3 = r$11[0], R$2 = r$11[1], I$2 = [
		"T",
		"C",
		"S"
	], Y$1 = [
		"E",
		"I",
		"Y"
	], l$10 = (H$4, A$4, E$5) => {
		if (H$4.startsWith(O$3, A$4) && ((A$5, E$6) => {
			for (let H$5 = t$12.length - 1; -1 < H$5; H$5--) {
				var e$60 = t$12[H$5];
				if (n$2(e$60, U$1)) {
					if (A$5[--E$6] !== e$60) return !1;
				} else if (!{
					" ": () => !N$1(A$5, --E$6, U$1),
					"#": () => N$1(A$5, --E$6, 64),
					".": () => N$1(A$5, --E$6, 8),
					"&": () => N$1(A$5, --E$6, 16) || W$1(A$5.substr(--E$6, 2), ["CH", "SH"]),
					"@": () => {
						var H$6;
						return !!N$1(A$5, --E$6, 4) || "H" === (H$6 = A$5[E$6]) && !!W$1(H$6, I$2);
					},
					"^": () => N$1(A$5, --E$6, 32),
					"+": () => W$1(A$5[--E$6], Y$1),
					":": () => {
						for (; 0 <= E$6 && N$1(A$5, E$6 - 1, 32);) E$6--;
						return !0;
					}
				}[e$60]()) return !1;
			}
			return !0;
		})(H$4, A$4) && ((A$5, E$6) => {
			for (let H$5 = 0; H$5 < R$2.length; H$5++) {
				var e$60 = R$2[H$5];
				if (n$2(e$60, U$1)) {
					if (A$5[++E$6] !== e$60) return !1;
				} else if (!{
					" ": () => !N$1(A$5, ++E$6, U$1),
					"#": () => N$1(A$5, ++E$6, 64),
					".": () => N$1(A$5, ++E$6, 8),
					"&": () => N$1(A$5, ++E$6, 16) || W$1(A$5.substr(++E$6 - 2, 2), ["HC", "HS"]),
					"@": () => {
						var H$6;
						return !!N$1(A$5, ++E$6, 4) || "H" === (H$6 = A$5[E$6]) && !!W$1(H$6, I$2);
					},
					"^": () => N$1(A$5, ++E$6, 32),
					"+": () => W$1(A$5[++E$6], Y$1),
					":": () => {
						for (; N$1(A$5, E$6 + 1, 32);) E$6++;
						return !0;
					},
					"%": () => {
						if ("E" !== A$5[E$6 + 1]) return "ING" === A$5.substr(E$6 + 1, 3) && (E$6 += 3, !0);
						if (N$1(A$5, E$6 + 2, U$1)) {
							if (!W$1(A$5[E$6 + 2], [
								"R",
								"S",
								"D"
							])) return "L" !== A$5[E$6 + 2] ? "FUL" === A$5.substr(E$6 + 2, 3) && (E$6 += 4, !0) : "Y" === A$5[E$6 + 3] && (E$6 += 3, !0);
							E$6 += 2;
						} else E$6++;
						return !0;
					}
				}[e$60]()) return !1;
			}
			return !0;
		})(H$4, A$4 + (O$3.length - 1))) return E$5(e$59, O$3.length), !0;
	};
	return l$10.c = O$3[0], l$10;
}, S = {}, T$2 = (" (A.)=EH4Y. |(A) =AH| (ARE) =AAR| (AR)O=AXR|(AR)#=EH4R| ^(AS)#=EY4S|(A)WA=AX|(AW)=AO5| :(ANY)=EH4NIY|(A)^+#=EY5|#:(ALLY)=ULIY| (AL)#=UL|(AGAIN)=AXGEH4N|#:(AG)E=IHJ|(A)^%=EY|(A)^+:#=AE| :(A)^+ =EY4| (ARR)=AXR|(ARR)=AE4R| ^(AR) =AA5R|(AR)=AA5R|(AIR)=EH4R|(AI)=EY4|(AY)=EY5|(AU)=AO4|#:(AL) =UL|#:(ALS) =ULZ|(ALK)=AO4K|(AL)^=AOL| :(ABLE)=EY4BUL|(ABLE)=AXBUL|(A)VO=EY4|(ANG)+=EY4NJ|(ATARI)=AHTAA4RIY|(A)TOM=AE|(A)TTI=AE| (AT) =AET| (A)T=AH|(A)=AE| (B) =BIY4| (BE)^#=BIH|(BEING)=BIY4IHNX| (BOTH) =BOW4TH| (BUS)#=BIH4Z|(BREAK)=BREY5K|(BUIL)=BIH4L|(B)=B| (C) =SIY4| (CH)^=K|^E(CH)=K|(CHA)R#=KEH5|(CH)=CH| S(CI)#=SAY4|(CI)A=SH|(CI)O=SH|(CI)EN=SH|(CITY)=SIHTIY|(C)+=S|(CK)=K|(COMMODORE)=KAA4MAHDOHR|(COM)=KAHM|(CUIT)=KIHT|(CREA)=KRIYEY|(C)=K| (D) =DIY4| (DR.) =DAA4KTER|#:(DED) =DIHD|.E(D) =D|#:^E(D) =T| (DE)^#=DIH| (DO) =DUW| (DOES)=DAHZ|(DONE) =DAH5N|(DOING)=DUW4IHNX| (DOW)=DAW|#(DU)A=JUW|#(DU)^#=JAX|(D)=D| (E) =IYIY4|#:(E) =|':^(E) =| :(E) =IY|#(ED) =D|#:(E)D =|(EV)ER=EH4V|(E)^%=IY4|(ERI)#=IY4RIY|(ERI)=EH4RIH|#:(ER)#=ER|(ERROR)=EH4ROHR|(ERASE)=IHREY5S|(ER)#=EHR|(ER)=ER| (EVEN)=IYVEHN|#:(E)W=|@(EW)=UW|(EW)=YUW|(E)O=IY|#:&(ES) =IHZ|#:(E)S =|#:(ELY) =LIY|#:(EMENT)=MEHNT|(EFUL)=FUHL|(EE)=IY4|(EARN)=ER5N| (EAR)^=ER5|(EAD)=EHD|#:(EA) =IYAX|(EA)SU=EH5|(EA)=IY5|(EIGH)=EY4|(EI)=IY4| (EYE)=AY4|(EY)=IY|(EU)=YUW5|(EQUAL)=IY4KWUL|(E)=EH| (F) =EH4F|(FUL)=FUHL|(FRIEND)=FREH5ND|(FATHER)=FAA4DHER|(F)F=|(F)=F| (G) =JIY4|(GIV)=GIH5V| (G)I^=G|(GE)T=GEH5|SU(GGES)=GJEH4S|(GG)=G| B#(G)=G|(G)+=J|(GREAT)=GREY4T|(GON)E=GAO5N|#(GH)=| (GN)=N|(G)=G| (H) =EY4CH| (HAV)=/HAE6V| (HERE)=/HIYR| (HOUR)=AW5ER|(HOW)=/HAW|(H)#=/H|(H)=| (IN)=IHN| (I) =AY4|(I) =AY|(IN)D=AY5N|SEM(I)=IY| ANT(I)=AY|(IER)=IYER|#:R(IED) =IYD|(IED) =AY5D|(IEN)=IYEHN|(IE)T=AY4EH|(I')=AY5| :(I)^%=AY5| :(IE) =AY4|(I)%=IY|(IE)=IY4| (IDEA)=AYDIY5AH|(I)^+:#=IH|(IR)#=AYR|(IZ)%=AYZ|(IS)%=AYZ|I^(I)^#=IH|+^(I)^+=AY|#:^(I)^+=IH|(I)^+=AY|(IR)=ER|(IGH)=AY4|(ILD)=AY5LD| (IGN)=IHGN|(IGN) =AY4N|(IGN)^=AY4N|(IGN)%=AY4N|(ICRO)=AY4KROH|(IQUE)=IY4K|(I)=IH| (J) =JEY4|(J)=J| (K) =KEY4| (K)N=|(K)=K| (L) =EH4L|(LO)C#=LOW|L(L)=|#:^(L)%=UL|(LEAD)=LIYD| (LAUGH)=LAE4F|(L)=L| (M) =EH4M| (MR.) =MIH4STER| (MS.)=MIH5Z| (MRS.) =MIH4SIXZ|(MOV)=MUW4V|(MACHIN)=MAHSHIY5N|M(M)=|(M)=M| (N) =EH4N|E(NG)+=NJ|(NG)R=NXG|(NG)#=NXG|(NGL)%=NXGUL|(NG)=NX|(NK)=NXK| (NOW) =NAW4|N(N)=|(NON)E=NAH4N|(N)=N| (O) =OH4W|(OF) =AHV| (OH) =OW5|(OROUGH)=ER4OW|#:(OR) =ER|#:(ORS) =ERZ|(OR)=AOR| (ONE)=WAHN|#(ONE) =WAHN|(OW)=OW| (OVER)=OW5VER|PR(O)V=UW4|(OV)=AH4V|(O)^%=OW5|(O)^EN=OW|(O)^I#=OW5|(OL)D=OW4L|(OUGHT)=AO5T|(OUGH)=AH5F| (OU)=AW|H(OU)S#=AW4|(OUS)=AXS|(OUR)=OHR|(OULD)=UH5D|(OU)^L=AH5|(OUP)=UW5P|(OU)=AW|(OY)=OY|(OING)=OW4IHNX|(OI)=OY5|(OOR)=OH5R|(OOK)=UH5K|F(OOD)=UW5D|L(OOD)=AH5D|M(OOD)=UW5D|(OOD)=UH5D|F(OOT)=UH5T|(OO)=UW5|(O')=OH|(O)E=OW|(O) =OW|(OA)=OW4| (ONLY)=OW4NLIY| (ONCE)=WAH4NS|(ON'T)=OW4NT|C(O)N=AA|(O)NG=AO| :^(O)N=AH|I(ON)=UN|#:(ON)=UN|#^(ON)=UN|(O)ST=OW|(OF)^=AO4F|(OTHER)=AH5DHER|R(O)B=RAA|^R(O):#=OW5|(OSS) =AO5S|#:^(OM)=AHM|(O)=AA| (P) =PIY4|(PH)=F|(PEOPL)=PIY5PUL|(POW)=PAW4|(PUT) =PUHT|(P)P=|(P)S=|(P)N=|(PROF.)=PROHFEH4SER|(P)=P| (Q) =KYUW4|(QUAR)=KWOH5R|(QU)=KW|(Q)=K| (R) =AA5R| (RE)^#=RIY|(R)R=|(R)=R| (S) =EH4S|(SH)=SH|#(SION)=ZHUN|(SOME)=SAHM|#(SUR)#=ZHER|(SUR)#=SHER|#(SU)#=ZHUW|#(SSU)#=SHUW|#(SED)=ZD|#(S)#=Z|(SAID)=SEHD|^(SION)=SHUN|(S)S=|.(S) =Z|#:.E(S) =Z|#:^#(S) =S|U(S) =S| :#(S) =Z|##(S) =Z| (SCH)=SK|(S)C+=|#(SM)=ZUM|#(SN)'=ZUM|(STLE)=SUL|(S)=S| (T) =TIY4| (THE) #=DHIY| (THE) =DHAX|(TO) =TUX| (THAT)=DHAET| (THIS) =DHIHS| (THEY)=DHEY| (THERE)=DHEHR|(THER)=DHER|(THEIR)=DHEHR| (THAN) =DHAEN| (THEM) =DHAEN|(THESE) =DHIYZ| (THEN)=DHEHN|(THROUGH)=THRUW4|(THOSE)=DHOHZ|(THOUGH) =DHOW|(TODAY)=TUXDEY|(TOMO)RROW=TUMAA5|(TO)TAL=TOW5| (THUS)=DHAH4S|(TH)=TH|#:(TED)=TIXD|S(TI)#N=CH|(TI)O=SH|(TI)A=SH|(TIEN)=SHUN|(TUR)#=CHER|(TU)A=CHUW| (TWO)=TUW|&(T)EN =|(T)=T| (U) =YUW4| (UN)I=YUWN| (UN)=AHN| (UPON)=AXPAON|@(UR)#=UH4R|(UR)#=YUH4R|(UR)=ER|(U)^ =AH|(U)^^=AH5|(UY)=AY5| G(U)#=|G(U)%=|G(U)#=W|#N(U)=YUW|@(U)=UW|(U)=YUW| (V) =VIY4|(VIEW)=VYUW5|(V)=V| (W) =DAH4BULYUW| (WERE)=WER|(WA)SH=WAA|(WA)ST=WEY|(WA)S=WAH|(WA)T=WAA|(WHERE)=WHEHR|(WHAT)=WHAHT|(WHOL)=/HOWL|(WHO)=/HUW|(WH)=WH|(WAR)#=WEHR|(WAR)=WAOR|(WOR)^=WER|(WR)=R|(WOM)A=WUHM|(WOM)E=WIHM|(WEA)R=WEH|(WANT)=WAA5NT|ANS(WER)=ER|(W)=W| (X) =EH4KR| (X)=Z|(X)=KS| (Y) =WAY4|(YOUNG)=YAHNX| (YOUR)=YOHR| (YOU)=YUW| (YES)=YEHS| (Y)=Y|F(Y)=AY|PS(YCH)=AYK|#:^(Y)=IY|#:^(Y)I=IY| :(Y) =AY| :(Y)#=AY| :(Y)^+:#=IH| :(Y)^#=AY|(Y)=IH| (Z) =ZIY4|(Z)=Z".split("|").map((H$3) => {
	var A$3 = (H$3 = E$1(H$3)).c;
	S[A$3] = S[A$3] || [], S[A$3].push(H$3);
}), "(A)=|(!)=.|(\") =-AH5NKWOWT-|(\")=KWOW4T-|(#)= NAH4MBER|($)= DAA4LER|(%)= PERSEH4NT|(&)= AEND|(')=|(*)= AE4STERIHSK|(+)= PLAH4S|(,)=,| (-) =-|(-)=|(.)= POYNT|(/)= SLAE4SH|(0)= ZIY4ROW| (1ST)=FER4ST| (10TH)=TEH4NTH|(1)= WAH4N| (2ND)=SEH4KUND|(2)= TUW4| (3RD)=THER4D|(3)= THRIY4|(4)= FOH4R| (5TH)=FIH4FTH|(5)= FAY4V| (64) =SIH4KSTIY FOHR|(6)= SIH4KS|(7)= SEH4VUN| (8TH)=EY4TH|(8)= EY4T|(9)= NAY4N|(:)=.|(;)=.|(<)= LEH4S DHAEN|(=)= IY4KWULZ|(>)= GREY4TER DHAEN|(?)=?|(@)= AE6T|(^)= KAE4RIXT".split("|").map(E$1)), f$1 = "*12345678".split(""), e$55 = " *.*?*,*-*IYIHEHAEAAAHAOUHAXIXERUXOHRXLXWXYXWHR*L*W*Y*M*N*NXDXQ*S*SHF*TH/H/XZ*ZHV*DHCH**J*******EYAYOYAWOWUWB*****D*****G*****GX****P*****T*****K*****KX****ULUMUN".match(/.{1,2}/g), D$1 = [
	32768,
	49408,
	49408,
	49408,
	49408,
	164,
	164,
	164,
	164,
	164,
	164,
	132,
	132,
	164,
	164,
	132,
	132,
	132,
	132,
	132,
	132,
	132,
	68,
	4164,
	4164,
	4164,
	4164,
	2124,
	3148,
	2124,
	1096,
	16460,
	9280,
	8256,
	8256,
	9280,
	64,
	64,
	9284,
	8260,
	8260,
	9284,
	8264,
	8256,
	76,
	8260,
	0,
	0,
	180,
	180,
	180,
	148,
	148,
	148,
	78,
	78,
	78,
	1102,
	1102,
	1102,
	78,
	78,
	78,
	78,
	78,
	78,
	75,
	75,
	75,
	1099,
	1099,
	1099,
	75,
	75,
	75,
	75,
	75,
	75,
	128,
	193,
	193
], i$2 = [
	0,
	4626,
	4626,
	4626,
	2056,
	2824,
	2312,
	2824,
	3592,
	3851,
	2822,
	4108,
	3082,
	1541,
	1541,
	3595,
	3082,
	3594,
	3082,
	2825,
	2056,
	2055,
	2825,
	2567,
	2310,
	2056,
	2054,
	2055,
	2055,
	2055,
	770,
	1285,
	514,
	514,
	514,
	514,
	514,
	514,
	1542,
	1542,
	2055,
	1542,
	1542,
	514,
	2312,
	1027,
	513,
	286,
	3597,
	3852,
	3852,
	3852,
	3598,
	3593,
	2054,
	513,
	514,
	1797,
	513,
	257,
	1798,
	513,
	514,
	1798,
	513,
	514,
	2056,
	514,
	514,
	1540,
	514,
	514,
	1798,
	513,
	1028,
	1798,
	257,
	1028,
	1479,
	1535
], g$1 = (A$3, E$4) => {
	var H$3 = e$55.findIndex((H$4) => H$4 === A$3 + E$4 && "*" !== H$4[1]);
	return -1 !== H$3 && H$3;
}, B$1 = (A$3) => {
	var H$3 = e$55.findIndex((H$4) => H$4 === A$3 + "*");
	return -1 !== H$3 && H$3;
}, p$1 = (r$11, t$12, O$3) => {
	for (let e$59 = 0; e$59 < r$11.length; e$59++) {
		let H$3 = r$11[e$59], A$3 = r$11[e$59 + 1] || "", E$4;
		if (!1 !== (E$4 = g$1(H$3, A$3))) e$59++, t$12(E$4);
		else if (!1 !== (E$4 = B$1(H$3))) t$12(E$4);
		else {
			for (E$4 = f$1.length; H$3 !== f$1[E$4] && 0 < E$4;) --E$4;
			if (0 === E$4) throw Error();
			O$3(E$4);
		}
	}
}, o$31 = (H$3, A$3) => Y(D$1[H$3], A$3), V$1 = 23, b$2 = 57, w = 69, m$1 = 1, J$2 = 2, y$1 = 8192, k$1 = 4096, Q$2 = 2048, x$1 = 1024, j$1 = 256, a$32 = 128, u$1 = 64, L$2 = 32, $ = 16, _$2 = 8, s = 4, G$1 = 2, h = 1, q$2 = (E$4, e$59, r$11, t$12) => {
	let H$3 = (H$4, A$4) => {
		switch (H$4) {
			case 53:
				o$31(r$11(A$4 - 1), x$1) && e$59(A$4, 16);
				break;
			case 42:
				E$4(A$4 + 1, 43, t$12(A$4));
				break;
			case 44: E$4(A$4 + 1, 45, t$12(A$4));
		}
	}, A$3 = (H$4, A$4) => {
		e$59(H$4, 13), E$4(H$4 + 1, A$4, t$12(H$4));
	}, O$3 = -1, R$2;
	for (; null !== (R$2 = r$11(++O$3));) if (0 !== R$2) if (o$31(R$2, $)) E$4(O$3 + 1, o$31(R$2, L$2) ? 21 : 20, t$12(O$3)), H$3(R$2, O$3);
	else if (78 === R$2) A$3(O$3, 24);
	else if (79 === R$2) A$3(O$3, 27);
	else if (80 === R$2) A$3(O$3, 28);
	else if (o$31(R$2, a$32) && t$12(O$3)) 0 === r$11(O$3 + 1) && null !== (R$2 = r$11(O$3 + 2)) && o$31(R$2, a$32) && t$12(O$3 + 2) && E$4(O$3 + 2, 31, 0);
	else {
		var I$2, Y$1 = 0 === O$3 ? null : r$11(O$3 - 1);
		if (R$2 === V$1) switch (Y$1) {
			case w:
				e$59(O$3 - 1, 42);
				break;
			case b$2:
				e$59(O$3 - 1, 44);
				break;
			default: o$31(Y$1, a$32) && e$59(O$3, 18);
		}
		else 24 === R$2 && o$31(Y$1, a$32) ? e$59(O$3, 19) : 60 === Y$1 && 32 === R$2 ? e$59(O$3, 38) : 60 === R$2 ? (I$2 = r$11(O$3 + 1), o$31(I$2, L$2) || null === I$2 || e$59(O$3, 63)) : (72 === R$2 && (I$2 = r$11(O$3 + 1), o$31(I$2, L$2) && null !== I$2 || (e$59(O$3, 75), R$2 = 75)), o$31(R$2, h) && 32 === Y$1 ? e$59(O$3, R$2 - 12) : o$31(R$2, h) || H$3(R$2, O$3), 69 !== R$2 && 57 !== R$2 || 0 < O$3 && o$31(r$11(O$3 - 1), a$32) && (0 === (R$2 = r$11(O$3 + 1)) && (R$2 = r$11(O$3 + 2)), o$31(R$2, a$32)) && !t$12(O$3 + 1) && e$59(O$3, 30));
	}
}, z = (r$11, t$12, O$3) => {
	for (let H$3 = 0; null !== r$11(H$3); H$3++) if (o$31(r$11(H$3), j$1)) {
		for (var A$3, E$4 = H$3; 1 < --H$3 && !o$31(r$11(H$3), a$32););
		if (0 === H$3) break;
		for (; H$3 < E$4; H$3++) o$31(r$11(H$3), y$1) && !o$31(r$11(H$3), s) || (A$3 = O$3(H$3), t$12(H$3, (A$3 >> 1) + A$3 + 1));
	}
	let R$2 = -1, I$2;
	for (; null !== (I$2 = r$11(++R$2));) {
		let H$3 = R$2, A$4, E$5, e$59;
		if (o$31(I$2, a$32)) I$2 = r$11(++H$3), o$31(I$2, u$1) ? (A$4 = null === I$2 ? u$1 | h : D$1[I$2], Y(A$4, s) ? (e$59 = O$3(R$2), t$12(R$2, (e$59 >> 2) + e$59 + 1)) : Y(A$4, h) && (E$5 = O$3(R$2), t$12(R$2, E$5 - (E$5 >> 3)))) : 18 !== I$2 && 19 !== I$2 || !o$31(r$11(++H$3), u$1) || t$12(R$2, O$3(R$2) - 1);
		else if (o$31(I$2, Q$2)) null !== (I$2 = r$11(++H$3)) && o$31(I$2, G$1) && (t$12(H$3, 6), t$12(H$3 - 1, 5));
		else if (o$31(I$2, G$1)) {
			for (; 0 === (I$2 = r$11(++H$3)););
			null !== I$2 && o$31(I$2, G$1) && (t$12(H$3, 1 + (O$3(H$3) >> 1)), t$12(R$2, 1 + (O$3(R$2) >> 1)));
		} else 0 < H$3 && o$31(I$2, k$1) && o$31(r$11(H$3 - 1), G$1) && t$12(H$3, O$3(H$3) - 2);
	}
}, H1 = (H$3, A$3, E$4) => {
	let e$59 = 0;
	for (var r$11; null !== (r$11 = H$3(e$59));) o$31(r$11, u$1) && null !== (r$11 = H$3(e$59 + 1)) && o$31(r$11, a$32) && 0 !== (r$11 = A$3(e$59 + 1)) && r$11 < 128 && E$4(e$59, r$11 + 1), ++e$59;
}, A1 = (H$3, A$3, E$4) => {
	let e$59 = 0;
	for (var r$11; null !== (r$11 = H$3(e$59));) {
		var t$12 = A$3(e$59);
		E$4(e$59, 0 === t$12 || 127 < t$12 ? 255 & i$2[r$11] : i$2[r$11] >> 8), e$59++;
	}
}, E1 = (E$4, H$3, A$3) => {
	let e$59 = -1;
	for (var r$11; null !== (r$11 = E$4(++e$59));) if (o$31(r$11, G$1)) {
		if (o$31(r$11, h)) {
			let H$4, A$4 = e$59;
			for (; 0 === (H$4 = E$4(++A$4)););
			if (null !== H$4 && (o$31(H$4, _$2) || 36 === H$4 || 37 === H$4)) continue;
		}
		H$3(e$59 + 1, r$11 + 1, A$3(e$59), 255 & i$2[r$11 + 1]), H$3(e$59 + 2, r$11 + 2, A$3(e$59), 255 & i$2[r$11 + 2]), e$59 += 2;
	}
}, e1 = [
	24,
	26,
	23,
	23,
	23
], r1 = [
	0,
	224,
	230,
	236,
	243,
	249,
	0,
	6,
	12,
	6
], M = [
	0,
	31,
	31,
	31,
	31,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	5,
	5,
	2,
	10,
	2,
	8,
	5,
	5,
	11,
	10,
	9,
	8,
	8,
	160,
	8,
	8,
	23,
	31,
	18,
	18,
	18,
	18,
	30,
	30,
	20,
	20,
	20,
	20,
	23,
	23,
	26,
	26,
	29,
	29,
	2,
	2,
	2,
	2,
	2,
	2,
	26,
	29,
	27,
	26,
	29,
	27,
	26,
	29,
	27,
	26,
	29,
	27,
	23,
	29,
	23,
	23,
	29,
	23,
	23,
	29,
	23,
	23,
	29,
	23,
	23,
	23
], K$2 = [
	0,
	2,
	2,
	2,
	2,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	3,
	2,
	4,
	4,
	2,
	2,
	2,
	2,
	2,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	2,
	2,
	2,
	1,
	0,
	1,
	0,
	1,
	0,
	5,
	5,
	5,
	5,
	5,
	4,
	4,
	2,
	0,
	1,
	2,
	0,
	1,
	2,
	0,
	1,
	2,
	0,
	1,
	2,
	0,
	2,
	2,
	0,
	1,
	3,
	0,
	2,
	3,
	0,
	2,
	160,
	160
], C = [
	0,
	2,
	2,
	2,
	2,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	3,
	3,
	4,
	4,
	3,
	3,
	3,
	3,
	3,
	1,
	2,
	3,
	2,
	1,
	3,
	3,
	3,
	3,
	1,
	1,
	3,
	3,
	3,
	2,
	2,
	3,
	2,
	3,
	0,
	0,
	5,
	5,
	5,
	5,
	4,
	4,
	2,
	0,
	2,
	2,
	0,
	3,
	2,
	0,
	4,
	2,
	0,
	3,
	2,
	0,
	2,
	2,
	0,
	2,
	3,
	0,
	3,
	3,
	0,
	3,
	176,
	160
], t1 = [
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	241,
	226,
	211,
	187,
	124,
	149,
	1,
	2,
	3,
	3,
	0,
	114,
	0,
	2,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	27,
	0,
	0,
	25,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0
], O1 = [
	0,
	5980947,
	5980947,
	5980947,
	5980947,
	7230474,
	6113550,
	5980947,
	5783320,
	5842971,
	5712919,
	5775125,
	5383440,
	5844244,
	6113550,
	4075794,
	5383182,
	5774866,
	4076306,
	7218448,
	5250317,
	6112527,
	5904395,
	3944978,
	7216654,
	5904395,
	7230217,
	5320198,
	7943686,
	6641158,
	7943686,
	5980945,
	6506758,
	6967046,
	5315078,
	7946758,
	6113550,
	5383440,
	6107913,
	6767114,
	4990984,
	6106890,
	6639366,
	6639366,
	7946758,
	6639365,
	7958022,
	0,
	5916691,
	5777179,
	5775125,
	5778203,
	5774866,
	5382669,
	5315078,
	5315078,
	5315078,
	7946758,
	7946758,
	7946758,
	7368198,
	7237126,
	7237126,
	6181894,
	6181894,
	6181894,
	5315078,
	5315078,
	5315078,
	7946758,
	7946758,
	7946758,
	6647046,
	6641162,
	7367946,
	6181894,
	6181894,
	6181894,
	556844,
	98067
], v = [
	0,
	0,
	0,
	0,
	0,
	526861,
	461581,
	527630,
	527887,
	68879,
	68623,
	3087,
	68367,
	2316,
	461581,
	330508,
	68623,
	3087,
	396301,
	67597,
	2061,
	461838,
	2061,
	330252,
	67597,
	2061,
	526861,
	780,
	2313,
	198153,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	779,
	66827,
	779,
	1035,
	0,
	0,
	1,
	66827,
	920064,
	66050,
	593422,
	68879,
	3087,
	68879,
	3087,
	2061,
	2,
	260,
	0,
	2,
	260,
	0,
	1,
	260,
	0,
	1,
	260,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	461324,
	0,
	0,
	330240,
	0,
	1245199,
	1048591
], R1 = [
	56,
	132,
	107,
	25,
	198,
	99,
	24,
	134,
	115,
	152,
	198,
	177,
	28,
	202,
	49,
	140,
	199,
	49,
	136,
	194,
	48,
	152,
	70,
	49,
	24,
	198,
	53,
	12,
	202,
	49,
	12,
	198,
	33,
	16,
	36,
	105,
	18,
	194,
	49,
	20,
	196,
	113,
	8,
	74,
	34,
	73,
	171,
	106,
	168,
	172,
	73,
	81,
	50,
	213,
	82,
	136,
	147,
	108,
	148,
	34,
	21,
	84,
	210,
	37,
	150,
	212,
	80,
	165,
	70,
	33,
	8,
	133,
	107,
	24,
	196,
	99,
	16,
	206,
	107,
	24,
	140,
	113,
	25,
	140,
	99,
	53,
	12,
	198,
	51,
	153,
	204,
	108,
	181,
	78,
	162,
	153,
	70,
	33,
	40,
	130,
	149,
	46,
	227,
	48,
	156,
	197,
	48,
	156,
	162,
	177,
	156,
	103,
	49,
	136,
	102,
	89,
	44,
	83,
	24,
	132,
	103,
	80,
	202,
	227,
	10,
	172,
	171,
	48,
	172,
	98,
	48,
	140,
	99,
	16,
	148,
	98,
	177,
	140,
	130,
	40,
	150,
	51,
	152,
	214,
	181,
	76,
	98,
	41,
	165,
	74,
	181,
	156,
	198,
	49,
	20,
	214,
	56,
	156,
	75,
	180,
	134,
	101,
	24,
	174,
	103,
	28,
	166,
	99,
	25,
	150,
	35,
	25,
	132,
	19,
	8,
	166,
	82,
	172,
	202,
	34,
	137,
	110,
	171,
	25,
	140,
	98,
	52,
	196,
	98,
	25,
	134,
	99,
	24,
	196,
	35,
	88,
	214,
	163,
	80,
	66,
	84,
	74,
	173,
	74,
	37,
	17,
	107,
	100,
	137,
	74,
	99,
	57,
	138,
	35,
	49,
	42,
	234,
	162,
	169,
	68,
	197,
	18,
	205,
	66,
	52,
	140,
	98,
	24,
	140,
	99,
	17,
	72,
	102,
	49,
	157,
	68,
	51,
	29,
	70,
	49,
	156,
	198,
	177,
	12,
	205,
	50,
	136,
	196,
	115,
	24,
	134,
	115,
	8,
	214,
	99,
	88,
	7,
	129,
	224,
	240,
	60,
	7,
	135,
	144,
	60,
	124,
	15,
	199,
	192,
	192,
	240,
	124,
	30,
	7,
	128,
	128,
	0,
	28,
	120,
	112,
	241,
	199,
	31,
	192,
	12,
	254,
	28,
	31,
	31,
	14,
	10,
	122,
	192,
	113,
	242,
	131,
	143,
	3,
	15,
	15,
	12,
	0,
	121,
	248,
	97,
	224,
	67,
	15,
	131,
	231,
	24,
	249,
	193,
	19,
	218,
	233,
	99,
	143,
	15,
	131,
	131,
	135,
	195,
	31,
	60,
	112,
	240,
	225,
	225,
	227,
	135,
	184,
	113,
	14,
	32,
	227,
	141,
	72,
	120,
	28,
	147,
	135,
	48,
	225,
	193,
	193,
	228,
	120,
	33,
	131,
	131,
	195,
	135,
	6,
	57,
	229,
	195,
	135,
	7,
	14,
	28,
	28,
	112,
	244,
	113,
	156,
	96,
	54,
	50,
	195,
	30,
	60,
	243,
	143,
	14,
	60,
	112,
	227,
	199,
	143,
	15,
	15,
	14,
	60,
	120,
	240,
	227,
	135,
	6,
	240,
	227,
	7,
	193,
	153,
	135,
	15,
	24,
	120,
	112,
	112,
	252,
	243,
	16,
	177,
	140,
	140,
	49,
	124,
	112,
	225,
	134,
	60,
	100,
	108,
	176,
	225,
	227,
	15,
	35,
	143,
	15,
	30,
	62,
	56,
	60,
	56,
	123,
	143,
	7,
	14,
	60,
	244,
	23,
	30,
	60,
	120,
	242,
	158,
	114,
	73,
	227,
	37,
	54,
	56,
	88,
	57,
	226,
	222,
	60,
	120,
	120,
	225,
	199,
	97,
	225,
	225,
	176,
	240,
	240,
	195,
	199,
	14,
	56,
	192,
	240,
	206,
	115,
	115,
	24,
	52,
	176,
	225,
	199,
	142,
	28,
	60,
	248,
	56,
	240,
	225,
	193,
	139,
	134,
	143,
	28,
	120,
	112,
	240,
	120,
	172,
	177,
	143,
	57,
	49,
	219,
	56,
	97,
	195,
	14,
	14,
	56,
	120,
	115,
	23,
	30,
	57,
	30,
	56,
	100,
	225,
	241,
	193,
	78,
	15,
	64,
	162,
	2,
	197,
	143,
	129,
	161,
	252,
	18,
	8,
	100,
	224,
	60,
	34,
	224,
	69,
	7,
	142,
	12,
	50,
	144,
	240,
	31,
	32,
	73,
	224,
	248,
	12,
	96,
	240,
	23,
	26,
	65,
	170,
	164,
	208,
	141,
	18,
	130,
	30,
	30,
	3,
	248,
	62,
	3,
	12,
	115,
	128,
	112,
	68,
	38,
	3,
	36,
	225,
	62,
	4,
	78,
	4,
	28,
	193,
	9,
	204,
	158,
	144,
	33,
	7,
	144,
	67,
	100,
	192,
	15,
	198,
	144,
	156,
	193,
	91,
	3,
	226,
	29,
	129,
	224,
	94,
	29,
	3,
	132,
	184,
	44,
	15,
	128,
	177,
	131,
	224,
	48,
	65,
	30,
	67,
	137,
	131,
	80,
	252,
	36,
	46,
	19,
	131,
	241,
	124,
	76,
	44,
	201,
	13,
	131,
	176,
	181,
	130,
	228,
	232,
	6,
	156,
	7,
	160,
	153,
	29,
	7,
	62,
	130,
	143,
	112,
	48,
	116,
	64,
	202,
	16,
	228,
	232,
	15,
	146,
	20,
	63,
	6,
	248,
	132,
	136,
	67,
	129,
	10,
	52,
	57,
	65,
	198,
	227,
	28,
	71,
	3,
	176,
	184,
	19,
	10,
	194,
	100,
	248,
	24,
	249,
	96,
	179,
	192,
	101,
	32,
	96,
	166,
	140,
	195,
	129,
	32,
	48,
	38,
	30,
	28,
	56,
	211,
	1,
	176,
	38,
	64,
	244,
	11,
	195,
	66,
	31,
	133,
	50,
	38,
	96,
	64,
	201,
	203,
	1,
	236,
	17,
	40,
	64,
	250,
	4,
	52,
	224,
	112,
	76,
	140,
	29,
	7,
	105,
	3,
	22,
	200,
	4,
	35,
	232,
	198,
	154,
	11,
	26,
	3,
	224,
	118,
	6,
	5,
	207,
	30,
	188,
	88,
	49,
	113,
	102,
	0,
	248,
	63,
	4,
	252,
	12,
	116,
	39,
	138,
	128,
	113,
	194,
	58,
	38,
	6,
	192,
	31,
	5,
	15,
	152,
	64,
	174,
	1,
	127,
	192,
	7,
	255,
	0,
	14,
	254,
	0,
	3,
	223,
	128,
	3,
	239,
	128,
	27,
	241,
	194,
	0,
	231,
	224,
	24,
	252,
	224,
	33,
	252,
	128,
	60,
	252,
	64,
	14,
	126,
	0,
	63,
	62,
	0,
	15,
	254,
	0,
	31,
	255,
	0,
	62,
	240,
	7,
	252,
	0,
	126,
	16,
	63,
	255,
	0,
	63,
	56,
	14,
	124,
	1,
	135,
	12,
	252,
	199,
	0,
	62,
	4,
	15,
	62,
	31,
	15,
	15,
	31,
	15,
	2,
	131,
	135,
	207,
	3,
	135,
	15,
	63,
	192,
	7,
	158,
	96,
	63,
	192,
	3,
	254,
	0,
	63,
	224,
	119,
	225,
	192,
	254,
	224,
	195,
	224,
	1,
	223,
	248,
	3,
	7,
	0,
	126,
	112,
	0,
	124,
	56,
	24,
	254,
	12,
	30,
	120,
	28,
	124,
	62,
	14,
	31,
	30,
	30,
	62,
	0,
	127,
	131,
	7,
	219,
	135,
	131,
	7,
	199,
	7,
	16,
	113,
	255,
	0,
	63,
	226,
	1,
	224,
	193,
	195,
	225,
	0,
	127,
	192,
	5,
	240,
	32,
	248,
	240,
	112,
	254,
	120,
	121,
	248,
	2,
	63,
	12,
	143,
	3,
	15,
	159,
	224,
	193,
	199,
	135,
	3,
	195,
	195,
	176,
	225,
	225,
	193,
	227,
	224,
	113,
	240,
	0,
	252,
	112,
	124,
	12,
	62,
	56,
	14,
	28,
	112,
	195,
	199,
	3,
	129,
	193,
	199,
	231,
	0,
	15,
	199,
	135,
	25,
	9,
	239,
	196,
	51,
	224,
	193,
	252,
	248,
	112,
	240,
	120,
	248,
	240,
	97,
	199,
	0,
	31,
	248,
	1,
	124,
	248,
	240,
	120,
	112,
	60,
	124,
	206,
	14,
	33,
	131,
	207,
	8,
	7,
	143,
	8,
	193,
	135,
	143,
	128,
	199,
	227,
	0,
	7,
	248,
	224,
	239,
	0,
	57,
	247,
	128,
	14,
	248,
	225,
	227,
	248,
	33,
	159,
	192,
	255,
	3,
	248,
	7,
	192,
	31,
	248,
	196,
	4,
	252,
	196,
	193,
	188,
	135,
	240,
	15,
	192,
	127,
	5,
	224,
	37,
	236,
	192,
	62,
	132,
	71,
	240,
	142,
	3,
	248,
	3,
	251,
	192,
	25,
	248,
	7,
	156,
	12,
	23,
	248,
	7,
	224,
	31,
	161,
	252,
	15,
	252,
	1,
	240,
	63,
	0,
	254,
	3,
	240,
	31,
	0,
	253,
	0,
	255,
	136,
	13,
	249,
	1,
	255,
	0,
	112,
	7,
	192,
	62,
	66,
	243,
	13,
	196,
	127,
	128,
	252,
	7,
	240,
	94,
	192,
	63,
	0,
	120,
	63,
	129,
	255,
	1,
	248,
	1,
	195,
	232,
	12,
	228,
	100,
	143,
	228,
	15,
	240,
	7,
	240,
	194,
	31,
	0,
	127,
	192,
	111,
	128,
	126,
	3,
	248,
	7,
	240,
	63,
	192,
	120,
	15,
	130,
	7,
	254,
	34,
	119,
	112,
	2,
	118,
	3,
	254,
	0,
	254,
	103,
	0,
	124,
	199,
	241,
	142,
	198,
	59,
	224,
	63,
	132,
	243,
	25,
	216,
	3,
	153,
	252,
	9,
	184,
	15,
	248,
	0,
	157,
	36,
	97,
	249,
	13,
	0,
	253,
	3,
	240,
	31,
	144,
	63,
	1,
	248,
	31,
	208,
	15,
	248,
	55,
	1,
	248,
	7,
	240,
	15,
	192,
	63,
	0,
	254,
	3,
	248,
	15,
	192,
	63,
	0,
	250,
	3,
	240,
	15,
	128,
	255,
	1,
	184,
	7,
	240,
	1,
	252,
	1,
	188,
	128,
	19,
	30,
	0,
	127,
	225,
	64,
	127,
	160,
	127,
	176,
	0,
	63,
	192,
	31,
	192,
	56,
	15,
	240,
	31,
	128,
	255,
	1,
	252,
	3,
	241,
	126,
	1,
	254,
	1,
	240,
	255,
	0,
	127,
	192,
	29,
	7,
	240,
	15,
	192,
	126,
	6,
	224,
	7,
	224,
	15,
	248,
	6,
	193,
	254,
	1,
	252,
	3,
	224,
	15,
	0,
	252
], I1 = (A$3, E$4) => {
	let e$59 = (H$3, A$4) => (H$3 * A$4 >> 8 & 255) << 1, r$11 = [
		[],
		[],
		[]
	];
	O1.map((H$3, A$4) => {
		r$11[0][A$4] = 255 & H$3, r$11[1][A$4] = H$3 >> 8 & 255, r$11[2][A$4] = H$3 >> 16 & 255;
	});
	for (let H$3 = 5; H$3 < 30; H$3++) r$11[0][H$3] = e$59(A$3, r$11[0][H$3]), r$11[1][H$3] = e$59(E$4, r$11[1][H$3]);
	for (let H$3 = 48; H$3 < 54; H$3++) r$11[0][H$3] = e$59(A$3, r$11[0][H$3]), r$11[1][H$3] = e$59(E$4, r$11[1][H$3]);
	return r$11;
}, Y1 = (A$3, H$3, E$4, e$59) => {
	let Y$1 = [
		A$3,
		H$3[0],
		H$3[1],
		H$3[2],
		E$4[0],
		E$4[1],
		E$4[2]
	], l$10 = (H$4, A$4) => Y$1[H$4][A$4], r$11 = (A$4, E$5, e$60, H$4) => {
		let r$12 = H$4 < 0, t$13 = Math.abs(H$4) % A$4, O$4 = H$4 / A$4 | 0, R$3 = 0, I$3 = A$4;
		for (; 0 < --I$3;) {
			let H$5 = l$10(E$5, e$60) + O$4;
			(R$3 += t$13) >= A$4 && (R$3 -= A$4, r$12 ? H$5-- : H$5 && H$5++), Y$1[E$5][++e$60] = H$5, H$5 += O$4;
		}
	}, t$12, O$3, R$2 = 0;
	for (let H$4 = 0; H$4 < e$59.length - 1; H$4++) {
		var I$2 = e$59[H$4][0], U$2 = e$59[H$4 + 1][0], n$4 = M[U$2], N$3 = M[I$2], W$2 = (O$3 = N$3 === n$4 ? (t$12 = K$2[I$2], K$2[U$2]) : N$3 < n$4 ? (t$12 = C[U$2], K$2[U$2]) : (t$12 = K$2[I$2], C[I$2]), (R$2 += e$59[H$4][1]) + O$3), S$3 = R$2 - t$12, T$4 = t$12 + O$3;
		if (0 == (T$4 - 2 & 128)) {
			r$11((N$3 = e$59[H$4][1] >> 1) + (n$4 = e$59[H$4 + 1][1] >> 1), 0, S$3, A$3[R$2 + n$4] - A$3[R$2 - N$3]);
			for (let H$5 = 1; H$5 < 7; H$5++) {
				var f$5 = l$10(H$5, W$2) - l$10(H$5, S$3);
				r$11(T$4, H$5, S$3, f$5);
			}
		}
	}
	return R$2 + e$59[e$59.length - 1][1];
}, l1 = 255, U1 = 1, n1 = (E$4, e$59, r$11) => {
	let H$3 = (H$4, A$3, E$5) => {
		var e$60 = A$3;
		A$3 < 30 ? A$3 = 0 : A$3 -= 30;
		let r$12;
		for (; 127 === (r$12 = E$5[A$3]);) ++A$3;
		for (; A$3 !== e$60;) for (r$12 += H$4, E$5[A$3] = 255 & r$12; ++A$3 !== e$60 && 255 === E$5[A$3];);
	}, t$12 = [], O$3 = [
		[],
		[],
		[]
	], R$2 = [
		[],
		[],
		[]
	], I$2 = [], Y$1 = 0;
	for (let A$3 = 0; A$3 < e$59.length; A$3++) {
		var l$10 = e$59[A$3][0], U$2 = (l$10 === m$1 ? H$3(U1, Y$1, t$12) : l$10 === J$2 && H$3(l1, Y$1, t$12), r1[e$59[A$3][2]]);
		for (let H$4 = e$59[A$3][1]; 0 < H$4; H$4--) O$3[0][Y$1] = r$11[0][l$10], O$3[1][Y$1] = r$11[1][l$10], O$3[2][Y$1] = r$11[2][l$10], R$2[0][Y$1] = 255 & v[l$10], R$2[1][Y$1] = v[l$10] >> 8 & 255, R$2[2][Y$1] = v[l$10] >> 16 & 255, I$2[Y$1] = t1[l$10], t$12[Y$1] = E$4 + U$2 & 255, Y$1++;
	}
	return [
		t$12,
		O$3,
		R$2,
		I$2
	];
}, N1 = (H$3, A$3, E$4, e$59, r$11) => {
	var E$4 = I1(E$4, e$59), [t$12, O$3, R$2, e$59] = n1(A$3, H$3, E$4), A$3 = Y1(t$12, O$3, R$2, H$3);
	if (!r$11) for (let H$4 = 0; H$4 < t$12.length; H$4++) t$12[H$4] -= O$3[0][H$4] >> 1;
	var I$2 = [
		0,
		1,
		2,
		2,
		2,
		3,
		3,
		4,
		4,
		5,
		6,
		8,
		9,
		11,
		13,
		15
	];
	for (let H$4 = R$2[0].length - 1; 0 <= H$4; H$4--) R$2[0][H$4] = I$2[R$2[0][H$4]], R$2[1][H$4] = I$2[R$2[1][H$4]], R$2[2][H$4] = I$2[R$2[2][H$4]];
	return [
		A$3,
		O$3,
		t$12,
		R$2,
		e$59
	];
}, W1 = (H$3) => {
	let E$4 = new Uint8Array(H$3), e$59 = 0, r$11 = 0, t$12 = (H$4, A$3) => {
		A$3 = 16 * (15 & A$3), t$12.ary(H$4, [
			A$3,
			A$3,
			A$3,
			A$3,
			A$3
		]);
	};
	return t$12.ary = (H$4, A$3) => {
		if (((e$59 += [
			[
				162,
				167,
				167,
				127,
				128
			],
			[
				226,
				60,
				60,
				0,
				0
			],
			[
				225,
				60,
				59,
				0,
				0
			],
			[
				200,
				0,
				0,
				54,
				55
			],
			[
				199,
				0,
				0,
				54,
				54
			]
		][r$11][H$4]) / 50 | 0) > E$4.length) throw new Error();
		r$11 = H$4;
		for (let H$5 = 0; H$5 < 5; H$5++) E$4[(e$59 / 50 | 0) + H$5] = A$3[H$5];
	}, t$12.get = () => E$4.slice(0, e$59 / 50 | 0), t$12;
}, X$1 = (O$3, A$3, H$3, E$4) => {
	let e$59 = (7 & H$3) - 1, R$2 = 256 * e$59 & 65535, I$2 = 248 & H$3, r$11 = (H$4, A$4, E$5, e$60) => {
		let r$12 = 8, t$13 = R1[R$2 + I$2];
		for (; 0 != (128 & t$13) ? O$3(H$4, A$4) : O$3(E$5, e$60), t$13 <<= 1, --r$12;);
	};
	if (0 === I$2) {
		let H$4 = E$4 >> 4 ^ 255;
		for (I$2 = 255 & A$3; r$11(3, 26, 4, 6), I$2++, I$2 &= 255, 255 & ++H$4;);
		return I$2;
	}
	I$2 ^= 255;
	for (var t$12 = 255 & e1[e$59]; r$11(2, 5, 1, t$12), 255 & ++I$2;);
	return A$3;
}, c$4 = (H$3) => 127 * Math.sin(2 * Math.PI * (H$3 / 256)) | 0, S1 = (H$3, A$3, E$4, t$12, e$59, O$3, r$11) => {
	let R$2 = E$4, I$2 = 0, Y$1 = 0, l$10 = 0, U$2 = 0, n$4 = 0, N$3 = e$59[0], W$2 = .75 * N$3 | 0;
	for (; A$3;) {
		var S$3 = r$11[n$4];
		if (0 != (248 & S$3)) U$2 = X$1(H$3, U$2, S$3, e$59[255 & n$4]), n$4 += 2, A$3 -= 2, R$2 = E$4;
		else {
			{
				let A$4 = [], E$5 = 256 * I$2, e$60 = 256 * Y$1, r$12 = 256 * l$10;
				for (let H$4 = 0; H$4 < 5; H$4++) {
					var T$4 = c$4(255 & E$5 >> 8), f$5 = c$4(255 & e$60 >> 8), D$4 = (255 & r$12 >> 8) < 129 ? -112 : 112, T$4 = (T$4 * (15 & O$3[0][n$4]) + f$5 * (15 & O$3[1][n$4]) + D$4 * (15 & O$3[2][n$4])) / 32 + 128;
					A$4[H$4] = 0 | T$4, E$5 += 256 * t$12[0][n$4] / 4, e$60 += 256 * t$12[1][n$4] / 4, r$12 += 256 * t$12[2][n$4] / 4;
				}
				H$3.ary(0, A$4);
			}
			if (0 == --R$2) {
				if (n$4++, 0 == --A$3) return;
				R$2 = E$4;
			}
			if (0 != --N$3) {
				if (0 != --W$2 || 0 === S$3) {
					I$2 += t$12[0][n$4], Y$1 += t$12[1][n$4], l$10 += t$12[2][n$4];
					continue;
				}
				U$2 = X$1(H$3, U$2, S$3, e$59[255 & n$4]);
			}
		}
		N$3 = e$59[n$4], W$2 = .75 * N$3 | 0, I$2 = 0, Y$1 = 0, l$10 = 0;
	}
};
function d$1(H$3) {
	var A$3, E$4, e$59, r$11, t$12, O$3 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}, H$3 = ((H$4) => {
		if (!H$4) return !1;
		let A$4 = (H$5) => H$5 === I$2.length ? null : I$2[H$5], E$5 = (A$5, H$5, E$6, e$61) => {
			for (let H$6 = I$2.length - 1; H$6 >= A$5; H$6--) I$2[H$6 + 1] = I$2[H$6], R$2[H$6 + 1] = t$13(H$6), O$4[H$6 + 1] = r$12(H$6);
			I$2[A$5] = H$5, R$2[A$5] = 0 | e$61, O$4[A$5] = E$6;
		}, r$12 = (H$5) => 0 | O$4[H$5], t$13 = (H$5) => 0 | R$2[H$5], e$60 = (H$5, A$5) => {
			R$2[H$5] = A$5;
		}, O$4 = [], R$2 = [], I$2 = [], Y$1 = 0;
		return p$1(H$4, (H$5) => {
			O$4[Y$1] = 0, R$2[Y$1] = 0, I$2[Y$1++] = H$5;
		}, (H$5) => {
			O$4[Y$1 - 1] = H$5;
		}), q$2(E$5, (H$5, A$5) => {
			I$2[H$5] = A$5;
		}, A$4, r$12), H1(A$4, r$12, (H$5, A$5) => {
			O$4[H$5] = A$5;
		}), A1(A$4, r$12, e$60), z(A$4, e$60, t$13), E1(A$4, E$5, r$12), I$2.map((H$5, A$5) => H$5 ? [
			H$5,
			0 | R$2[A$5],
			0 | O$4[A$5]
		] : null).filter((H$5) => H$5);
	})(H$3);
	return !1 !== H$3 && (r$11 = void 0 === (r$11 = O$3.pitch) ? 64 : 255 & r$11, E$4 = void 0 === (E$4 = O$3.mouth) ? 128 : 255 & E$4, e$59 = void 0 === (e$59 = O$3.throat) ? 128 : 255 & e$59, A$3 = 255 & (O$3.speed || 72), O$3 = O$3.singmode || !1, r$11 = N1(H$3, r$11, E$4, e$59, O$3), E$4 = W1(176.4 * H$3.reduce((H$4, A$4) => H$4 + A$4[1], 0) * A$3 | 0), [e$59, O$3, H$3, r$11, t$12] = r$11, S1(E$4, e$59, A$3, O$3, H$3, r$11, t$12), E$4.get());
}
var F$1 = (H$3) => {
	let A$3 = " " + H$3.toUpperCase(), E$4 = 0, e$59 = "", r$11 = (H$4, A$4) => {
		E$4 += A$4, e$59 += H$4;
	}, t$12 = 0;
	for (; E$4 < A$3.length && t$12++ < 1e4;) {
		var O$3 = A$3[E$4];
		if ("." !== O$3 || N$1(A$3, E$4 + 1, 1)) if (n$2(O$3, 2)) T$2.some((H$4) => H$4(A$3, E$4, r$11));
		else if (0 !== l$6[O$3]) {
			if (!n$2(O$3, U$1)) return !1;
			S[O$3].some((H$4) => H$4(A$3, E$4, r$11));
		} else e$59 += " ", E$4++;
		else e$59 += ".", E$4++;
	}
	return e$59;
}, Z = d$1, P$1 = (H$3, A$3) => {
	if (!1 === (H$3 = d$1(H$3, A$3))) return !1;
	var E$4 = H$3, e$59 = new Float32Array(E$4.length);
	for (let H$4 = 0; H$4 < E$4.length; H$4++) e$59[H$4] = (E$4[H$4] - 128) / 256;
	return e$59;
};
function H$1(H$3) {
	let E$4 = H$3 || {}, e$59 = (H$4, A$3) => A$3 || E$4.phonetic ? H$4.toUpperCase() : F$1(H$4);
	this.buf8 = (H$4, A$3) => Z(e$59(H$4, A$3), E$4), this.buf32 = (H$4, A$3) => P$1(e$59(H$4, A$3), E$4), this.speak = (A$3, H$4) => {
		if (A$3 = this.buf32(A$3, H$4), I = null === I ? new AudioContext() : I) {
			var O$3 = I, R$2 = A$3;
			let t$12, H$5 = new Promise((H$6, A$4) => {
				let E$5 = O$3.createBufferSource(), e$60 = O$3.createBuffer(1, R$2.length, 22050), r$11 = e$60.getChannelData(0);
				for (let H$7 = 0; H$7 < R$2.length; H$7++) r$11[H$7] = R$2[H$7];
				E$5.buffer = e$60, E$5.connect(O$3.destination), E$5.onended = () => {
					H$6(!0);
				}, t$12 = (H$7) => {
					E$5.disconnect(), A$4(H$7);
				}, E$5.start(0);
			});
			return H$5.abort = t$12, H$5;
		}
		throw new Error();
	}, this.download = (H$4, A$3) => {
		var E$5, H$4 = this.buf8(H$4, A$3), A$3 = new Blob([R$1(H$4)], { type: "audio/vnd.wave" }), A$3 = (H$4 = window.URL || window.webkitURL).createObjectURL(A$3);
		(E$5 = document.createElement("a")).href = A$3, E$5.target = "_blank", E$5.download = "sam.wav", document.body.appendChild(E$5), E$5.click(), document.body.removeChild(E$5), H$4.revokeObjectURL(A$3);
	}, this.wav = (H$4, A$3) => R$1(this.buf8(H$4, A$3));
}
H$1.buf8 = Z, H$1.buf32 = P$1, H$1.convert = F$1;
function parseChordSuffix(suffix) {
	const tones = [];
	const omit = /* @__PURE__ */ new Set();
	let hasSus2 = false;
	let hasSus4 = false;
	let i$6 = 0;
	while (i$6 < suffix.length) {
		const extMatch = suffix.slice(i$6).match(/^([b#]?)(\d+)/);
		if (extMatch) {
			const acc = extMatch[1];
			const num = parseInt(extMatch[2], 10);
			i$6 += extMatch[0].length;
			let degree;
			let adjust = 0;
			if (num === 7) {
				degree = 6;
				adjust = acc === "b" ? -1 : acc === "#" ? 1 : 0;
			} else if (num === 9) {
				degree = 8;
				adjust = acc === "b" ? -1 : acc === "#" ? 1 : 0;
			} else if (num === 11) {
				degree = 10;
				adjust = acc === "b" ? -1 : acc === "#" ? 1 : 0;
			} else if (num === 13) {
				degree = 12;
				adjust = acc === "b" ? -1 : acc === "#" ? 1 : 0;
			} else if (num === 5) {
				degree = 4;
				adjust = acc === "b" ? -1 : acc === "#" ? 1 : 0;
			} else continue;
			tones.push({
				degree,
				semitoneAdjust: adjust
			});
			continue;
		}
		if (suffix.slice(i$6).startsWith("sus4")) {
			hasSus4 = true;
			i$6 += 4;
			continue;
		}
		if (suffix.slice(i$6).startsWith("sus2")) {
			hasSus2 = true;
			i$6 += 4;
			continue;
		}
		if (suffix.slice(i$6).startsWith("sus")) {
			hasSus4 = true;
			i$6 += 3;
			continue;
		}
		const noMatch = suffix.slice(i$6).match(/^no(\d+)/);
		if (noMatch) {
			const num = parseInt(noMatch[1], 10);
			i$6 += noMatch[0].length;
			if (num === 3) omit.add(2);
			else if (num === 5) omit.add(4);
			continue;
		}
		const addMatch = suffix.slice(i$6).match(/^add(\d+)/);
		if (addMatch) {
			const num = parseInt(addMatch[1], 10);
			i$6 += addMatch[0].length;
			if (num === 2) tones.push({
				degree: 1,
				semitoneAdjust: 0
			});
			else if (num === 4) tones.push({
				degree: 3,
				semitoneAdjust: 0
			});
			else if (num === 6) tones.push({
				degree: 5,
				semitoneAdjust: 0
			});
			continue;
		}
		if (suffix.slice(i$6).startsWith("o7")) {
			tones.push({
				degree: 0,
				semitoneAdjust: 0
			});
			tones.push({
				degree: 2,
				semitoneAdjust: -1
			});
			tones.push({
				degree: 4,
				semitoneAdjust: -1
			});
			tones.push({
				degree: 6,
				semitoneAdjust: -2
			});
			return tones;
		}
		i$6++;
	}
	const result = [];
	result.push({
		degree: 0,
		semitoneAdjust: 0
	});
	if (hasSus2) result.push({
		degree: 1,
		semitoneAdjust: 0
	});
	else if (hasSus4) result.push({
		degree: 3,
		semitoneAdjust: 0
	});
	else if (!omit.has(2)) result.push({
		degree: 2,
		semitoneAdjust: 0
	});
	if (!omit.has(4)) {
		const alteredFifth = tones.find((t$12) => t$12.degree === 4);
		if (alteredFifth) result.push(alteredFifth);
		else result.push({
			degree: 4,
			semitoneAdjust: 0
		});
	}
	for (const tone of tones) if (tone.degree >= 5 && !result.some((r$11) => r$11.degree === tone.degree)) result.push(tone);
	for (const tone of tones) if (tone.degree < 5 && tone.degree !== 0 && tone.degree !== 2 && tone.degree !== 4) {
		if (!result.some((r$11) => r$11.degree === tone.degree)) result.push(tone);
	}
	return result;
}
function romanToDegree(text) {
	const t$12 = text.toLowerCase();
	if (t$12 === "i") return 1;
	if (t$12 === "ii") return 2;
	if (t$12 === "iii") return 3;
	if (t$12 === "iv") return 4;
	if (t$12 === "v") return 5;
	if (t$12 === "vi") return 6;
	if (t$12 === "vii") return 7;
	return null;
}
var NOTE_OFFSETS = {
	c: 0,
	d: 2,
	e: 4,
	f: 5,
	g: 7,
	a: 9,
	b: 11
};
var NOTE_NAME_PATTERN = /^[a-gA-G][#b]?-?\d+$/;
function isNoteName(name) {
	return NOTE_NAME_PATTERN.test(name);
}
function noteNameToMidi(noteName) {
	const match = noteName.match(/^([a-gA-G])([#b]?)(-?\d+)$/);
	if (!match) throw new Error(`Invalid note name: ${noteName}`);
	const [, note, accidental, octave] = match;
	let midi = NOTE_OFFSETS[note.toLowerCase()] + (parseInt(octave, 10) + 1) * 12;
	if (accidental === "#") midi += 1;
	else if (accidental === "b") midi -= 1;
	return midi;
}
function midiToFrequency(midi) {
	return 440 * Math.pow(2, (midi - 69) / 12);
}
function compileFunctionBlock(state, block) {
	const stmts = block.body;
	for (let i$6 = 0; i$6 < stmts.length; i$6++) {
		const stmt = stmts[i$6];
		if (i$6 === stmts.length - 1) if (stmt.type === "expr") compileExpr(state, stmt.expr);
		else if (stmt.type === "block") {
			pushScope(state);
			compileFunctionBlock(state, stmt);
			popScope(state);
		} else {
			compileStmt(state, stmt);
			state.ops.push(AudioVmOp.PushScalar);
			state.ops.push(0);
		}
		else if (stmt.type === "expr") {
			compileExpr(state, stmt.expr);
			if (state.stack.length > 0) {
				state.ops.push(AudioVmOp.Pop);
				state.stack.pop();
			}
		} else compileStmt(state, stmt);
	}
	if (stmts.length === 0) {
		state.ops.push(AudioVmOp.PushScalar);
		state.ops.push(0);
	}
}
function compileFunction(state, expr, name) {
	const savedFunctionDepth = state.functionDepth;
	state.functionDepth = savedFunctionDepth + 1;
	const functionId = state.nextFunctionId++;
	const params = expr.params;
	const paramCount = params.length;
	const defaults = expr.defaults || [];
	const historyStartIndex = state.historySourceMap.length;
	const savedOps = state.ops;
	const savedStack = state.stack;
	const savedLocals = state.locals;
	const savedNextLocalIndex = state.nextLocalIndex;
	const savedInFunction = state.inFunction;
	const savedClosureVars = state.closureVars;
	const savedParamMap = state.paramNameToLocalIndex;
	if (savedFunctionDepth > 0) state.functionsByNameStack.push(/* @__PURE__ */ new Map());
	const closureVarNames = detectClosureVars(state, expr, state.locals);
	const closureVarInfos = [];
	for (const varName of closureVarNames) {
		if (varName === "$") {
			const outerPipe = state.pipeVars[state.pipeVars.length - 1];
			if (outerPipe) closureVarInfos.push(outerPipe.varInfo);
			continue;
		}
		const varInfo = lookupVariable(state, varName);
		if (varInfo) closureVarInfos.push(varInfo);
	}
	const savedCurrentFunctionId = state.currentFunctionId;
	const isOversampleCallback = state.captureGlobalsInClosures;
	state.currentFunctionId = functionId;
	const bodyOps = [];
	state.ops = bodyOps;
	state.stack = [];
	state.locals = [/* @__PURE__ */ new Map()];
	state.nextLocalIndex = 0;
	state.inFunction = true;
	state.closureVars = [];
	for (let i$6 = 0; i$6 < closureVarNames.length; i$6++) {
		const closureInfo = {
			scope: "closure",
			index: closureVarInfos[i$6].index,
			closureIndex: i$6
		};
		state.locals[0].set(closureVarNames[i$6], closureInfo);
	}
	const destructuredParams = new Array(paramCount);
	const paramNameToLocalIndex = /* @__PURE__ */ new Map();
	for (let i$6 = 0; i$6 < paramCount; i$6++) {
		const param = params[i$6];
		if (param.type === "param-destructure") {
			const tempVarInfo = {
				scope: "local",
				index: state.nextLocalIndex++
			};
			destructuredParams[i$6] = {
				names: param.names,
				tempVar: tempVarInfo
			};
		} else if (param.type === "param-named-destructure") {
			const tempVarInfo = {
				scope: "local",
				index: state.nextLocalIndex++
			};
			destructuredParams[i$6] = {
				names: param.names,
				tempVar: tempVarInfo
			};
			paramNameToLocalIndex.set(param.paramName, tempVarInfo.index);
		} else {
			const paramInfo = {
				scope: "local",
				index: state.nextLocalIndex++
			};
			state.locals[0].set(param.name, paramInfo);
			destructuredParams[i$6] = null;
			paramNameToLocalIndex.set(param.name, i$6);
		}
	}
	state.paramNameToLocalIndex = paramNameToLocalIndex;
	const defaultParamFunctionIds = /* @__PURE__ */ new Map();
	const defaultParamFunctionIdsByName = /* @__PURE__ */ new Map();
	let hasDefaultCalls = false;
	for (let i$6 = 0; i$6 < paramCount; i$6++) {
		const defaultExpr = defaults[i$6];
		if (defaultExpr) {
			if (defaultExpr.type === "call") hasDefaultCalls = true;
			const param = params[i$6];
			const destructInfo = destructuredParams[i$6];
			const paramName = param.type === "param" ? param.name : null;
			const paramInfo = destructInfo ? destructInfo.tempVar : {
				scope: "local",
				index: i$6
			};
			compileGetVariable(state, paramInfo);
			state.stack.push({ expr: defaultExpr });
			state.ops.push(AudioVmOp.IsUndefined);
			state.stack.pop();
			state.stack.push({ expr: defaultExpr });
			state.ops.push(AudioVmOp.JumpIfFalse);
			const jumpToSkipIndex = state.ops.length;
			state.ops.push(0);
			state.stack.pop();
			if (paramName) state.locals[0].delete(paramName);
			if (defaultExpr.type === "fn") {
				const innerId = compileFunction(state, defaultExpr, null);
				defaultParamFunctionIds.set(i$6, innerId);
				if (paramName) defaultParamFunctionIdsByName.set(paramName, innerId);
			} else compileExpr(state, defaultExpr);
			if (paramName) state.locals[0].set(paramName, paramInfo);
			compileSetVariable(state, paramInfo, defaultExpr);
			state.stack.pop();
			const skipTarget = state.ops.length;
			state.ops[jumpToSkipIndex] = skipTarget;
		}
	}
	if (defaultParamFunctionIdsByName.size > 0) state.functionIdToDefaultParamFunctions.set(functionId, defaultParamFunctionIdsByName);
	for (let i$6 = 0; i$6 < paramCount; i$6++) {
		const destructInfo = destructuredParams[i$6];
		if (destructInfo) {
			const { names, tempVar } = destructInfo;
			for (let j$4 = 0; j$4 < names.length; j$4++) {
				const localInfo = {
					scope: "local",
					index: state.nextLocalIndex++
				};
				state.locals[0].set(names[j$4], localInfo);
				compileGetVariable(state, tempVar);
				state.stack.push({ expr: params[i$6] });
				state.ops.push(AudioVmOp.PushScalar);
				state.ops.push(j$4);
				state.stack.push({ expr: params[i$6] });
				state.ops.push(AudioVmOp.ArrayGet, 0);
				state.stack.pop();
				state.stack.pop();
				state.stack.push({ expr: params[i$6] });
				compileSetVariable(state, localInfo, params[i$6]);
				state.stack.pop();
			}
		}
	}
	if (expr.body.type === "block") {
		compileFunctionBlock(state, expr.body);
		state.ops.push(AudioVmOp.Return);
	} else {
		compileExpr(state, expr.body);
		state.ops.push(AudioVmOp.Return);
	}
	const bytecodeLength = bodyOps.length;
	const localCount = state.nextLocalIndex;
	state.functionBytecodes.set(functionId, bodyOps);
	const paramNames = new Array(paramCount);
	const paramTypes = new Array(paramCount);
	let firstParamIn = 0;
	for (let i$6 = 0; i$6 < paramCount; i$6++) {
		const p$6 = params[i$6];
		paramTypes[i$6] = p$6.type;
		if (p$6.type === "param") paramNames[i$6] = p$6.name;
		else if (p$6.type === "param-named-destructure") paramNames[i$6] = p$6.paramName;
		else paramNames[i$6] = p$6.names[0] || "_";
	}
	if (paramCount > 0 && paramNames[0] === "in") {
		if (paramTypes[0] === "param") firstParamIn = 1;
		else if (paramTypes[0] === "param-named-destructure") {
			if (params[0].names.length === 2) firstParamIn = 2;
		}
	}
	const funcInfo = {
		id: functionId,
		paramCount,
		params: paramNames,
		paramTypes,
		firstParamIn,
		bytecodeStart: 0,
		bytecodeLength,
		closureVars: closureVarNames,
		definitionLine: expr.loc.line,
		defaultParamFunctionIds: defaultParamFunctionIds.size > 0 ? defaultParamFunctionIds : void 0,
		defaultParamExprs: hasDefaultCalls ? defaults : void 0
	};
	state.functions.push(funcInfo);
	if (name) {
		funcInfo.isGlobalScope = savedFunctionDepth === 0;
		state.functionsByNameStack[state.functionsByNameStack.length - 1].set(name, funcInfo);
	}
	state.ops = savedOps;
	state.stack = savedStack;
	state.locals = savedLocals;
	state.nextLocalIndex = savedNextLocalIndex;
	state.inFunction = savedInFunction;
	state.closureVars = savedClosureVars;
	state.paramNameToLocalIndex = savedParamMap;
	state.functionDepth = savedFunctionDepth;
	if (savedFunctionDepth > 0) state.functionsByNameStack.pop();
	for (const varInfo of closureVarInfos) {
		compilePushCellRef(state, varInfo, expr);
		state.stack.push({ expr });
	}
	state.ops.push(AudioVmOp.DefineFunction);
	state.ops.push(functionId);
	state.ops.push(paramCount);
	state.ops.push(firstParamIn);
	state.ops.push(closureVarNames.length);
	state.ops.push(localCount);
	state.ops.push(bytecodeLength);
	const functionBytecodeStart = state.ops.length;
	state.functionBytecodeStarts.set(functionId, functionBytecodeStart);
	for (let i$6 = 0; i$6 < bodyOps.length; i$6++) state.ops.push(bodyOps[i$6]);
	const history$1 = state.historySourceMap;
	for (let i$6 = historyStartIndex; i$6 < history$1.length; i$6++) {
		const entry = history$1[i$6];
		if (entry.__functionId === functionId) {
			const relativePc = entry.__relativePc;
			if (relativePc !== void 0) {
				entry.pc = functionBytecodeStart + relativePc;
				entry.__finalFunctionId = functionId;
			}
			delete entry.__functionId;
			delete entry.__relativePc;
		}
	}
	let returnIndex;
	let maxPc = -1;
	for (let i$6 = 0; i$6 < state.historySourceMap.length; i$6++) {
		const entry = state.historySourceMap[i$6];
		if (entry.__finalFunctionId === functionId && entry.pc > maxPc) {
			maxPc = entry.pc;
			returnIndex = i$6;
		}
	}
	if (returnIndex !== void 0) funcInfo.returnHistorySourceMapIndex = returnIndex;
	if (isOversampleCallback) state.oversampleCallbackFunctionIds.add(functionId);
	state.currentFunctionId = savedCurrentFunctionId;
	state.stack.push({ expr });
	return functionId;
}
const SYSTEM_VARS = new Set([
	"t",
	"samplesPerBeat",
	"samplesPerBar",
	"co",
	"undefined"
]);
var PIPE_SCOPE = new Map([["$", true]]);
var SYSTEM_VAR_NAMES = Array.from(SYSTEM_VARS);
var COMPOUND_ASSIGN_OP_TO_OPCODE = {
	"+=": AudioVmOp.Add,
	"-=": AudioVmOp.Sub,
	"*=": AudioVmOp.Mul,
	"/=": AudioVmOp.Div,
	"%=": AudioVmOp.Mod,
	"**=": AudioVmOp.Pow,
	"&=": AudioVmOp.BitAnd,
	"|=": AudioVmOp.BitOr,
	"^=": AudioVmOp.BitXor,
	"<<=": AudioVmOp.ShiftLeft,
	">>=": AudioVmOp.ShiftRight
};
function getFunctionByName(state, name) {
	for (let i$6 = state.functionsByNameStack.length - 1; i$6 >= 0; i$6--) {
		const info = state.functionsByNameStack[i$6].get(name);
		if (info) return info;
	}
}
function hasFunctionByName(state, name) {
	return getFunctionByName(state, name) !== void 0;
}
function* functionsByNameEntries(state) {
	const seen$1 = /* @__PURE__ */ new Set();
	for (let i$6 = state.functionsByNameStack.length - 1; i$6 >= 0; i$6--) {
		const map = state.functionsByNameStack[i$6];
		for (const [name, info] of map) if (!seen$1.has(name)) {
			seen$1.add(name);
			yield [name, info];
		}
	}
}
function hasGlobalFunctionByName(state, name) {
	return state.functionsByNameStack[0]?.has(name) ?? false;
}
function lookupVariable(state, name) {
	if (SYSTEM_VARS.has(name)) return {
		scope: "system",
		index: SYSTEM_VAR_NAMES.indexOf(name)
	};
	if (!state.compilingRecordCallback && state.paramNameToLocalIndex?.has(name)) return {
		scope: "local",
		index: state.paramNameToLocalIndex.get(name)
	};
	for (let i$6 = state.locals.length - 1; i$6 >= 0; i$6--) {
		const local = state.locals[i$6].get(name);
		if (local) return local;
	}
	if (state.inFunction) for (let i$6 = state.closureVars.length - 1; i$6 >= 0; i$6--) {
		const closure = state.closureVars[i$6].get(name);
		if (closure) return closure;
	}
	const global$1 = state.globals.get(name);
	if (global$1) return global$1;
	if (getFunctionByName(state, name)?.isGlobalScope) {
		const info = {
			scope: "global",
			index: state.nextGlobalIndex++
		};
		state.globals.set(name, info);
		return info;
	}
	return null;
}
function declareVariable(state, name, loc, shadow = false) {
	if (SYSTEM_VARS.has(name)) {
		error(state, `Cannot assign to system variable: ${name}`, loc);
		return {
			scope: "system",
			index: 0
		};
	}
	if (shadow) {
		const currentScope$1 = getCurrentScope(state);
		if (currentScope$1) {
			const info$2 = {
				scope: "local",
				index: state.nextLocalIndex++
			};
			currentScope$1.set(name, info$2);
			return info$2;
		}
		const info$1 = {
			scope: "global",
			index: state.nextGlobalIndex++
		};
		state.globals.set(name, info$1);
		return info$1;
	}
	const existing = lookupVariable(state, name);
	if (existing && existing.scope !== "system") return existing;
	const currentScope = getCurrentScope(state);
	if (currentScope) {
		const info$1 = {
			scope: "local",
			index: state.nextLocalIndex++
		};
		currentScope.set(name, info$1);
		return info$1;
	}
	const info = {
		scope: "global",
		index: state.nextGlobalIndex++
	};
	state.globals.set(name, info);
	return info;
}
function compilePushCellRef(state, varInfo, expr) {
	switch (varInfo.scope) {
		case "system":
			error(state, "Cannot capture system variable in closure", expr.loc);
			break;
		case "global":
			state.ops.push(AudioVmOp.GetCellRefGlobal);
			state.ops.push(varInfo.index);
			break;
		case "local":
			state.ops.push(AudioVmOp.GetCellRefLocal);
			state.ops.push(varInfo.index);
			break;
		case "closure":
			state.ops.push(AudioVmOp.GetCellRefClosure);
			state.ops.push(varInfo.closureIndex ?? 0);
			break;
	}
}
function compileGetVariable(state, varInfo) {
	switch (varInfo.scope) {
		case "system":
			state.ops.push(AudioVmOp.GetSystem);
			state.ops.push(varInfo.index);
			break;
		case "global":
			state.ops.push(AudioVmOp.GetGlobal);
			state.ops.push(varInfo.index);
			break;
		case "local":
			state.ops.push(AudioVmOp.GetLocal);
			state.ops.push(varInfo.index);
			break;
		case "closure":
			state.ops.push(AudioVmOp.GetClosure);
			state.ops.push(varInfo.closureIndex ?? 0);
			break;
	}
}
function compileSetVariable(state, varInfo, expr) {
	switch (varInfo.scope) {
		case "system":
			error(state, "Cannot assign to system variable", expr.loc);
			break;
		case "global":
			state.ops.push(AudioVmOp.SetGlobal);
			state.ops.push(varInfo.index);
			break;
		case "local":
			state.ops.push(AudioVmOp.SetLocal);
			state.ops.push(varInfo.index);
			break;
		case "closure":
			state.ops.push(AudioVmOp.SetClosure);
			state.ops.push(varInfo.closureIndex ?? 0);
			break;
	}
}
function compileAssign(state, expr) {
	const ops = state.ops;
	const stack = state.stack;
	const { left, right, op } = expr;
	const stackExpr = { expr };
	if (left.type === "destructure") {
		if (op !== "=" && op !== ":=") {
			error(state, "Destructuring assignment only supports = and := operators", expr.loc);
			return;
		}
		compileExpr(state, right);
		if (stack.length === 0) {
			error(state, "Assignment has no value", expr.loc);
			return;
		}
		const shadow = op === ":=";
		const stackRight = { expr: right };
		const names = left.names;
		for (let i$6 = 0; i$6 < names.length; i$6++) {
			const name = names[i$6];
			ops.push(AudioVmOp.Dup);
			stack.push(stackRight);
			ops.push(AudioVmOp.PushScalar, i$6);
			stack.push(stackRight);
			ops.push(AudioVmOp.ArrayGet, 0);
			stack.pop();
			stack.pop();
			stack.push(stackRight);
			compileSetVariable(state, declareVariable(state, name, left.loc, shadow), left);
			stack.pop();
		}
		stack.push(stackExpr);
		return;
	}
	if (left.type !== "identifier" && left.type !== "index") {
		error(state, "Assignment target must be an identifier, array index, or destructuring pattern", expr.loc);
		return;
	}
	if (op === "=>") {
		if (left.type !== "identifier") {
			error(state, "Function definition target must be an identifier", expr.loc);
			return;
		}
		const leftName = left.name;
		if (leftName === "mix") state.mixDefinitionLoc = expr.loc;
		const x$4 = {
			type: "identifier",
			name: "x",
			loc: left.loc
		};
		const fnExpr = {
			type: "fn",
			params: [{
				type: "param",
				name: "x",
				loc: left.loc
			}],
			defaults: [null],
			body: {
				type: "binary",
				op: "|>",
				left: x$4,
				right,
				loc: right.loc
			},
			loc: expr.loc
		};
		if (state.functionDepth === 0 && state.deferredGlobalFunctions.some((d$5) => d$5.name === leftName && d$5.loc.start === expr.loc.start && d$5.loc.end === expr.loc.end)) return;
		compileFunction(state, fnExpr, leftName);
		if (stack.length === 0) return;
		const varInfo = declareVariable(state, leftName, expr.loc);
		ops.push(AudioVmOp.Dup);
		stack.push({ expr: right });
		compileSetVariable(state, varInfo, left);
		stack.pop();
		stack.push(stackExpr);
		return;
	}
	if (left.type === "identifier" && left.name === "scale" && (op === "=" || op === ":=")) {
		if (right.type !== "string") {
			error(state, "scale must be set to a string literal", expr.loc);
			return;
		}
		const scaleIdx = findScaleIndex(right.value);
		if (scaleIdx === void 0) {
			error(state, `Unknown scale: ${right.value}`, expr.loc);
			return;
		}
		state.scale = right.value;
		state.scaleIndex = scaleIdx;
		const varInfo = declareVariable(state, "scale", expr.loc);
		ops.push(AudioVmOp.PushScalar, 0, AudioVmOp.SetGlobal, varInfo.index, AudioVmOp.PushScalar, 0);
		stack.push(stackExpr);
		return;
	}
	if (left.type === "identifier" && left.name === "bpm" && (op === "=" || op === ":=")) {
		if (right.type !== "number") {
			error(state, "bpm must be set to a literal number", expr.loc);
			return;
		}
		const bpm$1 = right.value;
		if (!Number.isFinite(bpm$1) || bpm$1 <= 0) {
			error(state, "bpm must be a finite number > 0", expr.loc);
			return;
		}
		ops.push(AudioVmOp.SetBpm, bpm$1);
		state.bpm = bpm$1;
		ops.push(AudioVmOp.PushScalar, bpm$1);
		stack.push(stackExpr);
		return;
	}
	if (left.type === "index") {
		const isCompound = op !== "=" && op !== ":=";
		const opCode = COMPOUND_ASSIGN_OP_TO_OPCODE[op];
		const stackRight = { expr: right };
		const stackLeft = { expr: left };
		if (isCompound && opCode === void 0) {
			error(state, "Compound assignment not supported for array elements", expr.loc);
			return;
		}
		compileExpr(state, left.object);
		if (stack.length === 0) {
			error(state, "Array expression has no value", expr.loc);
			return;
		}
		compileExpr(state, left.index);
		if (stack.length === 0) {
			error(state, "Index expression has no value", expr.loc);
			return;
		}
		if (isCompound) {
			const isGlobal = state.functionDepth === 0;
			const a$36 = isGlobal ? state.nextGlobalIndex++ : state.nextLocalIndex++;
			const b$4 = isGlobal ? state.nextGlobalIndex++ : state.nextLocalIndex++;
			const v$4 = isGlobal ? state.nextGlobalIndex++ : state.nextLocalIndex++;
			const saveOp = isGlobal ? AudioVmOp.SetGlobal : AudioVmOp.SetLocal;
			const loadOp = isGlobal ? AudioVmOp.GetGlobal : AudioVmOp.GetLocal;
			ops.push(saveOp, a$36);
			stack.pop();
			ops.push(saveOp, b$4);
			stack.pop();
			ops.push(loadOp, b$4, loadOp, a$36, AudioVmOp.ArrayGet, 0);
			stack.pop();
			stack.pop();
			stack.push(stackLeft);
			compileExpr(state, right);
			if (stack.length < 2) {
				error(state, "Compound assignment missing operands", expr.loc);
				return;
			}
			ops.push(opCode);
			stack.pop();
			stack.pop();
			stack.push(stackExpr);
			ops.push(saveOp, v$4);
			stack.pop();
			ops.push(loadOp, b$4, loadOp, a$36, loadOp, v$4);
			stack.push(stackRight);
			ops.push(AudioVmOp.ArraySet);
			stack.pop();
			stack.pop();
			stack.pop();
			ops.push(loadOp, v$4);
			stack.pop();
			stack.push(stackExpr);
		} else {
			compileExpr(state, right);
			if (stack.length === 0) {
				error(state, "Assignment has no value", expr.loc);
				return;
			}
			if (state.functionDepth === 0) {
				const tempGlobalIdx = state.nextGlobalIndex++;
				ops.push(AudioVmOp.SetGlobal, tempGlobalIdx);
				stack.pop();
				ops.push(AudioVmOp.GetGlobal, tempGlobalIdx);
				stack.push(stackRight);
				ops.push(AudioVmOp.ArraySet);
				stack.pop();
				stack.pop();
				stack.pop();
				ops.push(AudioVmOp.GetGlobal, tempGlobalIdx);
				stack.pop();
				stack.push(stackExpr);
			} else {
				const tempIndex = state.nextLocalIndex++;
				ops.push(AudioVmOp.SetLocal, tempIndex);
				stack.pop();
				ops.push(AudioVmOp.GetLocal, tempIndex);
				stack.push(stackRight);
				ops.push(AudioVmOp.ArraySet);
				stack.pop();
				stack.pop();
				stack.pop();
				ops.push(AudioVmOp.GetLocal, tempIndex);
				stack.pop();
				stack.push(stackExpr);
			}
		}
		return;
	}
	if (right.type === "fn" && left.type === "identifier") {
		const leftName = left.name;
		if (leftName === "mix") state.mixDefinitionLoc = expr.loc;
		if (state.functionDepth === 0 && state.deferredGlobalFunctions.some((d$5) => d$5.name === leftName && d$5.loc.start === expr.loc.start && d$5.loc.end === expr.loc.end)) return;
		const shadow = op === ":=";
		const varInfo = declareVariable(state, leftName, expr.loc, shadow);
		compileFunction(state, right, leftName);
		if (stack.length === 0) return;
		ops.push(AudioVmOp.Dup);
		stack.push({ expr: right });
		compileSetVariable(state, varInfo, left);
		stack.pop();
		stack.push(stackExpr);
		return;
	}
	if (op === "=" || op === ":=") {
		if (left.type === "identifier" && right.type === "array") state.varToArrayLiteral.set(left.name, right);
		if (left.type === "identifier" && right.type === "identifier" && hasFunctionByName(state, right.name)) state.functionAliases.set(left.name, right.name);
		compileExpr(state, right);
		if (stack.length === 0) {
			error(state, "Assignment has no value", expr.loc);
			return;
		}
		const shadow = op === ":=";
		const varInfo = declareVariable(state, left.name, expr.loc, shadow);
		ops.push(AudioVmOp.Dup);
		stack.push({ expr: right });
		compileSetVariable(state, varInfo, left);
		stack.pop();
		stack.push(stackExpr);
	} else {
		const varInfo = lookupVariable(state, left.name);
		if (!varInfo) {
			error(state, `Unknown variable: ${left.name}`, expr.loc);
			return;
		}
		compileGetVariable(state, varInfo);
		stack.push({ expr: left });
		compileExpr(state, right);
		if (stack.length < 2) {
			error(state, "Compound assignment missing operands", expr.loc);
			return;
		}
		const opCode = COMPOUND_ASSIGN_OP_TO_OPCODE[op];
		if (opCode !== void 0) {
			ops.push(opCode);
			stack.pop();
			stack.pop();
			stack.push(stackExpr);
		}
		ops.push(AudioVmOp.Dup);
		stack.push(stackExpr);
		compileSetVariable(state, varInfo, left);
		stack.pop();
		stack.push(stackExpr);
	}
}
function detectClosureVars(state, expr, outerLocals) {
	const outerPipe = state.pipeVars[state.pipeVars.length - 1];
	const includePipe = !!outerPipe && outerPipe.functionDepth < state.functionDepth;
	const includeGlobals = state.captureGlobalsInClosures;
	let scopes = outerLocals;
	if (includePipe || includeGlobals) {
		scopes = scopes.slice();
		if (includePipe) scopes.push(PIPE_SCOPE);
		if (includeGlobals) scopes.push(state.globals);
	}
	return collectClosureVarNames(expr, scopes, { systemVars: SYSTEM_VARS });
}
function detectCapturedVarsInBody(state, body) {
	const names = collectCapturedVarNames(body, { systemVars: SYSTEM_VARS });
	const captured = [];
	for (const name of names) {
		const info = lookupVariable(state, name);
		if (info) captured.push({
			name,
			info
		});
	}
	return captured;
}
function compileNoteVar(state, name, loc) {
	emitMidiToHzCall(state, noteNameToMidi(name), loc);
}
function compileDtofCall(state, degree, loc) {
	const midi = degreeToMidiTs(state.rootMidi, state.scaleIndex, degree);
	if (midi < 0) {
		error(state, `dtof: invalid degree ${degree} for current scale`, loc);
		return;
	}
	emitMidiToHzCall(state, midi, loc);
}
function getMidiToHzVar(state) {
	return lookupVariable(state, "midiToHz") ?? lookupVariable(state, "ntof") ?? lookupVariable(state, "mtof");
}
function emitMidiToHzCall(state, midi, loc) {
	const varInfo = getMidiToHzVar(state);
	if (!varInfo) {
		error(state, "midiToHz (or ntof) must be defined before using note/chord variables", loc);
		return;
	}
	state.ops.push(AudioVmOp.PushScalar);
	state.ops.push(midi);
	compileGetVariable(state, varInfo);
	state.ops.push(AudioVmOp.CallFunction);
	state.ops.push(1);
	state.stack.push({ expr: {
		type: "number",
		value: 0,
		loc
	} });
}
function resolveHashVar(name, state) {
	if (!name.startsWith("#")) return null;
	const rest = name.slice(1);
	if (rest === "scale") {
		const intervals = getScaleIntervalsByIndex(state.scaleIndex);
		if (!intervals || intervals.length === 0) return null;
		const rootMidi = state.rootMidi;
		const midis = [];
		for (let d$5 = 1; d$5 <= intervals.length; d$5++) {
			const m$5 = degreeToMidiTs(rootMidi, state.scaleIndex, d$5);
			if (m$5 >= 0) midis.push(m$5);
		}
		return { midis };
	}
	const scaleDegreeMatch = rest.match(/^(\d+)$/);
	if (scaleDegreeMatch) {
		const degree = parseInt(scaleDegreeMatch[1], 10);
		const rootMidi = state.rootMidi;
		const midi = degreeToMidiTs(rootMidi, state.scaleIndex, degree);
		if (midi < 0) return null;
		return { midi };
	}
	const chordMatch = rest.match(/^([ivxlcdmIVXLCDM]+)(.*)$/);
	if (chordMatch) {
		const roman = chordMatch[1];
		const suffix = chordMatch[2] ?? "";
		const base = romanToDegree(roman);
		if (base === null) return null;
		const tones = parseChordSuffix(suffix);
		const rootMidi = state.rootMidi;
		const midis = [];
		for (const tone of tones) {
			const scaleDegree = base + tone.degree;
			const midi = degreeToMidiTs(rootMidi, state.scaleIndex, scaleDegree, tone.semitoneAdjust);
			if (midi >= 0) midis.push(midi);
		}
		return { midis };
	}
	return null;
}
function emitMapMidiToHz(state, midis, loc) {
	const mapVar = lookupVariable(state, "map");
	const midiToHzVar = getMidiToHzVar(state);
	if (!mapVar || !midiToHzVar) {
		error(state, "map and midiToHz (or ntof) must be defined before using chord variables", loc);
		return;
	}
	for (const m$5 of midis) {
		state.ops.push(AudioVmOp.PushScalar);
		state.ops.push(m$5);
	}
	state.ops.push(AudioVmOp.MakeArray);
	state.ops.push(midis.length);
	compileGetVariable(state, midiToHzVar);
	compileGetVariable(state, mapVar);
	state.ops.push(AudioVmOp.CallFunction);
	state.ops.push(2);
	state.stack.push({ expr: {
		type: "array",
		items: [],
		loc
	} });
}
function compileHashVar(state, name, loc) {
	const result = resolveHashVar(name, state);
	if (!result) {
		error(state, `Unknown # variable: ${name}`, loc);
		return;
	}
	if ("midi" in result) emitMidiToHzCall(state, result.midi, loc);
	else emitMapMidiToHz(state, result.midis, loc);
}
const MINI_HISTORY_SIZE = 2048;
let MiniOp = /* @__PURE__ */ function(MiniOp$1) {
	MiniOp$1[MiniOp$1["Event"] = 0] = "Event";
	MiniOp$1[MiniOp$1["GroupStart"] = 1] = "GroupStart";
	MiniOp$1[MiniOp$1["GroupEnd"] = 2] = "GroupEnd";
	MiniOp$1[MiniOp$1["Rest"] = 3] = "Rest";
	MiniOp$1[MiniOp$1["Octave"] = 4] = "Octave";
	MiniOp$1[MiniOp$1["Transpose"] = 5] = "Transpose";
	MiniOp$1[MiniOp$1["Scale"] = 6] = "Scale";
	MiniOp$1[MiniOp$1["CycleStart"] = 7] = "CycleStart";
	MiniOp$1[MiniOp$1["CycleEnd"] = 8] = "CycleEnd";
	MiniOp$1[MiniOp$1["Swing"] = 9] = "Swing";
	return MiniOp$1;
}({});
function allocateBytecode(operationCount) {
	const size = 1 + operationCount * Math.max(28, 13, 3, 4, 1, 1, 2, 2, 2);
	return new Float32Array(size);
}
function writeEventOp(buffer, offset, values, modifiers) {
	const base = 1 + offset;
	let pc = 0;
	function emit(op) {
		buffer[base + pc] = op;
		pc++;
	}
	emit(MiniOp.Event);
	emit(Math.min(values.length, 16));
	emit(modifiers.velocity);
	emit(modifiers.hold);
	emit(modifiers.replicate);
	emit(modifiers.elongate);
	emit(modifiers.density);
	emit(modifiers.offset);
	emit(modifiers.jitter);
	emit(modifiers.prob);
	emit(modifiers.glide);
	emit(modifiers.strum);
	for (let i$6 = 0; i$6 < 16; i$6++) emit(values[i$6] ?? 0);
	return 28;
}
function writeGroupStartOp(buffer, offset, childCount, mode, modifiers) {
	const base = 1 + offset;
	let pc = 0;
	function emit(op) {
		buffer[base + pc] = op;
		pc++;
	}
	emit(MiniOp.GroupStart);
	emit(childCount);
	emit(mode === 2 ? 2 : mode === 1 ? 1 : 0);
	emit(modifiers.velocity);
	emit(modifiers.hold);
	emit(modifiers.replicate);
	emit(modifiers.elongate);
	emit(modifiers.density);
	emit(modifiers.offset);
	emit(modifiers.jitter);
	emit(modifiers.prob);
	emit(modifiers.glide);
	emit(modifiers.strum);
	return 13;
}
function writeGroupEndOp(buffer, offset) {
	const base = 1 + offset;
	buffer[base + 0] = MiniOp.GroupEnd;
	return 1;
}
function writeCycleStartOp(buffer, offset, pos, loop, childCount) {
	const base = 1 + offset;
	buffer[base + 0] = MiniOp.CycleStart;
	buffer[base + 1] = pos;
	buffer[base + 2] = loop;
	buffer[base + 3] = childCount;
	return 4;
}
function writeCycleEndOp(buffer, offset) {
	const base = 1 + offset;
	buffer[base + 0] = MiniOp.CycleEnd;
	return 1;
}
function writeOctaveOp(buffer, offset, delta) {
	const base = 1 + offset;
	buffer[base + 0] = MiniOp.Octave;
	buffer[base + 1] = delta;
	return 2;
}
function writeTransposeOp(buffer, offset, delta) {
	const base = 1 + offset;
	buffer[base + 0] = MiniOp.Transpose;
	buffer[base + 1] = delta;
	return 2;
}
function writeScaleOp(buffer, offset, rootMidi, scaleIndex) {
	const base = 1 + offset;
	buffer[base + 0] = MiniOp.Scale;
	buffer[base + 1] = rootMidi;
	buffer[base + 2] = scaleIndex;
	return 3;
}
function writeSwingOp(buffer, offset, amount) {
	const base = 1 + offset;
	buffer[base + 0] = MiniOp.Swing;
	buffer[base + 1] = amount;
	return 2;
}
function buildSourceMapFromNodes(nodes, _bytecode, offset, map) {
	let currentOffset = offset;
	for (const node of nodes) if (node.type === "event") {
		const opIndex = currentOffset;
		map.set(opIndex, {
			text: node.source.text,
			start: node.source.start,
			end: node.source.start + node.source.length
		});
		currentOffset += 28;
	} else if (node.type === "rest") {
		const opIndex = currentOffset;
		map.set(opIndex, {
			text: node.source.text,
			start: node.source.start,
			end: node.source.start + node.source.length
		});
		currentOffset += 28;
	} else if (node.type === "octave") {
		const opIndex = currentOffset;
		map.set(opIndex, {
			text: node.source.text,
			start: node.source.start,
			end: node.source.start + node.source.length
		});
		currentOffset += 2;
	} else if (node.type === "transpose") {
		const opIndex = currentOffset;
		map.set(opIndex, {
			text: node.source.text,
			start: node.source.start,
			end: node.source.start + node.source.length
		});
		currentOffset += 2;
	} else if (node.type === "scale") {
		const opIndex = currentOffset;
		map.set(opIndex, {
			text: node.source.text,
			start: node.source.start,
			end: node.source.start + node.source.length
		});
		currentOffset += 3;
	} else if (node.type === "swing") {
		const opIndex = currentOffset;
		map.set(opIndex, {
			text: node.source.text,
			start: node.source.start,
			end: node.source.start + node.source.length
		});
		currentOffset += 2;
	} else if (node.type === "group") {
		currentOffset += 13;
		currentOffset = buildSourceMapFromNodes(node.children, _bytecode, currentOffset, map);
		currentOffset += 1;
	} else if (node.type === "at") {
		currentOffset += 4;
		currentOffset = buildSourceMapFromNodes(node.children, _bytecode, currentOffset, map);
		currentOffset += 1;
	}
	return currentOffset;
}
var cacheByMiniSourceMap = /* @__PURE__ */ new Map();
function buildMiniSourceMap(src, nodes, bytecode$1) {
	const cached = cacheByMiniSourceMap.get(src);
	if (cached) return cached;
	if (cacheByMiniSourceMap.size > 1e3) cacheByMiniSourceMap.clear();
	const map = /* @__PURE__ */ new Map();
	buildSourceMapFromNodes(nodes, bytecode$1, 13, map);
	const result = map;
	cacheByMiniSourceMap.set(src, result);
	return result;
}
function euclidHit(pulses, steps, step, offset = 0) {
	if (steps <= 0) return false;
	if (pulses <= 0) return false;
	if (pulses >= steps) return true;
	let s$4 = step + offset;
	s$4 %= steps;
	if (s$4 < 0) s$4 += steps;
	return s$4 * pulses % steps < pulses;
}
var DEFAULT_MODS = {
	velocity: 1,
	hold: 0,
	replicate: 1,
	elongate: 1,
	density: 1,
	offset: 0,
	jitter: 0,
	prob: 0,
	glide: 0,
	strum: 0
};
var MODIFIER_START = new Set([
	"*",
	"!",
	"@",
	"/",
	"\\",
	".",
	";",
	"?",
	"+",
	"-",
	"$"
]);
var GROUP_OPEN = new Set([
	"[",
	"<",
	"("
]);
function cloneMods(mods) {
	return { ...mods };
}
function getDefaultMods() {
	return cloneMods(DEFAULT_MODS);
}
function parseModifiers(text) {
	const mods = getDefaultMods();
	let i$6 = 0;
	while (i$6 < text.length) {
		const ch = text[i$6];
		const rest = text.slice(i$6 + 1);
		switch (ch) {
			case "*": {
				const m$5 = rest.match(/^([\d.]+)/);
				if (m$5) {
					mods.density = parseFloat(m$5[1]) || 1;
					i$6 += m$5[0].length + 1;
				} else i$6++;
				break;
			}
			case "!": {
				const m$5 = rest.match(/^([\d.]+)/);
				if (m$5) {
					mods.replicate = parseFloat(m$5[1]) || 1;
					i$6 += m$5[0].length + 1;
				} else i$6++;
				break;
			}
			case "@": {
				const m$5 = rest.match(/^([\d.]+)/);
				if (m$5) {
					mods.elongate = parseFloat(m$5[1]) || 1;
					i$6 += m$5[0].length + 1;
				} else i$6++;
				break;
			}
			case "/": {
				const m$5 = rest.match(/^([\d.]+)/);
				if (m$5) {
					mods.density = 1 / (parseFloat(m$5[1]) || 1);
					i$6 += m$5[0].length + 1;
				} else i$6++;
				break;
			}
			case "\\": {
				const m$5 = rest.match(/^(-?[\d.]+)/);
				if (m$5 && m$5[1]) {
					mods.glide = parseFloat(m$5[1]);
					i$6 += m$5[0].length + 1;
				} else {
					mods.glide = 1;
					i$6++;
				}
				break;
			}
			case ".": {
				const m$5 = rest.match(/^([\d.]+)/);
				if (m$5) {
					const raw = m$5[1];
					let factor = parseFloat(raw);
					if (raw.indexOf(".") === -1) factor = parseFloat("0." + raw);
					mods.velocity *= factor;
					i$6 += m$5[0].length + 1;
				} else i$6++;
				break;
			}
			case ";": {
				const m$5 = rest.match(/^([\d.]+)/);
				if (m$5) {
					mods.hold = parseFloat(m$5[1]);
					i$6 += m$5[0].length + 1;
				} else i$6++;
				break;
			}
			case "?": {
				const m$5 = rest.match(/^([\d.]+)/);
				if (m$5) {
					mods.prob = parseFloat(m$5[1]);
					i$6 += m$5[0].length + 1;
				} else {
					mods.prob = .5;
					i$6++;
				}
				break;
			}
			case "+":
				if (rest.startsWith("?")) {
					const m$5 = rest.slice(1).match(/^([\d.]*)/);
					mods.jitter = m$5 && m$5[1] ? parseFloat(m$5[1]) : .5;
					i$6 += (m$5?.[0]?.length ?? 0) + 2;
				} else {
					const m$5 = rest.match(/^([\d.]+)/);
					if (m$5) {
						mods.offset += parseFloat(m$5[1]);
						i$6 += m$5[0].length + 1;
					} else i$6++;
				}
				break;
			case "-": {
				const m$5 = rest.match(/^([\d.]+)/);
				if (m$5) {
					mods.offset -= parseFloat(m$5[1]);
					i$6 += m$5[0].length + 1;
				} else i$6++;
				break;
			}
			case "$": {
				let j$4 = i$6;
				while (j$4 < text.length && text[j$4] === "$") j$4++;
				const dollarCount = j$4 - i$6;
				const m$5 = text.slice(j$4).match(/^([\d.]+)/);
				if (m$5) {
					const raw = parseFloat(m$5[1]);
					mods.strum = (dollarCount >= 4 ? 3 : dollarCount === 3 ? 2 : dollarCount === 2 ? 1 : 0) + Math.min(Math.max(raw, 0), .999999);
					i$6 = j$4 + m$5[0].length;
				} else i$6 = j$4;
				break;
			}
			default: i$6++;
		}
	}
	return mods;
}
function tokenize$2(input) {
	const tokens = [];
	let i$6 = 0;
	while (i$6 < input.length) {
		if (/\s/.test(input[i$6])) {
			i$6++;
			continue;
		}
		const start = i$6;
		const ch = input[i$6];
		if (ch === ":") {
			tokens.push({
				text: ":",
				start,
				end: i$6 + 1
			});
			i$6++;
			continue;
		}
		if (ch === "/" && input[i$6 + 1] === "/") {
			let j$4 = i$6 + 2;
			while (j$4 < input.length && input[j$4] !== "\n" && input[j$4] !== "\r") j$4++;
			tokens.push({
				text: input.slice(start, j$4),
				start,
				end: j$4
			});
			i$6 = j$4;
			continue;
		}
		if (GROUP_OPEN.has(ch)) {
			const close = ch === "[" ? "]" : ch === "<" ? ">" : ")";
			i$6++;
			let depth = 1;
			while (i$6 < input.length && depth > 0) {
				if (input[i$6] === ch) depth++;
				else if (input[i$6] === close) depth--;
				i$6++;
			}
			while (i$6 < input.length) {
				const c$7 = input[i$6];
				if (c$7 === ":" || /\s/.test(c$7) || GROUP_OPEN.has(c$7) || c$7 === "]" || c$7 === ">" || c$7 === ")") break;
				i$6++;
			}
			tokens.push({
				text: input.slice(start, i$6),
				start,
				end: i$6
			});
			continue;
		}
		i$6++;
		while (i$6 < input.length) {
			const c$7 = input[i$6];
			if (c$7 === ":" || /\s/.test(c$7) || GROUP_OPEN.has(c$7) || c$7 === "]" || c$7 === ">" || c$7 === ")") break;
			i$6++;
		}
		tokens.push({
			text: input.slice(start, i$6),
			start,
			end: i$6
		});
	}
	const mergedTokens = [];
	for (let ti = 0; ti < tokens.length; ti++) {
		const t$12 = tokens[ti];
		const next = tokens[ti + 1];
		if (next && t$12.end === next.start && /^[A-Za-z]+$/.test(t$12.text) && /^[0-9]+$/.test(next.text)) {
			mergedTokens.push({
				text: t$12.text + next.text,
				start: t$12.start,
				end: next.end
			});
			ti++;
		} else mergedTokens.push(t$12);
	}
	return mergedTokens;
}
function splitValueAndModifiers(text) {
	let i$6 = 0;
	while (i$6 < text.length) {
		const ch = text[i$6];
		if (MODIFIER_START.has(ch) && !(i$6 === 0 && (ch === "-" || ch === "+") && /\d/.test(text[i$6 + 1] ?? ""))) break;
		i$6++;
	}
	return {
		value: text.slice(0, i$6),
		mods: text.slice(i$6)
	};
}
function parseValues(valueText) {
	const values = [];
	let cursor = 0;
	while (cursor < valueText.length) {
		while (cursor < valueText.length && (valueText[cursor] === "," || /\s/.test(valueText[cursor]))) cursor++;
		if (cursor >= valueText.length) break;
		const rest = valueText.slice(cursor);
		const noteMatch = rest.match(/^([a-gA-G][#b]?)(-?\d+)/);
		if (noteMatch) {
			const midi = noteNameToMidi(noteMatch[1] + noteMatch[2]);
			values.push(midiToFrequency(midi));
			cursor += noteMatch[0].length;
			continue;
		}
		const numMatch = rest.match(/^-?[\d.]+/);
		if (numMatch) {
			values.push(parseFloat(numMatch[0]));
			cursor += numMatch[0].length;
			continue;
		}
		cursor++;
	}
	return values;
}
function isNoteNameText(text) {
	return /^([a-gA-G][#b]?)(-?\d+)$/.test(text);
}
function makeSource(input, start, end) {
	return {
		start,
		length: end - start,
		text: input.slice(start, end)
	};
}
function nodesSpan(nodes) {
	const first = nodes[0];
	const last = nodes.at(-1);
	if (!first || !last) return null;
	return {
		start: first.source.start,
		end: last.source.start + last.source.length
	};
}
function parseGroupedTokenText(raw, open) {
	const close = open === "[" ? "]" : open === "<" ? ">" : ")";
	const closingIndex = raw.lastIndexOf(close);
	if (closingIndex === -1) return {
		inner: raw.slice(1),
		modText: ""
	};
	const inner = raw.slice(1, closingIndex);
	const { mods: modText } = splitValueAndModifiers(raw.slice(closingIndex + 1));
	return {
		inner,
		modText
	};
}
function parseDeltaToken(token) {
	const raw = token?.text;
	if (!raw) return 0;
	const v$4 = parseFloat(raw);
	return Number.isFinite(v$4) ? v$4 : 0;
}
function parseEuclidToken(raw) {
	if (!raw.startsWith("(")) return null;
	if (!raw.endsWith(")")) return null;
	const inner = raw.slice(1, -1).trim();
	if (!/^\d+\s*,\s*\d+(?:\s*,\s*-?\d+)?$/.test(inner)) return null;
	const parts = inner.split(",").map((s$4) => parseInt(s$4.trim(), 10));
	const pulses = parts[0];
	const steps = parts[1];
	const offset = parts.length >= 3 ? parts[2] : 0;
	if (!Number.isFinite(pulses) || !Number.isFinite(steps) || !Number.isFinite(offset)) return null;
	return {
		pulses,
		steps,
		offset
	};
}
function cloneEventNode(node, nextSource, values) {
	return {
		type: "event",
		angle: false,
		parallel: false,
		values,
		children: [],
		modifiers: cloneMods(node.modifiers),
		source: nextSource
	};
}
function parseOctaveDelta(tokens) {
	return parseDeltaToken(tokens[1]);
}
function parseScaleDirective(tokens, startIndex) {
	let i$6 = startIndex;
	let rootMidi = noteNameToMidi("c4");
	let scaleIndex = SCALE_KEY_TO_INDEX.major ?? 0;
	const t0 = tokens[i$6]?.text?.toLowerCase();
	if (t0 && isNoteNameText(t0)) {
		rootMidi = noteNameToMidi(t0);
		i$6++;
	}
	const t1$1 = tokens[i$6]?.text?.toLowerCase();
	if (t1$1) {
		if (/^[a-z][a-z0-9]*$/.test(t1$1)) {
			let scaleName = t1$1;
			const nextToken = tokens[i$6 + 1];
			if (/^[a-z]+$/.test(t1$1) && nextToken && /^[0-9]+$/.test(nextToken.text) && nextToken.start === tokens[i$6].end) {
				scaleName = t1$1 + nextToken.text;
				i$6++;
			}
			scaleIndex = findScaleIndex(scaleName) ?? scaleIndex;
			i$6++;
		}
	}
	return {
		rootMidi,
		scaleIndex,
		nextIndex: i$6
	};
}
function tokensToNodesInternal(tokens, input) {
	const nodes = [];
	for (let ti = 0; ti < tokens.length; ti++) {
		const token = tokens[ti];
		const raw = token.text;
		const first = raw[0];
		if (raw.startsWith("//")) continue;
		if (raw === ",") {
			const left = nodes.slice();
			const rightTokens = tokens.slice(ti + 1);
			const right = rightTokens.length > 0 ? tokensToNodesInternal(rightTokens, input) : [];
			if (left.length === 0 && right.length === 0) return [];
			if (left.length === 0) return right;
			if (right.length === 0) return left;
			const leftGroup = {
				type: "group",
				angle: false,
				parallel: false,
				values: [],
				children: left,
				modifiers: getDefaultMods(),
				source: makeSource(input, left[0].source.start, left.at(-1).source.start + left.at(-1).source.length)
			};
			const rightGroup = {
				type: "group",
				angle: false,
				parallel: false,
				values: [],
				children: right,
				modifiers: getDefaultMods(),
				source: makeSource(input, right[0].source.start, right.at(-1).source.start + right.at(-1).source.length)
			};
			const endToken = rightTokens.at(-1) ?? token;
			return [{
				type: "group",
				angle: false,
				parallel: true,
				values: [],
				children: [leftGroup, rightGroup],
				modifiers: getDefaultMods(),
				source: makeSource(input, leftGroup.source.start, endToken.end)
			}];
		}
		if (raw === ".") {
			const segments = [];
			if (nodes.length > 0) segments.push(nodes.slice());
			let segStart = ti + 1;
			for (let j$4 = ti + 1; j$4 <= tokens.length; j$4++) {
				const isEnd = j$4 === tokens.length;
				const isDot = !isEnd && tokens[j$4]?.text === ".";
				if (!isEnd && !isDot) continue;
				const partTokens = tokens.slice(segStart, j$4);
				const partNodes = partTokens.length > 0 ? tokensToNodesInternal(partTokens, input) : [];
				if (partNodes.length > 0) segments.push(partNodes);
				segStart = j$4 + 1;
			}
			if (segments.length === 0) return [];
			if (segments.length === 1) return segments[0];
			const loop = segments.length;
			const onChildren = [];
			let groupStart = Infinity;
			let groupEnd = -Infinity;
			for (let si = 0; si < segments.length; si++) {
				const children = segments[si];
				const span = nodesSpan(children);
				const start = span?.start ?? 0;
				const end = span?.end ?? start;
				groupStart = Math.min(groupStart, start);
				groupEnd = Math.max(groupEnd, end);
				onChildren.push({
					type: "at",
					angle: false,
					parallel: false,
					values: [si + 1, loop],
					children,
					modifiers: getDefaultMods(),
					source: makeSource(input, start, end)
				});
			}
			if (!Number.isFinite(groupStart) || !Number.isFinite(groupEnd) || groupStart > groupEnd) {
				groupStart = 0;
				groupEnd = 0;
			}
			return [{
				type: "group",
				angle: false,
				parallel: false,
				values: [],
				children: onChildren,
				modifiers: getDefaultMods(),
				source: makeSource(input, groupStart, groupEnd)
			}];
		}
		if (first === "_") {
			const last = nodes.at(-1);
			if (last) last.modifiers.elongate += 1;
			continue;
		}
		if (raw === "scale") {
			const { rootMidi, scaleIndex, nextIndex } = parseScaleDirective(tokens, ti + 1);
			const last = nextIndex > ti + 1 ? tokens[nextIndex - 1] : token;
			nodes.push({
				type: "scale",
				angle: false,
				parallel: false,
				values: [rootMidi, scaleIndex],
				children: [],
				modifiers: getDefaultMods(),
				source: makeSource(input, token.start, last?.end ?? token.end)
			});
			ti = nextIndex - 1;
			continue;
		}
		if (raw === "at") {
			const next = tokens[ti + 1];
			const rawOn = next?.text ?? "";
			let pos = 0;
			let loop = 0;
			const slash = rawOn.indexOf("/");
			if (slash >= 0) {
				const a$36 = parseInt(rawOn.slice(0, slash), 10);
				const b$4 = parseInt(rawOn.slice(slash + 1), 10);
				pos = Number.isFinite(a$36) ? a$36 : 0;
				loop = Number.isFinite(b$4) ? b$4 : 0;
			} else {
				const a$36 = parseInt(rawOn, 10);
				pos = Number.isFinite(a$36) ? a$36 : 0;
			}
			const bodyStart = ti + 2;
			let bodyEnd = tokens.length;
			for (let j$4 = bodyStart; j$4 < tokens.length; j$4++) if (tokens[j$4]?.text === "at") {
				bodyEnd = j$4;
				break;
			}
			const children = tokensToNodesInternal(tokens.slice(bodyStart, bodyEnd), input);
			const last = tokens[bodyEnd - 1] ?? next ?? token;
			nodes.push({
				type: "at",
				angle: false,
				parallel: false,
				values: [pos, loop],
				children,
				modifiers: getDefaultMods(),
				source: makeSource(input, token.start, last?.end ?? token.end)
			});
			ti = bodyEnd - 1;
			continue;
		}
		if (raw === "octave" || raw === "transpose") {
			const next = tokens[ti + 1];
			const delta = parseDeltaToken(next);
			const end = next?.end ?? token.end;
			nodes.push({
				type: raw === "octave" ? "octave" : "transpose",
				angle: false,
				parallel: false,
				values: [delta],
				children: [],
				modifiers: getDefaultMods(),
				source: makeSource(input, token.start, end)
			});
			if (next) ti++;
			continue;
		}
		if (raw === "swing") {
			const next = tokens[ti + 1];
			const amount = parseDeltaToken(next);
			const end = next?.end ?? token.end;
			nodes.push({
				type: "swing",
				angle: false,
				parallel: false,
				values: [amount],
				children: [],
				modifiers: getDefaultMods(),
				source: makeSource(input, token.start, end)
			});
			if (next) ti++;
			continue;
		}
		if (first === "[" || first === "<") {
			const { inner, modText } = parseGroupedTokenText(raw, first);
			const modifiers$1 = parseModifiers(modText);
			const children = tokensToNodesInternal(tokenize$2(inner).map((t$12) => ({
				...t$12,
				start: t$12.start + token.start + 1,
				end: t$12.end + token.start + 1
			})), input);
			nodes.push({
				type: "group",
				angle: first === "<",
				parallel: false,
				values: [],
				children,
				modifiers: modifiers$1,
				source: makeSource(input, token.start, token.end)
			});
			continue;
		}
		if (first === "(") {
			const euclid = parseEuclidToken(raw);
			const last = nodes.at(-1);
			if (euclid && last?.type === "event") {
				const pulses = Math.floor(euclid.pulses);
				const steps = Math.floor(euclid.steps);
				const offset = Math.floor(euclid.offset);
				const spanSource = makeSource(input, last.source.start, token.end);
				nodes.pop();
				const safeSteps = Number.isFinite(steps) && steps > 0 ? steps : 0;
				for (let si = 0; si < safeSteps; si++) {
					const on$1 = euclidHit(pulses, steps, si, offset);
					nodes.push(cloneEventNode(last, spanSource, on$1 ? last.values.slice() : []));
				}
				continue;
			}
			const { inner, modText } = parseGroupedTokenText(raw, "(");
			const adjustedInnerTokens = tokenize$2(inner).map((t$12) => ({
				...t$12,
				start: t$12.start + token.start + 1,
				end: t$12.end + token.start + 1
			}));
			const head = adjustedInnerTokens[0]?.text;
			if (head === "scale") {
				const { rootMidi, scaleIndex, nextIndex } = parseScaleDirective(adjustedInnerTokens, 1);
				const items = adjustedInnerTokens.slice(nextIndex);
				const children$1 = [{
					type: "scale",
					angle: false,
					parallel: false,
					values: [rootMidi, scaleIndex],
					children: [],
					modifiers: getDefaultMods(),
					source: makeSource(input, token.start, token.end)
				}, ...tokensToNodesInternal(items, input)];
				nodes.push({
					type: "group",
					angle: false,
					parallel: false,
					values: [],
					children: children$1,
					modifiers: parseModifiers(modText),
					source: makeSource(input, token.start, token.end)
				});
				continue;
			}
			if (head === "octave") {
				nodes.push({
					type: "octave",
					angle: false,
					parallel: false,
					values: [parseOctaveDelta(adjustedInnerTokens)],
					children: [],
					modifiers: getDefaultMods(),
					source: makeSource(input, token.start, token.end)
				});
				continue;
			}
			if (head === "transpose") {
				nodes.push({
					type: "transpose",
					angle: false,
					parallel: false,
					values: [parseDeltaToken(adjustedInnerTokens[1])],
					children: [],
					modifiers: getDefaultMods(),
					source: makeSource(input, token.start, token.end)
				});
				continue;
			}
			if (head === "swing") {
				nodes.push({
					type: "swing",
					angle: false,
					parallel: false,
					values: [parseDeltaToken(adjustedInnerTokens[1])],
					children: [],
					modifiers: getDefaultMods(),
					source: makeSource(input, token.start, token.end)
				});
				continue;
			}
			const modifiers$1 = parseModifiers(modText);
			const children = tokensToNodesInternal(adjustedInnerTokens, input);
			nodes.push({
				type: "group",
				angle: false,
				parallel: false,
				values: [],
				children,
				modifiers: modifiers$1,
				source: makeSource(input, token.start, token.end)
			});
			continue;
		}
		const { value, mods } = splitValueAndModifiers(raw);
		if (value === "~") {
			const modifiers$1 = parseModifiers(mods);
			nodes.push({
				type: "rest",
				angle: false,
				parallel: false,
				values: [],
				children: [],
				modifiers: modifiers$1,
				source: makeSource(input, token.start, token.end)
			});
			continue;
		}
		let valueText = value;
		if (!valueText && mods) valueText = "c4";
		if (valueText?.toLowerCase() === "x") valueText = "c4";
		const chordMatch = valueText.match(/^([ivxlcdm]+)(.*)$/i);
		if (chordMatch) {
			const roman = chordMatch[1];
			const suffix = chordMatch[2] ?? "";
			const base = romanToDegree(roman);
			if (base !== null) {
				const values$1 = parseChordSuffix(suffix).map((tone) => {
					return -(base + tone.degree + tone.semitoneAdjust / 100);
				});
				const modifiers$1 = parseModifiers(mods);
				nodes.push({
					type: "event",
					angle: false,
					parallel: false,
					values: values$1,
					children: [],
					modifiers: modifiers$1,
					source: makeSource(input, token.start, token.end)
				});
				continue;
			}
		}
		if (/^\d+(?:,\d+)*$/.test(valueText)) {
			const values$1 = valueText.split(",").filter(Boolean).map((p$6) => -parseInt(p$6, 10));
			const modifiers$1 = parseModifiers(mods);
			nodes.push({
				type: "event",
				angle: false,
				parallel: false,
				values: values$1,
				children: [],
				modifiers: modifiers$1,
				source: makeSource(input, token.start, token.end)
			});
			continue;
		}
		const values = parseValues(valueText);
		const modifiers = parseModifiers(mods);
		nodes.push({
			type: "event",
			angle: false,
			parallel: false,
			values,
			children: [],
			modifiers,
			source: makeSource(input, token.start, token.end)
		});
	}
	return nodes;
}
function tokensToNodes(tokens, input, options$2 = {}) {
	const nodes = tokensToNodesInternal(tokens, input);
	if (!(nodes.some((node) => node.type === "scale") || nodes.some((node) => node.type === "group" && node.children.some((child) => child.type === "scale")))) {
		const defaultScaleNode = {
			type: "scale",
			angle: false,
			parallel: false,
			values: [options$2.defaultScale?.rootMidi ?? noteNameToMidi("c4"), options$2.defaultScale?.scaleIndex ?? SCALE_KEY_TO_INDEX.major ?? 0],
			children: [],
			modifiers: getDefaultMods(),
			source: {
				start: 0,
				length: 0,
				text: ""
			}
		};
		nodes.unshift(defaultScaleNode);
	}
	return nodes;
}
function compileNode(node, bytecode$1, offset) {
	if (node.type === "event") return writeEventOp(bytecode$1, offset, node.values, node.modifiers);
	else if (node.type === "group") {
		const mode = node.parallel ? 2 : node.angle ? 1 : 0;
		let currentOffset = writeGroupStartOp(bytecode$1, offset, node.children.length, mode, node.modifiers);
		for (const child of node.children) currentOffset += compileNode(child, bytecode$1, offset + currentOffset);
		currentOffset += writeGroupEndOp(bytecode$1, offset + currentOffset);
		return currentOffset;
	} else if (node.type === "rest") return writeEventOp(bytecode$1, offset, [], node.modifiers);
	else if (node.type === "octave") return writeOctaveOp(bytecode$1, offset, node.values[0] ?? 0);
	else if (node.type === "transpose") return writeTransposeOp(bytecode$1, offset, node.values[0] ?? 0);
	else if (node.type === "scale") return writeScaleOp(bytecode$1, offset, node.values[0] ?? 0, node.values[1] ?? 0);
	else if (node.type === "swing") return writeSwingOp(bytecode$1, offset, node.values[0] ?? 0);
	else if (node.type === "at") {
		let currentOffset = writeCycleStartOp(bytecode$1, offset, node.values[0] ?? 0, node.values[1] ?? 0, node.children.length);
		for (const child of node.children) currentOffset += compileNode(child, bytecode$1, offset + currentOffset);
		currentOffset += writeCycleEndOp(bytecode$1, offset + currentOffset);
		return currentOffset;
	}
	return 0;
}
var cacheByMiniNotation = /* @__PURE__ */ new Map();
function compileMiniNotation(input, options$2 = {}) {
	const cacheKey = options$2.defaultScale ? `${input}|scale:${options$2.defaultScale.rootMidi ?? 60},${options$2.defaultScale.scaleIndex ?? 0}` : input;
	const cached = cacheByMiniNotation.get(cacheKey);
	if (cached) return cached;
	if (cacheByMiniNotation.size > 1e3) cacheByMiniNotation.clear();
	const nodes = tokensToNodes(tokenize$2(input), input, { defaultScale: options$2.defaultScale });
	const root = {
		type: "group",
		values: [],
		children: nodes,
		modifiers: getDefaultMods(),
		angle: false,
		parallel: false,
		source: {
			start: 0,
			length: input.length,
			text: input
		}
	};
	const bytecode$1 = allocateBytecode(1024);
	let offset = compileNode(root, bytecode$1, 0);
	bytecode$1[0] = offset;
	const usedSize = 1 + offset;
	const trimmedBytecode = bytecode$1.slice(0, usedSize);
	const sourceMap = [];
	buildMiniSourceMap(input, nodes, trimmedBytecode).forEach((location$1, index) => {
		sourceMap.push({
			eventIndex: index,
			source: {
				start: location$1.start,
				length: location$1.end - location$1.start,
				text: location$1.text
			}
		});
	});
	const result = {
		bytecode: trimmedBytecode,
		sourceMap,
		nodes
	};
	cacheByMiniNotation.set(cacheKey, result);
	return result;
}
function compileMini(state, callExpr, args) {
	let seqExpr = null;
	let barsExpr = null;
	for (const arg of args) if (arg.type === "arg" && arg.value) {
		if (arg.name === "seq" || arg.name === "sequence") seqExpr = arg.value;
		else if (arg.name === "bars") barsExpr = arg.value;
		else if (!arg.name && !seqExpr) seqExpr = arg.value;
		else if (!arg.name && !barsExpr) barsExpr = arg.value;
	}
	if (!seqExpr) {
		error(state, "mini() requires a sequence string argument", callExpr.loc.line, callExpr.loc.column);
		return;
	}
	if (seqExpr.type !== "string") {
		error(state, "mini() sequence argument must be a string literal", callExpr.loc.line, callExpr.loc.column);
		return;
	}
	const sequence = seqExpr.value;
	const compileResult = compileMiniNotation(sequence, { defaultScale: {
		rootMidi: state.rootMidi,
		scaleIndex: state.scaleIndex
	} });
	if (compileResult.bytecode.length === 0) {
		error(state, "mini() sequence is empty", callExpr.loc.line, callExpr.loc.column);
		return;
	}
	const opLength = compileResult.bytecode[0];
	const ops = compileResult.bytecode.slice(1, 1 + opLength);
	const bytecodeWithHeader = [
		compileResult.bytecode.length,
		1,
		opLength,
		...ops
	];
	const bytecodeLength = 3 + opLength;
	if (barsExpr) compileExpr(state, barsExpr);
	else {
		state.ops.push(AudioVmOp.PushScalar);
		state.ops.push(1);
		state.stack.push({ expr: {
			type: "number",
			value: 1,
			loc: callExpr.loc
		} });
	}
	const pc = state.ops.length;
	if (callExpr.loc.line > state.preludeLines) {
		const historyEntry = {
			line: callExpr.loc.line - state.preludeLines,
			column: callExpr.loc.column,
			genName: "Mini",
			pc: state.inFunction ? 0 : pc,
			inFunction: state.inFunction,
			__fromMainProgram: !state.isDeferredPass,
			sequence,
			compileResult
		};
		state.historySourceMap.push(historyEntry);
		if (state.inFunction && state.currentFunctionId !== null) {
			historyEntry.__functionId = state.currentFunctionId;
			historyEntry.__relativePc = pc;
		} else historyEntry.pc = pc;
	}
	const transposeVar = lookupVariable(state, "transpose");
	const tuneVar = lookupVariable(state, "tune");
	const transposeIdx = transposeVar && transposeVar.scope === "global" ? transposeVar.index : -1;
	const tuneIdx = tuneVar && tuneVar.scope === "global" ? tuneVar.index : -1;
	state.ops.push(AudioVmOp.Mini);
	state.ops.push(bytecodeLength + 2);
	state.ops.push(...bytecodeWithHeader);
	state.ops.push(transposeIdx);
	state.ops.push(tuneIdx);
	state.stack.pop();
	state.stack.push({ expr: callExpr });
}
var OPCODE_INFO = {
	[AudioVmOp.PushScalar]: { kind: "param" },
	[AudioVmOp.PushAudio]: { kind: "param" },
	[AudioVmOp.SetBpm]: { kind: "param" },
	[AudioVmOp.GetSystem]: { kind: "param" },
	[AudioVmOp.GetGlobal]: { kind: "param" },
	[AudioVmOp.SetGlobal]: { kind: "param" },
	[AudioVmOp.GetLocal]: { kind: "param" },
	[AudioVmOp.SetLocal]: { kind: "param" },
	[AudioVmOp.GetClosure]: { kind: "param" },
	[AudioVmOp.SetClosure]: { kind: "param" },
	[AudioVmOp.GetCellRefLocal]: { kind: "param" },
	[AudioVmOp.GetCellRefGlobal]: { kind: "param" },
	[AudioVmOp.GetCellRefClosure]: { kind: "param" },
	[AudioVmOp.PushClosure]: { kind: "param" },
	[AudioVmOp.CallFunction]: { kind: "param" },
	[AudioVmOp.ArrayPush]: { kind: "param" },
	[AudioVmOp.MakeArray]: { kind: "param" },
	[AudioVmOp.ArrayGet]: { kind: "param" },
	[AudioVmOp.Out]: { kind: "param" },
	[AudioVmOp.Solo]: { kind: "param" },
	[AudioVmOp.MathUnary]: { kind: "param" },
	[AudioVmOp.MathBinary]: { kind: "param" },
	[AudioVmOp.MathTernary]: { kind: "param" },
	[AudioVmOp.Jump]: { kind: "pc-param" },
	[AudioVmOp.JumpIfFalse]: { kind: "pc-param" },
	[AudioVmOp.JumpIfTrue]: { kind: "pc-param" },
	[AudioVmOp.PushTryBlock]: { kind: "three-param" },
	[AudioVmOp.TableLookup]: { kind: "table" },
	[AudioVmOp.Alloc]: { kind: "param" },
	[AudioVmOp.Step]: { kind: "param" },
	[AudioVmOp.Random]: { kind: "param" },
	[AudioVmOp.Write]: { kind: "none" },
	[AudioVmOp.Tram]: { kind: "table" },
	[AudioVmOp.Mini]: { kind: "table" },
	[AudioVmOp.Timeline]: { kind: "table" },
	[AudioVmOp.DefineFunction]: { kind: "define-function" }
};
function isOpcode(value) {
	return Number.isInteger(value) && value >= 0 && value < 256;
}
function getOpcodeInfo(op) {
	return OPCODE_INFO[op] ?? { kind: "none" };
}
var FUNCTION_BYTECODE_CACHE_MAX_ENTRIES = 2048;
var FUNCTION_BYTECODE_CACHE_MAX_WORDS = 2e6;
var functionBytecodeCache = /* @__PURE__ */ new Map();
var functionBytecodeCacheWords = 0;
var hashScratchF32 = new Float32Array(1);
var hashScratchU32 = new Uint32Array(hashScratchF32.buffer);
function cacheGetFunctionBytecode(key) {
	const hit = functionBytecodeCache.get(key);
	if (!hit) return;
	functionBytecodeCache.delete(key);
	functionBytecodeCache.set(key, hit);
	return hit;
}
function cachePutFunctionBytecode(key, u32) {
	const existing = functionBytecodeCache.get(key);
	if (existing) {
		functionBytecodeCacheWords -= existing.length;
		functionBytecodeCache.delete(key);
	}
	functionBytecodeCache.set(key, u32);
	functionBytecodeCacheWords += u32.length;
	while (functionBytecodeCache.size > FUNCTION_BYTECODE_CACHE_MAX_ENTRIES || functionBytecodeCacheWords > FUNCTION_BYTECODE_CACHE_MAX_WORDS) {
		const first = functionBytecodeCache.entries().next().value;
		if (!first) break;
		functionBytecodeCache.delete(first[0]);
		functionBytecodeCacheWords -= first[1].length;
	}
}
function hashFunctionBytecodeSegment(ops, startPc, segLen) {
	let h1 = -2128831035;
	let h2 = -1640531527;
	for (let i$6 = 0; i$6 < segLen; i$6++) {
		hashScratchF32[0] = ops[startPc + i$6];
		const b$4 = hashScratchU32[0];
		h1 = Math.imul(h1 ^ b$4 + i$6, 16777619);
		h2 = Math.imul(h2 ^ b$4 + (i$6 << 1), 2246822507);
	}
	return `${segLen},${h1 >>> 0},${h2 >>> 0}`;
}
function patchPcParamsInRange(ops, startIndex, delta) {
	let pc = startIndex;
	const limit = ops.length;
	while (pc < limit) {
		const value = ops[pc];
		if (!isOpcode(value)) {
			pc++;
			continue;
		}
		const info = getOpcodeInfo(value);
		pc++;
		switch (info.kind) {
			case "pc-param":
				if (pc < limit) ops[pc++] += delta;
				break;
			case "three-param":
				if (pc < limit) ops[pc++] += delta;
				if (pc < limit) ops[pc++] += delta;
				if (pc < limit) pc++;
				break;
			case "define-function":
				if (pc + 5 < limit) {
					const bytecodeLen = ops[pc + 5];
					pc += 6 + bytecodeLen;
				}
				break;
			case "param":
			case "none":
				if (info.kind === "param") pc++;
				break;
			case "table":
				if (pc < limit) {
					const len = ops[pc++];
					pc += len;
				}
				break;
		}
	}
}
function getVal(ops, pc, patchMap, add) {
	if (patchMap == null) return ops[pc] + add;
	const v$4 = patchMap.get(pc);
	return v$4 !== void 0 ? v$4 : ops[pc] + add;
}
function encodeFunctionBytecode(ops, u32View, f32View, pc, limit, outputOffset = 0, jumpTargetAdd = 0, patchMap) {
	const startPc = pc;
	const canCache = patchMap == null && pc + 6 <= limit;
	let cacheKey = null;
	let cacheSegLen = 0;
	if (canCache) {
		cacheSegLen = 6 + ops[pc + 5];
		const segEnd = pc + cacheSegLen;
		if (segEnd <= limit) {
			cacheKey = hashFunctionBytecodeSegment(ops, pc, cacheSegLen);
			const cached = cacheGetFunctionBytecode(cacheKey);
			if (cached) {
				u32View.set(cached, outputOffset + pc);
				return segEnd;
			}
		} else {
			cacheKey = null;
			cacheSegLen = 0;
		}
	}
	for (let i$6 = 0; i$6 < 5 && pc < limit; i$6++) {
		f32View[outputOffset + pc] = getVal(ops, pc, patchMap, 0);
		pc++;
	}
	if (pc >= limit) return pc;
	const bytecodeLen = ops[pc];
	f32View[outputOffset + pc] = bytecodeLen;
	pc++;
	const bodyEnd = pc + bytecodeLen;
	const bodyJumpAdd = 0;
	while (pc < bodyEnd && pc < limit) {
		const value = ops[pc];
		if (!isOpcode(value)) {
			f32View[outputOffset + pc] = getVal(ops, pc, patchMap, 0);
			pc++;
			continue;
		}
		const opcode = value;
		const info = getOpcodeInfo(opcode);
		u32View[outputOffset + pc] = opcode;
		pc++;
		switch (info.kind) {
			case "none": break;
			case "param":
				if (pc < limit && pc < bodyEnd) {
					f32View[outputOffset + pc] = getVal(ops, pc, patchMap, 0);
					pc++;
				}
				break;
			case "pc-param":
				if (pc < limit && pc < bodyEnd) {
					f32View[outputOffset + pc] = getVal(ops, pc, patchMap, bodyJumpAdd);
					pc++;
				}
				break;
			case "three-param":
				if (pc < limit && pc < bodyEnd) f32View[outputOffset + pc] = getVal(ops, pc, patchMap, bodyJumpAdd);
				pc++;
				if (pc < limit && pc < bodyEnd) f32View[outputOffset + pc] = getVal(ops, pc, patchMap, bodyJumpAdd);
				pc++;
				if (pc < limit && pc < bodyEnd) f32View[outputOffset + pc] = getVal(ops, pc, patchMap, 0);
				pc++;
				break;
			case "table": {
				if (pc >= limit || pc >= bodyEnd) break;
				const len = ops[pc];
				f32View[outputOffset + pc] = len;
				pc++;
				for (let j$4 = 0; j$4 < len && pc < limit && pc < bodyEnd; j$4++) {
					f32View[outputOffset + pc] = getVal(ops, pc, patchMap, 0);
					pc++;
				}
				break;
			}
			case "define-function":
				pc = encodeFunctionBytecode(ops, u32View, f32View, pc, Math.min(limit, bodyEnd), outputOffset, jumpTargetAdd, patchMap);
				break;
		}
	}
	if (cacheKey && cacheSegLen > 0 && pc === startPc + cacheSegLen) {
		const encoded = u32View.slice(outputOffset + startPc, outputOffset + startPc + cacheSegLen);
		cachePutFunctionBytecode(cacheKey, encoded);
	}
	return pc;
}
function encodeToBuffer(ops, u32View, f32View, outputOffset, jumpTargetAdd, patchMap) {
	const limit = ops.length;
	let pc = 0;
	while (pc < limit) {
		const value = ops[pc];
		if (!isOpcode(value)) {
			f32View[outputOffset + pc] = getVal(ops, pc, patchMap, 0);
			pc++;
			continue;
		}
		const opcode = value;
		const info = getOpcodeInfo(opcode);
		u32View[outputOffset + pc] = opcode;
		pc++;
		switch (info.kind) {
			case "none": break;
			case "param":
				if (pc < limit) {
					f32View[outputOffset + pc] = getVal(ops, pc, patchMap, 0);
					pc++;
				}
				break;
			case "pc-param":
				if (pc < limit) {
					f32View[outputOffset + pc] = getVal(ops, pc, patchMap, jumpTargetAdd);
					pc++;
				}
				break;
			case "three-param":
				if (pc < limit) f32View[outputOffset + pc] = getVal(ops, pc, patchMap, jumpTargetAdd);
				pc++;
				if (pc < limit) f32View[outputOffset + pc] = getVal(ops, pc, patchMap, jumpTargetAdd);
				pc++;
				if (pc < limit) f32View[outputOffset + pc] = getVal(ops, pc, patchMap, 0);
				pc++;
				break;
			case "table": {
				if (pc >= limit) break;
				const len = ops[pc];
				f32View[outputOffset + pc] = len;
				pc++;
				for (let i$6 = 0; i$6 < len && pc < limit; i$6++) {
					f32View[outputOffset + pc] = getVal(ops, pc, patchMap, 0);
					pc++;
				}
				break;
			}
			case "define-function":
				pc = encodeFunctionBytecode(ops, u32View, f32View, pc, limit, outputOffset, jumpTargetAdd, patchMap);
				break;
		}
	}
}
function encodeBytecode(ops, u32View, f32View) {
	encodeToBuffer(ops, u32View, f32View, 0, 0);
}
function encodeCallbackBytecode(ops) {
	const buffer = /* @__PURE__ */ new ArrayBuffer(ops.length * 4);
	const u32View = new Uint32Array(buffer);
	const f32View = new Float32Array(buffer);
	encodeBytecode(ops, u32View, f32View);
	return f32View;
}
function collectGlobalIndicesFromOps(ops, start, end, out) {
	let pc = start;
	while (pc < end) {
		const value = ops[pc];
		if (!isOpcode(value)) {
			pc++;
			continue;
		}
		const info = getOpcodeInfo(value);
		pc++;
		switch (info.kind) {
			case "param":
				if (value === AudioVmOp.GetGlobal && pc < end) out.add(Math.round(ops[pc]));
				pc++;
				break;
			case "define-function":
				if (pc + 5 < end) {
					const bodyLen = Math.round(ops[pc + 5]);
					const bodyStart = pc + 6;
					const bodyEnd = bodyStart + bodyLen;
					collectGlobalIndicesFromOps(ops, bodyStart, Math.min(bodyEnd, end), out);
					pc = bodyEnd;
				}
				break;
			case "pc-param":
			case "three-param":
				if (info.kind === "pc-param") pc++;
				else pc += 3;
				break;
			case "table":
				if (pc < end) {
					const len = Math.round(ops[pc]);
					pc += 1 + len;
				}
				break;
			case "none": break;
		}
	}
}
function collectCalleeNamesFromBody(expr, out) {
	if (expr.type === "call") {
		if (expr.callee.type === "identifier") out.add(expr.callee.name);
		collectCalleeNamesFromBody(expr.callee, out);
		for (const a$36 of expr.args) if (a$36.type === "arg") collectCalleeNamesFromBody(a$36.value, out);
		return;
	}
	switch (expr.type) {
		case "number":
		case "string":
		case "identifier": return;
		case "fn":
			if (expr.body.type === "block") for (const s$4 of expr.body.body) collectCalleeNamesFromStmt(s$4, out);
			else collectCalleeNamesFromBody(expr.body, out);
			return;
		case "array":
			for (const it$1 of expr.items) collectCalleeNamesFromBody(it$1, out);
			return;
		case "index":
			collectCalleeNamesFromBody(expr.object, out);
			collectCalleeNamesFromBody(expr.index, out);
			return;
		case "member":
			collectCalleeNamesFromBody(expr.object, out);
			return;
		case "unary":
			collectCalleeNamesFromBody(expr.expr, out);
			return;
		case "binary":
			collectCalleeNamesFromBody(expr.left, out);
			collectCalleeNamesFromBody(expr.right, out);
			return;
		case "ternary":
			collectCalleeNamesFromBody(expr.test, out);
			collectCalleeNamesFromBody(expr.then, out);
			collectCalleeNamesFromBody(expr.else, out);
			return;
		case "assign":
			collectCalleeNamesFromBody(expr.left, out);
			collectCalleeNamesFromBody(expr.right, out);
			return;
		case "destructure": return;
	}
}
function collectCalleeNamesFromStmt(stmt, out) {
	if (stmt.type === "expr") return collectCalleeNamesFromBody(stmt.expr, out);
	if (stmt.type === "block") {
		for (const s$4 of stmt.body) collectCalleeNamesFromStmt(s$4, out);
		return;
	}
	const withTest = stmt;
	if (withTest.test) collectCalleeNamesFromBody(withTest.test, out);
	if (withTest.then) collectCalleeNamesFromStmt(withTest.then, out);
	if (withTest.else) collectCalleeNamesFromStmt(withTest.else, out);
	if (withTest.body) collectCalleeNamesFromStmt(withTest.body, out);
	if (withTest.from) collectCalleeNamesFromBody(withTest.from, out);
	if (withTest.to) collectCalleeNamesFromBody(withTest.to, out);
	if (withTest.iterable) collectCalleeNamesFromBody(withTest.iterable, out);
	const withValue = stmt;
	if (withValue.value && typeof withValue.value === "object" && "type" in withValue.value) collectCalleeNamesFromBody(withValue.value, out);
}
function addCallSiteToSampleRegistrations(state, handle, scopeId, seconds) {
	if (!state.sampleRegistrations.some((reg) => reg.type === "record" && reg.recordCallbackId === scopeId && reg.handle === handle && reg.recordSeconds === seconds)) state.sampleRegistrations.push({
		handle,
		type: "record",
		recordSeconds: seconds,
		recordCallbackId: scopeId,
		recordProjectId: state.projectId
	});
}
function processRecordCall(state, callExpr, callbackId, templateLocKey) {
	const args = callExpr.args;
	if (args.length !== 2) {
		error(state, "record() requires exactly 2 arguments: seconds and callback", callExpr.loc);
		return;
	}
	const secondsArg = args[0]?.type === "arg" ? args[0].value : null;
	const callbackArg = args[1]?.type === "arg" ? args[1].value : null;
	if (!secondsArg || secondsArg.type !== "number") {
		error(state, "record() seconds must be a literal number", callExpr.loc);
		return;
	}
	let callbackFn;
	if (callbackArg?.type === "identifier") {
		if (!getFunctionByName(state, callbackArg.name)) {
			error(state, `record() callback must be a function, but '${callbackArg.name}' is not a function`, callExpr.loc);
			return;
		}
		callbackFn = {
			type: "fn",
			params: [],
			defaults: [],
			body: {
				type: "call",
				callee: callbackArg,
				args: [],
				loc: callbackArg.loc
			},
			loc: callbackArg.loc
		};
	} else if (callbackArg?.type === "fn") callbackFn = callbackArg;
	else {
		error(state, "record() callback must be a function expression or function reference", callExpr.loc);
		return;
	}
	const seconds = Math.max(0, Math.min(10, secondsArg.value));
	const scopeId = callbackId !== -1 ? callbackId : state.nextRecordScopeId++;
	const capturedVars = detectCapturedVarsInBody(state, callbackFn.body);
	const calleeNames = /* @__PURE__ */ new Set();
	if (callbackFn.body.type === "block") for (const s$4 of callbackFn.body.body) collectCalleeNamesFromStmt(s$4, calleeNames);
	else collectCalleeNamesFromBody(callbackFn.body, calleeNames);
	const savedOps = state.ops;
	const savedStack = state.stack;
	const savedLocals = state.locals;
	const savedClosureVars = state.closureVars;
	const savedGlobals = new Map(state.globals);
	const resolveToCanonical = (n$4) => state.functionAliases.get(n$4) ?? n$4;
	const isPreludeFunction = (info) => info.definitionLine != null && info.definitionLine <= state.preludeLines;
	const hasGlobalFnCache = /* @__PURE__ */ new Map();
	const hasGlobalFn = (name) => {
		if (hasGlobalFnCache.has(name)) return hasGlobalFnCache.get(name);
		const v$4 = hasGlobalFunctionByName(state, name);
		hasGlobalFnCache.set(name, v$4);
		return v$4;
	};
	const globalFnMap = state.functionsByNameStack[0];
	const funcIdToGlobalName = /* @__PURE__ */ new Map();
	for (const [name, info] of globalFnMap) funcIdToGlobalName.set(info.id, name);
	const canonicalToAliases = /* @__PURE__ */ new Map();
	for (const [alias, target] of state.functionAliases) {
		const existing = canonicalToAliases.get(target);
		if (existing) existing.push(alias);
		else canonicalToAliases.set(target, [alias]);
	}
	const requiredNames = new Set(calleeNames);
	const indexToName = /* @__PURE__ */ new Map();
	for (const [name, info] of savedGlobals) if (info.scope === "global") indexToName.set(info.index, name);
	const requiredQueue = Array.from(requiredNames);
	const enqueueRequired = (name) => {
		if (requiredNames.has(name)) return;
		requiredNames.add(name);
		requiredQueue.push(name);
	};
	const enqueueCanonicalIfGlobal = (name) => {
		const canonical = resolveToCanonical(name);
		if (canonical !== name && hasGlobalFn(canonical)) enqueueRequired(canonical);
	};
	const tmpCallees = /* @__PURE__ */ new Set();
	while (requiredQueue.length > 0) {
		const name = requiredQueue.pop();
		enqueueCanonicalIfGlobal(name);
		const funcInfo = globalFnMap.get(name);
		if (!funcInfo) continue;
		for (const defaultExpr of funcInfo.defaultParamExprs ?? []) {
			if (!defaultExpr) continue;
			tmpCallees.clear();
			collectCalleeNamesFromBody(defaultExpr, tmpCallees);
			for (const callee of tmpCallees) {
				enqueueRequired(callee);
				enqueueCanonicalIfGlobal(callee);
			}
		}
		const bytecode$1 = state.functionBytecodes.get(funcInfo.id);
		if (!bytecode$1) continue;
		const indices = /* @__PURE__ */ new Set();
		collectGlobalIndicesFromOps(bytecode$1, 0, bytecode$1.length, indices);
		for (const idx of indices) {
			const refName = indexToName.get(idx);
			if (!refName) continue;
			const canonical = resolveToCanonical(refName) ?? refName;
			if (hasGlobalFn(canonical)) enqueueRequired(canonical);
		}
	}
	const defaultParamFnToRecordGlobal = /* @__PURE__ */ new Map();
	const enclosingDefaultParamNameToSlot = /* @__PURE__ */ new Map();
	const enclosingDefaultParams = state.currentFunctionId !== null ? state.functionIdToDefaultParamFunctions.get(state.currentFunctionId) : void 0;
	if (enclosingDefaultParams) for (const [paramName, defaultFnId] of enclosingDefaultParams) {
		const recordGlobalIdx = state.nextRecordGlobalIdx++;
		defaultParamFnToRecordGlobal.set(defaultFnId, recordGlobalIdx);
		enclosingDefaultParamNameToSlot.set(paramName, recordGlobalIdx);
	}
	for (const funcInfo of state.functions) {
		const fnName = funcIdToGlobalName.get(funcInfo.id);
		const isRequired = fnName !== void 0 && requiredNames.has(fnName);
		const isPrelude = isPreludeFunction(funcInfo);
		if (!isRequired && !isPrelude) continue;
		const thisDefaultParams = state.functionIdToDefaultParamFunctions.get(funcInfo.id);
		if (!thisDefaultParams) continue;
		for (const [paramName, defaultFnId] of thisDefaultParams) {
			if (defaultParamFnToRecordGlobal.has(defaultFnId)) continue;
			const recordGlobalIdx = state.nextRecordGlobalIdx++;
			defaultParamFnToRecordGlobal.set(defaultFnId, recordGlobalIdx);
		}
	}
	const dependencies = [];
	const recordGlobalIndices = [];
	const capturedVarMapping = /* @__PURE__ */ new Map();
	const scalarCaptureSources = [];
	for (const { name, info } of capturedVars) {
		const canonical = resolveToCanonical(name);
		if (hasGlobalFn(name) || hasGlobalFn(canonical)) continue;
		if (calleeNames.has(name) && info.scope === "global") continue;
		if (info.scope === "local" && enclosingDefaultParamNameToSlot.has(name)) {
			const recordGlobalIdx$1 = enclosingDefaultParamNameToSlot.get(name);
			dependencies.push({
				name,
				scope: info.scope,
				sourceIndex: info.index
			});
			recordGlobalIndices.push(recordGlobalIdx$1);
			capturedVarMapping.set(name, recordGlobalIdx$1);
			scalarCaptureSources.push({
				scope: info.scope,
				sourceIndex: info.index
			});
			continue;
		}
		const recordGlobalIdx = state.nextRecordGlobalIdx++;
		if (calleeNames.has(name) && (info.scope === "local" || info.scope === "closure")) {
			dependencies.push({
				name,
				scope: info.scope,
				sourceIndex: info.index
			});
			recordGlobalIndices.push(recordGlobalIdx);
			capturedVarMapping.set(name, recordGlobalIdx);
			continue;
		}
		dependencies.push({
			name,
			scope: info.scope,
			sourceIndex: info.index
		});
		recordGlobalIndices.push(recordGlobalIdx);
		capturedVarMapping.set(name, recordGlobalIdx);
		scalarCaptureSources.push({
			scope: info.scope,
			sourceIndex: info.index
		});
	}
	for (const funcInfo of state.functions) {
		const fnName = funcIdToGlobalName.get(funcInfo.id);
		if (!(fnName !== void 0 && requiredNames.has(fnName) || defaultParamFnToRecordGlobal.has(funcInfo.id)) || !(funcInfo.closureVars?.length ?? 0)) continue;
		for (const name of funcInfo.closureVars) {
			if (capturedVarMapping.has(name)) continue;
			const info = savedGlobals.get(name);
			if (info?.scope !== "global") continue;
			const recordGlobalIdx = state.nextRecordGlobalIdx++;
			const canonical = resolveToCanonical(name);
			dependencies.push({
				name,
				scope: "global",
				sourceIndex: info.index
			});
			recordGlobalIndices.push(recordGlobalIdx);
			capturedVarMapping.set(name, recordGlobalIdx);
			if (hasGlobalFn(name) || hasGlobalFn(canonical)) continue;
			scalarCaptureSources.push({
				scope: "global",
				sourceIndex: info.index
			});
		}
	}
	let captureStoreGlobalIdx = 0;
	const captureOps = [];
	state.locals = [/* @__PURE__ */ new Map()];
	state.closureVars = [];
	state.globals = new Map(savedGlobals);
	for (const [name, destGlobalIdx] of capturedVarMapping) state.globals.set(name, {
		scope: "global",
		index: destGlobalIdx
	});
	const loopOps = [];
	state.ops = loopOps;
	state.stack = [];
	state.compilingRecordCallback = true;
	if (callbackFn.body.type === "block") compileFunctionBlock(state, callbackFn.body);
	else compileExpr(state, callbackFn.body);
	if (state.stack.length > 0) {
		loopOps.push(AudioVmOp.Solo);
		loopOps.push(1);
		state.stack.pop();
	}
	loopOps.push(AudioVmOp.Post);
	state.compilingRecordCallback = false;
	const loopBytecode = encodeCallbackBytecode(loopOps);
	const numDepsFinal = scalarCaptureSources.length;
	if (callbackId !== -1) {
		if (!state.scopeCaptureGlobals.has(scopeId)) {
			captureStoreGlobalIdx = state.nextGlobalIndex++;
			state.scopeCaptureGlobals.set(scopeId, captureStoreGlobalIdx);
			state.arrayInitRequests.push({
				capacity: Math.max(1, numDepsFinal),
				globalIdx: captureStoreGlobalIdx
			});
		} else captureStoreGlobalIdx = state.scopeCaptureGlobals.get(scopeId);
		for (let depIndex = 0; depIndex < scalarCaptureSources.length; depIndex++) {
			const { scope, sourceIndex } = scalarCaptureSources[depIndex];
			captureOps.push(AudioVmOp.GetGlobal, captureStoreGlobalIdx, AudioVmOp.PushScalar, depIndex);
			if (scope === "global") captureOps.push(AudioVmOp.GetGlobal, sourceIndex);
			else if (scope === "local") captureOps.push(AudioVmOp.GetLocal, sourceIndex);
			else captureOps.push(AudioVmOp.GetClosure, sourceIndex);
			captureOps.push(AudioVmOp.ArraySet);
		}
	}
	const setupOps = [];
	state.stack = [];
	let maxSetupGlobalIndex = -1;
	for (const funcInfo of state.functions) {
		const fnName = funcIdToGlobalName.get(funcInfo.id);
		if (!(fnName !== void 0 && requiredNames.has(fnName) || defaultParamFnToRecordGlobal.has(funcInfo.id)) && !isPreludeFunction(funcInfo)) continue;
		const funcBytecode = state.functionBytecodes.get(funcInfo.id);
		if (!funcBytecode) continue;
		const closureCount = funcInfo.closureVars ? funcInfo.closureVars.length : 0;
		if (closureCount > 0) {
			const dummyCellRefGlobalIdx = 0;
			const thisDefaultParams = state.functionIdToDefaultParamFunctions.get(funcInfo.id);
			for (const name of funcInfo.closureVars) {
				const info = savedGlobals.get(name);
				const defaultFnId = thisDefaultParams?.get(name);
				let idx;
				if (defaultFnId !== void 0 && defaultParamFnToRecordGlobal.has(defaultFnId)) idx = defaultParamFnToRecordGlobal.get(defaultFnId);
				else if (capturedVarMapping.has(name)) idx = capturedVarMapping.get(name);
				else if (info?.scope === "global") idx = info.index;
				else idx = dummyCellRefGlobalIdx;
				if (idx > maxSetupGlobalIndex) maxSetupGlobalIndex = idx;
				setupOps.push(AudioVmOp.GetCellRefGlobal);
				setupOps.push(idx);
			}
		}
		setupOps.push(AudioVmOp.DefineFunction);
		setupOps.push(funcInfo.id);
		setupOps.push(funcInfo.paramCount);
		setupOps.push(funcInfo.firstParamIn);
		setupOps.push(closureCount);
		setupOps.push(funcInfo.localCount ?? 0);
		setupOps.push(funcBytecode.length);
		for (let k$4 = 0; k$4 < funcBytecode.length; k$4++) setupOps.push(funcBytecode[k$4]);
		const recordGlobalForDefaultParam = defaultParamFnToRecordGlobal.get(funcInfo.id);
		if (!fnName) {
			if (recordGlobalForDefaultParam !== void 0) {
				if (recordGlobalForDefaultParam > maxSetupGlobalIndex) maxSetupGlobalIndex = recordGlobalForDefaultParam;
				setupOps.push(AudioVmOp.SetGlobal);
				setupOps.push(recordGlobalForDefaultParam);
			} else setupOps.push(AudioVmOp.Pop);
			continue;
		}
		const targetNames = [fnName].concat(canonicalToAliases.get(fnName) ?? []);
		const indicesToSet = [];
		for (const name of targetNames) {
			const globalInfo = savedGlobals.get(name);
			if (globalInfo?.scope === "global") indicesToSet.push(globalInfo.index);
			const capturedIdx = capturedVarMapping.get(name);
			if (capturedIdx !== void 0) indicesToSet.push(capturedIdx);
		}
		for (let i$6 = 0; i$6 < indicesToSet.length; i$6++) {
			if (i$6 < indicesToSet.length - 1) setupOps.push(AudioVmOp.Dup);
			const idx = indicesToSet[i$6];
			if (idx > maxSetupGlobalIndex) maxSetupGlobalIndex = idx;
			setupOps.push(AudioVmOp.SetGlobal);
			setupOps.push(idx);
		}
	}
	const setupBytecode = encodeCallbackBytecode(setupOps);
	const maxSetupGlobalIndexFinal = maxSetupGlobalIndex >= 0 ? maxSetupGlobalIndex : void 0;
	state.globals = savedGlobals;
	state.locals = savedLocals;
	state.closureVars = savedClosureVars;
	const defaultParamRecordGlobals = defaultParamFnToRecordGlobal.size > 0 ? Array.from(defaultParamFnToRecordGlobal.values()) : void 0;
	const recordCallbackPayload = {
		setup: setupBytecode,
		loop: loopBytecode,
		dependencies,
		recordGlobalIndices,
		captureStoreGlobalIdx,
		defaultParamRecordGlobals,
		maxSetupGlobalIndex: maxSetupGlobalIndexFinal
	};
	if (callbackId !== -1) state.recordCallbacks.set(callbackId, recordCallbackPayload);
	else if (templateLocKey !== void 0) state.recordCallbackTemplates.set(templateLocKey, recordCallbackPayload);
	state.ops = savedOps;
	state.stack = savedStack;
	if (callbackId !== -1) state.ops.push(...captureOps);
	let handle;
	if (callbackId === -1) handle = 0;
	else {
		handle = sampleManager.registerRecord(state.projectId, seconds, scopeId);
		state.sampleRegistrations.push({
			handle,
			type: "record",
			recordSeconds: seconds,
			recordCallbackId: scopeId,
			recordProjectId: state.projectId
		});
		state.ops.push(AudioVmOp.Pop);
		state.ops.push(AudioVmOp.Pop);
		if (state.stack.length >= 2) {
			state.stack.pop();
			state.stack.pop();
		}
		state.ops.push(AudioVmOp.PushScalar);
		state.ops.push(handle);
	}
	state.stack.push({ expr: callExpr });
}
function processRecordCallSite(state, callExpr, funcName, funcInfo, callSiteId) {
	const recordCallLocKey = state.functionToRecordCall.get(funcName);
	if (!recordCallLocKey) return;
	const recordCallExpr = state.recordCallExprs.get(recordCallLocKey);
	if (!recordCallExpr) return;
	const args = recordCallExpr.args;
	const secondsArg = args[0]?.type === "arg" ? args[0].value : null;
	if (!secondsArg || secondsArg.type !== "number") return;
	const seconds = Math.max(0, Math.min(10, secondsArg.value));
	const handle = sampleManager.registerRecord(state.projectId, seconds, callSiteId);
	const template = state.recordCallbackTemplates.get(recordCallLocKey);
	if (!template) return;
	const scopeId = callSiteId;
	if (state.recordCaptureStoresByScopeGlobal === null) state.recordCaptureStoresByScopeGlobal = state.nextGlobalIndex++;
	const captureStoreGlobalIdx = state.recordCaptureStoresByScopeGlobal;
	if (state.currentRecordScopeIdGlobal !== null) state.ops.push(AudioVmOp.PushScalar, scopeId, AudioVmOp.SetGlobal, state.currentRecordScopeIdGlobal);
	if (state.recordHandleByScopeGlobal !== null) {
		state.callSiteIdToHandle.set(scopeId, handle);
		state.ops.push(AudioVmOp.GetGlobal, state.recordHandleByScopeGlobal, AudioVmOp.PushScalar, scopeId, AudioVmOp.PushScalar, handle, AudioVmOp.ArraySet);
	}
	state.recordCallbacks.set(scopeId, {
		...template,
		captureStoreGlobalIdx,
		useNestedCaptureStore: true
	});
	addCallSiteToSampleRegistrations(state, handle, scopeId, seconds);
}
function compileRecord(state, callExpr) {
	const locKey = `${callExpr.loc.line}:${callExpr.loc.column}:${callExpr.loc.start}:${callExpr.loc.end}`;
	const callbackId = state.recordCallIds.get(locKey);
	if (callbackId === void 0) {
		state.recordCallExprs.set(locKey, callExpr);
		const args = callExpr.args;
		const secondsArg = args[0]?.type === "arg" ? args[0].value : null;
		const callbackArg = args[1]?.type === "arg" ? args[1].value : null;
		if (!secondsArg || secondsArg.type !== "number") {
			error(state, "record() seconds must be a literal number", callExpr.loc);
			return;
		}
		if (!callbackArg) {
			error(state, "record() requires exactly 2 arguments: seconds and callback", callExpr.loc);
			return;
		}
		const opsBeforeRecord = state.ops.length;
		compileExpr(state, secondsArg);
		compileExpr(state, callbackArg);
		processRecordCall(state, callExpr, -1, locKey);
		if (state.recordHandleByScopeGlobal === null) {
			state.recordHandleByScopeGlobal = state.nextGlobalIndex++;
			const maxScopeId = state.recordCallIds.size > 0 ? Math.max(...state.recordCallIds.values()) : 0;
			const capacity = Math.max(100, maxScopeId + 1);
			state.arrayInitRequests.push({
				capacity,
				globalIdx: state.recordHandleByScopeGlobal
			});
		}
		if (state.currentRecordScopeIdGlobal === null) state.currentRecordScopeIdGlobal = state.nextGlobalIndex++;
		const tempCallbackData = state.recordCallbackTemplates.get(locKey);
		state.ops.length = opsBeforeRecord;
		state.ops.push(AudioVmOp.Pop);
		state.ops.push(AudioVmOp.Pop);
		if (state.recordCaptureStoresByScopeGlobal === null) state.recordCaptureStoresByScopeGlobal = state.nextGlobalIndex++;
		if (state.recordHandleByScopeGlobal !== null && state.currentRecordScopeIdGlobal !== null) state.ops.push(AudioVmOp.GetGlobal, state.recordHandleByScopeGlobal, AudioVmOp.GetGlobal, state.currentRecordScopeIdGlobal, AudioVmOp.ArrayGet, 0);
		else state.ops.push(AudioVmOp.PushScalar, 0);
		if (tempCallbackData && state.recordCaptureStoresByScopeGlobal !== null && state.currentRecordScopeIdGlobal !== null) for (let depIndex = 0; depIndex < tempCallbackData.dependencies.length; depIndex++) {
			const dep = tempCallbackData.dependencies[depIndex];
			state.ops.push(AudioVmOp.GetGlobal, state.recordCaptureStoresByScopeGlobal, AudioVmOp.GetGlobal, state.currentRecordScopeIdGlobal, AudioVmOp.ArrayGet);
			state.ops.push(AudioVmOp.Dup);
			state.ops.push(AudioVmOp.PushScalar, depIndex);
			if (dep.scope === "global") state.ops.push(AudioVmOp.GetGlobal, dep.sourceIndex);
			else if (dep.scope === "local") state.ops.push(AudioVmOp.GetLocal, dep.sourceIndex);
			else state.ops.push(AudioVmOp.GetClosure, dep.sourceIndex);
			state.ops.push(AudioVmOp.ArraySet);
		}
		return;
	}
	processRecordCall(state, callExpr, callbackId);
}
function compileTimeline(state, callExpr, args) {
	let seqExpr = null;
	let colorExpr = null;
	for (const arg of args) if (arg.type === "arg" && arg.value) {
		if (arg.name === "pattern" || arg.name === "seq" || arg.name === "sequence") seqExpr = arg.value;
		else if (arg.name === "color") colorExpr = arg.value;
		else if (!arg.name) {
			if (!seqExpr) seqExpr = arg.value;
			else if (!colorExpr) colorExpr = arg.value;
		}
	}
	if (!seqExpr) {
		error(state, "timeline() requires a pattern string argument", callExpr.loc);
		return;
	}
	if (seqExpr.type !== "string") {
		error(state, "timeline() pattern argument must be a string literal", callExpr.loc);
		return;
	}
	let colorIndex;
	if (colorExpr) {
		if (colorExpr.type !== "number") {
			error(state, "timeline() color argument must be a number 0-5 (red,green,yellow,blue,purple,cyan)", callExpr.loc);
			return;
		}
		const n$4 = Math.floor(Number(colorExpr.value));
		if (n$4 < 0 || n$4 > 5) {
			error(state, "timeline() color argument must be 0-5", callExpr.loc);
			return;
		}
		colorIndex = n$4;
	}
	const sequence = seqExpr.value;
	const compiled = compileTimelineNotation(sequence);
	if (compiled.bytecode.length <= 1) {
		error(state, "timeline() pattern is empty or invalid", callExpr.loc);
		return;
	}
	const bytecodeLength = compiled.bytecode.length;
	const pc = state.ops.length;
	if (callExpr.loc.line > state.preludeLines) {
		const historyEntry = {
			line: callExpr.loc.line - state.preludeLines,
			column: callExpr.loc.column,
			genName: "Timeline",
			pc: state.inFunction ? 0 : pc,
			inFunction: state.inFunction,
			__fromMainProgram: !state.isDeferredPass,
			sequence,
			timelineSegmentTokens: compiled.tokens.map((t$12) => ({
				fromTokenStart: t$12.fromTokenStart,
				fromTokenLength: t$12.fromTokenLength,
				toTokenStart: t$12.toTokenStart,
				toTokenLength: t$12.toTokenLength
			})),
			...colorIndex !== void 0 && { timelineColorIndex: colorIndex }
		};
		state.historySourceMap.push(historyEntry);
		if (state.inFunction && state.currentFunctionId !== null) {
			historyEntry.__functionId = state.currentFunctionId;
			historyEntry.__relativePc = pc;
		} else historyEntry.pc = pc;
	}
	state.ops.push(AudioVmOp.Timeline);
	state.ops.push(bytecodeLength);
	for (let i$6 = 0; i$6 < bytecodeLength; i$6++) state.ops.push(compiled.bytecode[i$6]);
	state.stack.push({ expr: callExpr });
}
function parseTramSequence(sequence) {
	const bytecode$1 = [];
	const beatMapping = [];
	let i$6 = 0;
	let linearIndex = 0;
	const parseSubsequenceInto = (target, startCharIndex) => {
		let beatCount = 0;
		let charIndex = startCharIndex;
		const startLinearIndex = linearIndex;
		while (i$6 < sequence.length) {
			const ch = sequence[i$6];
			const charStart = charIndex;
			if (ch === "X") {
				target.push(2);
				beatMapping.push({
					linearIndex: linearIndex++,
					startCol: charStart + 1,
					endCol: charStart + 2
				});
				beatCount++;
				i$6++;
				charIndex++;
			} else if (ch === "x") {
				target.push(1);
				beatMapping.push({
					linearIndex: linearIndex++,
					startCol: charStart + 1,
					endCol: charStart + 2
				});
				beatCount++;
				i$6++;
				charIndex++;
			} else if (ch === ".") {
				target.push(.5);
				beatMapping.push({
					linearIndex: linearIndex++,
					startCol: charStart + 1,
					endCol: charStart + 2
				});
				beatCount++;
				i$6++;
				charIndex++;
			} else if (ch === "-") {
				target.push(0);
				beatMapping.push({
					linearIndex: linearIndex++,
					startCol: charStart + 1,
					endCol: charStart + 2
				});
				beatCount++;
				i$6++;
				charIndex++;
			} else if (ch === "[") {
				i$6++;
				charIndex++;
				target.push(-1);
				const subContent = [];
				const subResult = parseSubsequenceInto(subContent, charIndex);
				const subBeatCount = subResult.beatCount;
				target.push(subBeatCount);
				target.push(...subContent);
				beatCount++;
				charIndex = subResult.endCharIndex;
			} else if (ch === "]") {
				i$6++;
				charIndex++;
				break;
			} else {
				i$6++;
				charIndex++;
			}
		}
		return {
			beatCount,
			endCharIndex: charIndex,
			linearIndex: linearIndex - startLinearIndex
		};
	};
	parseSubsequenceInto(bytecode$1, 0);
	return {
		bytecode: bytecode$1,
		beatMapping
	};
}
function compileTram(state, callExpr, args) {
	let seqExpr = null;
	let barsExpr = null;
	for (const arg of args) if (arg.type === "arg" && arg.value) {
		if (arg.name === "seq" || arg.name === "sequence") seqExpr = arg.value;
		else if (arg.name === "bars") barsExpr = arg.value;
		else if (!arg.name && !seqExpr) seqExpr = arg.value;
		else if (!arg.name && !barsExpr) barsExpr = arg.value;
	}
	if (!seqExpr) {
		error(state, "tram() requires a sequence string argument", callExpr.loc);
		return;
	}
	if (seqExpr.type !== "string") {
		error(state, "tram() sequence argument must be a string literal", callExpr.loc);
		return;
	}
	const sequence = seqExpr.value;
	const parseResult = parseTramSequence(sequence);
	if (parseResult.bytecode.length === 0) {
		error(state, "tram() sequence is empty", callExpr.loc);
		return;
	}
	if (barsExpr) compileExpr(state, barsExpr);
	else {
		state.ops.push(AudioVmOp.PushScalar);
		state.ops.push(1);
		state.stack.push({ expr: {
			type: "number",
			value: 1,
			loc: callExpr.loc
		} });
	}
	const pc = state.ops.length;
	if (callExpr.loc.line > state.preludeLines) {
		const historyEntry = {
			line: callExpr.loc.line - state.preludeLines,
			column: callExpr.loc.column,
			genName: "Tram",
			pc: state.inFunction ? 0 : pc,
			inFunction: state.inFunction,
			__fromMainProgram: !state.isDeferredPass,
			tramBeatMapping: parseResult.beatMapping.map((m$5) => ({
				linearIndex: m$5.linearIndex,
				startCol: seqExpr.loc.column + m$5.startCol,
				endCol: seqExpr.loc.column + m$5.endCol
			}))
		};
		state.historySourceMap.push(historyEntry);
		if (state.inFunction && state.currentFunctionId !== null) {
			historyEntry.__functionId = state.currentFunctionId;
			historyEntry.__relativePc = pc;
		} else historyEntry.pc = pc;
	}
	const bytecode$1 = parseResult.bytecode;
	const tramLen = bytecode$1.length;
	if (!Number.isInteger(tramLen) || tramLen <= 0) {
		error(state, "tram() bytecode length invalid", callExpr.loc);
		return;
	}
	for (let b$4 = 0; b$4 < tramLen; b$4++) {
		const v$4 = bytecode$1[b$4];
		if (typeof v$4 !== "number" || !Number.isFinite(v$4)) {
			error(state, "tram() bytecode contains invalid value", callExpr.loc);
			return;
		}
	}
	state.ops.push(AudioVmOp.Tram);
	state.ops.push(tramLen);
	state.ops.push(...bytecode$1);
	state.stack.pop();
	state.stack.push({ expr: callExpr });
}
const MATH_UNARY = [
	"sin",
	"cos",
	"tan",
	"asin",
	"acos",
	"atan",
	"tanh",
	"abs",
	"sqrt",
	"square",
	"cube",
	"log",
	"exp",
	"log10",
	"log2",
	"exp2",
	"floor",
	"ceil",
	"round",
	"trunc",
	"fract",
	"sign",
	"isnan",
	"isinf",
	"heaviside"
];
const MATH_BINARY = [
	"min",
	"max",
	"hypot",
	"mod",
	"snap",
	"step",
	"safediv",
	"swing"
];
const MATH_TERNARY = [
	"clamp",
	"lerp",
	"wrap",
	"pingpong",
	"fold",
	"smoothstep",
	"smootherstep",
	"select"
];
function getMathUnaryId(name) {
	const i$6 = MATH_UNARY.indexOf(name);
	return i$6 >= 0 ? i$6 : -1;
}
function getMathBinaryId(name) {
	const i$6 = MATH_BINARY.indexOf(name);
	return i$6 >= 0 ? i$6 : -1;
}
function getMathTernaryId(name) {
	const i$6 = MATH_TERNARY.indexOf(name);
	return i$6 >= 0 ? i$6 : -1;
}
var GEN_KEY_SEP = "\0";
var primaryGenNameByVariantName = Object.create(null);
var primarySpecByGenKey = Object.create(null);
var opCodeByGenKey = Object.create(null);
var paramHasByGenKey = Object.create(null);
var defaultsByGenName = Object.create(null);
var typePredOpByName = {
	isundefined: AudioVmOp.IsUndefined,
	isscalar: AudioVmOp.IsScalar,
	isaudio: AudioVmOp.IsAudio,
	isarray: AudioVmOp.IsArray,
	isfunction: AudioVmOp.IsFunction
};
for (const [genName, desc] of Object.entries(gens)) {
	const out = Object.create(null);
	for (const p$6 of desc.parameters) if (p$6.default !== void 0) out[p$6.name] = p$6.default;
	defaultsByGenName[genName] = out;
}
for (const s$4 of genSpecs) {
	if (!(s$4.variantName in primaryGenNameByVariantName)) primaryGenNameByVariantName[s$4.variantName] = s$4.genName;
	const key = `${s$4.genName}${GEN_KEY_SEP}${s$4.variantName}`;
	if (key in primarySpecByGenKey) continue;
	primarySpecByGenKey[key] = s$4;
	const has = Object.create(null);
	for (const pn of s$4.paramNames) has[pn] = true;
	paramHasByGenKey[key] = has;
	const opCode = AudioVmOp[`Gen${s$4.genName}_${s$4.variantName}`];
	if (opCode !== void 0) opCodeByGenKey[key] = opCode;
}
function callNameFromCallee(callee) {
	if (callee.type === "identifier") return callee.name;
	if (callee.type === "member") return callee.property;
	if (callee.type === "index") return "[]";
	return "?";
}
function bestEffortArgs(args) {
	const out = {};
	let pos = 0;
	for (const a$36 of args) {
		if (a$36.type !== "arg" || !a$36.value) continue;
		const key = a$36.name ?? String(pos++);
		if (!out[key]) out[key] = [];
		out[key].push(a$36.value);
	}
	return out;
}
function matchFixedArgs(state, callExpr, funcName, args, paramNames) {
	const matched = new Array(paramNames.length).fill(null);
	let positionalIndex = 0;
	for (const arg of args) {
		if (arg.type !== "arg" || !arg.value) continue;
		if (arg.name) {
			const argName = arg.name;
			let matchedParamIndex = -1;
			for (let j$4 = 0; j$4 < paramNames.length; j$4++) if (paramNames[j$4].startsWith(argName)) {
				matchedParamIndex = j$4;
				break;
			}
			if (matchedParamIndex === -1) {
				error(state, `No parameter matches '${argName}' in ${funcName}()`, callExpr.loc);
				return null;
			}
			if (matched[matchedParamIndex] !== null) {
				error(state, `Parameter '${paramNames[matchedParamIndex]}' already provided in ${funcName}()`, callExpr.loc);
				return null;
			}
			matched[matchedParamIndex] = arg.value;
		} else if (arg.shorthand && arg.value.type === "identifier") {
			const shorthandName = arg.value.name;
			const matchedParamIndex = paramNames.indexOf(shorthandName);
			if (matchedParamIndex !== -1) {
				if (matched[matchedParamIndex] !== null) {
					error(state, `Parameter '${paramNames[matchedParamIndex]}' already provided in ${funcName}()`, callExpr.loc);
					return null;
				}
				matched[matchedParamIndex] = arg.value;
			} else {
				while (positionalIndex < paramNames.length && matched[positionalIndex] !== null) positionalIndex++;
				if (positionalIndex >= paramNames.length) {
					error(state, `Too many arguments for ${funcName}()`, callExpr.loc);
					return null;
				}
				matched[positionalIndex] = arg.value;
				positionalIndex++;
			}
		} else {
			while (positionalIndex < paramNames.length && matched[positionalIndex] !== null) positionalIndex++;
			if (positionalIndex >= paramNames.length) {
				error(state, `Too many arguments for ${funcName}()`, callExpr.loc);
				return null;
			}
			matched[positionalIndex] = arg.value;
			positionalIndex++;
		}
	}
	return matched;
}
function pushCallMeta(state, callExpr, name, args) {
	if (callExpr.loc.line <= state.preludeLines) return;
	state.functionCallsMeta.push({
		name,
		astNode: callExpr,
		args
	});
}
function pushArrayGetHistoryForArrayExpr(state, arrayExpr, loc) {
	const pc = state.ops.length;
	if (loc.line <= state.preludeLines) return;
	let line = loc.line - state.preludeLines;
	let column = loc.column;
	let arrayGetElementMapping;
	if (arrayExpr.type === "array") {
		line = arrayExpr.loc.line - state.preludeLines;
		column = arrayExpr.loc.column;
		arrayGetElementMapping = arrayExpr.items.map((item, index) => ({
			index,
			startCol: item.loc.column,
			endCol: item.loc.column + (item.loc.end - item.loc.start)
		}));
	} else if (arrayExpr.type === "identifier") {
		const literal = state.varToArrayLiteral.get(arrayExpr.name);
		if (literal) {
			line = literal.loc.line - state.preludeLines;
			column = literal.loc.column;
			arrayGetElementMapping = literal.items.map((item, index) => ({
				index,
				startCol: item.loc.column,
				endCol: item.loc.column + (item.loc.end - item.loc.start)
			}));
		}
	}
	const historyEntry = {
		line,
		column,
		genName: "ArrayGet",
		pc: state.inFunction ? 0 : pc,
		inFunction: state.inFunction,
		__fromMainProgram: !state.isDeferredPass,
		arrayGetElementMapping
	};
	state.historySourceMap.push(historyEntry);
	if (state.inFunction && state.currentFunctionId !== null) {
		const entryWithPending = historyEntry;
		entryWithPending.__functionId = state.currentFunctionId;
		entryWithPending.__relativePc = pc;
	} else historyEntry.pc = pc;
}
function pushCallSiteSourceMap(state, callExpr, funcName) {
	const pc = state.ops.length;
	const entry = {
		line: Math.max(1, callExpr.loc.line - state.preludeLines),
		column: callExpr.loc.column,
		genName: "_call",
		pc: state.inFunction ? 0 : pc,
		inFunction: state.inFunction,
		__fromMainProgram: !state.isDeferredPass,
		callSite: true,
		funcName
	};
	state.historySourceMap.push(entry);
	if (state.inFunction && state.currentFunctionId !== null) {
		const entryWithPending = entry;
		entryWithPending.__functionId = state.currentFunctionId;
		entryWithPending.__relativePc = pc;
	} else entry.pc = pc;
}
function compileGetCall(state, arrayExpr, indexExpr, loc, resultExpr) {
	const stackBefore = state.stack.length;
	compileExpr(state, arrayExpr);
	compileExpr(state, indexExpr);
	pushArrayGetHistoryForArrayExpr(state, arrayExpr, loc);
	state.ops.push(AudioVmOp.ArrayGet, 0);
	state.stack.length = stackBefore;
	state.stack.push({ expr: resultExpr });
}
function compileCall(state, expr) {
	if (expr.callee.type === "member") {
		const memberExpr = expr.callee;
		if (memberExpr.property === "map") {
			const syntheticCall = {
				type: "call",
				callee: {
					type: "identifier",
					name: "map",
					loc: expr.loc
				},
				args: [{
					type: "arg",
					value: memberExpr.object,
					loc: memberExpr.object.loc
				}, ...expr.args],
				loc: expr.loc
			};
			compileCallWithArgs(state, syntheticCall, syntheticCall.args, -1);
			return;
		}
		if (memberExpr.property === "avg") {
			const syntheticCall = {
				type: "call",
				callee: {
					type: "identifier",
					name: "avg",
					loc: expr.loc
				},
				args: [{
					type: "arg",
					value: memberExpr.object,
					loc: memberExpr.object.loc
				}],
				loc: expr.loc
			};
			compileCallWithArgs(state, syntheticCall, syntheticCall.args, -1);
			return;
		}
		if (memberExpr.property === "shuffle") {
			const syntheticCall = {
				type: "call",
				callee: {
					type: "identifier",
					name: "shuffle",
					loc: expr.loc
				},
				args: [{
					type: "arg",
					value: memberExpr.object,
					loc: memberExpr.object.loc
				}, ...expr.args],
				loc: expr.loc
			};
			compileCallWithArgs(state, syntheticCall, syntheticCall.args, -1);
			return;
		}
		if (memberExpr.property === "reverse") {
			const syntheticCall = {
				type: "call",
				callee: {
					type: "identifier",
					name: "reverse",
					loc: expr.loc
				},
				args: [{
					type: "arg",
					value: memberExpr.object,
					loc: memberExpr.object.loc
				}],
				loc: expr.loc
			};
			compileCallWithArgs(state, syntheticCall, syntheticCall.args, -1);
			return;
		}
		if (memberExpr.property === "walk") {
			const syntheticCall = {
				type: "call",
				callee: {
					type: "identifier",
					name: "Walk",
					loc: expr.loc
				},
				args: [{
					type: "arg",
					value: memberExpr.object,
					loc: memberExpr.object.loc
				}, ...expr.args],
				loc: expr.loc
			};
			compileCallWithArgs(state, syntheticCall, syntheticCall.args, -1);
			return;
		}
		if (memberExpr.property === "glide") {
			const syntheticCall = {
				type: "call",
				callee: {
					type: "identifier",
					name: "Glide",
					loc: expr.loc
				},
				args: [{
					type: "arg",
					value: memberExpr.object,
					loc: memberExpr.object.loc
				}, ...expr.args],
				loc: expr.loc
			};
			compileCallWithArgs(state, syntheticCall, syntheticCall.args, -1);
			return;
		}
		if (memberExpr.property === "step") {
			const syntheticCall = {
				type: "call",
				callee: {
					type: "identifier",
					name: "Step",
					loc: expr.loc
				},
				args: [{
					type: "arg",
					value: memberExpr.object,
					loc: memberExpr.object.loc
				}, ...expr.args],
				loc: expr.loc
			};
			compileCallWithArgs(state, syntheticCall, syntheticCall.args, -1);
			return;
		}
		if (memberExpr.property === "random") {
			const syntheticCall = {
				type: "call",
				callee: {
					type: "identifier",
					name: "Random",
					loc: expr.loc
				},
				args: [{
					type: "arg",
					value: memberExpr.object,
					loc: memberExpr.object.loc
				}, ...expr.args],
				loc: expr.loc
			};
			compileCallWithArgs(state, syntheticCall, syntheticCall.args, -1);
			return;
		}
		pushCallMeta(state, expr, memberExpr.property, bestEffortArgs(expr.args));
		compileExpr(state, memberExpr.object);
		if (state.stack.length === 0) {
			error(state, "Method call requires an object", expr.loc);
			return;
		}
		if (memberExpr.property === "push") {
			const args = expr.args.map((arg) => arg.type === "arg" ? arg.value : null).filter((a$36) => a$36 !== null);
			if (args.length === 0) {
				error(state, "push() requires at least one argument", expr.loc);
				return;
			}
			for (const arg of args) compileExpr(state, arg);
			state.ops.push(AudioVmOp.ArrayPush);
			state.ops.push(args.length);
			state.stack.length -= args.length;
			state.stack.push({ expr });
			return;
		} else error(state, `Unknown method: ${memberExpr.property}`, expr.loc);
		return;
	}
	compileCallWithArgs(state, expr, expr.args, -1);
}
function compileCallWithArgs(state, callExpr, args, dollarIndex) {
	const callee = callExpr.callee;
	if (callee.type === "index") {
		pushCallMeta(state, callExpr, "[]", bestEffortArgs(args));
		for (const arg of args) if (arg.type === "arg" && arg.value) compileExpr(state, arg.value);
		const idxCallee = callee;
		compileGetCall(state, idxCallee.object, idxCallee.index, idxCallee.loc, idxCallee);
		state.ops.push(AudioVmOp.CallFunction);
		state.ops.push(args.length);
		state.stack.push({ expr: callExpr });
		return;
	}
	if (callee.type !== "identifier") {
		pushCallMeta(state, callExpr, callNameFromCallee(callee), bestEffortArgs(args));
		error(state, "Only simple function calls are supported", callExpr.loc);
		return;
	}
	const funcName = callee.name;
	if (funcName === "dtof") {
		pushCallMeta(state, callExpr, "dtof", bestEffortArgs(args));
		const degreeArg = args[0]?.type === "arg" ? args[0].value : null;
		if (!degreeArg || degreeArg.type !== "number") {
			error(state, "dtof(degree) requires a literal number (scale degree 1-based)", callExpr.loc);
			return;
		}
		compileDtofCall(state, degreeArg.value, callExpr.loc);
		state.stack.push({ expr: callExpr });
		return;
	}
	if (funcName === "get") {
		if (args.length < 2) {
			pushCallMeta(state, callExpr, "get", bestEffortArgs(args));
			error(state, "get(array, index) requires two arguments", callExpr.loc);
			return;
		}
		const arrayArg = args[0]?.type === "arg" ? args[0].value : null;
		const indexArg = args[1]?.type === "arg" ? args[1].value : null;
		if (!arrayArg || !indexArg) {
			pushCallMeta(state, callExpr, "get", bestEffortArgs(args));
			error(state, "get(array, index) requires two arguments", callExpr.loc);
			return;
		}
		compileGetCall(state, arrayArg, indexArg, callExpr.loc, callExpr);
		pushCallMeta(state, callExpr, "get", {
			array: [arrayArg],
			index: [indexArg]
		});
		return;
	}
	if (funcName === "out" || funcName === "solo" || funcName === "outs" || funcName === "sout") {
		pushCallMeta(state, callExpr, funcName, bestEffortArgs(args));
		const isSolo = funcName !== "out";
		let argCount$1 = 0;
		for (let i$6 = 0; i$6 < args.length; i$6++) {
			const arg = args[i$6];
			if (arg.type === "arg" && arg.value) {
				compileExpr(state, arg.value);
				argCount$1++;
			}
		}
		if (argCount$1 === 0) {
			error(state, `${funcName} requires at least one argument`, callExpr.loc);
			return;
		}
		if (argCount$1 > 2) {
			error(state, `${funcName} accepts 1 or 2 arguments, got ${argCount$1}`, callExpr.loc);
			return;
		}
		const userLine = Math.max(1, callExpr.loc.line - state.preludeLines);
		const outSoloPc = state.ops.length;
		const outSoloHistoryEntry = {
			line: userLine,
			column: callExpr.loc.column,
			genName: isSolo ? "Solo" : "Out",
			pc: state.inFunction ? 0 : outSoloPc,
			inFunction: state.inFunction,
			__fromMainProgram: !state.isDeferredPass
		};
		state.historySourceMap.push(outSoloHistoryEntry);
		if (state.inFunction && state.currentFunctionId !== null) {
			outSoloHistoryEntry.__functionId = state.currentFunctionId;
			outSoloHistoryEntry.__relativePc = outSoloPc;
		} else outSoloHistoryEntry.pc = outSoloPc;
		state.ops.push(isSolo ? AudioVmOp.Solo : AudioVmOp.Out);
		state.ops.push(argCount$1);
		for (let i$6 = 0; i$6 < argCount$1; i$6++) state.stack.pop();
		return;
	}
	if (funcName === "oversample") {
		pushCallMeta(state, callExpr, funcName, bestEffortArgs(args));
		if (args.length !== 2) {
			error(state, "oversample() requires exactly 2 arguments: factor and callback", callExpr.loc);
			return;
		}
		const factorArg = args[0]?.type === "arg" ? args[0].value : null;
		const callbackArg = args[1]?.type === "arg" ? args[1].value : null;
		if (!factorArg || !callbackArg) {
			error(state, "oversample() requires factor and callback arguments", callExpr.loc);
			return;
		}
		compileExpr(state, factorArg);
		if (callbackArg.type === "fn") {
			const prev = state.captureGlobalsInClosures;
			state.captureGlobalsInClosures = true;
			compileExpr(state, callbackArg);
			state.captureGlobalsInClosures = prev;
		} else compileExpr(state, callbackArg);
		state.ops.push(AudioVmOp.Oversample);
		if (state.stack.length >= 2) {
			state.stack.pop();
			state.stack.pop();
		} else state.stack.length = Math.max(0, state.stack.length - 2);
		state.stack.push({ expr: callExpr });
		return;
	}
	if (funcName === "espeak") {
		pushCallMeta(state, callExpr, funcName, bestEffortArgs(args));
		if (args.length < 1) {
			error(state, "espeak() requires at least 1 argument: text", callExpr.loc);
			return;
		}
		const matchedArgs = matchFixedArgs(state, callExpr, "espeak", args, [
			"text",
			"variant",
			"speed",
			"pitch"
		]);
		if (!matchedArgs) return;
		const [textArg, variantArg, speedArg, pitchArg] = matchedArgs;
		if (!textArg || textArg.type !== "string") {
			error(state, "espeak() text must be a literal string", callExpr.loc);
			return;
		}
		if (variantArg && variantArg.type !== "string") {
			error(state, "espeak() variant must be a literal string", callExpr.loc);
			return;
		}
		if (speedArg && speedArg.type !== "number") {
			error(state, "espeak() speed must be a literal number", callExpr.loc);
			return;
		}
		if (pitchArg && pitchArg.type !== "number") {
			error(state, "espeak() pitch must be a literal number", callExpr.loc);
			return;
		}
		const text = textArg.value;
		const variant = variantArg?.value ?? "m1";
		const speedNorm = speedArg ? Number(speedArg.value) : .5;
		const pitchNorm = pitchArg ? Number(pitchArg.value) : .5;
		const handle = sampleManager.registerEspeak();
		state.sampleRegistrations.push({
			handle,
			type: "espeak",
			espeakText: text,
			espeakVariant: variant,
			espeakSpeed: speedNorm,
			espeakPitch: pitchNorm
		});
		state.ops.push(AudioVmOp.PushScalar);
		state.ops.push(handle);
		state.stack.push({ expr: callExpr });
		return;
	}
	if (funcName === "sam") {
		pushCallMeta(state, callExpr, funcName, bestEffortArgs(args));
		if (args.length < 1) {
			error(state, "sam() requires at least 1 argument: text", callExpr.loc);
			return;
		}
		const matchedArgs = matchFixedArgs(state, callExpr, "sam", args, [
			"text",
			"pitch",
			"speed",
			"mouth",
			"throat",
			"singmode",
			"phonetic"
		]);
		if (!matchedArgs) return;
		const [textArg, pitchArg, speedArg, mouthArg, throatArg, singmodeArg, phoneticArg] = matchedArgs;
		if (!textArg || textArg.type !== "string") {
			error(state, "sam() text must be a literal string", callExpr.loc);
			return;
		}
		if (pitchArg && pitchArg.type !== "number") {
			error(state, "sam() pitch must be a literal number", callExpr.loc);
			return;
		}
		if (speedArg && speedArg.type !== "number") {
			error(state, "sam() speed must be a literal number", callExpr.loc);
			return;
		}
		if (mouthArg && mouthArg.type !== "number") {
			error(state, "sam() mouth must be a literal number", callExpr.loc);
			return;
		}
		if (throatArg && throatArg.type !== "number") {
			error(state, "sam() throat must be a literal number", callExpr.loc);
			return;
		}
		if (singmodeArg && singmodeArg.type !== "number") {
			error(state, "sam() singmode must be a literal number 0 or 1", callExpr.loc);
			return;
		}
		if (phoneticArg && phoneticArg.type !== "number") {
			error(state, "sam() phonetic must be a literal number 0 or 1", callExpr.loc);
			return;
		}
		const DEFAULT_SPEED = 72;
		const DEFAULT_PITCH = 64;
		const DEFAULT_THROAT = 128;
		const DEFAULT_MOUTH = 128;
		const pitchNorm = pitchArg ? Number(pitchArg.value) : void 0;
		const speedNorm = speedArg ? Number(speedArg.value) : void 0;
		const mouthNorm = mouthArg ? Number(mouthArg.value) : void 0;
		const throatNorm = throatArg ? Number(throatArg.value) : void 0;
		const pitch = pitchNorm === void 0 ? DEFAULT_PITCH : Math.round((1 - pitchNorm) * 255);
		const speed = speedNorm === void 0 ? DEFAULT_SPEED : Math.round((1 - speedNorm) * 255);
		const mouth = mouthNorm === void 0 ? DEFAULT_MOUTH : Math.round((1 - mouthNorm) * 255);
		const throat = throatNorm === void 0 ? DEFAULT_THROAT : Math.round((1 - throatNorm) * 255);
		const singmode = singmodeArg ? Number(singmodeArg.value) !== 0 : false;
		const phonetic = phoneticArg ? Number(phoneticArg.value) !== 0 : false;
		try {
			const buf = new H$1({
				pitch,
				speed,
				mouth,
				throat,
				singmode,
				phonetic
			}).buf32(textArg.value, phonetic);
			if (!(buf instanceof Float32Array)) {
				error(state, "sam() synthesis failed", callExpr.loc);
				return;
			}
			const sourceSampleRate = 22050;
			const targetSampleRate = 48e3;
			const ratio = targetSampleRate / sourceSampleRate;
			const targetLength = Math.max(1, Math.round(buf.length * ratio));
			const resampled = new Float32Array(targetLength);
			for (let i$6 = 0; i$6 < targetLength; i$6++) {
				const t$12 = i$6 / ratio;
				const i0 = Math.floor(t$12);
				const i1 = Math.min(i0 + 1, buf.length - 1);
				const frac = t$12 - i0;
				const v0 = buf[i0] ?? 0;
				resampled[i$6] = v0 + ((buf[i1] ?? 0) - v0) * frac;
			}
			const sampleRate = targetSampleRate;
			const handle = sampleManager.registerInlineSample([resampled], sampleRate);
			state.sampleRegistrations.push({
				handle,
				type: "inline",
				inlineChannels: [resampled],
				inlineSampleRate: sampleRate
			});
			state.ops.push(AudioVmOp.PushScalar);
			state.ops.push(handle);
			state.stack.push({ expr: callExpr });
			return;
		} catch (e$59) {
			error(state, `sam() synthesis error: ${e$59 instanceof Error ? e$59.message : String(e$59)}`, callExpr.loc);
			return;
		}
	}
	if (funcName === "freesound") {
		pushCallMeta(state, callExpr, funcName, bestEffortArgs(args));
		if (args.length !== 1) {
			error(state, "freesound() requires exactly 1 argument: id", callExpr.loc);
			return;
		}
		const idArg = args[0]?.type === "arg" ? args[0].value : null;
		if (!idArg || idArg.type !== "number") {
			error(state, "freesound() id must be a literal number", callExpr.loc);
			return;
		}
		const id = idArg.value;
		const handle = sampleManager.registerFreesound(id);
		state.sampleRegistrations.push({
			handle,
			type: "freesound",
			freesoundId: id
		});
		state.ops.push(AudioVmOp.PushScalar);
		state.ops.push(handle);
		state.stack.push({ expr: callExpr });
		return;
	}
	if (funcName === "record") {
		pushCallMeta(state, callExpr, funcName, bestEffortArgs(args));
		compileRecord(state, callExpr);
		return;
	}
	if (funcName === "tram") {
		pushCallMeta(state, callExpr, funcName, bestEffortArgs(args));
		compileTram(state, callExpr, args);
		return;
	}
	if (funcName === "mini") {
		pushCallMeta(state, callExpr, funcName, bestEffortArgs(args));
		compileMini(state, callExpr, args);
		return;
	}
	if (funcName === "label") {
		const a0 = args[0]?.type === "arg" ? args[0].value : null;
		const a1 = args[1]?.type === "arg" ? args[1].value : null;
		const a2 = args[2]?.type === "arg" ? args[2].value : null;
		if (a0?.type === "number" && a1?.type === "string") {
			const bar = Math.max(0, Math.floor(Number(a0.value)) - 1);
			let colorIndex = 1;
			if (a2?.type === "number") colorIndex = Math.max(0, Math.min(5, Math.floor(Number(a2.value))));
			state.labels.push({
				bar,
				text: a1.value,
				colorIndex
			});
		}
		state.ops.push(AudioVmOp.PushScalar);
		state.ops.push(0);
		state.stack.push({ expr: callExpr });
		return;
	}
	if (funcName === "timeline") {
		pushCallMeta(state, callExpr, funcName, bestEffortArgs(args));
		compileTimeline(state, callExpr, args);
		return;
	}
	if (funcName === "alloc") {
		pushCallMeta(state, callExpr, funcName, bestEffortArgs(args));
		if (args.length !== 1) {
			error(state, "alloc() requires 1 argument: seconds", callExpr.loc);
			return;
		}
		const secondsArg = args[0]?.type === "arg" ? args[0].value : null;
		if (!secondsArg) {
			error(state, "alloc() requires seconds argument", callExpr.loc);
			return;
		}
		const stackBefore$1 = state.stack.length;
		compileExpr(state, secondsArg);
		state.ops.push(AudioVmOp.Alloc);
		state.ops.push(state.nextAllocCallSiteId++);
		state.stack.length = stackBefore$1;
		state.stack.push({ expr: callExpr });
		return;
	}
	if (funcName === "write") {
		pushCallMeta(state, callExpr, funcName, bestEffortArgs(args));
		if (args.length !== 2) {
			error(state, "write() requires 2 arguments: input and buf", callExpr.loc);
			return;
		}
		const inputArg = args[0]?.type === "arg" ? args[0].value : null;
		const bufArg = args[1]?.type === "arg" ? args[1].value : null;
		if (!inputArg || !bufArg) {
			error(state, "write() requires input and buf arguments", callExpr.loc);
			return;
		}
		const stackBefore$1 = state.stack.length;
		compileExpr(state, inputArg);
		compileExpr(state, bufArg);
		state.ops.push(AudioVmOp.Write);
		state.stack.length = stackBefore$1;
		state.stack.push({ expr: callExpr });
		return;
	}
	if (funcName === "read") {
		pushCallMeta(state, callExpr, funcName, bestEffortArgs(args));
		if (args.length !== 2) {
			error(state, "read() requires 2 arguments: buf and offset (seconds)", callExpr.loc);
			return;
		}
		const bufArg = args[0]?.type === "arg" ? args[0].value : null;
		const offsetArg = args[1]?.type === "arg" ? args[1].value : null;
		if (!bufArg || !offsetArg) {
			error(state, "read() requires buf and offset arguments", callExpr.loc);
			return;
		}
		const stackBefore$1 = state.stack.length;
		compileExpr(state, bufArg);
		compileExpr(state, offsetArg);
		state.ops.push(AudioVmOp.Read);
		state.stack.length = stackBefore$1;
		state.stack.push({ expr: callExpr });
		return;
	}
	if (funcName === "isundefined" || funcName === "isscalar" || funcName === "isaudio" || funcName === "isarray" || funcName === "isfunction") {
		pushCallMeta(state, callExpr, funcName, bestEffortArgs(args));
		let argCount$1 = dollarIndex >= 0 ? 1 : 0;
		for (const a$36 of args) if (a$36.type === "arg" && a$36.value) argCount$1++;
		if (argCount$1 > 1) {
			error(state, `Too many arguments for function '${funcName}'`, callExpr.loc);
			return;
		}
		const argExpr = dollarIndex === 0 ? null : args[0]?.type === "arg" ? args[0].value : null;
		if (argExpr) compileExpr(state, argExpr);
		if (state.stack.length === 0) {
			error(state, `${funcName} requires a value`, callExpr.loc);
			return;
		}
		const op = typePredOpByName[funcName];
		state.ops.push(op);
		state.stack.pop();
		state.stack.push({ expr: callExpr });
		return;
	}
	const mathUnaryId = getMathUnaryId(funcName);
	if (mathUnaryId >= 0) {
		pushCallMeta(state, callExpr, funcName, bestEffortArgs(args));
		let argCount$1 = 0;
		for (const a$36 of args) if (a$36.type === "arg" && a$36.value) argCount$1++;
		if (argCount$1 > 1) {
			error(state, `Too many arguments for function '${funcName}'`, callExpr.loc);
			return;
		}
		const argExpr = args[0]?.type === "arg" ? args[0].value : null;
		if (!argExpr) {
			error(state, `${funcName}(x) requires one argument`, callExpr.loc);
			return;
		}
		compileExpr(state, argExpr);
		if (state.stack.length === 0) {
			error(state, `${funcName} requires a value`, callExpr.loc);
			return;
		}
		state.ops.push(AudioVmOp.MathUnary);
		state.ops.push(mathUnaryId);
		state.stack.pop();
		state.stack.push({ expr: callExpr });
		return;
	}
	const mathBinaryId = getMathBinaryId(funcName);
	if (mathBinaryId >= 0) {
		pushCallMeta(state, callExpr, funcName, bestEffortArgs(args));
		let argCount$1 = 0;
		for (const a$36 of args) if (a$36.type === "arg" && a$36.value) argCount$1++;
		if (argCount$1 > 2) {
			error(state, `Too many arguments for function '${funcName}'`, callExpr.loc);
			return;
		}
		const left = args[0]?.type === "arg" ? args[0].value : null;
		const right = args[1]?.type === "arg" ? args[1].value : null;
		if (!left || !right) {
			error(state, `${funcName}(x, y) requires two arguments`, callExpr.loc);
			return;
		}
		compileExpr(state, left);
		compileExpr(state, right);
		if (state.stack.length < 2) {
			error(state, `${funcName} requires two values`, callExpr.loc);
			return;
		}
		state.ops.push(AudioVmOp.MathBinary);
		state.ops.push(mathBinaryId);
		state.stack.pop();
		state.stack.pop();
		state.stack.push({ expr: callExpr });
		return;
	}
	const mathTernaryId = getMathTernaryId(funcName);
	if (mathTernaryId >= 0) {
		pushCallMeta(state, callExpr, funcName, bestEffortArgs(args));
		let argCount$1 = 0;
		for (const a$37 of args) if (a$37.type === "arg" && a$37.value) argCount$1++;
		if (argCount$1 > 3) {
			error(state, `Too many arguments for function '${funcName}'`, callExpr.loc);
			return;
		}
		const a$36 = args[0]?.type === "arg" ? args[0].value : null;
		const b$4 = args[1]?.type === "arg" ? args[1].value : null;
		const c$7 = args[2]?.type === "arg" ? args[2].value : null;
		if (!a$36 || !b$4 || !c$7) {
			error(state, `${funcName}(a, b, c) requires three arguments`, callExpr.loc);
			return;
		}
		compileExpr(state, a$36);
		compileExpr(state, b$4);
		compileExpr(state, c$7);
		if (state.stack.length < 3) {
			error(state, `${funcName} requires three values`, callExpr.loc);
			return;
		}
		state.ops.push(AudioVmOp.MathTernary);
		state.ops.push(mathTernaryId);
		state.stack.pop();
		state.stack.pop();
		state.stack.pop();
		state.stack.push({ expr: callExpr });
		return;
	}
	if (funcName === "slicer") {
		const thresholdArg = args.find((a$36) => a$36.type === "arg" && a$36.name === "threshold" && a$36.value);
		if (thresholdArg && thresholdArg.type === "arg" && thresholdArg.value?.type !== "number") {
			error(state, "slicer() threshold parameter must be a scalar value", callExpr.loc);
			return;
		}
	}
	if (funcName === "Walk") {
		pushCallMeta(state, callExpr, "Walk", bestEffortArgs(args));
		if (args.length < 2) {
			error(state, "Walk(array, bar, swing?, offset?) requires at least array and bar", callExpr.loc);
			return;
		}
		const arrayArg = args[0]?.type === "arg" ? args[0].value : null;
		const barArg = args[1]?.type === "arg" ? args[1].value : null;
		const swingArg = args.length > 2 && args[2]?.type === "arg" ? args[2].value : null;
		const offsetArg = args.length > 3 && args[3]?.type === "arg" ? args[3].value : null;
		if (!arrayArg || !barArg) {
			error(state, "Walk requires array and bar arguments", callExpr.loc);
			return;
		}
		compileExpr(state, arrayArg);
		compileExpr(state, barArg);
		if (swingArg) compileExpr(state, swingArg);
		else {
			state.ops.push(AudioVmOp.PushScalar);
			state.ops.push(0);
			state.stack.push({ expr: callExpr });
		}
		if (offsetArg) compileExpr(state, offsetArg);
		else {
			state.ops.push(AudioVmOp.PushScalar);
			state.ops.push(0);
			state.stack.push({ expr: callExpr });
		}
		pushArrayGetHistoryForArrayExpr(state, arrayArg, arrayArg.loc);
		state.ops.push(AudioVmOp.Walk);
		state.stack.length -= 4;
		state.stack.push({ expr: callExpr });
		return;
	}
	if (funcName === "Glide") {
		pushCallMeta(state, callExpr, "Glide", bestEffortArgs(args));
		if (args.length < 2) {
			error(state, "Glide(array, bar, exponent?) requires at least array and bar", callExpr.loc);
			return;
		}
		const arrayArg = args[0]?.type === "arg" ? args[0].value : null;
		const barArg = args[1]?.type === "arg" ? args[1].value : null;
		const exponentArg = args.length > 2 && args[2]?.type === "arg" ? args[2].value : null;
		if (!arrayArg || !barArg) {
			error(state, "Glide requires array and bar arguments", callExpr.loc);
			return;
		}
		compileExpr(state, arrayArg);
		compileExpr(state, barArg);
		if (exponentArg) compileExpr(state, exponentArg);
		else {
			state.ops.push(AudioVmOp.PushScalar);
			state.ops.push(1);
			state.stack.push({ expr: callExpr });
		}
		state.ops.push(AudioVmOp.Glide);
		state.stack.length -= 3;
		state.stack.push({ expr: callExpr });
		return;
	}
	if (funcName === "Step") {
		pushCallMeta(state, callExpr, "Step", bestEffortArgs(args));
		if (args.length < 2) {
			error(state, "Step(array, trig) requires array and trigger", callExpr.loc);
			return;
		}
		const arrayArg = args[0]?.type === "arg" ? args[0].value : null;
		const trigArg = args[1]?.type === "arg" ? args[1].value : null;
		if (!arrayArg || !trigArg) {
			error(state, "Step requires array and trig arguments", callExpr.loc);
			return;
		}
		compileExpr(state, arrayArg);
		compileExpr(state, trigArg);
		pushArrayGetHistoryForArrayExpr(state, arrayArg, arrayArg.loc);
		state.ops.push(AudioVmOp.Step);
		state.ops.push(state.nextStepCallSiteId++);
		state.stack.length -= 2;
		state.stack.push({ expr: callExpr });
		return;
	}
	if (funcName === "Random") {
		pushCallMeta(state, callExpr, "Random", bestEffortArgs(args));
		if (args.length < 2) {
			error(state, "Random(array, trig, seed?) requires array and trigger", callExpr.loc);
			return;
		}
		const arrayArg = args[0]?.type === "arg" ? args[0].value : null;
		const trigArg = args[1]?.type === "arg" ? args[1].value : null;
		const seedArg = args[2]?.type === "arg" ? args[2].value : null;
		if (!arrayArg || !trigArg) {
			error(state, "Random requires array and trig arguments", callExpr.loc);
			return;
		}
		compileExpr(state, arrayArg);
		compileExpr(state, trigArg);
		if (seedArg) compileExpr(state, seedArg);
		else {
			state.ops.push(AudioVmOp.PushScalar);
			state.ops.push(0);
			state.stack.push({ expr: callExpr });
		}
		pushArrayGetHistoryForArrayExpr(state, arrayArg, arrayArg.loc);
		state.ops.push(AudioVmOp.Random);
		state.ops.push(state.nextStepCallSiteId++);
		state.stack.length -= 3;
		state.stack.push({ expr: callExpr });
		return;
	}
	const variantGenName = primaryGenNameByVariantName[funcName];
	const genName = variantGenName ?? funcName.charAt(0).toUpperCase() + funcName.slice(1);
	const genKey = `${genName}${GEN_KEY_SEP}${variantGenName ? funcName : "default"}`;
	const spec = primarySpecByGenKey[genKey];
	if (!spec) {
		const varInfo = lookupVariable(state, funcName);
		if (varInfo) {
			compileUserFunctionCall(state, callExpr, funcName, varInfo, args, dollarIndex);
			return;
		}
		pushCallMeta(state, callExpr, funcName, bestEffortArgs(args));
		error(state, `Unknown generator: ${funcName}`, callExpr.loc);
		return;
	}
	const paramCount = spec.paramNames.length;
	const usesInput = spec.usesInput;
	const totalArgs = paramCount + (usesInput ? 1 : 0);
	const stackBefore = state.stack.length;
	const paramHas = paramHasByGenKey[genKey];
	const namedByName = Object.create(null);
	const namedOrder = [];
	const positionalArgs = [];
	let argCount = 0;
	for (const a$36 of args) {
		if (a$36.type !== "arg" || !a$36.value) continue;
		argCount++;
		if (a$36.name) {
			if (!(a$36.name in namedByName)) namedOrder.push(a$36.name);
			namedByName[a$36.name] = a$36.value;
			continue;
		}
		if (a$36.value.type === "identifier") {
			const n$4 = a$36.value.name;
			if (paramHas[n$4]) {
				if (!(n$4 in namedByName)) namedOrder.push(n$4);
				namedByName[n$4] = a$36.value;
				continue;
			}
		}
		positionalArgs.push(a$36.value);
	}
	argCount += dollarIndex >= 0 ? 1 : 0;
	if (argCount > totalArgs) {
		error(state, `Too many arguments for function '${funcName}'`, callExpr.loc);
		return;
	}
	const opCode = opCodeByGenKey[genKey];
	if (opCode === void 0) {
		error(state, `Unknown opcode for generator: ${spec.genName}_${spec.variantName}`, callExpr.loc);
		return;
	}
	let positionalIndex = 0;
	const resolvedArgs = callExpr.loc.line <= state.preludeLines ? null : {};
	const namedUsed = new Array(namedOrder.length).fill(false);
	const defaults = defaultsByGenName[genName];
	for (let i$6 = 0; i$6 < totalArgs; i$6++) if (i$6 === dollarIndex) {
		if (state.stack.length === 0) {
			error(state, "$ used without a value on the stack", callExpr.loc);
			return;
		}
		positionalIndex++;
	} else {
		const paramIndex = usesInput ? i$6 - 1 : i$6;
		const paramName = paramIndex >= 0 ? spec.paramNames[paramIndex] : null;
		let argExpr = null;
		if (paramName) for (let j$4 = 0; j$4 < namedOrder.length; j$4++) {
			if (namedUsed[j$4]) continue;
			const argName = namedOrder[j$4];
			if (!paramName.startsWith(argName)) continue;
			namedUsed[j$4] = true;
			argExpr = namedByName[argName] ?? null;
			break;
		}
		if (!argExpr) {
			argExpr = positionalArgs[positionalIndex] ?? null;
			positionalIndex++;
		}
		if (resolvedArgs && paramName && argExpr) (resolvedArgs[paramName] ??= []).push(argExpr);
		if (argExpr) compileExpr(state, argExpr);
		else {
			const defaultValue = (paramName ? defaults?.[paramName] : void 0) ?? 0;
			state.ops.push(AudioVmOp.PushScalar);
			state.ops.push(defaultValue);
			state.stack.push({ expr: {
				type: "number",
				value: defaultValue,
				loc: callExpr.loc
			} });
		}
	}
	const pc = state.ops.length;
	if (callExpr.loc.line > state.preludeLines) {
		const historyEntry = {
			line: callExpr.loc.line - state.preludeLines,
			column: callExpr.loc.column,
			genName: spec.genName,
			pc: state.inFunction ? 0 : pc,
			inFunction: state.inFunction,
			__fromMainProgram: !state.isDeferredPass
		};
		state.historySourceMap.push(historyEntry);
		if (state.inFunction && state.currentFunctionId !== null) {
			historyEntry.__functionId = state.currentFunctionId;
			historyEntry.__relativePc = pc;
		} else historyEntry.pc = pc;
	}
	state.ops.push(opCode);
	state.stack.length = stackBefore;
	state.stack.push({ expr: callExpr });
	pushCallMeta(state, callExpr, spec.genName, resolvedArgs ?? {});
}
function resolveFunctionInfo(state, funcName) {
	let info = getFunctionByName(state, funcName);
	if (info) return info;
	let target = funcName;
	while (state.functionAliases.has(target)) {
		target = state.functionAliases.get(target);
		info = getFunctionByName(state, target);
		if (info) return info;
	}
}
function compileUserFunctionCall(state, callExpr, funcName, varInfo, args, dollarIndex) {
	const funcInfo = getFunctionByName(state, funcName);
	const resolvedFuncInfo = funcInfo ?? resolveFunctionInfo(state, funcName);
	const callSiteLocKey = `${callExpr.loc.line}:${callExpr.loc.column}:${callExpr.loc.start}:${callExpr.loc.end}`;
	const callSiteId = state.recordCallIds.get(callSiteLocKey);
	if (!state.compilingRecordCallback && funcInfo && state.functionToRecordCall.has(funcName) && callSiteId !== void 0) processRecordCallSite(state, callExpr, funcName, funcInfo, callSiteId);
	const hasNamedArgs = args.some((arg) => arg.type === "arg" && (arg.name || arg.shorthand && arg.value.type === "identifier"));
	if (!resolvedFuncInfo || !hasNamedArgs) {
		pushCallMeta(state, callExpr, funcName, bestEffortArgs(args));
		const argsProvided = args.filter((a$36) => a$36.type === "arg" && a$36.value).length + (dollarIndex >= 0 ? 1 : 0);
		const paramCount$1 = resolvedFuncInfo?.params.length ?? 0;
		if (resolvedFuncInfo && argsProvided > paramCount$1) {
			error(state, `Too many arguments for function '${funcName}'`, callExpr.loc);
			return;
		}
		for (let i$6 = 0; i$6 < args.length; i$6++) {
			if (i$6 === dollarIndex) continue;
			const arg = args[i$6];
			if (arg.type === "arg" && arg.value) compileExpr(state, arg.value);
		}
		const missingCount = Math.max(0, paramCount$1 - argsProvided);
		for (let i$6 = 0; i$6 < missingCount; i$6++) {
			state.ops.push(AudioVmOp.PushUndefined);
			state.stack.push({ expr: callExpr });
		}
		const argCount$1 = argsProvided + missingCount;
		compileGetVariable(state, varInfo);
		pushCallSiteSourceMap(state, callExpr, funcName);
		state.ops.push(AudioVmOp.CallFunction);
		state.ops.push(argCount$1);
		state.stack.push({ expr: callExpr });
		return;
	}
	const params = resolvedFuncInfo.params;
	const paramCount = params.length;
	const matchedArgs = new Array(paramCount).fill(null);
	let positionalIndex = 0;
	let dollarParamIndex = -1;
	for (let i$6 = 0; i$6 < args.length; i$6++) {
		const arg = args[i$6];
		if (arg.type !== "arg") continue;
		if (arg.name) {
			const argName = arg.name;
			let matchedParamIndex = -1;
			for (let j$4 = 0; j$4 < params.length; j$4++) if (params[j$4].startsWith(argName)) {
				matchedParamIndex = j$4;
				break;
			}
			if (matchedParamIndex === -1) {
				error(state, `No parameter matches '${argName}' in function '${funcName}'`, callExpr.loc);
				return;
			}
			if (matchedArgs[matchedParamIndex] !== null) {
				error(state, `Parameter '${params[matchedParamIndex]}' already provided`, callExpr.loc);
				return;
			}
			matchedArgs[matchedParamIndex] = arg.value;
		} else if (arg.shorthand && arg.value.type === "identifier") {
			const shorthandName = arg.value.name;
			const matchedParamIndex = params.indexOf(shorthandName);
			if (matchedParamIndex !== -1) {
				if (matchedArgs[matchedParamIndex] !== null) {
					error(state, `Parameter '${params[matchedParamIndex]}' already provided`, callExpr.loc);
					return;
				}
				matchedArgs[matchedParamIndex] = arg.value;
				if (i$6 === dollarIndex) dollarParamIndex = matchedParamIndex;
			} else {
				while (positionalIndex < paramCount && matchedArgs[positionalIndex] !== null) positionalIndex++;
				if (positionalIndex >= paramCount) {
					error(state, `Too many arguments for function '${funcName}'`, callExpr.loc);
					return;
				}
				matchedArgs[positionalIndex] = arg.value;
				if (i$6 === dollarIndex) dollarParamIndex = positionalIndex;
				positionalIndex++;
			}
		} else {
			while (positionalIndex < paramCount && matchedArgs[positionalIndex] !== null) positionalIndex++;
			if (positionalIndex >= paramCount) {
				error(state, `Too many arguments for function '${funcName}'`, callExpr.loc);
				return;
			}
			matchedArgs[positionalIndex] = arg.value;
			if (i$6 === dollarIndex) dollarParamIndex = positionalIndex;
			positionalIndex++;
		}
	}
	const resolvedArgs = {};
	for (let i$6 = 0; i$6 < paramCount; i$6++) {
		const expr = matchedArgs[i$6];
		if (expr) resolvedArgs[params[i$6]] = [expr];
	}
	pushCallMeta(state, callExpr, funcName, resolvedArgs);
	let lastProvidedIndex = -1;
	for (let i$6 = paramCount - 1; i$6 >= 0; i$6--) if (matchedArgs[i$6] !== null) {
		lastProvidedIndex = i$6;
		break;
	}
	const argCount = lastProvidedIndex >= 0 ? lastProvidedIndex + 1 : paramCount;
	for (let i$6 = 0; i$6 < argCount; i$6++) {
		if (i$6 === dollarParamIndex) continue;
		const argExpr = matchedArgs[i$6];
		if (argExpr) compileExpr(state, argExpr);
		else {
			state.ops.push(AudioVmOp.PushUndefined);
			state.stack.push({ expr: callExpr });
		}
	}
	compileGetVariable(state, varInfo);
	pushCallSiteSourceMap(state, callExpr, funcName);
	state.ops.push(AudioVmOp.CallFunction);
	state.ops.push(argCount);
	state.stack.push({ expr: callExpr });
}
function compileIf(state, stmt) {
	compileExpr(state, stmt.test);
	state.ops.push(AudioVmOp.JumpIfFalse);
	const jumpToElsePatchIndex = state.ops.length;
	state.ops.push(0);
	compileStmt(state, stmt.then);
	if (stmt.else) {
		state.ops.push(AudioVmOp.Jump);
		const jumpToEndPatchIndex = state.ops.length;
		state.ops.push(0);
		const elseTarget = state.ops.length;
		state.ops[jumpToElsePatchIndex] = elseTarget;
		compileStmt(state, stmt.else);
		const endTarget = state.ops.length;
		state.ops[jumpToEndPatchIndex] = endTarget;
	} else {
		const endTarget = state.ops.length;
		state.ops[jumpToElsePatchIndex] = endTarget;
	}
}
function compileWhile(state, stmt) {
	const loopStart = state.ops.length;
	const loopContext = {
		breakTargets: [],
		continueTargets: []
	};
	state.loopStack.push(loopContext);
	compileExpr(state, stmt.test);
	state.ops.push(AudioVmOp.JumpIfFalse);
	const jumpToEndPatchIndex = state.ops.length;
	state.ops.push(0);
	compileStmt(state, stmt.body);
	const continueTarget = state.ops.length;
	for (const patchIndex of loopContext.continueTargets) state.ops[patchIndex] = continueTarget;
	state.ops.push(AudioVmOp.Jump);
	state.ops.push(loopStart);
	const endTarget = state.ops.length;
	state.ops[jumpToEndPatchIndex] = endTarget;
	for (const patchIndex of loopContext.breakTargets) state.ops[patchIndex] = endTarget;
	state.loopStack.pop();
}
function compileDoWhile(state, stmt) {
	const loopStart = state.ops.length;
	const loopContext = {
		breakTargets: [],
		continueTargets: []
	};
	state.loopStack.push(loopContext);
	compileStmt(state, stmt.body);
	const continueTarget = state.ops.length;
	for (const patchIndex of loopContext.continueTargets) state.ops[patchIndex] = continueTarget;
	compileExpr(state, stmt.test);
	state.ops.push(AudioVmOp.JumpIfTrue);
	state.ops.push(loopStart);
	const endTarget = state.ops.length;
	for (const patchIndex of loopContext.breakTargets) state.ops[patchIndex] = endTarget;
	state.loopStack.pop();
}
function compileFor(state, stmt) {
	pushScope(state);
	compileExpr(state, stmt.from);
	if (state.stack.length === 0) {
		error(state, "for loop start has no value", stmt.loc);
		popScope(state);
		return;
	}
	const loopVar = declareVariable(state, stmt.init, stmt.loc);
	compileSetVariable(state, loopVar, stmt.from);
	state.stack.pop();
	const loopStart = state.ops.length;
	const loopContext = {
		breakTargets: [],
		continueTargets: []
	};
	state.loopStack.push(loopContext);
	compileGetVariable(state, loopVar);
	state.stack.push({ expr: {
		type: "identifier",
		name: stmt.init,
		loc: stmt.loc
	} });
	compileExpr(state, stmt.to);
	state.ops.push(AudioVmOp.LessEqual);
	state.stack.pop();
	state.stack.pop();
	state.stack.push({ expr: stmt.from });
	state.ops.push(AudioVmOp.JumpIfFalse);
	const jumpToEndPatchIndex = state.ops.length;
	state.ops.push(0);
	state.stack.pop();
	compileStmt(state, stmt.body);
	const continueTarget = state.ops.length;
	for (const patchIndex of loopContext.continueTargets) state.ops[patchIndex] = continueTarget;
	compileGetVariable(state, loopVar);
	state.stack.push({ expr: {
		type: "identifier",
		name: stmt.init,
		loc: stmt.loc
	} });
	state.ops.push(AudioVmOp.PushScalar);
	state.ops.push(1);
	state.stack.push({ expr: {
		type: "number",
		value: 1,
		loc: stmt.loc
	} });
	state.ops.push(AudioVmOp.Add);
	state.stack.pop();
	state.stack.pop();
	state.stack.push({ expr: {
		type: "identifier",
		name: stmt.init,
		loc: stmt.loc
	} });
	compileSetVariable(state, loopVar, stmt.from);
	state.stack.pop();
	state.ops.push(AudioVmOp.Jump);
	state.ops.push(loopStart);
	const endTarget = state.ops.length;
	state.ops[jumpToEndPatchIndex] = endTarget;
	for (const patchIndex of loopContext.breakTargets) state.ops[patchIndex] = endTarget;
	state.loopStack.pop();
	popScope(state);
}
function compileForOf(state, stmt) {
	const tempId = state.nextTempId++;
	const arrName = `__arr_${tempId}`;
	const lenName = `__len_${tempId}`;
	const idxName = `__i_${tempId}`;
	compileExpr(state, stmt.iterable);
	if (state.stack.length === 0) {
		error(state, "for-of iterable has no value", stmt.loc);
		return;
	}
	const arrayVar = declareVariable(state, arrName, stmt.loc);
	compileSetVariable(state, arrayVar, stmt.iterable);
	state.stack.pop();
	compileGetVariable(state, arrayVar);
	state.stack.push({ expr: stmt.iterable });
	state.ops.push(AudioVmOp.ArrayLen);
	state.stack.pop();
	state.stack.push({ expr: stmt.iterable });
	const lengthVar = declareVariable(state, lenName, stmt.loc);
	compileSetVariable(state, lengthVar, stmt.iterable);
	state.stack.pop();
	state.ops.push(AudioVmOp.PushScalar);
	state.ops.push(0);
	state.stack.push({ expr: {
		type: "number",
		value: 0,
		loc: stmt.loc
	} });
	const indexVar = declareVariable(state, idxName, stmt.loc);
	compileSetVariable(state, indexVar, stmt.iterable);
	state.stack.pop();
	const loopStart = state.ops.length;
	const loopContext = {
		breakTargets: [],
		continueTargets: []
	};
	state.loopStack.push(loopContext);
	compileGetVariable(state, indexVar);
	state.stack.push({ expr: {
		type: "identifier",
		name: idxName,
		loc: stmt.loc
	} });
	compileGetVariable(state, lengthVar);
	state.stack.push({ expr: {
		type: "identifier",
		name: lenName,
		loc: stmt.loc
	} });
	state.ops.push(AudioVmOp.Less);
	state.stack.pop();
	state.stack.pop();
	state.stack.push({ expr: stmt.iterable });
	state.ops.push(AudioVmOp.JumpIfFalse);
	const jumpToEndPatchIndex = state.ops.length;
	state.ops.push(0);
	state.stack.pop();
	compileGetVariable(state, arrayVar);
	state.stack.push({ expr: stmt.iterable });
	compileGetVariable(state, indexVar);
	state.stack.push({ expr: {
		type: "identifier",
		name: idxName,
		loc: stmt.loc
	} });
	state.ops.push(AudioVmOp.ArrayGet, 0);
	state.stack.pop();
	state.stack.pop();
	state.stack.push({ expr: {
		type: "identifier",
		name: stmt.value,
		loc: stmt.loc
	} });
	compileSetVariable(state, declareVariable(state, stmt.value, stmt.loc), stmt.iterable);
	state.stack.pop();
	if (stmt.index) {
		compileGetVariable(state, indexVar);
		state.stack.push({ expr: {
			type: "identifier",
			name: idxName,
			loc: stmt.loc
		} });
		compileSetVariable(state, declareVariable(state, stmt.index, stmt.loc), stmt.iterable);
		state.stack.pop();
	}
	if (stmt.length) {
		compileGetVariable(state, lengthVar);
		state.stack.push({ expr: {
			type: "identifier",
			name: lenName,
			loc: stmt.loc
		} });
		compileSetVariable(state, declareVariable(state, stmt.length, stmt.loc), stmt.iterable);
		state.stack.pop();
	}
	compileStmt(state, stmt.body);
	const continueTarget = state.ops.length;
	for (const patchIndex of loopContext.continueTargets) state.ops[patchIndex] = continueTarget;
	compileGetVariable(state, indexVar);
	state.stack.push({ expr: {
		type: "identifier",
		name: idxName,
		loc: stmt.loc
	} });
	state.ops.push(AudioVmOp.PushScalar);
	state.ops.push(1);
	state.stack.push({ expr: {
		type: "number",
		value: 1,
		loc: stmt.loc
	} });
	state.ops.push(AudioVmOp.Add);
	state.stack.pop();
	state.stack.pop();
	state.stack.push({ expr: {
		type: "identifier",
		name: idxName,
		loc: stmt.loc
	} });
	compileSetVariable(state, indexVar, stmt.iterable);
	state.stack.pop();
	state.ops.push(AudioVmOp.Jump);
	state.ops.push(loopStart);
	const endTarget = state.ops.length;
	state.ops[jumpToEndPatchIndex] = endTarget;
	for (const patchIndex of loopContext.breakTargets) state.ops[patchIndex] = endTarget;
	state.loopStack.pop();
}
function compileBreak(state, stmt) {
	if (state.loopStack.length === 0) {
		error(state, "break statement outside of loop", stmt.loc);
		return;
	}
	let targetLoop = null;
	if (stmt.label) {
		for (let i$6 = state.loopStack.length - 1; i$6 >= 0; i$6--) if (state.loopStack[i$6].label === stmt.label) {
			targetLoop = state.loopStack[i$6];
			break;
		}
		if (!targetLoop) {
			error(state, `Label not found: ${stmt.label}`, stmt.loc);
			return;
		}
	} else targetLoop = state.loopStack[state.loopStack.length - 1];
	state.ops.push(AudioVmOp.Jump);
	const patchIndex = state.ops.length;
	state.ops.push(0);
	targetLoop.breakTargets.push(patchIndex);
}
function compileContinue(state, stmt) {
	if (state.loopStack.length === 0) {
		error(state, "continue statement outside of loop", stmt.loc);
		return;
	}
	let targetLoop = null;
	if (stmt.label) {
		for (let i$6 = state.loopStack.length - 1; i$6 >= 0; i$6--) if (state.loopStack[i$6].label === stmt.label) {
			targetLoop = state.loopStack[i$6];
			break;
		}
		if (!targetLoop) {
			error(state, `Label not found: ${stmt.label}`, stmt.loc);
			return;
		}
	} else targetLoop = state.loopStack[state.loopStack.length - 1];
	state.ops.push(AudioVmOp.Jump);
	const patchIndex = state.ops.length;
	state.ops.push(0);
	targetLoop.continueTargets.push(patchIndex);
}
function compileLabel(state, stmt) {
	if (stmt.stmt.type === "while" || stmt.stmt.type === "do" || stmt.stmt.type === "for" || stmt.stmt.type === "for-of") {
		const loopContext = {
			label: stmt.name,
			breakTargets: [],
			continueTargets: []
		};
		state.loopStack.push(loopContext);
		if (stmt.stmt.type === "while") {
			const loopStart = state.ops.length;
			compileExpr(state, stmt.stmt.test);
			state.ops.push(AudioVmOp.JumpIfFalse);
			const jumpToEndPatchIndex = state.ops.length;
			state.ops.push(0);
			compileStmt(state, stmt.stmt.body);
			const continueTarget = state.ops.length;
			for (const patchIndex of loopContext.continueTargets) state.ops[patchIndex] = continueTarget;
			state.ops.push(AudioVmOp.Jump);
			state.ops.push(loopStart);
			const endTarget = state.ops.length;
			state.ops[jumpToEndPatchIndex] = endTarget;
			for (const patchIndex of loopContext.breakTargets) state.ops[patchIndex] = endTarget;
		} else if (stmt.stmt.type === "do") {
			const loopStart = state.ops.length;
			compileStmt(state, stmt.stmt.body);
			const continueTarget = state.ops.length;
			for (const patchIndex of loopContext.continueTargets) state.ops[patchIndex] = continueTarget;
			compileExpr(state, stmt.stmt.test);
			state.ops.push(AudioVmOp.JumpIfTrue);
			state.ops.push(loopStart);
			const endTarget = state.ops.length;
			for (const patchIndex of loopContext.breakTargets) state.ops[patchIndex] = endTarget;
		} else if (stmt.stmt.type === "for") {
			pushScope(state);
			compileExpr(state, stmt.stmt.from);
			if (state.stack.length === 0) {
				error(state, "for loop start has no value", stmt.stmt.loc);
				popScope(state);
				state.loopStack.pop();
				return;
			}
			const loopVar = declareVariable(state, stmt.stmt.init, stmt.stmt.loc);
			compileSetVariable(state, loopVar, stmt.stmt.from);
			state.stack.pop();
			const loopStart = state.ops.length;
			compileGetVariable(state, loopVar);
			state.stack.push({ expr: {
				type: "identifier",
				name: stmt.stmt.init,
				loc: stmt.stmt.loc
			} });
			compileExpr(state, stmt.stmt.to);
			state.ops.push(AudioVmOp.LessEqual);
			state.stack.pop();
			state.stack.pop();
			state.stack.push({ expr: stmt.stmt.from });
			state.ops.push(AudioVmOp.JumpIfFalse);
			const jumpToEndPatchIndex = state.ops.length;
			state.ops.push(0);
			state.stack.pop();
			compileStmt(state, stmt.stmt.body);
			const continueTarget = state.ops.length;
			for (const patchIndex of loopContext.continueTargets) state.ops[patchIndex] = continueTarget;
			compileGetVariable(state, loopVar);
			state.stack.push({ expr: {
				type: "identifier",
				name: stmt.stmt.init,
				loc: stmt.stmt.loc
			} });
			state.ops.push(AudioVmOp.PushScalar);
			state.ops.push(1);
			state.stack.push({ expr: {
				type: "number",
				value: 1,
				loc: stmt.stmt.loc
			} });
			state.ops.push(AudioVmOp.Add);
			state.stack.pop();
			state.stack.pop();
			state.stack.push({ expr: {
				type: "identifier",
				name: stmt.stmt.init,
				loc: stmt.stmt.loc
			} });
			compileSetVariable(state, loopVar, stmt.stmt.from);
			state.stack.pop();
			state.ops.push(AudioVmOp.Jump);
			state.ops.push(loopStart);
			const endTarget = state.ops.length;
			state.ops[jumpToEndPatchIndex] = endTarget;
			for (const patchIndex of loopContext.breakTargets) state.ops[patchIndex] = endTarget;
			popScope(state);
		} else if (stmt.stmt.type === "for-of") {
			const forOfStmt = stmt.stmt;
			const tempId = state.nextTempId++;
			const arrName = `__arr_${tempId}`;
			const lenName = `__len_${tempId}`;
			const idxName = `__i_${tempId}`;
			compileExpr(state, forOfStmt.iterable);
			if (state.stack.length === 0) {
				error(state, "for-of iterable has no value", forOfStmt.loc);
				state.loopStack.pop();
				return;
			}
			const arrayVar = declareVariable(state, arrName, forOfStmt.loc);
			compileSetVariable(state, arrayVar, forOfStmt.iterable);
			state.stack.pop();
			compileGetVariable(state, arrayVar);
			state.stack.push({ expr: forOfStmt.iterable });
			state.ops.push(AudioVmOp.ArrayLen);
			state.stack.pop();
			state.stack.push({ expr: forOfStmt.iterable });
			const lengthVar = declareVariable(state, lenName, forOfStmt.loc);
			compileSetVariable(state, lengthVar, forOfStmt.iterable);
			state.stack.pop();
			state.ops.push(AudioVmOp.PushScalar);
			state.ops.push(0);
			state.stack.push({ expr: {
				type: "number",
				value: 0,
				loc: forOfStmt.loc
			} });
			const indexVar = declareVariable(state, idxName, forOfStmt.loc);
			compileSetVariable(state, indexVar, forOfStmt.iterable);
			state.stack.pop();
			const loopStart = state.ops.length;
			compileGetVariable(state, indexVar);
			state.stack.push({ expr: {
				type: "identifier",
				name: idxName,
				loc: forOfStmt.loc
			} });
			compileGetVariable(state, lengthVar);
			state.stack.push({ expr: {
				type: "identifier",
				name: lenName,
				loc: forOfStmt.loc
			} });
			state.ops.push(AudioVmOp.Less);
			state.stack.pop();
			state.stack.pop();
			state.stack.push({ expr: forOfStmt.iterable });
			state.ops.push(AudioVmOp.JumpIfFalse);
			const jumpToEndPatchIndex = state.ops.length;
			state.ops.push(0);
			state.stack.pop();
			compileGetVariable(state, arrayVar);
			state.stack.push({ expr: forOfStmt.iterable });
			compileGetVariable(state, indexVar);
			state.stack.push({ expr: {
				type: "identifier",
				name: idxName,
				loc: forOfStmt.loc
			} });
			state.ops.push(AudioVmOp.ArrayGet, 0);
			state.stack.pop();
			state.stack.pop();
			state.stack.push({ expr: {
				type: "identifier",
				name: forOfStmt.value,
				loc: forOfStmt.loc
			} });
			compileSetVariable(state, declareVariable(state, forOfStmt.value, forOfStmt.loc), forOfStmt.iterable);
			state.stack.pop();
			if (forOfStmt.index) {
				compileGetVariable(state, indexVar);
				state.stack.push({ expr: {
					type: "identifier",
					name: idxName,
					loc: forOfStmt.loc
				} });
				compileSetVariable(state, declareVariable(state, forOfStmt.index, forOfStmt.loc), forOfStmt.iterable);
				state.stack.pop();
			}
			if (forOfStmt.length) {
				compileGetVariable(state, lengthVar);
				state.stack.push({ expr: {
					type: "identifier",
					name: lenName,
					loc: forOfStmt.loc
				} });
				compileSetVariable(state, declareVariable(state, forOfStmt.length, forOfStmt.loc), forOfStmt.iterable);
				state.stack.pop();
			}
			compileStmt(state, forOfStmt.body);
			const continueTarget = state.ops.length;
			for (const patchIndex of loopContext.continueTargets) state.ops[patchIndex] = continueTarget;
			compileGetVariable(state, indexVar);
			state.stack.push({ expr: {
				type: "identifier",
				name: idxName,
				loc: forOfStmt.loc
			} });
			state.ops.push(AudioVmOp.PushScalar);
			state.ops.push(1);
			state.stack.push({ expr: {
				type: "number",
				value: 1,
				loc: forOfStmt.loc
			} });
			state.ops.push(AudioVmOp.Add);
			state.stack.pop();
			state.stack.pop();
			state.stack.push({ expr: {
				type: "identifier",
				name: idxName,
				loc: forOfStmt.loc
			} });
			compileSetVariable(state, indexVar, forOfStmt.iterable);
			state.stack.pop();
			state.ops.push(AudioVmOp.Jump);
			state.ops.push(loopStart);
			const endTarget = state.ops.length;
			state.ops[jumpToEndPatchIndex] = endTarget;
			for (const patchIndex of loopContext.breakTargets) state.ops[patchIndex] = endTarget;
		}
		state.loopStack.pop();
	} else compileStmt(state, stmt.stmt);
}
function compileThrow(state, stmt) {
	if (stmt.value) compileExpr(state, stmt.value);
	else {
		state.ops.push(AudioVmOp.PushScalar);
		state.ops.push(0);
		state.stack.push({ expr: {
			type: "number",
			value: 0,
			loc: stmt.loc
		} });
	}
	state.ops.push(AudioVmOp.Throw);
	state.stack.pop();
}
function compileTry(state, stmt) {
	let catchParamIndex = -1;
	if (stmt.catch) {
		catchParamIndex = state.nextLocalIndex;
		state.nextLocalIndex++;
	}
	state.ops.push(AudioVmOp.PushTryBlock);
	const catchPcIndex = state.ops.length;
	state.ops.push(-1);
	const finallyPcIndex = state.ops.length;
	state.ops.push(-1);
	state.ops.push(catchParamIndex);
	compileStmt(state, stmt.body);
	if (!stmt.finally) state.ops.push(AudioVmOp.PopTryBlock);
	state.ops.push(AudioVmOp.Jump);
	const jumpFromTryIndex = state.ops.length;
	state.ops.push(0);
	const jumpsToFinallyOrEnd = [jumpFromTryIndex];
	if (stmt.catch) {
		const catchStart = state.ops.length;
		state.ops[catchPcIndex] = catchStart;
		pushScope(state);
		const currentScope = getCurrentScope(state);
		if (currentScope) currentScope.set(stmt.catch.param, {
			scope: "local",
			index: catchParamIndex
		});
		if (stmt.catch.body.type === "block") for (const s$4 of stmt.catch.body.body) compileStmt(state, s$4);
		else compileStmt(state, stmt.catch.body);
		popScope(state);
		if (!stmt.finally) state.ops.push(AudioVmOp.PopTryBlock);
		state.ops.push(AudioVmOp.Jump);
		jumpsToFinallyOrEnd.push(state.ops.length);
		state.ops.push(0);
	}
	let finallyStart = -1;
	if (stmt.finally) {
		finallyStart = state.ops.length;
		state.ops[finallyPcIndex] = finallyStart;
		compileStmt(state, stmt.finally);
		state.ops.push(AudioVmOp.PopTryBlock);
	}
	const endTarget = state.ops.length;
	const jumpTarget = stmt.finally ? finallyStart : endTarget;
	for (const index of jumpsToFinallyOrEnd) state.ops[index] = jumpTarget;
}
function compileUnaryOp(state, expr) {
	compileExpr(state, expr.expr);
	if (state.stack.length === 0) {
		error(state, "Unary operator requires an operand", expr.loc.line, expr.loc.column);
		return;
	}
	const opCode = {
		"-": AudioVmOp.Neg,
		"!": AudioVmOp.Not,
		"~": AudioVmOp.BitNot
	}[expr.op];
	if (opCode === void 0) {
		error(state, `Unknown unary operator: ${expr.op}`, expr.loc.line, expr.loc.column);
		return;
	}
	state.ops.push(opCode);
	state.stack.pop();
	state.stack.push({ expr });
}
function compileBinaryOp(state, expr) {
	compileExpr(state, expr.left);
	compileExpr(state, expr.right);
	const opCode = {
		"+": AudioVmOp.Add,
		"-": AudioVmOp.Sub,
		"*": AudioVmOp.Mul,
		"/": AudioVmOp.Div,
		"%": AudioVmOp.Mod,
		"**": AudioVmOp.Pow,
		">": AudioVmOp.Greater,
		"<": AudioVmOp.Less,
		">=": AudioVmOp.GreaterEqual,
		"<=": AudioVmOp.LessEqual,
		"==": AudioVmOp.Equal,
		"!=": AudioVmOp.NotEqual,
		"&&": AudioVmOp.And,
		"||": AudioVmOp.Or,
		"&": AudioVmOp.BitAnd,
		"|": AudioVmOp.BitOr,
		"^": AudioVmOp.BitXor,
		"<<": AudioVmOp.ShiftLeft,
		">>": AudioVmOp.ShiftRight
	}[expr.op];
	if (opCode === void 0) {
		error(state, `Unknown binary operator: ${expr.op}`, expr.loc.line, expr.loc.column);
		return;
	}
	state.ops.push(opCode);
	state.stack.pop();
	state.stack.pop();
	state.stack.push({ expr });
}
function compileTernary(state, expr) {
	compileExpr(state, expr.test);
	state.ops.push(AudioVmOp.JumpIfFalse);
	const jumpToElsePatchIndex = state.ops.length;
	state.ops.push(0);
	compileExpr(state, expr.then);
	state.ops.push(AudioVmOp.Jump);
	const jumpToEndPatchIndex = state.ops.length;
	state.ops.push(0);
	const elseTarget = state.ops.length;
	state.ops[jumpToElsePatchIndex] = elseTarget;
	state.stack.pop();
	compileExpr(state, expr.else);
	const endTarget = state.ops.length;
	state.ops[jumpToEndPatchIndex] = endTarget;
	state.stack[state.stack.length - 1] = { expr };
}
function compilePipe(state, expr) {
	compileExpr(state, expr.left);
	if (state.stack.length === 0) {
		error(state, "Pipe operator requires a left-hand value", expr.loc);
		return;
	}
	pushScope(state);
	const pipeName = `__pipe_${state.nextTempId++}`;
	const pipeVar = state.functionDepth === 0 ? (() => {
		const info = {
			scope: "global",
			index: state.nextGlobalIndex++
		};
		getCurrentScope(state).set(pipeName, info);
		return info;
	})() : declareVariable(state, pipeName, expr.loc, true);
	compileSetVariable(state, pipeVar, expr.left);
	state.stack.pop();
	state.pipeVars.push({
		varInfo: pipeVar,
		functionDepth: state.functionDepth
	});
	compileExpr(state, expr.right);
	state.pipeVars.pop();
	popScope(state);
}
function compileArray(state, expr) {
	if (expr.items.length === 0) {
		state.ops.push(AudioVmOp.MakeArray);
		state.ops.push(0);
		state.stack.push({ expr });
		return;
	}
	for (const item of expr.items) compileExpr(state, item);
	state.ops.push(AudioVmOp.MakeArray);
	state.ops.push(expr.items.length);
	state.stack.length -= expr.items.length;
	state.stack.push({ expr });
}
function compileMember(state, expr) {
	compileExpr(state, expr.object);
	if (state.stack.length === 0) {
		error(state, "Member access requires an object", expr.loc);
		return;
	}
	if (expr.property === "length") {
		state.ops.push(AudioVmOp.ArrayLen);
		state.stack.pop();
		state.stack.push({ expr });
		return;
	} else if (expr.property === "avg" || expr.property === "push" || expr.property === "shuffle" || expr.property === "map") return;
	else error(state, `Unknown property: ${expr.property}`, expr.loc);
}
function isTopLevelFnAssign(state, stmt) {
	if (state.functionDepth !== 0) return false;
	if (stmt.type !== "expr" || stmt.expr.type !== "assign") return false;
	const expr = stmt.expr;
	if (expr.left.type !== "identifier") return false;
	return expr.op === "=>" || expr.op === ":=" && expr.right.type === "fn" || expr.op === "=" && expr.right.type === "fn";
}
function isDeferredDefStmt(state, stmt) {
	if (!isTopLevelFnAssign(state, stmt)) return false;
	const expr = stmt.expr;
	if (expr.left.type !== "identifier") return false;
	const name = expr.left.name;
	const loc = expr.loc;
	return state.deferredGlobalFunctions.some((d$5) => d$5.name === name && d$5.loc.start === loc.start && d$5.loc.end === loc.end);
}
function declareAssignLhs(state, expr) {
	const shadow = expr.op === ":=";
	if (expr.left.type === "destructure") {
		for (const name of expr.left.names) declareVariable(state, name, expr.left.loc, shadow);
		return;
	}
	if (expr.left.type === "identifier") declareVariable(state, expr.left.name, expr.loc, shadow);
}
function collectDeferredGlobalFunctions(state, body, atTopLevel = true) {
	for (const stmt of body) {
		if (stmt.type === "block") {
			pushScope(state);
			collectDeferredGlobalFunctions(state, stmt.body, false);
			popScope(state);
			continue;
		}
		if (stmt.type === "expr" && stmt.expr.type === "assign") {
			const assign = stmt.expr;
			const existedBefore = atTopLevel && assign.left.type === "identifier" ? lookupVariable(state, assign.left.name) : null;
			declareAssignLhs(state, assign);
			if (atTopLevel && isTopLevelFnAssign(state, stmt)) {
				if (assign.left.type !== "identifier") continue;
				const name = assign.left.name;
				if (existedBefore) continue;
				if (name === "mix") state.mixDefinitionLoc = assign.loc;
				const varInfo = lookupVariable(state, name);
				if (!varInfo || varInfo.scope !== "global") continue;
				const globalIndex = varInfo.index;
				let fnExpr;
				if (assign.op === "=>") {
					const x$4 = {
						type: "identifier",
						name: "x",
						loc: assign.left.loc
					};
					fnExpr = {
						type: "fn",
						params: [{
							type: "param",
							name: "x",
							loc: assign.left.loc
						}],
						defaults: [null],
						body: {
							type: "binary",
							op: "|>",
							left: x$4,
							right: assign.right,
							loc: assign.right.loc
						},
						loc: assign.loc
					};
				} else {
					if (assign.right.type !== "fn") continue;
					fnExpr = assign.right;
				}
				state.deferredGlobalFunctions.push({
					name,
					fnExpr,
					globalIndex,
					loc: assign.loc
				});
			}
		}
	}
}
function compile$2(state, program, preludeLines = 0) {
	state.preludeLines = preludeLines;
	state.ops = [];
	state.errors = [];
	state.stack = [];
	state.functionAliases = /* @__PURE__ */ new Map();
	state.globals = /* @__PURE__ */ new Map();
	state.locals = [];
	state.closureVars = [];
	state.functions = [];
	state.stringExpressions = /* @__PURE__ */ new Map();
	state.functionBytecodes = /* @__PURE__ */ new Map();
	state.loopStack = [];
	state.pipeVars = [];
	state.nextGlobalIndex = 0;
	state.nextLocalIndex = 0;
	state.nextFunctionId = 0;
	state.nextTempId = 0;
	state.inFunction = false;
	state.sampleRegistrations = [];
	state.recordCallbacks = /* @__PURE__ */ new Map();
	state.recordCallbackTemplates = /* @__PURE__ */ new Map();
	state.nextRecordScopeId = 0;
	state.scopeCaptureGlobals = /* @__PURE__ */ new Map();
	state.arrayInitOps = [];
	state.arrayInitRequests = [];
	state.arrayInitPcOffset = 0;
	state.nextRecordGlobalIdx = 1e3;
	state.recordHandleByScopeGlobal = null;
	state.currentRecordScopeIdGlobal = null;
	state.recordCaptureStoresByScopeGlobal = null;
	state.callSiteIdToHandle = /* @__PURE__ */ new Map();
	state.historySourceMap = [];
	state.labels = [];
	state.varToArrayLiteral = /* @__PURE__ */ new Map();
	state.mixDefinitionLoc = null;
	state.scale = "major";
	state.scaleIndex = 0;
	state.rootMidi = 0;
	state.functionBytecodeStarts = /* @__PURE__ */ new Map();
	state.currentFunctionId = null;
	state.deferredGlobalFunctions = [];
	state.functionsByNameStack = [/* @__PURE__ */ new Map()];
	state.oversampleCallbackFunctionIds = /* @__PURE__ */ new Set();
	const recordMapping = assignRecordCallIds(program);
	state.recordCallIds = recordMapping.recordCallIds;
	state.functionToRecordCall = recordMapping.functionToRecordCall;
	state.recordCallExprs = /* @__PURE__ */ new Map();
	collectDeferredGlobalFunctions(state, program.body);
	const deferredNames = new Set(state.deferredGlobalFunctions.map((d$5) => d$5.name));
	const collectAliasesFromAst = (body) => {
		for (const stmt of body) {
			if (stmt.type === "block") {
				collectAliasesFromAst(stmt.body);
				continue;
			}
			if (stmt.type === "expr" && stmt.expr.type === "assign") {
				const assign = stmt.expr;
				if (assign.left.type === "identifier" && assign.right.type === "identifier") {
					const target = assign.right.name;
					if (deferredNames.has(target)) state.functionAliases.set(assign.left.name, target);
				}
			}
		}
	};
	collectAliasesFromAst(program.body);
	state.ops = [];
	state.isDeferredPass = true;
	for (const { name, fnExpr, globalIndex, loc } of state.deferredGlobalFunctions) {
		const prevCaptureGlobals = state.captureGlobalsInClosures;
		if (loc.line <= state.preludeLines) state.captureGlobalsInClosures = true;
		compileFunction(state, fnExpr, name);
		state.captureGlobalsInClosures = prevCaptureGlobals;
		state.ops.push(AudioVmOp.SetGlobal, globalIndex);
		state.stack.pop();
	}
	const deferredOps = state.ops.slice();
	const deferredLength = deferredOps.length;
	state.ops = [];
	state.isDeferredPass = false;
	for (const stmt of program.body) {
		if (isDeferredDefStmt(state, stmt)) continue;
		compileStmt(state, stmt);
	}
	state.ops = deferredOps.concat(state.ops);
	patchPcParamsInRange(state.ops, deferredLength, deferredLength);
	state.arrayInitPcOffset = deferredLength;
	const arrayInitOps = [];
	for (const { capacity, globalIdx } of state.arrayInitRequests) {
		for (let j$4 = 0; j$4 < capacity; j$4++) arrayInitOps.push(AudioVmOp.PushUndefined);
		arrayInitOps.push(AudioVmOp.MakeArray, capacity, AudioVmOp.SetGlobal, globalIdx);
	}
	if (state.recordCaptureStoresByScopeGlobal !== null && state.recordCallbacks.size > 0) {
		const maxScopeId = Math.max(...state.recordCallbacks.keys(), -1);
		for (let scopeId = 0; scopeId <= maxScopeId; scopeId++) {
			const cb = state.recordCallbacks.get(scopeId);
			const numDeps = cb ? cb.recordGlobalIndices.length : 1;
			const capacity = Math.max(1, numDeps);
			for (let j$4 = 0; j$4 < capacity; j$4++) arrayInitOps.push(AudioVmOp.PushUndefined);
			arrayInitOps.push(AudioVmOp.MakeArray, capacity);
		}
		arrayInitOps.push(AudioVmOp.MakeArray, maxScopeId + 1, AudioVmOp.SetGlobal, state.recordCaptureStoresByScopeGlobal);
	}
	state.arrayInitRequests = [];
	const arrayInitOffset = arrayInitOps.length;
	if (arrayInitOffset > 0) for (let i$6 = 0; i$6 < state.historySourceMap.length; i$6++) {
		const entry = state.historySourceMap[i$6];
		if (entry.inFunction && entry.__finalFunctionId !== void 0) {
			if (state.oversampleCallbackFunctionIds.has(entry.__finalFunctionId)) continue;
		}
	}
	if (state.errors.length > 0) return {
		bytecode: null,
		errors: state.errors,
		sampleRegistrations: [],
		recordCallbacks: /* @__PURE__ */ new Map(),
		historySourceMap: [],
		labels: [],
		functionCalls: [],
		bpm: state.bpm
	};
	const postPc = state.ops.length;
	const mixDef = state.mixDefinitionLoc;
	if (mixDef !== null) {
		const mixLine = Math.max(1, mixDef.line - state.preludeLines);
		state.historySourceMap.push({
			line: mixLine,
			column: mixDef.column,
			genName: "Mix",
			pc: postPc,
			inFunction: false
		});
	}
	state.ops.push(AudioVmOp.Post);
	const mixVarInfo = lookupVariable(state, "mix");
	if (mixVarInfo && mixVarInfo.scope === "global") {
		state.ops.push(AudioVmOp.GetGlobal);
		state.ops.push(mixVarInfo.index);
	} else {
		state.ops.push(AudioVmOp.GetGlobal);
		state.ops.push(0);
	}
	state.ops.push(AudioVmOp.CallFunction);
	state.ops.push(1);
	if (state.stack.length > 0) state.stack.pop();
	state.stack.push({ expr: {
		type: "array",
		items: [],
		loc: {
			start: 0,
			end: 0,
			line: 0,
			column: 0
		}
	} });
	const totalLen = arrayInitOffset + state.ops.length;
	const buffer = /* @__PURE__ */ new ArrayBuffer(totalLen * 4);
	const u32View = new Uint32Array(buffer);
	const f32View = new Float32Array(buffer);
	if (arrayInitOffset > 0) {
		encodeToBuffer(arrayInitOps, u32View, f32View, 0, 0);
		encodeToBuffer(state.ops, u32View, f32View, arrayInitOffset, arrayInitOffset);
	} else encodeToBuffer(state.ops, u32View, f32View, 0, 0);
	for (const [funcName, recordCallLocKey] of state.functionToRecordCall.entries()) {
		if (!hasFunctionByName(state, funcName)) continue;
		const recordCallExpr = state.recordCallExprs.get(recordCallLocKey);
		if (recordCallExpr) {
			const args = recordCallExpr.args;
			const secondsArg = args[0]?.type === "arg" ? args[0].value : null;
			if (secondsArg && secondsArg.type === "number") {
				const seconds = Math.max(0, Math.min(10, secondsArg.value));
				const directRecordCallIds = /* @__PURE__ */ new Set();
				for (const [locKey, id] of state.recordCallIds.entries()) if (state.recordCallExprs.has(locKey)) directRecordCallIds.add(id);
				for (const [callSiteLocKey, callSiteId] of state.recordCallIds.entries()) {
					if (directRecordCallIds.has(callSiteId)) continue;
					if (!state.recordCallbacks.has(callSiteId)) continue;
					if (!state.sampleRegistrations.some((reg) => reg.type === "record" && reg.recordCallbackId === callSiteId)) {
						const handle = sampleManager.registerRecord(state.projectId, seconds, callSiteId);
						state.sampleRegistrations.push({
							handle,
							type: "record",
							recordSeconds: seconds,
							recordCallbackId: callSiteId,
							recordProjectId: state.projectId
						});
					}
				}
			}
		}
	}
	for (const entry of state.historySourceMap) entry.pc += arrayInitOffset + (entry.__fromMainProgram ? state.arrayInitPcOffset : 0);
	const functionReturnPcs = {};
	for (const [name, funcInfo] of functionsByNameEntries(state)) {
		const idx = funcInfo.returnHistorySourceMapIndex;
		if (idx != null) {
			const entry = state.historySourceMap[idx];
			if (entry) functionReturnPcs[name] = entry.pc;
		}
	}
	return {
		bytecode: f32View,
		errors: [],
		sampleRegistrations: state.sampleRegistrations,
		historySourceMap: state.historySourceMap,
		labels: state.labels,
		recordCallbacks: state.recordCallbacks,
		functionReturnPcs,
		functionCalls: state.functionCallsMeta,
		bpm: state.bpm
	};
}
function compileStmt(state, stmt) {
	switch (stmt.type) {
		case "expr":
			compileExpr(state, stmt.expr);
			break;
		case "block":
			pushScope(state);
			for (const s$4 of stmt.body) compileStmt(state, s$4);
			popScope(state);
			break;
		case "return":
			if (stmt.value) compileExpr(state, stmt.value);
			else {
				state.ops.push(AudioVmOp.PushScalar);
				state.ops.push(0);
				state.stack.push({ expr: {
					type: "number",
					value: 0,
					loc: stmt.loc
				} });
			}
			state.ops.push(AudioVmOp.Return);
			break;
		case "if":
			compileIf(state, stmt);
			break;
		case "while":
			compileWhile(state, stmt);
			break;
		case "do":
			compileDoWhile(state, stmt);
			break;
		case "for":
			compileFor(state, stmt);
			break;
		case "for-of":
			compileForOf(state, stmt);
			break;
		case "break":
			compileBreak(state, stmt);
			break;
		case "continue":
			compileContinue(state, stmt);
			break;
		case "label":
			compileLabel(state, stmt);
			break;
		case "throw":
			compileThrow(state, stmt);
			break;
		case "try":
			compileTry(state, stmt);
			break;
		default: error(state, `Unsupported statement type: ${stmt.type}`, stmt.loc);
	}
}
var OUT_SOLO_BUILTINS = new Set(["out", "solo"]);
function isKnownBuiltinName(name) {
	return getBuiltinSpec(name) !== null || OUT_SOLO_BUILTINS.has(name);
}
function getBuiltinSpec(name) {
	const byVariant = genSpecs.find((s$4) => s$4.variantName === name);
	if (byVariant) return byVariant;
	const genName = name.charAt(0).toUpperCase() + name.slice(1);
	return genSpecs.find((s$4) => s$4.genName === genName && s$4.variantName === "default") ?? null;
}
function compileBuiltinAsValue(state, builtinName, loc) {
	if (OUT_SOLO_BUILTINS.has(builtinName)) {
		compileFunction(state, {
			type: "fn",
			params: [{
				type: "param",
				name: "in",
				loc
			}, {
				type: "param",
				name: "name",
				loc
			}],
			defaults: [null, {
				type: "identifier",
				name: "undefined",
				loc
			}],
			body: {
				type: "call",
				callee: {
					type: "identifier",
					name: builtinName,
					loc
				},
				args: [{
					type: "arg",
					value: {
						type: "identifier",
						name: "in",
						loc
					},
					shorthand: true,
					loc
				}, {
					type: "arg",
					value: {
						type: "identifier",
						name: "name",
						loc
					},
					shorthand: true,
					loc
				}],
				loc
			},
			loc
		}, null);
		return;
	}
	const spec = getBuiltinSpec(builtinName);
	if (!spec) return;
	const paramNames = spec.usesInput ? ["in", ...spec.paramNames] : spec.paramNames;
	const params = paramNames.map((name) => ({
		type: "param",
		name,
		loc
	}));
	const callArgs = paramNames.map((name) => ({
		type: "arg",
		value: {
			type: "identifier",
			name,
			loc
		},
		shorthand: true,
		loc
	}));
	compileFunction(state, {
		type: "fn",
		params,
		body: {
			type: "call",
			callee: {
				type: "identifier",
				name: builtinName,
				loc
			},
			args: callArgs,
			loc
		},
		loc
	}, null);
}
function compileExpr(state, expr) {
	switch (expr.type) {
		case "number":
			state.ops.push(AudioVmOp.PushScalar);
			state.ops.push(expr.value);
			state.stack.push({ expr });
			break;
		case "string":
			const stringKey = `${expr.loc.start}:${expr.loc.end}:${expr.loc.line}:${expr.loc.column}`;
			state.stringExpressions.set(stringKey, {
				value: expr.value,
				delimiter: expr.delimiter,
				loc: expr.loc
			});
			state.stack.push({ expr });
			break;
		case "identifier":
			if (expr.name === "$") {
				const pipe = state.pipeVars[state.pipeVars.length - 1];
				if (!pipe) {
					error(state, "$ used outside of a pipe", expr.loc);
					return;
				}
				if (pipe.functionDepth === state.functionDepth) compileGetVariable(state, pipe.varInfo);
				else {
					const varInfo = lookupVariable(state, "$");
					if (!varInfo) {
						error(state, "$ used outside of a pipe", expr.loc);
						return;
					}
					compileGetVariable(state, varInfo);
				}
				state.stack.push({ expr });
			} else if (expr.name.startsWith("#")) {
				compileHashVar(state, expr.name, expr.loc);
				state.stack.push({ expr });
			} else {
				const varInfo = lookupVariable(state, expr.name);
				if (varInfo) {
					compileGetVariable(state, varInfo);
					state.stack.push({ expr });
				} else if (isNoteName(expr.name)) {
					compileNoteVar(state, expr.name, expr.loc);
					state.stack.push({ expr });
				} else if (isKnownBuiltinName(expr.name)) {
					compileBuiltinAsValue(state, expr.name, expr.loc);
					state.stack.push({ expr });
				} else error(state, `Unknown identifier: ${expr.name}`, expr.loc);
			}
			break;
		case "array":
			compileArray(state, expr);
			break;
		case "index": {
			const idx = expr;
			compileGetCall(state, idx.object, idx.index, idx.loc, idx);
			break;
		}
		case "member":
			compileMember(state, expr);
			break;
		case "fn":
			compileFunction(state, expr, null);
			break;
		case "assign":
			compileAssign(state, expr);
			break;
		case "call":
			compileCall(state, expr);
			break;
		case "unary":
			compileUnaryOp(state, expr);
			break;
		case "binary":
			if (expr.op === "|>") compilePipe(state, expr);
			else compileBinaryOp(state, expr);
			break;
		case "ternary":
			compileTernary(state, expr);
			break;
		case "destructure":
			error(state, "Destructuring pattern can only be used in assignments", expr.loc);
			break;
		default: error(state, `Unsupported expression type: ${expr.type}`, expr.loc);
	}
}
function error(state, message, loc) {
	state.errors.push({
		message,
		loc
	});
}
function pushScope(state) {
	state.locals.push(/* @__PURE__ */ new Map());
}
function popScope(state) {
	state.locals.pop();
}
function getCurrentScope(state) {
	return state.locals.length > 0 ? state.locals[state.locals.length - 1] : null;
}
var State = class {
	arrayInitOps = [];
	arrayInitPcOffset = 0;
	arrayInitRequests = [];
	callSiteIdToHandle = /* @__PURE__ */ new Map();
	captureGlobalsInClosures = false;
	scopeCaptureGlobals = /* @__PURE__ */ new Map();
	nextRecordScopeId = 0;
	closureVars = [];
	compilingRecordCallback = false;
	currentFunctionId = null;
	deferredGlobalFunctions = [];
	errors = [];
	functionCallsMeta = [];
	functionBytecodes = /* @__PURE__ */ new Map();
	functionBytecodeStarts = /* @__PURE__ */ new Map();
	functionDepth = 0;
	functions = [];
	functionAliases = /* @__PURE__ */ new Map();
	functionsByNameStack = [/* @__PURE__ */ new Map()];
	functionToRecordCall = /* @__PURE__ */ new Map();
	functionIdToDefaultParamFunctions = /* @__PURE__ */ new Map();
	globals = /* @__PURE__ */ new Map();
	historySourceMap = [];
	labels = [];
	mixDefinitionLoc = null;
	isDeferredPass = false;
	inFunction = false;
	paramNameToLocalIndex = null;
	locals = [];
	loopStack = [];
	nextFunctionId = 0;
	nextGlobalIndex = 0;
	nextLocalIndex = 0;
	nextRecordGlobalIdx = 1e3;
	nextAllocCallSiteId = 0;
	nextStepCallSiteId = 0;
	nextTempId = 0;
	ops = [];
	oversampleCallbackFunctionIds = /* @__PURE__ */ new Set();
	pipeVars = [];
	preludeLines = 0;
	recordCallbacks = /* @__PURE__ */ new Map();
	recordCallbackTemplates = /* @__PURE__ */ new Map();
	recordCallExprs = /* @__PURE__ */ new Map();
	recordCallIds = /* @__PURE__ */ new Map();
	recordHandleByScopeGlobal = null;
	currentRecordScopeIdGlobal = null;
	recordCaptureStoresByScopeGlobal = null;
	sampleRegistrations = [];
	projectId = null;
	seenCallSites = /* @__PURE__ */ new Set();
	stack = [];
	stringExpressions = /* @__PURE__ */ new Map();
	bpm = 120;
	varToArrayLiteral = /* @__PURE__ */ new Map();
	scale = "major";
	scaleIndex = 0;
	rootMidi = 0;
};
function disassembleBytecode(bytecode$1, indent = 0) {
	const lines = [];
	const u32 = new Uint32Array(bytecode$1.buffer, bytecode$1.byteOffset, bytecode$1.length);
	let pc = 0;
	const pad = "  ".repeat(indent);
	while (pc < bytecode$1.length) {
		const opcode = u32[pc];
		const info = getOpcodeInfo(opcode);
		const name = AudioVmOp[opcode] ?? `Unknown(${opcode})`;
		const here = pc++;
		switch (info.kind) {
			case "param":
			case "pc-param": {
				const param = Math.round(bytecode$1[pc]);
				const suffix = name === "CallFunction" ? ` arg(s)` : "";
				lines.push(`${pad}${here}: ${name} ${param}${suffix}`);
				pc++;
				break;
			}
			case "three-param":
				lines.push(`${pad}${here}: ${name} ${Math.round(bytecode$1[pc])} ${Math.round(bytecode$1[pc + 1])} ${Math.round(bytecode$1[pc + 2])}`);
				pc += 3;
				break;
			case "table": {
				const len = Math.round(bytecode$1[pc]);
				lines.push(`${pad}${here}: ${name} len=${len}`);
				pc += 1 + len;
				break;
			}
			case "define-function": {
				const id = Math.round(bytecode$1[pc]);
				const paramCount = Math.round(bytecode$1[pc + 1]);
				const firstParamIn = Math.round(bytecode$1[pc + 2]);
				const closureCount = Math.round(bytecode$1[pc + 3]);
				const localCount = Math.round(bytecode$1[pc + 4]);
				const len = Math.round(bytecode$1[pc + 5]);
				lines.push(`${pad}${here}: ${name} id=${id} paramCount=${paramCount} firstParamIn=${firstParamIn} closureCount=${closureCount} localCount=${localCount} len=${len}`);
				pc += 6;
				lines.push(...disassembleBytecode(bytecode$1.subarray(pc, pc + len), indent + 1));
				pc += len;
				break;
			}
			case "none":
				lines.push(`${pad}${here}: ${name}`);
				break;
		}
	}
	return lines;
}
function compile$1(program, preludeLines = 0, opts) {
	const state = new State();
	if (opts?.projectId !== void 0) state.projectId = opts.projectId;
	return compile$2(state, program, preludeLines);
}
var ASSIGN_OPS = new Set([
	"=",
	":=",
	"=>",
	"+=",
	"-=",
	"*=",
	"/=",
	"%=",
	"**=",
	"&=",
	"|=",
	"^=",
	"<<=",
	">>="
]);
var BIN_PREC = {
	"||": { prec: 2 },
	"&&": { prec: 3 },
	"|": { prec: 3.5 },
	"^": { prec: 3.7 },
	"&": { prec: 3.9 },
	"==": { prec: 4 },
	"!=": { prec: 4 },
	"<": { prec: 5 },
	"<=": { prec: 5 },
	">": { prec: 5 },
	">=": { prec: 5 },
	"<<": { prec: 5.5 },
	">>": { prec: 5.5 },
	"+": { prec: 6 },
	"-": { prec: 6 },
	"*": { prec: 7 },
	"/": { prec: 7 },
	"%": { prec: 7 },
	"**": {
		prec: 8,
		right: true
	}
};
function parseTokens(input, tokens) {
	const p$6 = new Parser(input, tokens);
	let program = null;
	try {
		program = p$6.parseProgram();
	} catch (e$59) {
		if (p$6.errors.length === 0) p$6.error("Parse error: " + (e$59 instanceof Error ? e$59.message : String(e$59)));
	}
	return {
		program,
		errors: p$6.errors
	};
}
function collectNumberLiterals(program) {
	const out = [];
	const walkExpr = (e$59) => {
		if (e$59.type === "number") {
			out.push(e$59);
			return;
		}
		switch (e$59.type) {
			case "string":
			case "identifier":
			case "destructure": return;
			case "array":
				for (const it$1 of e$59.items) walkExpr(it$1);
				return;
			case "index":
				walkExpr(e$59.object);
				walkExpr(e$59.index);
				return;
			case "member":
				walkExpr(e$59.object);
				return;
			case "unary":
				walkExpr(e$59.expr);
				return;
			case "binary":
				walkExpr(e$59.left);
				walkExpr(e$59.right);
				return;
			case "ternary":
				walkExpr(e$59.test);
				walkExpr(e$59.then);
				walkExpr(e$59.else);
				return;
			case "call":
				walkExpr(e$59.callee);
				for (const a$36 of e$59.args) if (a$36.type === "arg") walkExpr(a$36.value);
				return;
			case "assign":
				walkExpr(e$59.left);
				walkExpr(e$59.right);
				return;
			case "fn":
				for (const d$5 of e$59.defaults ?? []) if (d$5) walkExpr(d$5);
				if (e$59.body.type === "block") walkStmt(e$59.body);
				else walkExpr(e$59.body);
				return;
			default: return;
		}
	};
	const walkStmt = (s$4) => {
		switch (s$4.type) {
			case "expr":
				walkExpr(s$4.expr);
				return;
			case "block":
				for (const it$1 of s$4.body) walkStmt(it$1);
				return;
			case "if":
				walkExpr(s$4.test);
				walkStmt(s$4.then);
				if (s$4.else) walkStmt(s$4.else);
				return;
			case "while":
			case "do":
				walkExpr(s$4.test);
				walkStmt(s$4.body);
				return;
			case "for":
				walkExpr(s$4.from);
				walkExpr(s$4.to);
				walkStmt(s$4.body);
				return;
			case "for-of":
				walkExpr(s$4.iterable);
				walkStmt(s$4.body);
				return;
			case "return":
			case "throw":
				if (s$4.value) walkExpr(s$4.value);
				return;
			case "try":
				walkStmt(s$4.body);
				if (s$4.catch) walkStmt(s$4.catch.body);
				if (s$4.finally) walkStmt(s$4.finally);
				return;
			case "label":
				walkStmt(s$4.stmt);
				return;
			case "break":
			case "continue": return;
		}
	};
	for (const stmt of program.body) walkStmt(stmt);
	return out;
}
var Parser = class {
	errors = [];
	pos = 0;
	guard = 0;
	guardMax;
	hasFatalError = false;
	constructor(input, tokens) {
		this.input = input;
		this.tokens = tokens;
		this.guardMax = tokens.length * 16 + 1024;
	}
	checkUnmatchedBraces() {
		let braceDepth = 0;
		let parenDepth = 0;
		let bracketDepth = 0;
		const openBraces = [];
		const openParens = [];
		const openBrackets = [];
		for (let i$6 = 0; i$6 < this.tokens.length; i$6++) {
			const tok = this.tokens[i$6];
			if (tok.type === "eof") break;
			if (tok.type === "punct") {
				const val = String(tok.value);
				if (val === "{") {
					braceDepth++;
					openBraces.push(tok);
				} else if (val === "}") {
					braceDepth--;
					if (braceDepth < 0) return {
						message: `Unmatched closing brace "}"`,
						token: tok
					};
					openBraces.pop();
				} else if (val === "(") {
					parenDepth++;
					openParens.push(tok);
				} else if (val === ")") {
					parenDepth--;
					if (parenDepth < 0) return {
						message: `Unmatched closing parenthesis ")"`,
						token: tok
					};
					openParens.pop();
				} else if (val === "[") {
					bracketDepth++;
					openBrackets.push(tok);
				} else if (val === "]") {
					bracketDepth--;
					if (bracketDepth < 0) return {
						message: `Unmatched closing bracket "]"`,
						token: tok
					};
					openBrackets.pop();
				}
			}
		}
		if (braceDepth > 0 && openBraces.length > 0) return {
			message: `Unclosed brace "{"`,
			token: openBraces[openBraces.length - 1]
		};
		if (parenDepth > 0 && openParens.length > 0) return {
			message: `Unclosed parenthesis "("`,
			token: openParens[openParens.length - 1]
		};
		if (bracketDepth > 0 && openBrackets.length > 0) return {
			message: `Unclosed bracket "["`,
			token: openBrackets[openBrackets.length - 1]
		};
		return null;
	}
	tick() {
		this.guard++;
		if (this.guard > this.guardMax) {
			const braceError = this.checkUnmatchedBraces();
			if (braceError) this.error(braceError.message, braceError.token);
			else this.error("Parser exceeded max steps (possible infinite loop). Check for unmatched braces, parentheses, or brackets.");
			throw new Error("parse guard");
		}
	}
	at() {
		const t$12 = this.tokens[this.pos];
		if (t$12 === void 0) throw new Error("Parser invariant: pos out of range");
		return t$12;
	}
	prev() {
		if (this.pos <= 0) throw new Error("Parser invariant: prev at start");
		return this.tokens[this.pos - 1];
	}
	is(type, value) {
		const t$12 = this.at();
		if (t$12.type !== type) return false;
		if (value === void 0) return true;
		return t$12.value === value;
	}
	eat(type, value) {
		const t$12 = this.at();
		if (t$12.type !== type || value !== void 0 && t$12.value !== value) return null;
		this.pos++;
		return t$12;
	}
	expect(type, value, message) {
		const t$12 = this.at();
		if (t$12.type === type && (value === void 0 || t$12.value === value)) {
			this.pos++;
			return t$12;
		}
		this.error(message ?? `Expected ${value ?? type}`);
		return t$12;
	}
	error(message, tok = this.at()) {
		this.errors.push({
			message,
			loc: {
				start: tok.start,
				end: tok.end,
				line: tok.line,
				column: tok.column
			},
			code: this.input.slice(tok.start, Math.min(this.input.length, tok.start + 80))
		});
	}
	locFrom(start, end) {
		return {
			start: start.start,
			end: end.end,
			line: start.line,
			column: start.column
		};
	}
	parseProgram() {
		const braceError = this.checkUnmatchedBraces();
		if (braceError) {
			this.error(braceError.message, braceError.token);
			this.hasFatalError = true;
			this.at();
			this.prev();
			throw new Error("parse error");
		}
		const start = this.at();
		const body = [];
		while (!this.is("eof") && !this.hasFatalError) {
			this.tick();
			if (this.is("punct", ";")) {
				this.pos++;
				continue;
			}
			const stmt = this.parseStmt();
			if (stmt) body.push(stmt);
			this.eat("punct", ";");
		}
		const end = this.prev();
		return {
			type: "program",
			body,
			loc: this.locFrom(start, end)
		};
	}
	syncStmt() {
		if (this.hasFatalError) return;
		const startLine = this.at().line;
		while (!this.is("eof") && !this.hasFatalError) {
			this.tick();
			if (this.is("punct", ";") || this.is("punct", "}")) return;
			if (this.at().line > startLine) return;
			this.pos++;
		}
	}
	parseStmt() {
		if (this.hasFatalError) return null;
		const t$12 = this.at();
		if (this.eat("punct", "{")) {
			const body = [];
			while (!this.is("eof") && !this.is("punct", "}") && !this.hasFatalError) {
				this.tick();
				if (this.is("punct", ";")) {
					this.pos++;
					continue;
				}
				const stmt = this.parseStmt();
				if (stmt) body.push(stmt);
				this.eat("punct", ";");
			}
			if (this.hasFatalError) return null;
			const endTok = this.expect("punct", "}", "Unclosed block");
			return {
				type: "block",
				body,
				loc: this.locFrom(t$12, endTok)
			};
		}
		if (this.eat("keyword", "if")) {
			const start = t$12;
			this.expect("punct", "(", "Expected \"(\" after if");
			const test = this.parseExpr();
			this.expect("punct", ")", "Expected \")\" after if condition");
			const then = this.parseStmt() ?? {
				type: "block",
				body: [],
				loc: this.locFrom(this.prev(), this.prev())
			};
			let elseBranch;
			if (this.eat("keyword", "else")) elseBranch = this.parseStmt() ?? {
				type: "block",
				body: [],
				loc: this.locFrom(this.prev(), this.prev())
			};
			const end = elseBranch ? elseBranch.loc : then.loc;
			return {
				type: "if",
				test,
				then,
				else: elseBranch,
				loc: {
					start: start.start,
					end: end.end,
					line: start.line,
					column: start.column
				}
			};
		}
		if (this.eat("keyword", "while")) {
			const start = t$12;
			this.expect("punct", "(", "Expected \"(\" after while");
			const test = this.parseExpr();
			this.expect("punct", ")", "Expected \")\" after while condition");
			return {
				type: "while",
				test,
				body: this.parseStmt() ?? {
					type: "block",
					body: [],
					loc: this.locFrom(this.prev(), this.prev())
				},
				loc: this.locFrom(start, this.prev())
			};
		}
		if (this.eat("keyword", "do")) {
			const start = t$12;
			const body = this.parseStmt() ?? {
				type: "block",
				body: [],
				loc: this.locFrom(this.prev(), this.prev())
			};
			this.expect("keyword", "while", "Expected \"while\" after do body");
			this.expect("punct", "(", "Expected \"(\" after while");
			const test = this.parseExpr();
			this.expect("punct", ")", "Expected \")\" after while condition");
			return {
				type: "do",
				body,
				test,
				loc: this.locFrom(start, this.prev())
			};
		}
		if (this.eat("keyword", "for")) {
			const start = t$12;
			this.expect("punct", "(", "Expected \"(\" after for");
			const nameTok = this.expect("identifier", void 0, "Expected loop variable name");
			const name = String(nameTok.value);
			if (this.eat("keyword", "in")) {
				const from = this.parseExpr();
				this.expect("operator", "..", "Expected \"..\" range in for loop");
				const to = this.parseExpr();
				this.expect("punct", ")", "Expected \")\" after for loop");
				return {
					type: "for",
					init: name,
					from,
					to,
					body: this.parseStmt() ?? {
						type: "block",
						body: [],
						loc: this.locFrom(this.prev(), this.prev())
					},
					loc: this.locFrom(start, this.prev())
				};
			} else {
				let indexName;
				let lengthName;
				if (this.eat("punct", ",")) {
					const indexTok = this.expect("identifier", void 0, "Expected index variable name");
					indexName = String(indexTok.value);
					if (this.eat("punct", ",")) {
						const lengthTok = this.expect("identifier", void 0, "Expected length variable name");
						lengthName = String(lengthTok.value);
					}
				}
				if (!this.eat("keyword", "of")) {
					this.error("Expected \"in\" or \"of\" in for loop");
					return {
						type: "block",
						body: [],
						loc: this.locFrom(start, start)
					};
				}
				const iterable = this.parseExpr();
				this.expect("punct", ")", "Expected \")\" after for-of loop");
				const body = this.parseStmt() ?? {
					type: "block",
					body: [],
					loc: this.locFrom(this.prev(), this.prev())
				};
				return {
					type: "for-of",
					value: name,
					index: indexName,
					length: lengthName,
					iterable,
					body,
					loc: this.locFrom(start, this.prev())
				};
			}
		}
		if (this.eat("keyword", "return")) {
			const start = t$12;
			if (this.is("punct", ";") || this.is("punct", "}") || this.is("eof")) return {
				type: "return",
				loc: this.locFrom(start, start)
			};
			return {
				type: "return",
				value: this.parseExpr(),
				loc: this.locFrom(start, this.prev())
			};
		}
		if (this.eat("keyword", "break")) {
			const start = t$12;
			const label = this.is("identifier") ? String(this.at().value) : void 0;
			if (label) this.pos++;
			return {
				type: "break",
				label,
				loc: this.locFrom(start, this.prev())
			};
		}
		if (this.eat("keyword", "continue")) {
			const start = t$12;
			const label = this.is("identifier") ? String(this.at().value) : void 0;
			if (label) this.pos++;
			return {
				type: "continue",
				label,
				loc: this.locFrom(start, this.prev())
			};
		}
		if (this.eat("keyword", "throw")) {
			const start = t$12;
			if (this.is("punct", ";") || this.is("punct", "}") || this.is("eof")) return {
				type: "throw",
				loc: this.locFrom(start, start)
			};
			return {
				type: "throw",
				value: this.parseExpr(),
				loc: this.locFrom(start, this.prev())
			};
		}
		if (this.eat("keyword", "try")) {
			const start = t$12;
			const body = this.parseStmt();
			if (!body) {
				this.error("Expected statement after try");
				return {
					type: "block",
					body: [],
					loc: this.locFrom(start, start)
				};
			}
			let catchClause;
			let finallyClause;
			if (this.eat("keyword", "catch")) {
				this.expect("punct", "(", "Expected \"(\" after catch");
				const paramTok = this.expect("identifier", void 0, "Expected parameter name in catch");
				const param = String(paramTok.value);
				this.expect("punct", ")", "Expected \")\" after catch parameter");
				const catchBody = this.parseStmt();
				if (!catchBody) this.error("Expected statement after catch");
				else catchClause = {
					param,
					body: catchBody
				};
			}
			if (this.eat("keyword", "finally")) {
				const finallyBody = this.parseStmt();
				if (!finallyBody) this.error("Expected statement after finally");
				else finallyClause = finallyBody;
			}
			if (!catchClause && !finallyClause) this.error("try statement must have catch or finally clause");
			return {
				type: "try",
				body,
				catch: catchClause,
				finally: finallyClause,
				loc: this.locFrom(start, this.prev())
			};
		}
		if (this.is("identifier") && this.tokens[this.pos + 1]?.type === "punct" && this.tokens[this.pos + 1]?.value === ":") {
			const nameTok = this.eat("identifier");
			this.eat("punct", ":");
			const stmt = this.parseStmt();
			if (!stmt) {
				this.error("Expected statement after label");
				this.syncStmt();
				return null;
			}
			return {
				type: "label",
				name: String(nameTok.value),
				stmt,
				loc: this.locFrom(nameTok, this.prev())
			};
		}
		if (this.hasFatalError) return null;
		try {
			const expr = this.parseExpr();
			return {
				type: "expr",
				expr,
				loc: expr.loc
			};
		} catch {
			if (this.hasFatalError) return null;
			this.syncStmt();
			return null;
		}
	}
	parseExpr() {
		return this.parsePipe();
	}
	parsePipe() {
		const left = this.parseAssign();
		if (!this.eat("operator", "|>")) return left;
		this.prev();
		return {
			type: "binary",
			op: "|>",
			left,
			right: this.parsePipe(),
			loc: this.locFrom(this.tokenFromLoc(left.loc), this.prev())
		};
	}
	parseAssign() {
		const left = this.parseTernary();
		if (this.is("operator") && ASSIGN_OPS.has(String(this.at().value))) {
			const opTok = this.at();
			let destructureLeft = null;
			if (left.type === "array" && left.items.every((item) => item.type === "identifier")) destructureLeft = {
				type: "destructure",
				names: left.items.map((item) => item.name),
				loc: left.loc
			};
			this.pos++;
			const op = String(opTok.value);
			const right = op === "=>" ? this.parsePipe() : this.parseAssign();
			return {
				type: "assign",
				op,
				left: destructureLeft || left,
				right,
				loc: this.locFrom(left.loc ? {
					...opTok,
					start: left.loc.start,
					line: left.loc.line,
					column: left.loc.column
				} : opTok, this.prev())
			};
		}
		return left;
	}
	parseTernary() {
		const test = this.parseBinary(0);
		if (!this.eat("punct", "?")) return test;
		const then = this.parseExpr();
		this.expect("punct", ":", "Expected \":\" in ternary expression");
		return {
			type: "ternary",
			test,
			then,
			else: this.parseExpr(),
			loc: this.locFrom(this.tokenFromLoc(test.loc), this.prev())
		};
	}
	parseBinary(minPrec) {
		let left = this.parseUnary();
		while (true) {
			this.tick();
			const t$12 = this.at();
			if (t$12.type !== "operator") break;
			const op = String(t$12.value);
			const info = BIN_PREC[op];
			if (!info) break;
			if (info.prec < minPrec) break;
			this.pos++;
			const nextMin = info.right ? info.prec : info.prec + 1;
			const right = this.parseBinary(nextMin);
			left = {
				type: "binary",
				op,
				left,
				right,
				loc: this.locFrom(this.tokenFromLoc(left.loc), this.prev())
			};
		}
		return left;
	}
	parseUnary() {
		const t$12 = this.at();
		if (t$12.type === "operator" && (t$12.value === "!" || t$12.value === "-" || t$12.value === "+")) {
			this.pos++;
			const expr = this.parseUnary();
			return {
				type: "unary",
				op: String(t$12.value),
				expr,
				loc: this.locFrom(t$12, this.prev())
			};
		}
		return this.parsePostfix();
	}
	parsePostfix() {
		let expr = this.parsePrimary();
		while (true) {
			this.tick();
			const before = this.pos;
			if (this.eat("punct", ".")) {
				const prop = this.expect("identifier", void 0, "Expected property name after \".\"");
				expr = {
					type: "member",
					object: expr,
					property: String(prop.value),
					loc: this.locFrom(this.tokenFromLoc(expr.loc), prop)
				};
				continue;
			}
			if (this.eat("punct", "[")) {
				this.prev();
				const index = this.parseExpr();
				const end = this.expect("punct", "]", "Expected \"]\" to close index");
				expr = {
					type: "index",
					object: expr,
					index,
					loc: this.locFrom(this.tokenFromLoc(expr.loc), end)
				};
				continue;
			}
			if (this.eat("punct", "(")) {
				const args = [];
				this.prev();
				while (!this.is("eof") && !this.is("punct", ")")) {
					this.tick();
					const argStart = this.at();
					if ((this.is("identifier") || this.is("keyword") && this.at().value === "in") && this.tokens[this.pos + 1]?.type === "punct" && this.tokens[this.pos + 1]?.value === ":") {
						const nameTok = this.at();
						this.pos++;
						this.eat("punct", ":");
						const value = this.parseExpr();
						args.push({
							type: "arg",
							name: String(nameTok.value),
							value,
							loc: this.locFrom(argStart, this.prev())
						});
					} else {
						const value = this.parseExpr();
						const shorthand = value.type === "identifier";
						args.push({
							type: "arg",
							value,
							shorthand,
							loc: this.locFrom(argStart, this.prev())
						});
					}
					if (!this.eat("punct", ",")) break;
				}
				const end = this.expect("punct", ")", "Expected \")\" to close call");
				expr = {
					type: "call",
					callee: expr,
					args,
					loc: this.locFrom(this.tokenFromLoc(expr.loc), end)
				};
				continue;
			}
			if (this.pos === before) break;
			break;
		}
		return expr;
	}
	parsePrimary() {
		const t$12 = this.at();
		if (t$12.type === "number") {
			this.pos++;
			return {
				type: "number",
				value: Number(t$12.value),
				loc: this.locFrom(t$12, t$12)
			};
		}
		if (t$12.type === "string") {
			this.pos++;
			const delimiter = t$12.stringDelimiter ?? "double";
			return {
				type: "string",
				value: String(t$12.value),
				delimiter,
				loc: this.locFrom(t$12, t$12)
			};
		}
		if (t$12.type === "keyword") {
			if (t$12.value === "true" || t$12.value === "false" || t$12.value === "null") {
				this.pos++;
				return {
					type: "number",
					value: t$12.value === "true" ? 1 : t$12.value === "false" ? 0 : 0,
					loc: this.locFrom(t$12, t$12)
				};
			}
			if (t$12.value === "in") {
				const nameTok = t$12;
				const name = String(t$12.value);
				const next = this.tokens[this.pos + 1];
				if (next?.type === "operator" && next.value === "->") {
					this.pos += 2;
					const body = this.parseFnBody();
					return {
						type: "fn",
						params: [{
							type: "param",
							name,
							loc: this.locFrom(nameTok, nameTok)
						}],
						defaults: [null],
						body,
						loc: this.locFrom(nameTok, this.prev())
					};
				}
				this.pos++;
				return {
					type: "identifier",
					name,
					loc: this.locFrom(nameTok, nameTok)
				};
			}
		}
		if (t$12.type === "identifier") {
			const nameTok = t$12;
			const name = String(t$12.value);
			const next = this.tokens[this.pos + 1];
			if (next?.type === "operator" && next.value === "->") {
				this.pos += 2;
				const body = this.parseFnBody();
				return {
					type: "fn",
					params: [{
						type: "param",
						name,
						loc: this.locFrom(nameTok, nameTok)
					}],
					defaults: [null],
					body,
					loc: this.locFrom(nameTok, this.prev())
				};
			}
			this.pos++;
			return {
				type: "identifier",
				name,
				loc: this.locFrom(nameTok, nameTok)
			};
		}
		if (this.eat("punct", "[")) {
			const start = t$12;
			const items = [];
			while (!this.is("eof") && !this.is("punct", "]")) {
				items.push(this.parseExpr());
				if (!this.eat("punct", ",")) break;
			}
			const end = this.expect("punct", "]", "Expected \"]\" to close array literal");
			return {
				type: "array",
				items,
				loc: this.locFrom(start, end)
			};
		}
		if (this.eat("punct", "(")) {
			const startPos = this.pos;
			const start = this.prev();
			const parsedParams = this.tryParseFnParamsUntilCloseParen();
			if (parsedParams) {
				const arrow = this.at();
				if (arrow.type === "operator" && arrow.value === "->") {
					this.pos++;
					const body = this.parseFnBody();
					return {
						type: "fn",
						params: parsedParams.params,
						defaults: parsedParams.defaults,
						body,
						loc: this.locFrom(start, this.prev())
					};
				}
				this.pos = startPos;
			}
			const expr = this.parseExpr();
			this.expect("punct", ")", "Expected \")\"");
			return {
				...expr,
				loc: this.locFrom(start, this.prev())
			};
		}
		this.error("Unexpected token in expression");
		this.hasFatalError = true;
		throw new Error("parse error");
	}
	parseFnBody() {
		if (this.is("punct", "{")) return this.parseStmt();
		return this.parsePipe();
	}
	tryParseFnParamsUntilCloseParen() {
		const startPos = this.pos;
		const params = [];
		const defaults = [];
		if (this.eat("punct", ")")) return {
			params,
			defaults
		};
		while (!this.is("eof")) {
			this.tick();
			const paramStart = this.at();
			if (this.is("punct", "[")) {
				this.pos++;
				const names = [];
				while (!this.is("eof") && !this.is("punct", "]")) {
					if (!this.is("identifier") && !(this.is("keyword") && this.at().value === "in")) {
						this.pos = startPos;
						return null;
					}
					names.push(String(this.at().value));
					this.pos++;
					if (!this.eat("punct", ",")) break;
				}
				if (!this.eat("punct", "]")) {
					this.pos = startPos;
					return null;
				}
				const param = {
					type: "param-destructure",
					names,
					loc: this.locFrom(paramStart, this.prev())
				};
				params.push(param);
			} else if (this.is("identifier") || this.is("keyword") && this.at().value === "in") {
				const name = String(this.at().value);
				this.pos++;
				if (this.eat("punct", ":") && this.is("punct", "[")) {
					this.pos++;
					const names = [];
					while (!this.is("eof") && !this.is("punct", "]")) {
						if (!this.is("identifier") && !(this.is("keyword") && this.at().value === "in")) {
							this.pos = startPos;
							return null;
						}
						names.push(String(this.at().value));
						this.pos++;
						if (!this.eat("punct", ",")) break;
					}
					if (!this.eat("punct", "]")) {
						this.pos = startPos;
						return null;
					}
					const param = {
						type: "param-named-destructure",
						paramName: name,
						names,
						loc: this.locFrom(paramStart, this.prev())
					};
					params.push(param);
				} else {
					const param = {
						type: "param",
						name,
						loc: this.locFrom(paramStart, this.prev())
					};
					params.push(param);
				}
			} else {
				this.pos = startPos;
				return null;
			}
			let def = null;
			if (this.eat("operator", "=")) {
				if (!this.is("punct", ",") && !this.is("punct", ")")) {
					const errLen = this.errors.length;
					const before = this.pos;
					try {
						def = this.parseExpr();
					} catch {
						this.errors.length = errLen;
						this.pos = startPos;
						return null;
					}
					if (this.pos === before) {
						this.errors.length = errLen;
						this.pos = startPos;
						return null;
					}
					this.errors.length = errLen;
				}
			}
			defaults.push(def);
			if (this.eat("punct", ",")) {
				if (this.eat("punct", ")")) return {
					params,
					defaults
				};
				continue;
			}
			if (this.eat("punct", ")")) return {
				params,
				defaults
			};
			this.pos = startPos;
			return null;
		}
		this.pos = startPos;
		return null;
	}
	tokenFromLoc(loc) {
		return {
			...this.at(),
			start: loc.start,
			end: loc.end,
			line: loc.line,
			column: loc.column
		};
	}
};
const CONTROL_PRELUDE_SRC = `\
/**
 * control prelude
 */

mix => $
bpm = 120
transpose = 0
tune = 1
scale = 'major'
o0=2 o1=4 o2=8 o3=16 o4=32 o5=64 o6=128 o7=256 o8=512 o9=1024 o10=2048 o11=4096

/**
 * array
 */

map=(array,fn)->{
  newArray:=[]
  for (el of array) newArray.push(fn(el))
  newArray
}

avg=array->{
  sum=0
  for (el of array) sum += el
  sum/array.length
}

shuffle=(array,seed=0)->{
  copy:=[]
  for (el of array) copy.push(el)
  n:=copy.length
  for (k in 0 .. n - 2) {
    i:=n-1-k
    r:=fract(seed*12.9898+i*78.233+k*45.17)
    j:=floor(r*(i+1))
    tmp:=copy[i]
    copy[i]=copy[j]
    copy[j]=tmp
  }
  copy
}

reverse=array->{
  copy:=[]
  n:=array.length
  for (i in 0 .. n - 1) copy.push(array[n-1-i])
  copy
}

/**
 * effects
 */

delay=(in,seconds=0.5,feedback=0,cb=x->x,size=1)->{
  buf=alloc(size)
  sample=read(buf,seconds)
  write(cb(in+sample*feedback),buf)
  sample
}

tube=(in,drive=3,bias=.2)->{
  tanh((in+bias)*drive)-tanh(bias*drive)
}

// Modulated delay effect with LFO-controlled delay time
moddelay=(in,base,depth,rate,feedback,offset=0)->{
  lfo = lfotri(rate, offset)
  seconds = base + depth * lfo
  delay(in, seconds, feedback)
}

// Classic flanger effect (modulated comb filter)
flanger=(in,rate=1,depth=0.00125,base=0.00125,feedback=0.7)->{
  moddelay(in, base, depth, rate, feedback)
}

// Multi-voice chorus effect with spread and modulation
chorus=(in,voices=3,base=0.02,depth=0.006,rate=0.25,spread=.5)->{
  sum = 0
  voices = max(voices,1)

  for (i in 0 .. voices - 1) {
    phase = (i / voices) * spread
    sum += moddelay(
      in,
      base,
      depth,
      rate,
      feedback:0,
      phase
    )
  }

  sum / voices
}

/**
 * utilities
 */

print = value -> { emit(value); value }

// Compile-time only: label(bar, text, color?) for timeline header/minimap visualization. bar is 1-based, color 0-5.
label = (bar, text, color=1) -> 0

midiToHz = midi -> {
  m := midi + transpose
  emit(m)
  440 * 2 ** ((m - 69) / 12) * tune
}

play=(x,cb,voices=1)->{
  sum=0
  for (i in 0 .. voices - 1) {
    [hz,vel,trig]=isarray(x) && isarray(x[i]) ? x[i] : [0,0,0]
    sum+=cb(hold(hz),vel,trig)
  }
  sum/voices
}

dec=(hz=1,floor=0,offset=1,trig)->1-inc(hz,1-floor,1-offset,trig)

buses=[[0,0],[0,0],[0,0],[0,0],[0,0]]

bus=(index,in)->{
  if (isundefined(in)) return buses[index]
  else if (isarray(in)) {
    buses[index][0]+=in[0]
    buses[index][1]+=in[1]
    analyser(in[0])
    return buses[index]
  }
  else {
    buses[index]+=analyser(in)
    return buses[index]
  }
}

buss=(index,in)->solo(in)

// Convert decibels to linear gain multiplier (10^(dB/20))
db=x->10**(x/20)

// Convert bipolar signal to unipolar ([-1,1] to [0,1])
uni=x->x*.5+.5

// Convert unipolar signal to bipolar ([-1,1] to [0,1])
bi=x->x*2-1

// Crossfade between two signals
crossfade=(a,b,t)->lerp(a,b,clamp(t,0,1))

// Convert semitones to frequency multiplier (2^(semitones/12))
semis=x->2**(x/12)

// Convert mono signal to stereo, optionally with delay-based widening
stereo=(in,width=0)->[in,delay(in,seconds:width)]

// Convert stereo signal to mono by averaging channels
mono=([L,R])->(L+R)*.5

// Adjust stereo width using mid-side processing (1 = normal, 0 = mono, >1 = wider)
stereowidth=([L,R],width=1)->{
  mid=(L+R)*0.5
  side=(L-R)*0.5
  side*=width
  return [mid+side,mid-side]
}

// Widen stereo signal by delaying high frequencies in right channel
widen=([L,R],seconds=0.0001)->{
  cutoff=200
  loL=lp(L,cutoff)
  loR=lp(R,cutoff)
  hiL=hp(L,cutoff)
  hiR=hp(R,cutoff)
  return [loL+hiL,loR+delay(hiR,seconds)]
}

// Pan stereo signal (0=left, 0.5=center, 1=right)
pan=([L,R],balance=0.5)->{
  p=clamp(balance,0,1)
  return [L*(1-p),R*p]
}

/**
 * aliases
 */
ntof = midiToHz
mtof = midiToHz
outs = solo
sout = solo

/**
 * synths
 */

// Karplus-Strong plucked string synthesis
karplus=(hz,pluck=pink,seed=1854,attack=.0001,decay=.1,exponent=50,damping=.5,trig)->{
  exc := pluck(seed, trig) * ad(attack,decay,exponent,trig)
  delayTime := safediv(1, hz)
  dampingCutoff := hz*((1-damping)*30)
  oversample(8, () -> delay(exc,delayTime,1,x -> tanh(lp1(x, dampingCutoff))))
}

rhodes=(hz,vel=1,trig)->{
  v = clamp(vel,0,1)

  // Tine FM (velocity controls metallic bite)
  fmIndex = hz * (.2 + 2.8*v)
  fm = sine(hz*2.01) * fmIndex
  tine = sine(hz + fm, 0, trig)

  // Dual tone-bar resonances (slightly inharmonic)
  resonances = [
    bp(tine, hz*3.8, 7),
    bp(tine, hz*7.1, 9)
  ].avg()

  // Pickup / hammer click
  click = hp(tine, 2500, 0.7)
        * ad(.0004,.025,14,trig)
        * (.3 + .7*v)

  // Raw mix
  s = tine*.55 + resonances*.9 + click*.35

  // Envelope + velocity scaling
  s *= (.15 + .85*v)

  // Gentle saturation + DC cleanup
  s = tube(s, drive:2.0 + v, bias:.04)

  // Pickup EQ tilt (brighter with velocity)
  s = ls(s, 250, -2*(1-v))
    + hs(s, 3200, 3*v)

  // Classic Rhodes chorus
  s = chorus(s, voices:5, rate:.13, depth:.008, spread:.2)

  s*.5
}

rhodes70=(hz,vel=1,trig)->{
  v = clamp(vel,0,1)

  // Fundamental (very pure)
  core = sine(hz, trig)

  // Hammer / tine attack (noise, not FM)
  hammer =
    bp(pink(1234,trig), hz*2.5, 6)
    * ad(.0006,.04,10,trig)
    * (.25 + .6*v)

  // Tone-bar resonances (dominant character)
  resonances = [
    bp(core, hz*3.2, 8),
    bp(core, hz*6.4, 10)
  ].avg()

  // Slight beating via slow detune (control-rate, not audio-rate)
  det = 1 + (.002 + .004*v) * lfosine(.6)
  body = sine(hz*det) * .3

  // Mix (bars > fundamental)
  s =
    core*.35 +
    resonances*1.0 +
    body +
    hammer

  // Apply envelope + velocity
  s *= (.2 + .8*v)

  // Very gentle saturation (mostly for compression feel)
  s = tanh(s * (1.2 + .8*v))

  // Pickup EQ: dark, rounded top
  s = ls(s, 220, -1.5)
    |> hs($, 2800, 1.2*v)

  // Subtle chorus (slow + shallow)
  s = chorus(s, voices:2, rate:.15, depth:.003, spread:.4)

  s
}

// Supersaw oscillator with detuned voices
supersaw=(hz,voices=5,spread=.05)->{
  s = 0
  for (i in 0 .. voices) {
    d = (i/(voices+1)-.5)*spread
    s += saw(hz*(1+d))
  }
  s / voices
}

bdsynth=(
  base=#1*o2,
  punch=25000k,
  offset=0.0006,
  cutoff=5k,
  q=.25,
  amp=trig->ad(.0001,.5,40,trig),
  fm=trig->ad(.00008,.013,900,trig),
  filter=trig->ad(.000147,.25,50.000,trig),
  trig=tram('x-x-x-x-'),
)->sine(base+punch*fm(trig),offset,trig)*amp(trig) |> lps($,base+cutoff*filter(trig),q) |> limiter($)

bd=(base,punch,offset,cutoff,q,amp,fm,filter,trig=tram('x-x-x-x-'))->{
  sample=record(.2,()->bdsynth(base,punch,offset,cutoff,q,amp,fm,filter,trig:1))
  sampler(sample,trig)
}

hhsynth=(width=.4,trig)->{
  env=adsr(.06,.05 ,.950 ,.1 ,32,trig)
  oversample(8,()->[205.3,369.6,304.4,522.7,800,540].map(x->pwm(x,width)).avg()*env
  |> bp($,8000,.85)|>bp($,10k,.85)|>hp($,11k,.85)) |> tanh($*6)
}

ch=(width=.9,trig=tram('--x-',1/4))->{
  sample=record(.2,()->hhsynth(width,trig:step(.9,dec())))
  sampler(sample,trig,offset:.29)*ad(0.0001,.5,3,trig)*.6
}

oh=(width=.4,trig=tram('-x',1/4))->{
  sample=record(.2,()->hhsynth(width,trig:step(.9,dec())))
  sampler(sample,trig,offset:.299)*ad(0.0001,.9,trig)*.8
}

sdsynth=(seed=7,base=#5*o2,trig=step(.9,dec()))->{
  amp=ad(.0001,1.7366,20,trig)
  noise=adsr(.0001,.0231 ,.870 ,.3159 ,8.000,trig)
  click = ad(.0001, .02, 4, trig)
  pitch = ad(.0001, .3095 , 20, trig)
  pitchAmt=base*2
  ;(sine(base+pitch*pitchAmt,trig)*.3 |> bps($, base * 2, .8))*amp

  +(white(seed,trig) |> hps($, 1800,.4) |> bps($, 7100, .4))*noise
  +(white(8,trig) |> hps($, 4000,.6))*click
  |> tube($,2,.01)*.3
}

sd=(seed,trig=tram('-x',1/2))->{
  sample=record(.2,()->sdsynth(seed))
  sampler(sample,trig)
}

drums=(seed=1)->{
  chw = fract(seed * 1234.1234)
  ohw = fract(seed * 4567.4567)
  bd()+sd(seed)+ch(chw)+oh(ohw) |> limiter($)
}

;
`;
function getControlPreludeText() {
	const preludeText = (CONTROL_PRELUDE_SRC.endsWith("\n") ? CONTROL_PRELUDE_SRC : CONTROL_PRELUDE_SRC + "\n") + "\n";
	return {
		preludeText,
		preludeLen: preludeText.length,
		preludeLines: preludeText.split("\n").length - 1
	};
}
var KEYWORDS = new Set([
	"if",
	"else",
	"for",
	"while",
	"do",
	"break",
	"continue",
	"return",
	"switch",
	"case",
	"default",
	"try",
	"catch",
	"finally",
	"throw",
	"true",
	"false",
	"null",
	"in",
	"of"
]);
var OPS = [
	">>>",
	">>=",
	"<<=",
	"**=",
	"&=",
	"|=",
	"^=",
	"=>",
	"..",
	"==",
	"!=",
	"<=",
	">=",
	"&&",
	"||",
	"|>",
	"->",
	":=",
	"<<",
	">>",
	"**",
	"+=",
	"-=",
	"*=",
	"/=",
	"%="
];
var SINGLE_OPS = new Set([
	"=",
	"<",
	">",
	"+",
	"-",
	"*",
	"/",
	"%",
	"!",
	"&",
	"|",
	"^",
	"~"
]);
var PUNCT = new Set([
	"(",
	")",
	"{",
	"}",
	"[",
	"]",
	",",
	";",
	":",
	".",
	"?"
]);
function tokenize$1(input) {
	const tokens = [];
	const errors = [];
	let i$6 = 0;
	let line = 1;
	let column = 1;
	let guard = 0;
	const guardMax = input.length * 4 + 1024;
	const push = (type, value, start, end, l$10, c$7, stringDelimiter) => {
		tokens.push({
			type,
			value,
			start,
			end,
			line: l$10,
			column: c$7,
			stringDelimiter
		});
	};
	const err = (message, start, end, l$10, c$7) => {
		errors.push({
			message,
			loc: {
				start,
				end,
				line: l$10,
				column: c$7
			},
			code: input.slice(start, Math.min(input.length, start + 80))
		});
	};
	const isWs = (ch) => ch === " " || ch === "	" || ch === "\r" || ch === "\n";
	const isDigit = (ch) => ch >= "0" && ch <= "9";
	const isIdentStart = (ch) => ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z" || ch === "_" || ch === "$";
	const isIdent = (ch) => isIdentStart(ch) || isDigit(ch);
	const advance = (n$4 = 1) => {
		while (n$4-- > 0) {
			const ch = input[i$6];
			i$6++;
			if (ch === "\n") {
				line++;
				column = 1;
			} else column++;
		}
	};
	const matchOp = () => {
		for (const op of OPS) if (input.startsWith(op, i$6)) return op;
		return null;
	};
	while (i$6 < input.length) {
		guard++;
		if (guard > guardMax) {
			err("Lexer exceeded max steps (possible infinite loop)", i$6, i$6 + 1, line, column);
			break;
		}
		const ch = input[i$6];
		if (isWs(ch)) {
			advance(1);
			continue;
		}
		if (ch === "/" && input[i$6 + 1] === "/") {
			advance(2);
			while (i$6 < input.length && input[i$6] !== "\n") advance(1);
			continue;
		}
		if (ch === "/" && input[i$6 + 1] === "*") {
			const start = i$6;
			const l$10 = line;
			const c$7 = column;
			advance(2);
			let closed = false;
			while (i$6 < input.length) {
				if (input[i$6] === "*" && input[i$6 + 1] === "/") {
					advance(2);
					closed = true;
					break;
				}
				advance(1);
			}
			if (!closed) err("Unclosed block comment", start, i$6, l$10, c$7);
			continue;
		}
		const op = matchOp();
		if (op) {
			const start = i$6;
			const l$10 = line;
			const c$7 = column;
			advance(op.length);
			push("operator", op, start, i$6, l$10, c$7);
			continue;
		}
		const lastTok = tokens[tokens.length - 1];
		const prefixCtx = !lastTok || lastTok.type === "punct" && "([,?:".includes(String(lastTok.value)) || lastTok.type === "operator" && lastTok.value === "=";
		const next = input[i$6 + 1];
		if (prefixCtx && (ch === "-" || ch === "+") && (isDigit(next ?? "") || next === "." && isDigit(input[i$6 + 2] ?? ""))) {
			const start = i$6;
			const l$10 = line;
			const c$7 = column;
			const sign = ch === "-" ? -1 : 1;
			advance(1);
			const numStart = i$6;
			let hasDot = false;
			while (i$6 < input.length) {
				const cur = input[i$6];
				if (isDigit(cur)) {
					advance(1);
					continue;
				}
				if (cur === "." && !hasDot) {
					if (input[i$6 + 1] === ".") break;
					hasDot = true;
					advance(1);
					continue;
				}
				if ((cur === "e" || cur === "E") && (isDigit(input[i$6 + 1] ?? "") || ["+", "-"].includes(input[i$6 + 1] ?? ""))) {
					advance(1);
					if (input[i$6] === "+" || input[i$6] === "-") advance(1);
					while (isDigit(input[i$6] ?? "")) advance(1);
					continue;
				}
				break;
			}
			const rawEnd = i$6;
			let mult = 1;
			if (input[i$6] === "k") {
				mult = 1e3;
				advance(1);
			}
			const raw = input.slice(numStart, rawEnd);
			const n$4 = Number(raw) * mult * sign;
			if (!Number.isFinite(n$4)) err("Invalid number literal", start, i$6, l$10, c$7);
			push("number", n$4, start, i$6, l$10, c$7);
			continue;
		}
		if (SINGLE_OPS.has(ch)) {
			const start = i$6;
			const l$10 = line;
			const c$7 = column;
			advance(1);
			push("operator", ch, start, i$6, l$10, c$7);
			continue;
		}
		if (PUNCT.has(ch) && !(ch === "." && isDigit(input[i$6 + 1] ?? ""))) {
			const start = i$6;
			const l$10 = line;
			const c$7 = column;
			advance(1);
			push("punct", ch, start, i$6, l$10, c$7);
			continue;
		}
		if (ch === "\"" || ch === "'" || ch === "`") {
			const quote = ch;
			let delimiter;
			if (ch === "'") delimiter = "single";
			else if (ch === "\"") delimiter = "double";
			else delimiter = "backtick";
			const start = i$6;
			const l$10 = line;
			const c$7 = column;
			advance(1);
			let content = "";
			let closed = false;
			while (i$6 < input.length) {
				const cur = input[i$6];
				if (cur === quote) {
					advance(1);
					closed = true;
					break;
				}
				content += cur;
				advance(1);
			}
			if (!closed) err("Unclosed string literal", start, i$6, l$10, c$7);
			push("string", content, start, i$6, l$10, c$7, delimiter);
			continue;
		}
		if (isDigit(ch) || ch === "." && isDigit(input[i$6 + 1] ?? "")) {
			const start = i$6;
			const l$10 = line;
			const c$7 = column;
			let hasDot = false;
			while (i$6 < input.length) {
				const cur = input[i$6];
				if (isDigit(cur)) {
					advance(1);
					continue;
				}
				if (cur === "." && !hasDot) {
					if (input[i$6 + 1] === ".") break;
					hasDot = true;
					advance(1);
					continue;
				}
				if ((cur === "e" || cur === "E") && (isDigit(input[i$6 + 1] ?? "") || ["+", "-"].includes(input[i$6 + 1] ?? ""))) {
					advance(1);
					if (input[i$6] === "+" || input[i$6] === "-") advance(1);
					while (isDigit(input[i$6] ?? "")) advance(1);
					continue;
				}
				break;
			}
			const rawEnd = i$6;
			let mult = 1;
			if (input[i$6] === "k") {
				mult = 1e3;
				advance(1);
			}
			const raw = input.slice(start, rawEnd);
			const n$4 = Number(raw) * mult;
			if (!Number.isFinite(n$4)) err("Invalid number literal", start, i$6, l$10, c$7);
			push("number", n$4, start, i$6, l$10, c$7);
			continue;
		}
		if (ch === "#") {
			const start = i$6;
			const l$10 = line;
			const c$7 = column;
			advance(1);
			while (i$6 < input.length && isIdent(input[i$6] ?? "")) advance(1);
			push("identifier", "#" + input.slice(start + 1, i$6), start, i$6, l$10, c$7);
			continue;
		}
		const isNoteLetter = (c$7) => /^[a-gA-G]$/.test(c$7);
		if (isNoteLetter(ch)) {
			const noteMatch = input.slice(i$6).match(/^[a-gA-G]([#b])?(-?\d+)/);
			if (noteMatch) {
				const start = i$6;
				const l$10 = line;
				const c$7 = column;
				advance(noteMatch[0].length);
				push("identifier", noteMatch[0], start, i$6, l$10, c$7);
				continue;
			}
		}
		if (isIdentStart(ch)) {
			const start = i$6;
			const l$10 = line;
			const c$7 = column;
			while (i$6 < input.length && isIdent(input[i$6] ?? "")) advance(1);
			const s$4 = input.slice(start, i$6);
			if (KEYWORDS.has(s$4)) push("keyword", s$4, start, i$6, l$10, c$7);
			else push("identifier", s$4, start, i$6, l$10, c$7);
			continue;
		}
		{
			const start = i$6;
			const l$10 = line;
			const c$7 = column;
			advance(1);
			err(`Unexpected character "${ch}"`, start, i$6, l$10, c$7);
		}
	}
	push("eof", null, i$6, i$6, line, column);
	return {
		tokens,
		errors
	};
}
function shiftUserTokens(tokens, preludeLen, preludeLines) {
	const out = [];
	for (const t$12 of tokens) {
		if (t$12.type === "eof") continue;
		out.push({
			...t$12,
			start: t$12.start + preludeLen,
			end: t$12.end + preludeLen,
			line: t$12.line + preludeLines
		});
	}
	return out;
}
function createControlPipeline(preludeSrc) {
	const { preludeText, preludeLen, preludeLines } = getControlPreludeText();
	const preludeLex = tokenize$1(preludeText);
	if (preludeLex.errors.length) throw new Error(`Control prelude lex failed:\n${preludeLex.errors.map((e$59) => `${e$59.loc.line}:${e$59.loc.column} ${e$59.message}`).join("\n")}`);
	const preludeTokens = preludeLex.tokens.filter((t$12) => t$12.type !== "eof");
	function lex(src) {
		const userLex = tokenize$1(src);
		const shiftedUserTokens = shiftUserTokens(userLex.tokens, preludeLen, preludeLines);
		const eof = userLex.tokens[userLex.tokens.length - 1];
		const shiftedEof = {
			...eof,
			start: eof.start + preludeLen,
			end: eof.end + preludeLen,
			line: eof.line + preludeLines
		};
		return {
			preludeText,
			preludeLen,
			preludeLines,
			preludeTokens,
			userTokens: userLex.tokens,
			tokens: [
				...preludeTokens,
				...shiftedUserTokens,
				shiftedEof
			],
			errors: userLex.errors
		};
	}
	function parse(src, existingLex) {
		const l$10 = existingLex ?? lex(src);
		const fullSrc = preludeText + src;
		const parsed = parseTokens(fullSrc, l$10.tokens);
		const parseErrors = parsed.errors.map((e$59) => e$59.loc.line > preludeLines ? {
			...e$59,
			loc: {
				...e$59.loc,
				line: e$59.loc.line - preludeLines
			}
		} : e$59);
		const errors = [...l$10.errors.map((e$59) => ({
			message: e$59.message,
			loc: e$59.loc,
			code: e$59.code
		})), ...parseErrors];
		const program = errors.length ? null : parsed.program;
		return {
			src,
			fullSrc,
			preludeLen,
			preludeLines,
			program,
			errors,
			numberLiterals: program ? collectNumberLiterals(program).filter((n$4) => n$4.loc.line > preludeLines) : []
		};
	}
	function compileProgram(program, opts) {
		return compile$1(program, preludeLines, opts);
	}
	function compileSource(src, opts) {
		const l$10 = lex(src);
		const p$6 = parse(src, l$10);
		if (p$6.errors.length > 0 || !p$6.program) {
			const formattedErrors$1 = [];
			for (const e$59 of l$10.errors) formattedErrors$1.push(`Lex ${e$59.loc.line}:${e$59.loc.column} ${e$59.message}`);
			for (const e$59 of p$6.errors) formattedErrors$1.push(`Parse ${e$59.loc.line}:${e$59.loc.column} ${e$59.message}`);
			return {
				lex: l$10,
				parse: p$6,
				compile: {
					bytecode: null,
					errors: [],
					sampleRegistrations: [],
					functionCalls: [],
					bpm: 120,
					labels: []
				},
				errors: formattedErrors$1
			};
		}
		const c0 = compileProgram(p$6.program, opts);
		const errors = c0.errors.map((e$59) => e$59.loc.line > p$6.preludeLines ? {
			...e$59,
			loc: {
				...e$59.loc,
				line: e$59.loc.line - p$6.preludeLines
			}
		} : e$59);
		const c$7 = {
			...c0,
			errors
		};
		const formattedErrors = [];
		for (const e$59 of l$10.errors) formattedErrors.push(`Lex ${e$59.loc.line}:${e$59.loc.column} ${e$59.message}`);
		for (const e$59 of p$6.errors) formattedErrors.push(`Parse ${e$59.loc.line}:${e$59.loc.column} ${e$59.message}`);
		for (const e$59 of c$7.errors) formattedErrors.push(`Compile ${e$59.loc.line}:${e$59.loc.column} ${e$59.message}`);
		return {
			lex: l$10,
			parse: p$6,
			compile: c$7,
			errors: formattedErrors
		};
	}
	return {
		lex,
		parse,
		compile: compileProgram,
		compileSource
	};
}
const controlPipeline = createControlPipeline();
async function fetchFreesoundSample(ctx$1, id) {
	const url = `https://freesound.cowbell.workers.dev/get?id=${id}`;
	const response = await fetch(url);
	if (!response.ok) throw new Error(`Failed to fetch freesound ${id}: ${response.status}`);
	const arrayBuffer = await response.arrayBuffer();
	const audioBuffer = await ctx$1.decodeAudioData(arrayBuffer);
	const channels = [];
	for (let ch = 0; ch < audioBuffer.numberOfChannels; ch++) channels.push(new Float32Array(audioBuffer.getChannelData(ch)));
	return {
		channels,
		sampleRate: audioBuffer.sampleRate
	};
}
async function fetchEspeakSample(ctx$1, opts) {
	const url = new URL("https://mespeak.stagas.deno.net", self.location?.origin ?? void 0);
	const speedParam = Math.round(Math.max(0, Math.min(200, opts.speed * 200)));
	const pitchParam = Math.round(Math.max(0, Math.min(100, opts.pitch * 100)));
	url.searchParams.set("text", opts.text);
	url.searchParams.set("variant", opts.variant);
	url.searchParams.set("speed", String(speedParam));
	url.searchParams.set("pitch", String(pitchParam));
	const response = await fetch(url.toString());
	if (!response.ok) throw new Error(`Failed to fetch espeak sample: ${response.status}`);
	const arrayBuffer = await response.arrayBuffer();
	const audioBuffer = await ctx$1.decodeAudioData(arrayBuffer);
	const channels = [];
	for (let ch = 0; ch < audioBuffer.numberOfChannels; ch++) channels.push(new Float32Array(audioBuffer.getChannelData(ch)));
	return {
		channels,
		sampleRate: audioBuffer.sampleRate
	};
}
const fetchRequiredSamples = atomic(async (audioContext$1, worklet, record, fetchingSamples, programId, getRecordGeneration, recordCallbacks, mainBytecode, onCapturedValues) => {
	const generation = getRecordGeneration(programId);
	const toFetch = (await worklet.getRequiredSamples()).filter(({ handle }) => !fetchingSamples.has(handle));
	if (toFetch.length === 0) return;
	for (const { handle } of toFetch) fetchingSamples.add(handle);
	await Promise.all(toFetch.map(async ({ handle, freesoundId, recordSeconds, recordCallbackId }) => {
		if (freesoundId !== void 0) try {
			console.log(`[dsp] Fetching freesound ${freesoundId} for handle ${handle}...`);
			const { channels, sampleRate } = await fetchFreesoundSample(audioContext$1, freesoundId);
			console.log(`[dsp] Fetched freesound ${freesoundId}: ${channels.length} channels, ${channels[0]?.length} samples at ${sampleRate}Hz`);
			const existing = sampleManager.getSample(handle);
			if (existing?.channels.length) for (let i$6 = 0; i$6 < existing.channels.length; i$6++) untrack(`sab-freesound-${handle}-${i$6}`);
			const sharedChannels = channels.map((ch, i$6) => {
				const sab = new SharedArrayBuffer(ch.byteLength);
				track(`sab-freesound-${handle}-${i$6}`, "SharedArrayBuffer", ch.byteLength, {
					source: "fetch-samples",
					handle
				});
				new Float32Array(sab).set(ch);
				return sab;
			});
			await worklet.setSampleData({
				handle,
				channels: sharedChannels,
				sampleRate
			});
			sampleManager.setSampleData(handle, channels, sampleRate);
			console.log(`[dsp] Set sample data for handle ${handle}`);
		} catch (error$1) {
			const msg = error$1 instanceof Error ? error$1.message : String(error$1);
			console.error(`[dsp] Error fetching freesound ${freesoundId}:`, msg);
			await worklet.setSampleError({
				handle,
				error: msg
			});
			sampleManager.setSampleError(handle, msg);
			throw error$1;
		} finally {
			fetchingSamples.delete(handle);
		}
		else if (recordSeconds !== void 0 && recordCallbackId !== void 0 && recordCallbacks && mainBytecode) try {
			const callbackData = recordCallbacks.get(recordCallbackId);
			if (!callbackData) throw new Error(`No callback bytecode found for callback ID ${recordCallbackId}`);
			const sampleRate = 48e3;
			const numSamples = Math.floor(recordSeconds * sampleRate);
			console.log("[dsp] recordAndSend", handle);
			const capturedValues = await record.recordAndSend({
				handle,
				mainBytecode,
				setupBytecode: callbackData.setup,
				loopBytecode: callbackData.loop,
				captureStoreGlobalIdx: callbackData.captureStoreGlobalIdx,
				recordGlobalIndices: callbackData.recordGlobalIndices,
				defaultParamRecordGlobals: callbackData.defaultParamRecordGlobals,
				callbackId: recordCallbackId,
				useNestedCaptureStore: callbackData.useNestedCaptureStore ?? true,
				numSamples,
				sampleRate
			});
			if (getRecordGeneration(programId) !== generation) return;
			if (onCapturedValues) onCapturedValues(recordCallbackId, capturedValues);
		} catch (error$1) {
			if (getRecordGeneration(programId) !== generation) return;
			const msg = error$1 instanceof Error ? error$1.message : String(error$1);
			console.error(`[dsp] Error recording sample for callback ${recordCallbackId}:`, msg);
			throw error$1;
		} finally {
			fetchingSamples.delete(handle);
		}
	}));
});
let DspProgramState = /* @__PURE__ */ function(DspProgramState$1) {
	DspProgramState$1[DspProgramState$1["Stop"] = 0] = "Stop";
	DspProgramState$1[DspProgramState$1["Start"] = 1] = "Start";
	DspProgramState$1[DspProgramState$1["Pause"] = 2] = "Pause";
	return DspProgramState$1;
}({});
let SharedProgramStateIndex = /* @__PURE__ */ function(SharedProgramStateIndex$1) {
	SharedProgramStateIndex$1[SharedProgramStateIndex$1["HistoryPackIndex"] = 0] = "HistoryPackIndex";
	SharedProgramStateIndex$1[SharedProgramStateIndex$1["HistoryPackEpoch"] = 1] = "HistoryPackEpoch";
	SharedProgramStateIndex$1[SharedProgramStateIndex$1["Bpm"] = 2] = "Bpm";
	SharedProgramStateIndex$1[SharedProgramStateIndex$1["State"] = 3] = "State";
	SharedProgramStateIndex$1[SharedProgramStateIndex$1["SampleCount"] = 4] = "SampleCount";
	return SharedProgramStateIndex$1;
}({});
function createSharedProgramStateViewsFromBuffer(buffer, byteOffset = 0) {
	return {
		u32: new Uint32Array(buffer, byteOffset, 5),
		f32: new Float32Array(buffer, byteOffset, 5)
	};
}
let SharedTransportRunningState = /* @__PURE__ */ function(SharedTransportRunningState$1) {
	SharedTransportRunningState$1[SharedTransportRunningState$1["Stop"] = 0] = "Stop";
	SharedTransportRunningState$1[SharedTransportRunningState$1["Start"] = 1] = "Start";
	SharedTransportRunningState$1[SharedTransportRunningState$1["Pause"] = 2] = "Pause";
	return SharedTransportRunningState$1;
}({});
let SharedTransportIndex = /* @__PURE__ */ function(SharedTransportIndex$1) {
	SharedTransportIndex$1[SharedTransportIndex$1["SampleCount"] = 0] = "SampleCount";
	SharedTransportIndex$1[SharedTransportIndex$1["Running"] = 1] = "Running";
	SharedTransportIndex$1[SharedTransportIndex$1["SeekVersion"] = 2] = "SeekVersion";
	SharedTransportIndex$1[SharedTransportIndex$1["StopAndSeekToZero"] = 3] = "StopAndSeekToZero";
	SharedTransportIndex$1[SharedTransportIndex$1["ActuallyPlaying"] = 4] = "ActuallyPlaying";
	SharedTransportIndex$1[SharedTransportIndex$1["HistorySyncRequested"] = 5] = "HistorySyncRequested";
	SharedTransportIndex$1[SharedTransportIndex$1["LoopBeginSamples"] = 6] = "LoopBeginSamples";
	SharedTransportIndex$1[SharedTransportIndex$1["LoopEndSamples"] = 7] = "LoopEndSamples";
	SharedTransportIndex$1[SharedTransportIndex$1["ProjectEndSamples"] = 8] = "ProjectEndSamples";
	return SharedTransportIndex$1;
}({});
function createSharedTransportViewsFromBuffer(buffer, byteOffset = 0) {
	return {
		u32: new Uint32Array(buffer, byteOffset, 9),
		f32: new Float32Array(buffer, byteOffset, 9)
	};
}
function bytecodeStructureHash(bytecode$1) {
	const u32 = new Uint32Array(bytecode$1.buffer, bytecode$1.byteOffset, bytecode$1.length);
	const f32 = bytecode$1;
	const mix = (h$5, v$4) => {
		h$5 = (h$5 ^ v$4) >>> 0;
		h$5 = Math.imul(h$5, 16777619) >>> 0;
		return h$5 >>> 0;
	};
	const roundPosI32 = (x$4) => x$4 + .5 | 0;
	const hashRange = (startPc, limitPc, seed) => {
		let h$5 = seed >>> 0;
		let pc = startPc;
		while (pc < limitPc) {
			const op = u32[pc];
			h$5 = mix(h$5, op);
			pc++;
			const { kind } = getOpcodeInfo(op);
			switch (kind) {
				case "param":
				case "pc-param": {
					if (pc >= limitPc) throw new Error(`Invalid bytecode: missing param for op ${op} at pc ${pc - 1}`);
					const paramBits = u32[pc];
					const paramF = f32[pc];
					if (op === AudioVmOp.PushScalar || op === AudioVmOp.PushAudio || op === AudioVmOp.SetBpm) h$5 = mix(h$5, 0);
					else {
						const r$11 = roundPosI32(paramF) >>> 0;
						h$5 = mix(h$5, r$11 || paramBits);
					}
					pc++;
					break;
				}
				case "three-param":
					if (pc + 2 >= limitPc) throw new Error(`Invalid bytecode: missing 3 params for op ${op} at pc ${pc - 1}`);
					h$5 = mix(h$5, roundPosI32(f32[pc]) >>> 0);
					pc++;
					h$5 = mix(h$5, roundPosI32(f32[pc]) >>> 0);
					pc++;
					h$5 = mix(h$5, roundPosI32(f32[pc]) >>> 0);
					pc++;
					break;
				case "table": {
					if (pc >= limitPc) throw new Error(`Invalid bytecode: missing table len for op ${op} at pc ${pc - 1}`);
					const len = roundPosI32(f32[pc]);
					if (len < 0) throw new Error(`Invalid bytecode: negative table len ${len} for op ${op} at pc ${pc - 1}`);
					h$5 = mix(h$5, len >>> 0);
					const end = pc + 1 + len;
					if (end > limitPc) throw new Error(`Invalid bytecode: table overruns bytecode for op ${op} at pc ${pc - 1}`);
					pc = end;
					break;
				}
				case "define-function": {
					if (pc + 5 >= limitPc) throw new Error(`Invalid bytecode: missing function header for op ${op} at pc ${pc - 1}`);
					const functionId = roundPosI32(f32[pc]);
					pc++;
					const paramCount = roundPosI32(f32[pc]);
					pc++;
					const firstParamIn = roundPosI32(f32[pc]);
					pc++;
					const closureCount = roundPosI32(f32[pc]);
					pc++;
					const localCount = roundPosI32(f32[pc]);
					pc++;
					const bytecodeLength = roundPosI32(f32[pc]);
					pc++;
					if (bytecodeLength < 0) throw new Error(`Invalid bytecode: negative function bytecode len ${bytecodeLength}`);
					h$5 = mix(h$5, functionId >>> 0);
					h$5 = mix(h$5, paramCount >>> 0);
					h$5 = mix(h$5, firstParamIn >>> 0);
					h$5 = mix(h$5, closureCount >>> 0);
					h$5 = mix(h$5, localCount >>> 0);
					const innerStart = pc;
					const innerEnd = pc + bytecodeLength;
					if (innerEnd > limitPc) throw new Error(`Invalid bytecode: function overruns bytecode (end ${innerEnd}, limit ${limitPc})`);
					h$5 = hashRange(innerStart, innerEnd, h$5);
					pc = innerEnd;
					break;
				}
				case "none":
				default: break;
			}
		}
		return h$5 >>> 0;
	};
	return hashRange(0, bytecode$1.length, 2166136261);
}
function hashCallbackBytecode(setup, loop, recordGlobalIndices, captureStoreGlobalIdx) {
	let hash = hashF32Bits(setup);
	hash = hash * 31 + hashF32Bits(loop) | 0;
	return `${hash}:${captureStoreGlobalIdx}:${recordGlobalIndices.join(",")}`;
}
function bindProgramShared(buf, init, historyMeta) {
	const stateViews = createSharedProgramStateViewsFromBuffer(init.stateBuffer);
	let packs;
	if (init.historyMetaBuffers && init.historyMetaBuffers.length === 2) packs = [new Uint32Array(init.historyMetaBuffers[0]), new Uint32Array(init.historyMetaBuffers[1])];
	else if (historyMeta instanceof SharedArrayBuffer) {
		const u32 = new Uint32Array(historyMeta);
		packs = [u32, u32];
	} else if (historyMeta instanceof Uint32Array) packs = [historyMeta, historyMeta];
	else {
		const empty = new Uint32Array(0);
		packs = [empty, empty];
	}
	const packIndex = stateViews.u32[SharedProgramStateIndex.HistoryPackIndex] >>> 0;
	const current = packs[Math.min(packIndex, packs.length - 1)];
	return {
		id: init.id,
		vmIds: init.vmIds,
		controlOpsCapacity: init.controlOpsCapacity,
		bufferRef: buf,
		stateU32: stateViews.u32,
		stateF32: stateViews.f32,
		historyMetaPacks: packs,
		historyMetaU32: current
	};
}
var _mainBytecodeTempId = 0;
async function setControlOps(dspState, worklet, program, ops) {
	if (dspState.isProgramSharedStale(program.shared.bufferRef)) {
		const init = await worklet.getProgramShared({ programId: program.shared.id });
		if (init) program.shared = bindProgramShared(dspState.buffer, init, program.shared.historyMetaU32);
	}
	if (ops.length > program.shared.controlOpsCapacity) throw new Error(`Control ops length ${ops.length} exceeds capacity ${program.shared.controlOpsCapacity}`);
	await worklet.setControlOps({
		programId: program.shared.id,
		ops
	});
	program.lastOps = ops;
}
async function setControlOpsSwap(dspState, worklet, program, ops) {
	if (dspState.isProgramSharedStale(program.shared.bufferRef)) {
		const init = await worklet.getProgramShared({ programId: program.shared.id });
		if (init) program.shared = bindProgramShared(dspState.buffer, init, program.shared.historyMetaU32);
	}
	if (ops.length > program.shared.controlOpsCapacity) throw new Error(`Control ops length ${ops.length} exceeds capacity ${program.shared.controlOpsCapacity}`);
	await worklet.setControlOpsSwap({
		programId: program.shared.id,
		ops
	});
	program.lastOps = ops;
}
function applyCompileState(result) {
	const mainBytecode = result.compile.bytecode;
	const historySourceMap = result.compile.historySourceMap || [];
	const functionReturnPcs = result.compile.functionReturnPcs ?? {};
	const structureHash = bytecodeStructureHash(mainBytecode);
	const arrayGetHistoryCount = historySourceMap.filter((e$59) => e$59.genName === "ArrayGet").length;
	return {
		mainBytecode,
		newRecordCallbacks: result.compile.recordCallbacks || /* @__PURE__ */ new Map(),
		structureHash,
		historySourceMap,
		functionReturnPcs,
		arrayGetHistoryCount
	};
}
function getProgramState(shared) {
	return shared.stateU32[SharedProgramStateIndex.State] ?? DspProgramState.Stop;
}
function updateMainBytecodeHash(mainBytecode, lastHash) {
	const mainHash = hashF32Bits(mainBytecode);
	return {
		changed: mainHash !== lastHash,
		newHash: mainHash
	};
}
function computeCallbackChanges(newRecordCallbacks, mainBytecodeChanged, lastCallbackBytecodeHashes, lastCapturedValues) {
	const newBytecodeHashes = /* @__PURE__ */ new Map();
	const changedCallbackIds = /* @__PURE__ */ new Set();
	const callbacksToCheckValues = [];
	for (const [callbackId, data] of newRecordCallbacks) {
		const hash = hashCallbackBytecode(data.setup, data.loop, data.recordGlobalIndices, data.captureStoreGlobalIdx);
		newBytecodeHashes.set(callbackId, hash);
		if (lastCallbackBytecodeHashes.get(callbackId) !== hash) changedCallbackIds.add(callbackId);
		else if (mainBytecodeChanged && data.recordGlobalIndices.length > 0 && lastCapturedValues.has(callbackId)) callbacksToCheckValues.push({
			callbackId,
			data
		});
	}
	return {
		newBytecodeHashes,
		changedCallbackIds,
		callbacksToCheckValues
	};
}
async function checkCapturedValueChanges(callbacksToCheckValues, mainBytecode, changedCallbackIds, record, lastCapturedValues) {
	if (callbacksToCheckValues.length === 0) return;
	track(`sab-mainBytecode-${++_mainBytecodeTempId}`, "SharedArrayBuffer", mainBytecode.byteLength, { source: "dsp-program:checkCapturedValueChanges" });
	const mainBytecodeShared = new Float32Array(new SharedArrayBuffer(mainBytecode.byteLength));
	mainBytecodeShared.set(mainBytecode);
	for (const { callbackId, data } of callbacksToCheckValues) {
		const newValues = await record.getCapturedValues({
			mainBytecode: mainBytecodeShared,
			scopeId: callbackId,
			captureStoreGlobalIdx: data.captureStoreGlobalIdx,
			numDeps: data.recordGlobalIndices.length,
			recordGlobalIndices: data.recordGlobalIndices,
			defaultParamRecordGlobals: data.defaultParamRecordGlobals,
			sampleRate: 48e3
		});
		if (!newValues) continue;
		const oldValues = lastCapturedValues.get(callbackId) || [];
		if (newValues.length !== oldValues.length || newValues.some((v$4, i$6) => v$4 !== oldValues[i$6])) changedCallbackIds.add(callbackId);
	}
}
function markRemovedCallbacksAsChanged(newRecordCallbacks, changedCallbackIds, lastCallbackBytecodeHashes, lastCapturedValues) {
	for (const callbackId of lastCallbackBytecodeHashes.keys()) if (!newRecordCallbacks.has(callbackId)) {
		changedCallbackIds.add(callbackId);
		lastCapturedValues.delete(callbackId);
	}
}
function invalidateHandlesForChangedCallbacks(programId, changedCallbackIds, registrations, dspState) {
	const invalidatedHandles = [];
	if (changedCallbackIds.size === 0) return invalidatedHandles;
	for (const reg of registrations) if (reg.type === "record" && reg.recordCallbackId !== void 0) {
		if (changedCallbackIds.has(reg.recordCallbackId)) {
			sampleManager.clearHandle(reg.handle);
			invalidatedHandles.push(reg.handle);
		}
	}
	dspState.invalidateRecordings(programId);
	for (const h$5 of invalidatedHandles) dspState.fetchingSamples.delete(h$5);
	return invalidatedHandles;
}
async function ensureSharedBound(dspState, worklet, shared) {
	if (!dspState.isProgramSharedStale(shared.bufferRef)) return null;
	const init = await worklet.getProgramShared({ programId: shared.id });
	if (!init) return null;
	return bindProgramShared(dspState.buffer, init, shared.historyMetaU32);
}
function getHistoryIndexForFunctionReturn(name, functionReturnPcs, cachedHistoryViews) {
	const pc = functionReturnPcs[name];
	if (pc == null) return null;
	return cachedHistoryViews.find((v$4) => v$4.callStackFrames.includes(pc))?.historyIndex ?? null;
}
async function getVmView(memory, worklet, programId) {
	const result = await worklet.getVmInfoPtr({ programId });
	if (result === null) return null;
	const { infoPtr } = result;
	return new AudioVmView(memory, infoPtr);
}
function applySourceMappingToViews(result, cachedHistoryViews) {
	if (cachedHistoryViews.length === 0) return {
		typedHistories: [],
		userCallHistories: []
	};
	if (result.errors.length > 0) return {
		typedHistories: [],
		userCallHistories: []
	};
	return createTypedHistories(cachedHistoryViews, result.compile.historySourceMap || []);
}
async function applySyncMode(opts, worklet, programId) {
	const syncEnabled = !!opts.enabled;
	const syncBars = Math.max(1, Math.round(Number(opts.bars) || 1));
	await worklet.setProgramSync({
		programId,
		enabled: syncEnabled,
		bars: syncBars
	});
	return {
		syncEnabled,
		syncBars
	};
}
function setProgramState(shared, s$4) {
	shared.stateU32[SharedProgramStateIndex.State] = s$4;
}
async function rebindProgram(worklet, shared, dspState) {
	const init = await worklet.getProgramShared({ programId: shared.id });
	if (!init) return shared;
	return bindProgramShared(dspState.buffer, init, shared.historyMetaU32);
}
var setControlCompileSnapshotImpl = atomic(async (ccs, shared, dspState, worklet, record, setCodeToken, program, recordCallbacks, lastStructureHash, lastMainBytecodeHash, lastCallbackBytecodeHashes, lastCapturedValues, lastRecordSecondsByCallbackId, freesoundIds, opts) => {
	const token = setCodeToken + 1 >>> 0;
	setCodeToken = token;
	const { mainBytecode, newRecordCallbacks, structureHash, historySourceMap: newHistorySourceMap, functionReturnPcs: newFunctionReturnPcs, arrayGetHistoryCount } = applyCompileState(ccs);
	const historySourceMap = newHistorySourceMap;
	const functionReturnPcs = newFunctionReturnPcs;
	const hashResult = updateMainBytecodeHash(mainBytecode, lastMainBytecodeHash);
	lastMainBytecodeHash = hashResult.newHash;
	const mainBytecodeChanged = hashResult.changed;
	const { newBytecodeHashes, changedCallbackIds, callbacksToCheckValues } = computeCallbackChanges(newRecordCallbacks, mainBytecodeChanged, lastCallbackBytecodeHashes, lastCapturedValues);
	await checkCapturedValueChanges(callbacksToCheckValues, mainBytecode, changedCallbackIds, record, lastCapturedValues);
	const structureUnchanged = structureHash === lastStructureHash;
	lastStructureHash = structureHash;
	let recordDurationChanged = false;
	let freesoundsChanged = false;
	let inlineSamplesPresent = false;
	let espeakSamplesPresent = false;
	for (const reg of ccs.compile.sampleRegistrations) if (reg.type === "record" && reg.recordCallbackId != null && reg.recordSeconds != null) {
		if (lastRecordSecondsByCallbackId.get(reg.recordCallbackId) !== reg.recordSeconds) {
			recordDurationChanged = true;
			break;
		}
	} else if (reg.type === "freesound" && reg.freesoundId != null && !freesoundIds.has(reg.freesoundId)) {
		freesoundIds.add(reg.freesoundId);
		freesoundsChanged = true;
	} else if (reg.type === "inline") inlineSamplesPresent = true;
	else if (reg.type === "espeak") espeakSamplesPresent = true;
	if (changedCallbackIds.size === 0 && structureUnchanged && !recordDurationChanged && !freesoundsChanged && !inlineSamplesPresent && !espeakSamplesPresent && !opts?.fullResync) {
		lastMainBytecodeHash = updateMainBytecodeHash(mainBytecode, lastMainBytecodeHash).newHash;
		const nextShared$1 = await ensureSharedBound(dspState, worklet, shared);
		if (nextShared$1) shared = nextShared$1;
		console.log("set control ops");
		await setControlOps(dspState, worklet, program, mainBytecode);
		console.log("set control ops done");
		return {
			shared,
			historySourceMap,
			functionReturnPcs,
			lastStructureHash,
			lastMainBytecodeHash
		};
	}
	markRemovedCallbacksAsChanged(newRecordCallbacks, changedCallbackIds, lastCallbackBytecodeHashes, lastCapturedValues);
	const invalidatedHandles = invalidateHandlesForChangedCallbacks(shared.id, changedCallbackIds, ccs.compile.sampleRegistrations, dspState);
	recordCallbacks.clear();
	for (const [k$4, v$4] of newRecordCallbacks) recordCallbacks.set(k$4, v$4);
	lastCallbackBytecodeHashes.clear();
	for (const [k$4, v$4] of newBytecodeHashes) lastCallbackBytecodeHashes.set(k$4, v$4);
	lastRecordSecondsByCallbackId.clear();
	for (const reg of ccs.compile.sampleRegistrations) if (reg.type === "record" && reg.recordCallbackId != null && reg.recordSeconds != null) lastRecordSecondsByCallbackId.set(reg.recordCallbackId, reg.recordSeconds);
	await worklet.syncSampleRegistrations({
		registrations: ccs.compile.sampleRegistrations,
		invalidatedHandles: invalidatedHandles.length > 0 ? invalidatedHandles : void 0
	});
	for (const reg of ccs.compile.sampleRegistrations) if (reg.type === "inline" && reg.inlineChannels && reg.inlineSampleRate != null) {
		await worklet.setSampleDataDirect({
			handle: reg.handle,
			channels: reg.inlineChannels,
			sampleRate: reg.inlineSampleRate
		});
		sampleManager.setSampleData(reg.handle, reg.inlineChannels, reg.inlineSampleRate);
	} else if (reg.type === "espeak" && reg.espeakText) {
		const text = reg.espeakText;
		const variant = reg.espeakVariant ?? "m1";
		const speed = reg.espeakSpeed ?? .5;
		const pitch = reg.espeakPitch ?? .5;
		try {
			console.log(`[dsp] Fetching espeak sample for handle ${reg.handle}...`);
			const { channels, sampleRate } = await fetchEspeakSample(dspState.audioContext, {
				text,
				variant,
				speed,
				pitch
			});
			await worklet.setSampleDataDirect({
				handle: reg.handle,
				channels,
				sampleRate
			});
			sampleManager.setSampleData(reg.handle, channels, sampleRate);
			console.log(`[dsp] Set espeak sample data for handle ${reg.handle}`);
		} catch (error$1) {
			const msg = error$1 instanceof Error ? error$1.message : String(error$1);
			console.error("[dsp] Error fetching espeak sample:", msg);
			await worklet.setSampleError({
				handle: reg.handle,
				error: msg
			});
			sampleManager.setSampleError(reg.handle, msg);
			throw error$1;
		}
	}
	await fetchRequiredSamples(dspState.audioContext, worklet, record, dspState.fetchingSamples, shared.id, () => dspState.getProgramRecordGeneration(shared.id), recordCallbacks, mainBytecode, (callbackId, values) => {
		if (token !== setCodeToken) return;
		lastCapturedValues.set(callbackId, values);
	});
	if (token !== setCodeToken) throw new Error("Superceeded by a newer setCode call");
	const nextShared = await ensureSharedBound(dspState, worklet, shared);
	if (nextShared) shared = nextShared;
	await setControlOpsSwap(dspState, worklet, program, mainBytecode);
	return {
		shared,
		historySourceMap,
		functionReturnPcs,
		lastStructureHash,
		lastMainBytecodeHash
	};
}, { timeout: 1e3 });
function createDspProgram(dspState, shared, worklet, record) {
	let lastOps = null;
	let lastStructureHash = null;
	let setCodeToken = 0;
	let recordCallbacks = /* @__PURE__ */ new Map();
	let lastCallbackBytecodeHashes = /* @__PURE__ */ new Map();
	let lastCapturedValues = /* @__PURE__ */ new Map();
	let lastRecordSecondsByCallbackId = /* @__PURE__ */ new Map();
	let freesoundIds = /* @__PURE__ */ new Set();
	let lastMainBytecodeHash = 0;
	let historySourceMap = [];
	let functionReturnPcs = {};
	let cachedHistories = [];
	let cachedUserCallHistories = [];
	let cachedHistoryViews = [];
	let lastHistoryPackEpoch = 0;
	const latency = createDspLatency({
		audioContext: dspState.audioContext,
		getIsPlaying: () => getProgramState(shared) === DspProgramState.Start,
		getRawSampleCount: () => Number(Atomics.load(shared.stateU32, SharedProgramStateIndex.SampleCount)) >>> 0
	});
	const emptyOutputs = {
		left: new Float32Array(0),
		right: new Float32Array(0),
		chunkSamples: 128,
		currentChunkPos: 0
	};
	async function setControlCompileSnapshot(ccs, opts) {
		const result = await setControlCompileSnapshotImpl(ccs, shared, dspState, worklet, record, setCodeToken, program, recordCallbacks, lastStructureHash, lastMainBytecodeHash, lastCallbackBytecodeHashes, lastCapturedValues, lastRecordSecondsByCallbackId, freesoundIds, opts);
		if (result.lastStructureHash) lastStructureHash = result.lastStructureHash;
		if (result.lastMainBytecodeHash) lastMainBytecodeHash = result.lastMainBytecodeHash;
		if (result.historySourceMap) historySourceMap = result.historySourceMap;
		if (result.functionReturnPcs) functionReturnPcs = result.functionReturnPcs;
		if (result.shared) shared = result.shared;
	}
	function updateHistoriesFromCurrentPack() {
		const memory = dspState.memory;
		if (!memory?.buffer) return false;
		const epoch = Atomics.load(shared.stateU32, SharedProgramStateIndex.HistoryPackEpoch) >>> 0;
		if (epoch === lastHistoryPackEpoch) return false;
		lastHistoryPackEpoch = epoch;
		const packIndex = Atomics.load(shared.stateU32, SharedProgramStateIndex.HistoryPackIndex) >>> 0;
		const metaPacks = shared.historyMetaPacks;
		const meta = metaPacks[packIndex] ?? metaPacks[0];
		if (!(meta.buffer instanceof SharedArrayBuffer)) return false;
		const lock = Atomics.load(meta, 0);
		const historyCount = meta[1] ?? 0;
		if (lock !== 0 || historyCount === 0) return false;
		const { histories } = AudioVmView.fromHistoryMetaShared(memory, meta);
		const { typedHistories, userCallHistories } = createTypedHistories(histories, historySourceMap);
		cachedHistoryViews = histories;
		cachedHistories = typedHistories;
		cachedUserCallHistories = userCallHistories;
		return true;
	}
	function getOutputs() {
		const memory = dspState.memory;
		if (!memory?.buffer) return emptyOutputs;
		updateHistoriesFromCurrentPack();
		const outHistory = cachedHistoryViews.find((h$5) => h$5.genName === "Out" || h$5.genName === "Solo");
		if (outHistory && outHistory.outputPtr !== 0) {
			const ringLen = outHistory.ringChunks * outHistory.chunkSamples;
			const ptr = outHistory.outputPtr;
			return {
				left: new Float32Array(memory.buffer, ptr, ringLen),
				right: new Float32Array(memory.buffer, ptr, ringLen),
				chunkSamples: outHistory.chunkSamples,
				currentChunkPos: outHistory.outputChunkPos
			};
		}
		return emptyOutputs;
	}
	const program = {
		get id() {
			return shared.id;
		},
		get vmIds() {
			return shared.vmIds;
		},
		get shared() {
			return shared;
		},
		set shared(s$4) {
			shared = s$4;
		},
		get lastOps() {
			return lastOps;
		},
		set lastOps(o$34) {
			lastOps = o$34;
		},
		get state() {
			return getProgramState(shared);
		},
		get isPlaying() {
			return getProgramState(shared) === DspProgramState.Start;
		},
		get sampleCount() {
			return Atomics.load(shared.stateU32, SharedProgramStateIndex.SampleCount) >>> 0;
		},
		set sampleCount(value) {
			Atomics.store(shared.stateU32, SharedProgramStateIndex.SampleCount, value >>> 0);
		},
		get histories() {
			return cachedHistories;
		},
		get userCallHistories() {
			return cachedUserCallHistories;
		},
		get historyViews() {
			return cachedHistoryViews;
		},
		get outputs() {
			return getOutputs();
		},
		latency,
		getHistoryIndexForFunctionReturn: (name) => getHistoryIndexForFunctionReturn(name, functionReturnPcs, cachedHistoryViews),
		getVmView: () => getVmView(dspState.memory, worklet, shared.id),
		refreshHistories() {
			return updateHistoriesFromCurrentPack();
		},
		reapplySourceMapping(result) {
			const next = applySourceMappingToViews(result, cachedHistoryViews);
			if (next.typedHistories.length > 0) {
				cachedHistories = next.typedHistories;
				cachedUserCallHistories = next.userCallHistories;
			}
		},
		async setSyncMode(opts) {
			const sync = await applySyncMode(opts, worklet, shared.id);
			sync.syncEnabled;
			sync.syncBars;
		},
		async rebind() {
			shared = await rebindProgram(worklet, shared, dspState);
		},
		setControlCompileSnapshot,
		start() {
			setProgramState(shared, DspProgramState.Start);
		},
		pause() {
			setProgramState(shared, DspProgramState.Pause);
		},
		stop() {
			setProgramState(shared, DspProgramState.Stop);
		},
		_setState(s$4) {
			setProgramState(shared, s$4);
		},
		_getHistoryMetaU32() {
			return shared.historyMetaU32;
		},
		_applyShared(_shared) {
			shared = _shared;
		}
	};
	return program;
}
function isMobile$1() {
	return /Mobi|Android|Tablet/i.test(navigator.userAgent);
}
var asconfig_mobile_default = {
	targets: {
		"test": {
			"outFile": "as/build/index-mobile.wasm",
			"optimizeLevel": 0,
			"converge": false,
			"sourceMap": true,
			"debug": true,
			"noAssert": false,
			"uncheckedBehavior": "never"
		},
		"debug": {
			"outFile": "as/build/index-mobile.wasm",
			"optimizeLevel": 0,
			"converge": false,
			"sourceMap": true,
			"debug": true,
			"noAssert": true,
			"uncheckedBehavior": "always"
		},
		"release": {
			"outFile": "as/build/index-mobile.wasm",
			"optimizeLevel": 3,
			"shrinkLevel": 2,
			"converge": false,
			"sourceMap": true,
			"debug": true,
			"noAssert": true,
			"uncheckedBehavior": "always"
		}
	},
	options: {
		"enable": [
			"simd",
			"relaxed-simd",
			"threads"
		],
		"importMemory": true,
		"initialMemory": 64,
		"maximumMemory": 2048,
		"sharedMemory": true,
		"bindings": "esm",
		"runtime": "minimal",
		"exportRuntime": true
	}
};
var asconfig_default = {
	targets: {
		"test": {
			"outFile": "as/build/index.wasm",
			"optimizeLevel": 0,
			"converge": false,
			"sourceMap": true,
			"debug": true,
			"noAssert": false,
			"uncheckedBehavior": "never"
		},
		"debug": {
			"outFile": "as/build/index.wasm",
			"optimizeLevel": 0,
			"converge": false,
			"sourceMap": true,
			"debug": true,
			"noAssert": true,
			"uncheckedBehavior": "always"
		},
		"release": {
			"outFile": "as/build/index.wasm",
			"optimizeLevel": 3,
			"shrinkLevel": 2,
			"converge": false,
			"sourceMap": true,
			"debug": true,
			"noAssert": true,
			"uncheckedBehavior": "always"
		}
	},
	options: {
		"enable": [
			"simd",
			"relaxed-simd",
			"threads"
		],
		"importMemory": true,
		"initialMemory": 64,
		"maximumMemory": 16384,
		"sharedMemory": true,
		"bindings": "esm",
		"runtime": "minimal",
		"exportRuntime": true
	}
};
var worklet_default = "/assets/worklet-BSGFxBDd.js";
function getWasmPaths() {
	const base = isMobile$1() ? "/as/build/index-mobile.wasm" : "/as/build/index.wasm";
	return {
		wasm: new URL(base, location.origin).toString(),
		sourcemap: new URL(base + ".map", location.origin).toString(),
		config: isMobile$1() ? asconfig_mobile_default : asconfig_default
	};
}
async function fetchWasmBinary() {
	const { wasm } = getWasmPaths();
	const response = await fetch(wasm + "?t=" + Date.now());
	if (!response.ok) throw new Error(`Failed to fetch WASM: ${response.status} ${response.statusText}`);
	return await response.arrayBuffer();
}
async function createWasmBinary() {
	const { sourcemap, config } = getWasmPaths();
	return {
		sourcemapUrl: sourcemap,
		binary: await fetchWasmBinary(),
		config
	};
}
async function createDspState(opts) {
	const { sourcemap, config } = getWasmPaths();
	const audioContext$1 = new AudioContext({ latencyHint: opts.latencyHint ?? .01 });
	const moduleUrl = new URL(worklet_default, window.location.origin).toString();
	await audioContext$1.audioWorklet.addModule(moduleUrl);
	const processor = new AudioWorkletNode(audioContext$1, "dsp", {
		outputChannelCount: [2],
		processorOptions: {
			sourcemapUrl: sourcemap,
			config
		}
	});
	processor.connect(audioContext$1.destination);
	return {
		audioContext: audioContext$1,
		processor,
		wasmBinary: await createWasmBinary(),
		onHistoriesRefreshed: void 0,
		memory: null,
		get buffer() {
			return this.memory?.buffer;
		},
		workletError: null,
		programRecordGeneration: /* @__PURE__ */ new Map(),
		fetchingSamples: /* @__PURE__ */ new Set(),
		getProgramRecordGeneration(programId) {
			return this.programRecordGeneration.get(programId) ?? 0;
		},
		invalidateRecordings(programId) {
			this.programRecordGeneration.set(programId, (this.programRecordGeneration.get(programId) ?? 0) + 1);
		},
		isProgramSharedStale(controlOpsBuffer) {
			return controlOpsBuffer !== this.buffer;
		}
	};
}
const Getter = (cb, target = {}) => new Proxy(target, { get: (_$5, key) => cb(key) });
var defaultTransferables = [typeof OffscreenCanvas !== "undefined" ? OffscreenCanvas : void 0, typeof MessagePort !== "undefined" ? MessagePort : void 0].filter(Boolean);
const rpc = (port, api$1 = {}, transferables = defaultTransferables) => {
	const xfer = (args, transferables$1) => args.reduce((p$6, n$4) => {
		if (typeof n$4 === "object") {
			if (transferables$1.some((ctor) => n$4 instanceof ctor)) p$6.push(n$4);
			else for (const key in n$4) if (n$4[key] && transferables$1.some((ctor) => n$4[key] instanceof ctor)) p$6.push(n$4[key]);
		}
		return p$6;
	}, []);
	let callbackId = 0;
	const calls = /* @__PURE__ */ new Map();
	port.onmessage = async ({ data }) => {
		const { cid } = data;
		if (data.method) {
			let result;
			try {
				if (!(data.method in api$1)) throw new TypeError(`Method "${data.method}" does not exist in RPC API.`);
				if (typeof api$1[data.method] !== "function") throw new TypeError(`Property "${data.method}" exists in RPC but is not type function, instead it is type: "${typeof api$1[data.method]}"`);
				result = await api$1[data.method](...data.args);
				port.postMessage({
					cid,
					result
				}, xfer([result], transferables));
			} catch (error$1) {
				port.postMessage({
					cid,
					error: error$1
				});
			}
		} else {
			if (!calls.has(cid)) {
				console.log(cid, calls.size, Object.keys(data.result));
				throw new ReferenceError("Callback id not found: " + cid);
			}
			const { resolve, reject } = calls.get(cid);
			calls.delete(data.cid);
			if (data.error) reject(data.error);
			else resolve(data.result);
		}
	};
	const call = (method, ...args) => {
		const cid = ++callbackId;
		const deferred = Deferred$1();
		calls.set(cid, deferred);
		try {
			port.postMessage({
				method,
				args,
				cid
			}, xfer(args, transferables));
		} catch (error$1) {
			console.error(`Rpc call failed: "${method}"`, args.map((x$4) => x$4.constructor.name + ": " + x$4.toString()), error$1);
		}
		return deferred.promise;
	};
	return Getter((key) => key === "then" ? void 0 : call.bind(null, key), call);
};
function createWasmImports(memory) {
	return {
		debug: { debugAudioVmOp: (pc, op = -1, stackTop) => {} },
		sample: {
			readSampleChunk: (sampleHandle, channel, startSample, length, destPtr) => {
				const sample = sampleManager.getSample(sampleHandle);
				if (!sample || !sample.ready) {
					const chunk$1 = new Float32Array(length);
					new Float32Array(memory.buffer, destPtr, length).set(chunk$1);
					return;
				}
				const chunk = sampleManager.readChunk(sampleHandle, channel, startSample, length);
				new Float32Array(memory.buffer, destPtr, length).set(chunk);
			},
			getSampleLength: (sampleHandle, channel) => {
				const sample = sampleManager.getSample(sampleHandle);
				return !sample || !sample.ready ? 0 : sample.channels[channel] ? sample.channels[channel].length : 0;
			},
			getSampleChannelCount: (sampleHandle) => {
				const sample = sampleManager.getSample(sampleHandle);
				if (!sample || !sample.ready) return 0;
				return sample.channels.length;
			},
			getSliceCount: (sampleHandle, threshold) => {
				return sampleManager.getSlices(sampleHandle, threshold).count;
			},
			getSlicePoint: (sampleHandle, threshold, index) => {
				const result = sampleManager.getSlices(sampleHandle, threshold);
				if (index < 0 || index >= result.count) return 0;
				return result.points[index] ?? 0;
			},
			getSampleVersion: (sampleHandle) => sampleManager.getSampleVersion(sampleHandle)
		}
	};
}
function createWasmRuntime(core) {
	const { wasm, memory } = core;
	return {
		get memory() {
			return memory;
		},
		get buffer() {
			return memory.buffer;
		},
		createFloat32Buffer(capacity) {
			return wasm.createFloat32Buffer(capacity);
		},
		freeFloat32Buffer(ptr) {
			wasm.freeFloat32Buffer(ptr >>> 0);
		},
		copyAudioVmState(fromVmId, toVmId) {
			wasm.copyAudioVmState(fromVmId, toVmId);
		},
		getAudioVmInfoPtr(vmId$1) {
			return wasm.getAudioVmInfoAt(vmId$1);
		},
		generateMiniHistoryWindow(bytecodePtr, historyPtr, windowStartSample, windowEndSample, bpm$1, sampleRate, barValue) {
			wasm.generateMiniHistoryWindow(bytecodePtr, historyPtr, windowStartSample, windowEndSample, bpm$1, sampleRate, barValue);
		},
		runAudioVmAt(vmId$1, audioOpsPtr, controlOpsLength, bufferLength, sampleCount, sampleRate, nyquist, piOverNyquist, bpm$1) {
			wasm.runAudioVmAt(vmId$1, audioOpsPtr, controlOpsLength, bufferLength, sampleCount, sampleRate, nyquist, piOverNyquist, bpm$1);
		},
		resetAudioVmAt(vmId$1) {
			wasm.resetAudioVmAt(vmId$1);
		},
		softResetAudioVmAt(vmId$1) {
			wasm.softResetAudioVmAt(vmId$1);
		},
		gc() {
			wasm.__collect();
		},
		memoryGrow(delta) {
			return wasm.memoryGrow(delta);
		},
		memoryUsage() {
			return wasm.memoryUsage();
		},
		setBpmOverride(bpm$1) {
			wasm.bpmOverride(bpm$1);
		}
	};
}
var section$1 = "sourceMappingURL";
function read_uint(buf, pos = 0) {
	let n$4 = 0;
	let shift = 0;
	let b$4 = buf[pos];
	let outpos = pos + 1;
	while (b$4 >= 128) {
		n$4 = n$4 | b$4 - 128 << shift;
		b$4 = buf[outpos];
		outpos++;
		shift += 7;
	}
	return [n$4 + (b$4 << shift), outpos];
}
function encode_uint(n$4) {
	let result = [];
	while (n$4 > 127) {
		result.push(128 | n$4 & 127);
		n$4 = n$4 >> 7;
	}
	result.push(n$4);
	return new Uint8Array(result);
}
function ab2str(buf) {
	let str = "";
	let bytes = new Uint8Array(buf);
	for (let i$6 = 0; i$6 < bytes.length; i$6++) str += String.fromCharCode(bytes[i$6]);
	return str;
}
function str2ab(str) {
	let bytes = new Uint8Array(str.length);
	for (let i$6 = 0; i$6 < str.length; i$6++) bytes[i$6] = str[i$6].charCodeAt(0);
	return bytes;
}
function writeSection(name, value) {
	const nameBuf = str2ab(name);
	const valBuf = str2ab(value);
	const nameLen = encode_uint(nameBuf.length);
	const valLen = encode_uint(valBuf.length);
	const sectionLen = nameLen.length + nameBuf.length + valLen.length + valBuf.length;
	const headerLen = encode_uint(sectionLen);
	let bytes = new Uint8Array(sectionLen + headerLen.length + 1);
	let pos = 1;
	bytes.set(headerLen, pos);
	pos += headerLen.length;
	bytes.set(nameLen, pos);
	pos += nameLen.length;
	bytes.set(nameBuf, pos);
	pos += nameBuf.length;
	bytes.set(valLen, pos);
	pos += valLen.length;
	bytes.set(valBuf, pos);
	return bytes;
}
function findSection(buf, id) {
	let pos = 8;
	while (pos < buf.byteLength) {
		const sec_start = pos;
		const [sec_id, pos2] = read_uint(buf, pos);
		const [sec_size, body_pos] = read_uint(buf, pos2);
		pos = body_pos + sec_size;
		if (sec_id == 0) {
			const [name_len, name_pos] = read_uint(buf, body_pos);
			if (ab2str(buf.slice(name_pos, name_pos + name_len)) == id) return [
				sec_start,
				sec_size + 1 + (body_pos - pos2),
				name_pos + name_len
			];
		}
	}
	return [
		-1,
		null,
		null
	];
}
const wasmSourceMap = {
	getSourceMapURL: function(buf) {
		buf = new Uint8Array(buf);
		const [sec_start, _$5, uri_start] = findSection(buf, section$1);
		if (sec_start == -1) return null;
		const [uri_len, uri_pos] = read_uint(buf, uri_start);
		return ab2str(buf.slice(uri_pos, uri_pos + uri_len));
	},
	removeSourceMapURL: function(buf) {
		buf = new Uint8Array(buf);
		const [sec_start, sec_size, _$5] = findSection(buf, section$1);
		if (sec_start == -1) return buf;
		let strippedBuf = new Uint8Array(buf.length - sec_size);
		strippedBuf.set(buf.slice(0, sec_start));
		strippedBuf.set(buf.slice(sec_start + sec_size), sec_start);
		return strippedBuf;
	},
	setSourceMapURL: function(buf, url) {
		const stripped = this.removeSourceMapURL(buf);
		const newSection = writeSection(section$1, url);
		const outBuf = new Uint8Array(stripped.length + newSection.length);
		outBuf.set(stripped);
		outBuf.set(newSection, stripped.length);
		return outBuf;
	}
};
function liftString(memory, pointer) {
	if (!pointer) return "";
	const end = pointer + new Uint32Array(memory.buffer)[pointer - 4 >>> 2] >>> 1, memoryU16 = new Uint16Array(memory.buffer);
	let start = pointer >>> 1, string = "";
	while (end - start > 1024) string += String.fromCharCode(...memoryU16.subarray(start, start += 1024));
	return string + String.fromCharCode(...memoryU16.subarray(start, end));
}
async function wasmSetup({ binary, sourcemapUrl, config, imports }) {
	const buffer = wasmSourceMap.setSourceMapURL(binary, sourcemapUrl);
	const uint8 = new Uint8Array(buffer);
	const memory = new WebAssembly.Memory({
		initial: config.options.initialMemory,
		maximum: config.options.maximumMemory,
		shared: config.options.sharedMemory
	});
	const mod = await WebAssembly.compile(uint8.buffer);
	const extraImports = typeof imports === "function" ? imports({ memory }) : imports;
	const importObject = { env: {
		memory,
		abort(message$, fileName$, lineNumber$, columnNumber$) {
			const message = liftString(memory, message$ >>> 0);
			const fileName = liftString(memory, fileName$ >>> 0);
			const lineNumber = lineNumber$ >>> 0;
			const columnNumber = columnNumber$ >>> 0;
			throw new Error(`${message} in ${fileName}:${lineNumber}:${columnNumber}`);
		},
		seed: () => Date.now() * Math.random(),
		log: console.log,
		warn: console.warn,
		"console.log": (textPtr) => {
			console.log(liftString(memory, textPtr));
		},
		"console.warn": (textPtr) => {
			console.warn(liftString(memory, textPtr));
		}
	} };
	if (extraImports) for (const k$4 of Object.keys(extraImports)) {
		const mod$1 = extraImports[k$4];
		if (!mod$1) continue;
		importObject[k$4] = {
			...importObject[k$4],
			...mod$1
		};
	}
	return {
		wasm: (await WebAssembly.instantiate(mod, importObject)).exports,
		memory
	};
}
var DEBUG_PREVIEW_TIMING$1 = typeof process !== "undefined" && {}?.DEBUG_PREVIEW_TIMING === "1";
function ensureMiniEntryPool(pool, size) {
	while (pool.length < size) pool.push({
		opIndex: 0,
		voiceIndex: 0,
		value: 0,
		velocity: 0,
		startSeconds: 0,
		endSeconds: 0
	});
}
function createDspPreview(runtime) {
	let previewAudioContext = null;
	const state = {
		bytecode: null,
		result: null,
		historySourceMap: [],
		sampleRate: 48e3,
		structureHash: 0,
		vmView: null,
		histories: [],
		userCallHistories: [],
		audioOpsPtr: 0,
		audioOpsCapacity: 0,
		lastBuiltStructureHash: 0,
		lastAppliedHistorySourceMap: [],
		miniBytecodePtr: 0,
		miniBytecodeCapacity: 0,
		miniHistoryPtr: 0,
		miniEntryPool: []
	};
	async function ensurePreviewSamples(registrations) {
		if (typeof AudioContext === "undefined") return;
		if (!previewAudioContext) try {
			previewAudioContext = new AudioContext({ latencyHint: "interactive" });
		} catch (e$59) {
			const msg = e$59 instanceof Error ? e$59.message : String(e$59);
			console.error("[preview] Failed to create AudioContext for espeak samples:", msg);
			return;
		}
		const ctx$1 = previewAudioContext;
		for (const reg of registrations) if (reg.type === "inline" && reg.inlineChannels && reg.inlineSampleRate != null) sampleManager.setSampleData(reg.handle, reg.inlineChannels, reg.inlineSampleRate);
		else if (reg.type === "espeak" && reg.espeakText) {
			const text = reg.espeakText;
			const variant = reg.espeakVariant ?? "m1";
			const speed = reg.espeakSpeed ?? .5;
			const pitch = reg.espeakPitch ?? .5;
			try {
				const { channels, sampleRate } = await fetchEspeakSample(ctx$1, {
					text,
					variant,
					speed,
					pitch
				});
				sampleManager.setSampleData(reg.handle, channels, sampleRate);
			} catch (error$1) {
				const msg = error$1 instanceof Error ? error$1.message : String(error$1);
				console.error("[preview] Error fetching espeak sample:", msg);
				sampleManager.setSampleError(reg.handle, msg);
			}
		}
	}
	return {
		setControlCompileSnapshot(ccs) {
			state.result = ccs;
			state.bytecode = ccs.compile.bytecode;
			state.historySourceMap = ccs.compile.historySourceMap || [];
			if (state.bytecode) state.structureHash = bytecodeStructureHash(state.bytecode);
			if (ccs.compile.sampleRegistrations?.length) ensurePreviewSamples(ccs.compile.sampleRegistrations);
		},
		runPreview(vmId$1 = 0, sampleCount = 0, bufferLength = 128) {
			const t0 = DEBUG_PREVIEW_TIMING$1 ? performance.now() : 0;
			if (!state.bytecode) throw new Error("No code set. Call setCode() first.");
			const nyquist = state.sampleRate / 2;
			const piOverNyquist = Math.PI / nyquist;
			const bpm$1 = state.result.compile.bpm;
			runtime.resetAudioVmAt(vmId$1);
			const len = state.bytecode.length;
			if (state.audioOpsCapacity < len) {
				if (state.audioOpsPtr) runtime.freeFloat32Buffer(state.audioOpsPtr);
				state.audioOpsPtr = runtime.createFloat32Buffer(len);
				state.audioOpsCapacity = len;
			}
			const audioOpsPtr = state.audioOpsPtr;
			new Float32Array(runtime.buffer, audioOpsPtr, len).set(state.bytecode);
			runtime.runAudioVmAt(vmId$1, audioOpsPtr, len, bufferLength, sampleCount, state.sampleRate, nyquist, piOverNyquist, bpm$1);
			runtime.gc();
			const infoPtr = runtime.getAudioVmInfoPtr(vmId$1);
			if (!state.vmView || state.structureHash !== state.lastBuiltStructureHash) {
				state.vmView = new AudioVmView(runtime.memory, infoPtr);
				state.lastBuiltStructureHash = state.structureHash;
				state.lastAppliedHistorySourceMap = state.historySourceMap;
			} else if (state.historySourceMap !== state.lastAppliedHistorySourceMap) state.lastAppliedHistorySourceMap = state.historySourceMap;
			const result = createTypedHistories(state.vmView.histories, state.historySourceMap);
			state.histories = result.typedHistories;
			state.userCallHistories = result.userCallHistories;
			const vmView = state.vmView;
			const histories = state.histories;
			const userCallHistories = state.userCallHistories;
			if (DEBUG_PREVIEW_TIMING$1) console.log("[preview] runPreview", (performance.now() - t0).toFixed(2), "ms");
			return {
				vmView,
				histories,
				userCallHistories
			};
		},
		runMiniPreview(compileResult, startSeconds, endSeconds, bars) {
			const t0 = DEBUG_PREVIEW_TIMING$1 ? performance.now() : 0;
			const result = state.result;
			if (!result) throw new Error("No code set. Call setCode() first.");
			const arraySize = 2 + compileResult.bytecode.length;
			if (state.miniBytecodeCapacity < arraySize) {
				if (state.miniBytecodePtr) runtime.freeFloat32Buffer(state.miniBytecodePtr);
				state.miniBytecodePtr = runtime.createFloat32Buffer(arraySize);
				state.miniBytecodeCapacity = arraySize;
			}
			if (!state.miniHistoryPtr) state.miniHistoryPtr = runtime.createFloat32Buffer(1 + MINI_HISTORY_SIZE * 6);
			const bytecode$ = state.miniBytecodePtr;
			const history$ = state.miniHistoryPtr;
			const buf = runtime.memory.buffer;
			const array = new Float32Array(buf, bytecode$, arraySize);
			array[0] = compileResult.bytecode.length;
			array[1] = 1;
			array.set(compileResult.bytecode, 2);
			const sampleRate = 100;
			const windowStartSample = startSeconds * sampleRate;
			const windowEndSample = endSeconds * sampleRate;
			runtime.generateMiniHistoryWindow(bytecode$, history$, windowStartSample, windowEndSample, result.compile.bpm, sampleRate, bars);
			const historyLen = 1 + MINI_HISTORY_SIZE * 6;
			const history$1 = new Float32Array(buf, history$, historyLen);
			const length = history$1[0];
			ensureMiniEntryPool(state.miniEntryPool, length);
			const pool = state.miniEntryPool;
			const entries$1 = [];
			for (let i$6 = 0; i$6 < length; i$6++) {
				const base = 1 + i$6 * 6;
				const startSample = history$1[base + 4];
				const endSample = history$1[base + 5];
				const e$59 = pool[i$6];
				e$59.opIndex = history$1[base];
				e$59.voiceIndex = history$1[base + 1];
				e$59.value = history$1[base + 2];
				e$59.velocity = history$1[base + 3];
				e$59.startSeconds = startSample / sampleRate;
				e$59.endSeconds = endSample / sampleRate;
				entries$1.push({ ...e$59 });
			}
			if (DEBUG_PREVIEW_TIMING$1) console.log("[preview] runMiniPreview", (performance.now() - t0).toFixed(2), "ms");
			return entries$1;
		},
		*renderToAudio(code, bars, beatsPerBar = 4, vmId$1 = 999) {
			const ccs = controlPipeline.compileSource(code);
			this.setControlCompileSnapshot(ccs);
			if (ccs.errors.length > 0) throw new Error(`Compilation failed:\n${ccs.errors.join("\n")}`);
			if (!state.bytecode) throw new Error("No bytecode generated");
			const bpm$1 = ccs.compile.bpm;
			const totalSamples = Math.floor(bars * beatsPerBar * 60 / bpm$1 * state.sampleRate);
			const chunk = 128;
			const numChunks = Math.ceil(totalSamples / chunk);
			const renderedLength = numChunks * chunk;
			const left = new Float32Array(renderedLength);
			const right = new Float32Array(renderedLength);
			const nyquist = state.sampleRate / 2;
			const piOverNyquist = Math.PI / nyquist;
			const audioOpsPtr = runtime.createFloat32Buffer(state.bytecode.length);
			new Float32Array(runtime.buffer, audioOpsPtr, state.bytecode.length).set(state.bytecode);
			runtime.resetAudioVmAt(vmId$1);
			let offset = 0;
			for (let i$6 = 0; i$6 < numChunks; i$6++) {
				runtime.runAudioVmAt(vmId$1, audioOpsPtr, state.bytecode.length, chunk, offset, state.sampleRate, nyquist, piOverNyquist, bpm$1);
				const infoPtr = runtime.getAudioVmInfoPtr(vmId$1);
				const aInfo = new Uint32Array(runtime.buffer, infoPtr, 10);
				const outputLeftPtr = aInfo[8];
				const outputRightPtr = aInfo[9];
				if (outputLeftPtr && outputRightPtr) {
					left.set(new Float32Array(runtime.buffer, outputLeftPtr, chunk), offset);
					right.set(new Float32Array(runtime.buffer, outputRightPtr, chunk), offset);
				}
				offset += chunk;
				if ((i$6 + 1) % 128 === 0 || i$6 === numChunks - 1) yield totalSamples > 0 ? Math.min(1, offset / totalSamples) : 1;
			}
			runtime.freeFloat32Buffer(audioOpsPtr);
			yield 1;
			return {
				left: left.subarray(0, totalSamples).slice(),
				right: right.subarray(0, totalSamples).slice()
			};
		}
	};
}
var record_worker_default = "/assets/record-worker-QmGCic6L.js";
async function createRecordWorker(wasmBinary, worklet) {
	const url = new URL(record_worker_default, window.location.origin).toString();
	const worker = new Worker(url, { type: "module" });
	const mainChannel = new MessageChannel();
	const sampleSyncChannel = new MessageChannel();
	sampleSyncChannel.port2.onmessage = (e$59) => {
		const d$5 = e$59.data;
		if (d$5?.type === "sampleDataSync") sampleManager.setSampleData(d$5.handle, d$5.channels.map((sab) => new Float32Array(sab)), d$5.sampleRate);
		else if (d$5?.type === "sampleErrorSync") sampleManager.setSampleError(d$5.handle, d$5.error);
	};
	sampleSyncChannel.port2.start();
	worker.postMessage({
		type: "init",
		port: mainChannel.port1,
		sampleSyncPort: sampleSyncChannel.port1
	}, [mainChannel.port1, sampleSyncChannel.port1]);
	const record = rpc(mainChannel.port2);
	mainChannel.port2.start();
	await record.loadWasm(wasmBinary.binary, {
		sourcemapUrl: wasmBinary.sourcemapUrl,
		config: wasmBinary.config
	});
	const workerWorkletChannel = new MessageChannel();
	await record.connectWorklet(workerWorkletChannel.port1);
	await worklet.connectRecord(workerWorkletChannel.port2);
	return record;
}
async function createDspCore(wasmBinary, processor, transportBuffer) {
	const preview = createDspPreview(createWasmRuntime(await wasmSetup({
		...wasmBinary,
		config: wasmBinary.config,
		imports: ({ memory }) => createWasmImports(memory)
	})));
	const workletRpcApi = {};
	const worklet = rpc(processor.port, workletRpcApi);
	await worklet.loadWasm(wasmBinary.binary, { transportBuffer });
	return {
		memory: await worklet.getMemory(),
		worklet,
		workletRpcApi,
		preview,
		record: await createRecordWorker(wasmBinary, worklet)
	};
}
async function createDsp(state) {
	const programs = /* @__PURE__ */ new Set();
	const transportBuffer = new SharedArrayBuffer(36);
	track("sab-transport", "SharedArrayBuffer", 36, { source: "dsp" });
	const t$12 = createSharedTransportViewsFromBuffer(transportBuffer);
	const transport$1 = {
		transportU32: t$12.u32,
		transportF32: t$12.f32
	};
	const latency = createDspLatency({
		audioContext: state.audioContext,
		getIsPlaying: () => Atomics.load(transport$1.transportU32, SharedTransportIndex.ActuallyPlaying) !== 0,
		getRawSampleCount: () => transport$1.transportF32[SharedTransportIndex.SampleCount]
	});
	const core = await createDspCore(state.wasmBinary, state.processor, transportBuffer);
	state.memory = core.memory;
	const control = atomic(async function(fn$1) {
		return await fn$1();
	});
	function start(programs$1) {
		return control(async () => {
			await state.audioContext.resume();
			await rebindAllPrograms(await core.worklet.start(programs$1.map((p$6) => p$6.id)));
		});
	}
	function pause(programs$1) {
		return control(async () => {
			await rebindAllPrograms(await core.worklet.pause(programs$1.map((p$6) => p$6.id)));
		});
	}
	function stop(programs$1) {
		return control(async () => {
			await rebindAllPrograms(await core.worklet.stop(programs$1.map((p$6) => p$6.id)));
		});
	}
	function seek(sampleCount, programs$1, preview) {
		return control(async () => {
			await rebindAllPrograms(await core.worklet.seek({
				sampleCount,
				programIds: programs$1.map((p$6) => p$6.id),
				preview
			}));
		});
	}
	function seekPrograms(sampleCount, programs$1, preview) {
		return control(async () => {
			await rebindAllPrograms(await core.worklet.seekPrograms({
				sampleCount,
				programIds: programs$1.map((p$6) => p$6.id),
				preview
			}));
		});
	}
	function swapPrograms(program1, program2) {
		return control(async () => {
			await rebindAllPrograms(await core.worklet.swapPrograms([program1.id], [program2.id]));
		});
	}
	function setProgramGain(program, gain) {
		return control(async () => {
			await core.worklet.setProgramGain({
				programId: program.id,
				gain
			});
		});
	}
	function bpmOverride(bpm$1) {
		return control(async () => {
			await core.worklet.bpmOverride({ bpm: bpm$1 });
		});
	}
	function createProgram() {
		return control(async () => {
			const historyMetaBuffers = [createHistoryMetaSharedBuffer(), createHistoryMetaSharedBuffer()];
			const init = await core.worklet.initProgramSlot({ historyMetaBuffers });
			if (!init) throw new Error("Failed to init program shared buffers");
			if (!state.buffer) throw new Error("No buffer");
			const program = createDspProgram(state, bindProgramShared(state.buffer, init), core.worklet, core.record);
			programs.add(program);
			return program;
		});
	}
	function playProgram(program) {
		program._setState(DspProgramState.Start);
	}
	function stopProgram(program) {
		program._setState(DspProgramState.Stop);
	}
	function rebindProgramsSync(inits) {
		for (const program of programs) {
			const init = inits.find((i$6) => i$6.id === program.id);
			if (init && state.buffer) program.shared = bindProgramShared(state.buffer, init, program._getHistoryMetaU32());
		}
	}
	async function rebindAllPrograms(inits) {
		if (inits?.length) rebindProgramsSync(inits);
		else for (const program of programs) await program.rebind();
	}
	async function refreshHistories() {
		for (const program of programs) await program.refreshHistories();
	}
	const refresh = atomic(async function(inits) {
		if (inits?.length) await rebindAllPrograms(inits);
		await refreshHistories();
		state.onHistoriesRefreshed?.();
	}, { dropInbetween: true });
	function setWorkletError(error$1) {
		state.workletError = error$1;
	}
	async function waitForHistoryMeta(program, opts) {
		const meta = program.shared.historyMetaU32;
		if (!(meta.buffer instanceof SharedArrayBuffer)) return false;
		const maxTries = opts?.maxTries ?? 120;
		for (let i$6 = 0; i$6 < maxTries; i$6++) {
			if (Atomics.load(meta, 0) === 0) {
				if ((meta[1] ?? 0) > 0) return true;
			}
			await new Promise((r$11) => i$6 % 2 === 0 ? requestAnimationFrame(r$11) : setTimeout(r$11, 0));
		}
		return false;
	}
	async function refreshUntilHistories(program, opts) {
		if (!await waitForHistoryMeta(program, opts)) return false;
		const maxTries = opts?.maxTries ?? 120;
		for (let i$6 = 0; i$6 < maxTries; i$6++) {
			if (program.histories.length > 0 || program.historyViews.length > 0) return true;
			await new Promise((r$11) => i$6 % 2 === 0 ? requestAnimationFrame(r$11) : setTimeout(r$11, 0));
		}
		return program.histories.length > 0 || program.historyViews.length > 0;
	}
	const dsp = {
		state,
		core,
		transport: transport$1,
		latency,
		sampleManager,
		start,
		pause,
		stop,
		seek,
		seekPrograms,
		setProgramGain,
		bpmOverride,
		createProgram,
		playProgram,
		stopProgram,
		swapPrograms,
		rebindAllPrograms,
		refreshHistories,
		refresh,
		refreshUntilHistories,
		setWorkletError,
		get isPlaying() {
			return Atomics.load(transport$1.transportU32, SharedTransportIndex.Running) === SharedTransportRunningState.Start;
		},
		get isPaused() {
			return Atomics.load(transport$1.transportU32, SharedTransportIndex.Running) === SharedTransportRunningState.Pause;
		},
		get isStopped() {
			return Atomics.load(transport$1.transportU32, SharedTransportIndex.Running) === SharedTransportRunningState.Stop;
		},
		get isActuallyPlaying() {
			return Atomics.load(transport$1.transportU32, SharedTransportIndex.ActuallyPlaying) === SharedTransportRunningState.Start;
		},
		get isActuallyPaused() {
			return Atomics.load(transport$1.transportU32, SharedTransportIndex.ActuallyPlaying) === SharedTransportRunningState.Pause;
		},
		get isActuallyStopped() {
			return Atomics.load(transport$1.transportU32, SharedTransportIndex.ActuallyPlaying) === SharedTransportRunningState.Stop;
		},
		get loopBeginSamples() {
			return Atomics.load(transport$1.transportU32, SharedTransportIndex.LoopBeginSamples);
		},
		set loopBeginSamples(v$4) {
			Atomics.store(transport$1.transportU32, SharedTransportIndex.LoopBeginSamples, v$4);
		},
		get loopEndSamples() {
			return Atomics.load(transport$1.transportU32, SharedTransportIndex.LoopEndSamples);
		},
		set loopEndSamples(v$4) {
			Atomics.store(transport$1.transportU32, SharedTransportIndex.LoopEndSamples, v$4);
		},
		set projectEndSamples(v$4) {
			Atomics.store(transport$1.transportU32, SharedTransportIndex.ProjectEndSamples, v$4);
		},
		togglePause(programs$1) {
			if (this.isPlaying) this.pause(programs$1);
			else this.start(programs$1);
		}
	};
	Object.assign(core.workletRpcApi, dsp);
	return dsp;
}
function mergeBySource(a$36, b$4) {
	const out = { ...a$36 };
	for (const [k$4, v$4] of Object.entries(b$4)) {
		const cur = out[k$4] ?? {
			count: 0,
			bytes: 0
		};
		out[k$4] = {
			count: cur.count + v$4.count,
			bytes: cur.bytes + v$4.bytes
		};
	}
	return out;
}
async function getInfo(opts) {
	const mainSnapshot = getSnapshot();
	const mainSamples = sampleManager.getSampleMemoryInfo();
	let workletInfo = null;
	let recordInfo = null;
	if (opts?.worklet?.getMemoryInfo) workletInfo = await opts.worklet.getMemoryInfo();
	if (opts?.record?.getMemoryInfo) recordInfo = await opts.record.getMemoryInfo();
	const sabCat = mainSnapshot.byCategory.SharedArrayBuffer;
	let sabTotal = sabCat?.bytes ?? 0;
	let sabBySource = { ...sabCat?.bySource ?? {} };
	const abCat = mainSnapshot.byCategory.ArrayBuffer;
	let abTotal = abCat?.bytes ?? 0;
	let abBySource = { ...abCat?.bySource ?? {} };
	if (workletInfo) {
		const w$5 = workletInfo.snapshot.byCategory.SharedArrayBuffer;
		if (w$5) {
			sabTotal += w$5.bytes;
			sabBySource = mergeBySource(sabBySource, w$5.bySource);
		}
		const wa = workletInfo.snapshot.byCategory.ArrayBuffer;
		if (wa) {
			abTotal += wa.bytes;
			abBySource = mergeBySource(abBySource, wa.bySource);
		}
	}
	if (recordInfo) {
		const r$11 = recordInfo.snapshot.byCategory.SharedArrayBuffer;
		if (r$11) {
			sabTotal += r$11.bytes;
			sabBySource = mergeBySource(sabBySource, r$11.bySource);
		}
		const ra = recordInfo.snapshot.byCategory.ArrayBuffer;
		if (ra) {
			abTotal += ra.bytes;
			abBySource = mergeBySource(abBySource, ra.bySource);
		}
	}
	return {
		main: {
			snapshot: mainSnapshot,
			samples: mainSamples
		},
		worklet: workletInfo,
		record: recordInfo,
		sab: {
			totalBytes: sabTotal,
			bySource: sabBySource
		},
		arrayBuffer: {
			totalBytes: abTotal,
			bySource: abBySource
		},
		samples: mainSamples
	};
}
function reset$1() {
	reset();
}
const memoryDebug = {
	getInfo,
	reset: reset$1
};
function isMobile() {
	return /Mobi|Android|Tablet/i.test(navigator.userAgent);
}
function useReactiveEffect(fn$1, deps = []) {
	_$1(() => m(fn$1), deps);
}
function setFaviconSvg(svgText) {
	const href = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svgText) + "#" + Date.now();
	let link = document.querySelector("link[rel='icon']");
	if (!link) {
		link = document.createElement("link");
		link.rel = "icon";
		document.head.appendChild(link);
	}
	link.type = "image/svg+xml";
	link.href = href;
}
var signalified = /* @__PURE__ */ new WeakSet();
function signalify(value) {
	if (signalified.has(value)) return value;
	const descs = Object.getOwnPropertyDescriptors(value);
	const state = value;
	signalified.add(state);
	for (const [key, desc] of Object.entries(descs)) if (desc.get) {
		const s$4 = b(desc.get.bind(state));
		Object.defineProperty(state, key, {
			get: () => s$4.value,
			set: desc.set?.bind(state),
			configurable: false,
			enumerable: true
		});
	} else {
		const s$4 = c$3(desc.value);
		Object.defineProperty(state, key, {
			get: () => s$4.value,
			set: (value$1) => s$4.value = value$1,
			configurable: false,
			enumerable: true
		});
	}
	return state;
}
const settings = signalify({
	audioLatency: isMobile() ? .5 : .01,
	showVisuals: true,
	showKnobs: true,
	showDocs: true,
	wordWrap: true,
	analyserType: "waveform",
	debug: false
});
function debounce(ms, fn$1, options$2) {
	let resolving = false;
	let timeToResolve;
	let now;
	let delta;
	let callThis;
	let callArgs;
	function resolver() {
		now = performance.now();
		delta = timeToResolve - now;
		if (delta > 5) setTimeout(resolver, delta);
		else if (callArgs) {
			fn$1.apply(callThis, callArgs);
			resolving = false;
		}
	}
	function wrapper(...args) {
		callThis = this;
		callArgs = args;
		timeToResolve = performance.now() + ms;
		if (resolving) return;
		if (options$2?.first) {
			fn$1.apply(callThis, callArgs);
			if (!options$2.last) callArgs = void 0;
		}
		resolving = true;
		setTimeout(resolver, ms);
	}
	return wrapper;
}
function Deferred() {
	const _onwhen = () => {
		deferred.hasSettled = true;
		deferred.resolve = deferred.reject = noop;
	};
	const noop = () => {};
	let onwhen = _onwhen;
	const deferred = {
		hasSettled: false,
		when: (fn$1) => {
			onwhen = () => {
				_onwhen();
				fn$1();
			};
		}
	};
	deferred.promise = new Promise((resolve, reject) => {
		deferred.resolve = (arg) => {
			onwhen();
			deferred.value = arg;
			resolve(arg);
		};
		deferred.reject = (error$1) => {
			onwhen();
			deferred.error = error$1;
			reject(error$1);
		};
	});
	return deferred;
}
function hslToRgb([h$5, s$4, l$10]) {
	h$5 /= 360;
	let r$11, g$5, b$4;
	if (s$4 == 0) r$11 = g$5 = b$4 = l$10;
	else {
		const hue2rgb = function hue2rgb$1(p$7, q$6, t$12) {
			if (t$12 < 0) t$12 += 1;
			if (t$12 > 1) t$12 -= 1;
			if (t$12 < 1 / 6) return p$7 + (q$6 - p$7) * 6 * t$12;
			if (t$12 < 1 / 2) return q$6;
			if (t$12 < 2 / 3) return p$7 + (q$6 - p$7) * (2 / 3 - t$12) * 6;
			return p$7;
		};
		const q$5 = l$10 < .5 ? l$10 * (1 + s$4) : l$10 + s$4 - l$10 * s$4;
		const p$6 = 2 * l$10 - q$5;
		r$11 = hue2rgb(p$6, q$5, h$5 + 1 / 3);
		g$5 = hue2rgb(p$6, q$5, h$5);
		b$4 = hue2rgb(p$6, q$5, h$5 - 1 / 3);
	}
	return [
		r$11,
		g$5,
		b$4
	];
}
function rgbToHsl([r$11, g$5, b$4]) {
	const max = Math.max(r$11, g$5, b$4), min = Math.min(r$11, g$5, b$4);
	let h$5 = 0, s$4, l$10 = (max + min) / 2;
	if (max == min) h$5 = s$4 = 0;
	else {
		const d$5 = max - min;
		s$4 = l$10 > .5 ? d$5 / (2 - max - min) : d$5 / (max + min);
		switch (max) {
			case r$11:
				h$5 = (g$5 - b$4) / d$5;
				break;
			case g$5:
				h$5 = 2 + (b$4 - r$11) / d$5;
				break;
			case b$4:
				h$5 = 4 + (r$11 - g$5) / d$5;
				break;
		}
		h$5 *= 60;
		if (h$5 < 0) h$5 += 360;
	}
	return [
		h$5,
		s$4,
		l$10
	];
}
function luminate(c$7, a$36) {
	const hsl = rgbToHsl(hexToRgb(c$7));
	hsl[2] += a$36;
	hsl[2] = Math.max(0, Math.min(1, hsl[2]));
	return rgbToHex(hslToRgb(hsl));
}
function saturate(c$7, a$36) {
	const hsl = rgbToHsl(hexToRgb(c$7));
	hsl[1] += a$36;
	return rgbToHex(hslToRgb(hsl));
}
function hexToRgb(hex) {
	if (hex.length === 4) hex = hex.split("").map((x$4) => `${x$4}${x$4}`).join("");
	const [r$11, g$5, b$4] = hex.match(/[\da-f]{2}/gi).map((x$4) => Math.max(0, Math.min(1, parseInt(x$4, 16) / 255))).slice(0, 3);
	return [
		r$11,
		g$5,
		b$4
	];
}
function rgbToHex(rgb) {
	return `#${rgb.map((x$4) => Math.max(0, Math.min(255, Math.round(x$4 * 255))).toString(16).padStart(2, "0")).join("")}`;
}
var scriptRel = "modulepreload";
var assetsURL = function(dep) {
	return "/" + dep;
};
var seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
	let promise = Promise.resolve();
	if (deps && deps.length > 0) {
		const links = document.getElementsByTagName("link");
		const cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
		const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
		function allSettled(promises$2) {
			return Promise.all(promises$2.map((p$6) => Promise.resolve(p$6).then((value$1) => ({
				status: "fulfilled",
				value: value$1
			}), (reason) => ({
				status: "rejected",
				reason
			}))));
		}
		promise = allSettled(deps.map((dep) => {
			dep = assetsURL(dep, importerUrl);
			if (dep in seen) return;
			seen[dep] = true;
			const isCss = dep.endsWith(".css");
			const cssSelector = isCss ? "[rel=\"stylesheet\"]" : "";
			if (!!importerUrl) for (let i$1$1 = links.length - 1; i$1$1 >= 0; i$1$1--) {
				const link$1 = links[i$1$1];
				if (link$1.href === dep && (!isCss || link$1.rel === "stylesheet")) return;
			}
			else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) return;
			const link = document.createElement("link");
			link.rel = isCss ? "stylesheet" : scriptRel;
			if (!isCss) link.as = "script";
			link.crossOrigin = "";
			link.href = dep;
			if (cspNonce) link.setAttribute("nonce", cspNonce);
			document.head.appendChild(link);
			if (isCss) return new Promise((res, rej) => {
				link.addEventListener("load", res);
				link.addEventListener("error", () => rej(/* @__PURE__ */ new Error(`Unable to preload CSS for ${dep}`)));
			});
		}));
	}
	function handlePreloadError(err$2) {
		const e$1$1 = new Event("vite:preloadError", { cancelable: true });
		e$1$1.payload = err$2;
		window.dispatchEvent(e$1$1);
		if (!e$1$1.defaultPrevented) throw err$2;
	}
	return promise.then((res) => {
		for (const item of res || []) {
			if (item.status !== "rejected") continue;
			handlePreloadError(item.reason);
		}
		return baseModule().catch(handlePreloadError);
	});
};
var fft_default = (() => {
	return (async function(moduleArg = {}) {
		var moduleRtn;
		var Module$1 = moduleArg;
		var readyPromiseResolve, readyPromiseReject;
		var readyPromise = new Promise((resolve, reject) => {
			readyPromiseResolve = resolve;
			readyPromiseReject = reject;
		});
		var ENVIRONMENT_IS_WEB = typeof window == "object";
		var ENVIRONMENT_IS_WORKER = typeof WorkerGlobalScope != "undefined";
		var ENVIRONMENT_IS_NODE = typeof process == "object" && process.versions?.node && process.type != "renderer";
		if (ENVIRONMENT_IS_NODE) {
			const { createRequire } = await __vitePreload(async () => {
				const { createRequire: createRequire$1 } = await import("./__vite-browser-external-p9LbPB5k.js").then(__toDynamicImportESM(1));
				return { createRequire: createRequire$1 };
			}, []);
			var require$1 = createRequire(import.meta.url);
		}
		var _scriptName = import.meta.url;
		var scriptDirectory = "";
		function locateFile(path) {
			if (Module$1["locateFile"]) return Module$1["locateFile"](path, scriptDirectory);
			return scriptDirectory + path;
		}
		var readAsync, readBinary;
		if (ENVIRONMENT_IS_NODE) {
			var fs = require$1("fs");
			var nodePath = require$1("path");
			if (_scriptName.startsWith("file:")) scriptDirectory = nodePath.dirname(require$1("url").fileURLToPath(_scriptName)) + "/";
			readBinary = (filename) => {
				filename = isFileURI(filename) ? new URL(filename) : filename;
				return fs.readFileSync(filename);
			};
			readAsync = async (filename, binary = true) => {
				filename = isFileURI(filename) ? new URL(filename) : filename;
				return fs.readFileSync(filename, binary ? void 0 : "utf8");
			};
			if (process.argv.length > 1) process.argv[1].replace(/\\/g, "/");
			process.argv.slice(2);
		} else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
			try {
				scriptDirectory = new URL(".", _scriptName).href;
			} catch {}
			if (ENVIRONMENT_IS_WORKER) readBinary = (url) => {
				var xhr = new XMLHttpRequest();
				xhr.open("GET", url, false);
				xhr.responseType = "arraybuffer";
				xhr.send(null);
				return new Uint8Array(xhr.response);
			};
			readAsync = async (url) => {
				if (isFileURI(url)) return new Promise((resolve, reject) => {
					var xhr = new XMLHttpRequest();
					xhr.open("GET", url, true);
					xhr.responseType = "arraybuffer";
					xhr.onload = () => {
						if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
							resolve(xhr.response);
							return;
						}
						reject(xhr.status);
					};
					xhr.onerror = reject;
					xhr.send(null);
				});
				var response = await fetch(url, { credentials: "same-origin" });
				if (response.ok) return response.arrayBuffer();
				throw new Error(response.status + " : " + response.url);
			};
		}
		console.log.bind(console);
		var err = console.error.bind(console);
		var wasmBinary;
		var wasmMemory;
		var ABORT = false, HEAP8, HEAPU8, HEAPU32;
		var isFileURI = (filename) => filename.startsWith("file://");
		function updateMemoryViews() {
			var b$4 = wasmMemory.buffer;
			HEAP8 = new Int8Array(b$4);
			new Int16Array(b$4);
			HEAPU8 = new Uint8Array(b$4);
			new Uint16Array(b$4);
			new Int32Array(b$4);
			HEAPU32 = new Uint32Array(b$4);
			Module$1["HEAPF32"] = new Float32Array(b$4);
			new Float64Array(b$4);
			new BigInt64Array(b$4);
			new BigUint64Array(b$4);
		}
		function preRun() {
			if (Module$1["preRun"]) {
				if (typeof Module$1["preRun"] == "function") Module$1["preRun"] = [Module$1["preRun"]];
				while (Module$1["preRun"].length) addOnPreRun(Module$1["preRun"].shift());
			}
			callRuntimeCallbacks(onPreRuns);
		}
		function initRuntime() {
			wasmExports["e"]();
		}
		function postRun() {
			if (Module$1["postRun"]) {
				if (typeof Module$1["postRun"] == "function") Module$1["postRun"] = [Module$1["postRun"]];
				while (Module$1["postRun"].length) addOnPostRun(Module$1["postRun"].shift());
			}
			callRuntimeCallbacks(onPostRuns);
		}
		var runDependencies = 0;
		var dependenciesFulfilled = null;
		function addRunDependency(id) {
			runDependencies++;
			Module$1["monitorRunDependencies"]?.(runDependencies);
		}
		function removeRunDependency(id) {
			runDependencies--;
			Module$1["monitorRunDependencies"]?.(runDependencies);
			if (runDependencies == 0) {
				if (dependenciesFulfilled) {
					var callback = dependenciesFulfilled;
					dependenciesFulfilled = null;
					callback();
				}
			}
		}
		function abort(what) {
			Module$1["onAbort"]?.(what);
			what = "Aborted(" + what + ")";
			err(what);
			ABORT = true;
			what += ". Build with -sASSERTIONS for more info.";
			var e$59 = new WebAssembly.RuntimeError(what);
			readyPromiseReject(e$59);
			throw e$59;
		}
		var wasmBinaryFile;
		function findWasmBinary() {
			if (Module$1["locateFile"]) return locateFile("fft.wasm");
			return new URL("/assets/fft-fQZn6_ZU.wasm", "" + import.meta.url).href;
		}
		function getBinarySync(file) {
			if (file == wasmBinaryFile && wasmBinary) return new Uint8Array(wasmBinary);
			if (readBinary) return readBinary(file);
			throw "both async and sync fetching of the wasm failed";
		}
		async function getWasmBinary(binaryFile) {
			if (!wasmBinary) try {
				var response = await readAsync(binaryFile);
				return new Uint8Array(response);
			} catch {}
			return getBinarySync(binaryFile);
		}
		async function instantiateArrayBuffer(binaryFile, imports) {
			try {
				var binary = await getWasmBinary(binaryFile);
				return await WebAssembly.instantiate(binary, imports);
			} catch (reason) {
				err(`failed to asynchronously prepare wasm: ${reason}`);
				abort(reason);
			}
		}
		async function instantiateAsync(binary, binaryFile, imports) {
			if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isFileURI(binaryFile) && !ENVIRONMENT_IS_NODE) try {
				var response = fetch(binaryFile, { credentials: "same-origin" });
				return await WebAssembly.instantiateStreaming(response, imports);
			} catch (reason) {
				err(`wasm streaming compile failed: ${reason}`);
				err("falling back to ArrayBuffer instantiation");
			}
			return instantiateArrayBuffer(binaryFile, imports);
		}
		function getWasmImports() {
			return { a: wasmImports };
		}
		async function createWasm() {
			function receiveInstance(instance, module$1) {
				wasmExports = instance.exports;
				wasmMemory = wasmExports["d"];
				updateMemoryViews();
				removeRunDependency("wasm-instantiate");
				return wasmExports;
			}
			addRunDependency("wasm-instantiate");
			function receiveInstantiationResult(result) {
				return receiveInstance(result["instance"]);
			}
			var info = getWasmImports();
			if (Module$1["instantiateWasm"]) return new Promise((resolve, reject) => {
				Module$1["instantiateWasm"](info, (mod, inst) => {
					resolve(receiveInstance(mod, inst));
				});
			});
			wasmBinaryFile ??= findWasmBinary();
			try {
				return receiveInstantiationResult(await instantiateAsync(wasmBinary, wasmBinaryFile, info));
			} catch (e$59) {
				readyPromiseReject(e$59);
				return Promise.reject(e$59);
			}
		}
		var callRuntimeCallbacks = (callbacks) => {
			while (callbacks.length > 0) callbacks.shift()(Module$1);
		};
		var onPostRuns = [];
		var addOnPostRun = (cb) => onPostRuns.push(cb);
		var onPreRuns = [];
		var addOnPreRun = (cb) => onPreRuns.push(cb);
		class ExceptionInfo {
			constructor(excPtr) {
				this.excPtr = excPtr;
				this.ptr = excPtr - 24;
			}
			set_type(type) {
				HEAPU32[this.ptr + 4 >> 2] = type;
			}
			get_type() {
				return HEAPU32[this.ptr + 4 >> 2];
			}
			set_destructor(destructor) {
				HEAPU32[this.ptr + 8 >> 2] = destructor;
			}
			get_destructor() {
				return HEAPU32[this.ptr + 8 >> 2];
			}
			set_caught(caught) {
				caught = caught ? 1 : 0;
				HEAP8[this.ptr + 12] = caught;
			}
			get_caught() {
				return HEAP8[this.ptr + 12] != 0;
			}
			set_rethrown(rethrown) {
				rethrown = rethrown ? 1 : 0;
				HEAP8[this.ptr + 13] = rethrown;
			}
			get_rethrown() {
				return HEAP8[this.ptr + 13] != 0;
			}
			init(type, destructor) {
				this.set_adjusted_ptr(0);
				this.set_type(type);
				this.set_destructor(destructor);
			}
			set_adjusted_ptr(adjustedPtr) {
				HEAPU32[this.ptr + 16 >> 2] = adjustedPtr;
			}
			get_adjusted_ptr() {
				return HEAPU32[this.ptr + 16 >> 2];
			}
		}
		var exceptionLast = 0;
		var uncaughtExceptionCount = 0;
		var ___cxa_throw = (ptr, type, destructor) => {
			new ExceptionInfo(ptr).init(type, destructor);
			exceptionLast = ptr;
			uncaughtExceptionCount++;
			throw exceptionLast;
		};
		var __abort_js = () => abort("");
		var abortOnCannotGrowMemory = (requestedSize) => {
			abort("OOM");
		};
		var _emscripten_resize_heap = (requestedSize) => {
			HEAPU8.length;
			requestedSize >>>= 0;
			abortOnCannotGrowMemory(requestedSize);
		};
		if (Module$1["noExitRuntime"]) Module$1["noExitRuntime"];
		if (Module$1["print"]) Module$1["print"];
		if (Module$1["printErr"]) err = Module$1["printErr"];
		if (Module$1["wasmBinary"]) wasmBinary = Module$1["wasmBinary"];
		if (Module$1["arguments"]) Module$1["arguments"];
		if (Module$1["thisProgram"]) Module$1["thisProgram"];
		var wasmImports = {
			a: ___cxa_throw,
			b: __abort_js,
			c: _emscripten_resize_heap
		};
		var wasmExports = await createWasm();
		wasmExports["e"];
		Module$1["_initFFT"] = wasmExports["f"];
		Module$1["_free"] = wasmExports["g"];
		Module$1["_malloc"] = wasmExports["h"];
		Module$1["_fft"] = wasmExports["i"];
		Module$1["_ifft"] = wasmExports["j"];
		Module$1["_initCQT"] = wasmExports["k"];
		Module$1["_cqt"] = wasmExports["l"];
		Module$1["_freeFFT"] = wasmExports["m"];
		Module$1["_freeCQT"] = wasmExports["n"];
		function run() {
			if (runDependencies > 0) {
				dependenciesFulfilled = run;
				return;
			}
			preRun();
			if (runDependencies > 0) {
				dependenciesFulfilled = run;
				return;
			}
			function doRun() {
				Module$1["calledRun"] = true;
				if (ABORT) return;
				initRuntime();
				readyPromiseResolve(Module$1);
				Module$1["onRuntimeInitialized"]?.();
				postRun();
			}
			if (Module$1["setStatus"]) {
				Module$1["setStatus"]("Running...");
				setTimeout(() => {
					setTimeout(() => Module$1["setStatus"](""), 1);
					doRun();
				}, 1);
			} else doRun();
		}
		function preInit() {
			if (Module$1["preInit"]) {
				if (typeof Module$1["preInit"] == "function") Module$1["preInit"] = [Module$1["preInit"]];
				while (Module$1["preInit"].length > 0) Module$1["preInit"].shift()();
			}
		}
		preInit();
		run();
		moduleRtn = readyPromise;
		return moduleRtn;
	});
})();
var WaveFFT = class WaveFFT {
	static isValidSize(size) {
		return Number.isInteger(size) && size > 0 && (size & size - 1) === 0;
	}
	constructor(size) {
		this.size = size;
		this.module = null;
		this.realPtr = null;
		this.imagPtr = null;
		this.cqtOutputRealPtr = null;
		this.cqtOutputImagPtr = null;
		this.memoryGeneration = 0;
		this._initialized = false;
		this._cqtInitialized = false;
	}
	async init() {
		if (!Number.isInteger(this.size) || this.size <= 0) throw new Error("FFT size must be a positive integer");
		if (!WaveFFT.isValidSize(this.size)) throw new Error("FFT size must be a power of two");
		this.module = await fft_default();
		this.HEAPF32 = this.module.HEAPF32;
		if (!this.module._initFFT(this.size)) throw new Error("Failed to initialize FFT");
		this._allocateBuffers();
		this._initialized = true;
	}
	_allocateBuffers() {
		this._freeBuffers();
		this.realPtr = this.module._malloc(this.size * 4);
		this.imagPtr = this.module._malloc(this.size * 4);
		if (!this.realPtr || !this.imagPtr) {
			this._freeBuffers();
			throw new Error("Memory allocation failed");
		}
		this._updateArrayViews();
	}
	_freeBuffers() {
		if (this.realPtr) {
			this.module._free(this.realPtr);
			this.realPtr = null;
		}
		if (this.imagPtr) {
			this.module._free(this.imagPtr);
			this.imagPtr = null;
		}
	}
	_updateArrayViews() {
		this.memoryGeneration = this.module.HEAPF32.buffer.byteLength;
		this.real = new Float32Array(this.module.HEAPF32.buffer, this.realPtr, this.size);
		this.imag = new Float32Array(this.module.HEAPF32.buffer, this.imagPtr, this.size);
		if (this.cqtOutputRealPtr && this._cqtInitialized) {
			this.cqtOutputReal = new Float32Array(this.module.HEAPF32.buffer, this.cqtOutputRealPtr, this.cqtTotalBins);
			this.cqtOutputImag = new Float32Array(this.module.HEAPF32.buffer, this.cqtOutputImagPtr, this.cqtTotalBins);
		}
	}
	_checkMemoryResize() {
		const currentBuffer = this.module.HEAPF32.buffer;
		if (currentBuffer.byteLength !== this.memoryGeneration) if (currentBuffer === this.module.HEAPF32.buffer) this._updateArrayViews();
		else this._checkMemoryResize();
	}
	async resize(newSize) {
		if (!this._initialized) throw new Error("FFT not initialized");
		if (!Number.isInteger(newSize) || newSize <= 0) throw new Error("FFT size must be a positive integer");
		if (!WaveFFT.isValidSize(newSize)) throw new Error("FFT size must be a power of two");
		if (newSize === this.size) return;
		let cqtParams = null;
		if (this._cqtInitialized) cqtParams = {
			binsPerOctave: this.cqtBinsPerOctave,
			octaves: this.cqtOctaves,
			sampleRate: this.cqtSampleRate,
			minFreq: this.cqtMinFreq
		};
		this.size = newSize;
		if (!this.module._initFFT(this.size)) throw new Error("Failed to resize FFT");
		this._allocateBuffers();
		if (cqtParams) await this.initCQT(cqtParams.binsPerOctave, cqtParams.octaves, cqtParams.sampleRate, cqtParams.minFreq);
	}
	fft(inputReal, output = null) {
		if (!this.module || !this._initialized) throw new Error("Module not initialized");
		if (!inputReal || inputReal.length !== this.size) throw new Error("Input array must match FFT size");
		this._checkMemoryResize();
		this.real.set(inputReal);
		this.imag.fill(0);
		if (!this.module._fft(this.realPtr, this.imagPtr, this.size)) throw new Error("FFT computation failed");
		if (output) {
			output.real.set(this.real);
			output.imag.set(this.imag);
			return output;
		}
		return {
			real: new Float32Array(this.real),
			imag: new Float32Array(this.imag)
		};
	}
	fftComplex(inputReal, inputImag, output = null) {
		if (!this.module || !this._initialized) throw new Error("Module not initialized");
		if (!inputReal || !inputImag || inputReal.length !== this.size || inputImag.length !== this.size) throw new Error("Input arrays must match FFT size");
		this._checkMemoryResize();
		this.real.set(inputReal);
		this.imag.set(inputImag);
		if (!this.module._fft(this.realPtr, this.imagPtr, this.size)) throw new Error("FFT computation failed");
		if (output) {
			output.real.set(this.real);
			output.imag.set(this.imag);
			return output;
		}
		return {
			real: new Float32Array(this.real),
			imag: new Float32Array(this.imag)
		};
	}
	ifft(inputReal, inputImag, output = null) {
		if (!this.module || !this._initialized) throw new Error("Module not initialized");
		if (!inputReal || !inputImag || inputReal.length !== this.size || inputImag.length !== this.size) throw new Error("Input arrays must match FFT size");
		this._checkMemoryResize();
		this.real.set(inputReal);
		this.imag.set(inputImag);
		if (!this.module._ifft(this.realPtr, this.imagPtr, this.size)) throw new Error("IFFT computation failed");
		if (output) {
			output.real.set(this.real);
			output.imag.set(this.imag);
			return output;
		}
		return {
			real: new Float32Array(this.real),
			imag: new Float32Array(this.imag)
		};
	}
	getMagnitudeSpectrum(fftResult) {
		if (!fftResult || !fftResult.real || !fftResult.imag) throw new Error("Invalid FFT result object");
		const magnitude = new Float32Array(Math.floor(this.size / 2) + 1);
		for (let i$6 = 0; i$6 < magnitude.length; i$6++) {
			const re = fftResult.real[i$6];
			const im = fftResult.imag[i$6];
			magnitude[i$6] = Math.sqrt(re * re + im * im);
		}
		return magnitude;
	}
	async initCQT(binsPerOctave, octaves, sampleRate, minFreq) {
		if (!this.module || !this._initialized) throw new Error("Module not initialized");
		if (!Number.isInteger(binsPerOctave) || !Number.isInteger(octaves) || binsPerOctave <= 0 || octaves <= 0 || sampleRate <= 0 || minFreq <= 0) throw new Error("Invalid CQT parameters");
		this.cqtBinsPerOctave = binsPerOctave;
		this.cqtOctaves = octaves;
		this.cqtSampleRate = sampleRate;
		this.cqtMinFreq = minFreq;
		this.cqtTotalBins = binsPerOctave * octaves;
		if (!this.module._initCQT(binsPerOctave, octaves, this.size, sampleRate, minFreq)) throw new Error("Failed to initialize CQT");
		if (this.cqtOutputRealPtr) this.module._free(this.cqtOutputRealPtr);
		if (this.cqtOutputImagPtr) this.module._free(this.cqtOutputImagPtr);
		this.cqtOutputRealPtr = this.module._malloc(this.cqtTotalBins * 4);
		this.cqtOutputImagPtr = this.module._malloc(this.cqtTotalBins * 4);
		if (!this.cqtOutputRealPtr || !this.cqtOutputImagPtr) {
			if (this.cqtOutputRealPtr) this.module._free(this.cqtOutputRealPtr);
			if (this.cqtOutputImagPtr) this.module._free(this.cqtOutputImagPtr);
			this.cqtOutputRealPtr = null;
			this.cqtOutputImagPtr = null;
			this._cqtInitialized = false;
			throw new Error("Memory allocation failed in initCQT");
		}
		this._cqtInitialized = true;
		this._updateArrayViews();
	}
	cqt(inputReal, output = null) {
		if (!this.module || !this._initialized || !this._cqtInitialized) throw new Error("CQT not initialized");
		if (!inputReal || inputReal.length !== this.size) throw new Error("Input array must match FFT size");
		this._checkMemoryResize();
		this.real.set(inputReal);
		this.imag.fill(0);
		if (!this.module._fft(this.realPtr, this.imagPtr, this.size)) throw new Error("FFT computation failed");
		if (!this.module._cqt(this.realPtr, this.imagPtr, this.cqtOutputRealPtr, this.cqtOutputImagPtr, this.size, this.cqtBinsPerOctave, this.cqtOctaves)) throw new Error("CQT computation failed");
		if (output) {
			output.real.set(this.cqtOutputReal);
			output.imag.set(this.cqtOutputImag);
			return output;
		}
		return {
			real: new Float32Array(this.cqtOutputReal),
			imag: new Float32Array(this.cqtOutputImag)
		};
	}
	static hann(N$3) {
		const w$5 = new Float32Array(N$3);
		for (let i$6 = 0; i$6 < N$3; i$6++) w$5[i$6] = .5 * (1 - Math.cos(2 * Math.PI * i$6 / (N$3 - 1)));
		return w$5;
	}
	static hamming(N$3) {
		const w$5 = new Float32Array(N$3);
		for (let i$6 = 0; i$6 < N$3; i$6++) w$5[i$6] = .54 - .46 * Math.cos(2 * Math.PI * i$6 / (N$3 - 1));
		return w$5;
	}
	static blackman(N$3) {
		const w$5 = new Float32Array(N$3);
		for (let i$6 = 0; i$6 < N$3; i$6++) w$5[i$6] = .42 - .5 * Math.cos(2 * Math.PI * i$6 / (N$3 - 1)) + .08 * Math.cos(4 * Math.PI * i$6 / (N$3 - 1));
		return w$5;
	}
	stft(samples, { fftSize: fftSize$1 = this.size, hopSize = Math.floor(fftSize$1 / 2), window: window$1 = null } = {}) {
		if (!this.module || !this._initialized) throw new Error("Module not initialized");
		if (fftSize$1 !== this.size) throw new Error(`FFT size mismatch. Expected ${this.size}, got ${fftSize$1}`);
		if (!samples || samples.length === 0) throw new Error("Input samples array is empty");
		if (hopSize <= 0) throw new Error("Hop size must be positive");
		const wnd = window$1 || WaveFFT.hann(fftSize$1);
		const length = samples.length;
		let totalFrames = Math.floor((length - fftSize$1) / hopSize) + 1;
		if (totalFrames < 1) totalFrames = 1;
		const freqBins = Math.floor(fftSize$1 / 2) + 1;
		const magnitudes = new Array(totalFrames);
		const complex = new Array(totalFrames);
		let maxMagnitude = 0;
		for (let frameIdx = 0, sampleOffset = 0; frameIdx < totalFrames; frameIdx++, sampleOffset += hopSize) {
			this.real.fill(0);
			this.imag.fill(0);
			const frameLength = Math.min(fftSize$1, length - sampleOffset);
			for (let i$6 = 0; i$6 < frameLength; i$6++) this.real[i$6] = samples[sampleOffset + i$6] * wnd[i$6];
			if (!this.module._fft(this.realPtr, this.imagPtr, this.size)) throw new Error("FFT computation failed");
			const frameComplex = new Float32Array(fftSize$1 * 2);
			for (let i$6 = 0; i$6 < fftSize$1; i$6++) {
				frameComplex[i$6 * 2] = this.real[i$6];
				frameComplex[i$6 * 2 + 1] = this.imag[i$6];
			}
			complex[frameIdx] = frameComplex;
			const frameMagnitudes = new Float32Array(freqBins);
			for (let bin = 0; bin < freqBins; bin++) {
				const re = this.real[bin];
				const im = this.imag[bin];
				const mag = Math.sqrt(re * re + im * im);
				if (mag > maxMagnitude) maxMagnitude = mag;
				frameMagnitudes[bin] = mag;
			}
			magnitudes[frameIdx] = frameMagnitudes;
		}
		return {
			magnitudes,
			complex,
			fftSize: fftSize$1,
			hopSize,
			freqBins,
			timeBins: totalFrames,
			maxMagnitude,
			sampleRate: null
		};
	}
	istft(complexFrames, { fftSize: fftSize$1 = this.size, hopSize = Math.floor(fftSize$1 / 2), window: window$1 = null } = {}) {
		if (!this.module || !this._initialized) throw new Error("Module not initialized");
		if (fftSize$1 !== this.size) throw new Error(`FFT size mismatch. Expected ${this.size}, got ${fftSize$1}`);
		const wnd = window$1 || WaveFFT.hann(fftSize$1);
		const frameCount = complexFrames.length;
		const outputLength = (frameCount - 1) * hopSize + fftSize$1;
		const output = new Float32Array(outputLength);
		const windowSum = new Float32Array(outputLength);
		for (let frameIdx = 0; frameIdx < frameCount; frameIdx++) {
			const frameComplex = complexFrames[frameIdx];
			for (let i$6 = 0; i$6 < fftSize$1; i$6++) {
				this.real[i$6] = frameComplex[i$6 * 2];
				this.imag[i$6] = frameComplex[i$6 * 2 + 1];
			}
			if (!this.module._ifft(this.realPtr, this.imagPtr, this.size)) throw new Error("IFFT computation failed");
			const offset = frameIdx * hopSize;
			for (let i$6 = 0; i$6 < fftSize$1; i$6++) {
				output[offset + i$6] += this.real[i$6] * wnd[i$6];
				windowSum[offset + i$6] += wnd[i$6] * wnd[i$6];
			}
		}
		for (let i$6 = 0; i$6 < outputLength; i$6++) if (windowSum[i$6] > 1e-9) output[i$6] /= windowSum[i$6];
		return output;
	}
	dispose() {
		if (this.module) {
			this._freeBuffers();
			if (this.cqtOutputRealPtr) this.module._free(this.cqtOutputRealPtr);
			if (this.cqtOutputImagPtr) this.module._free(this.cqtOutputImagPtr);
			this.module._freeFFT();
			this.module._freeCQT();
			this.module = null;
			this.realPtr = this.imagPtr = this.cqtOutputRealPtr = this.cqtOutputImagPtr = null;
			this.real = this.imag = this.cqtOutputReal = this.cqtOutputImag = null;
			this._initialized = false;
			this._cqtInitialized = false;
		}
	}
};
var codeDollar = 36;
var codeHash = 35;
var codeUnderscore = 95;
var codeBackslash = 92;
var codeLf = 10;
var codeCr = 13;
var codeTab = 9;
var codeVt = 11;
var codeFf = 12;
var codeSpace = 32;
var codeSlash = 47;
var codeStar = 42;
var codeSingleQuote = 39;
var codeDoubleQuote = 34;
var codeBacktick = 96;
var codeDot = 46;
var codeLParen = 40;
var codePlus = 43;
var codeMinus = 45;
var codeLowerE = 101;
var codeUpperE = 69;
var codeLowerK = 107;
var keywords = new Set([
	"let",
	"const",
	"var",
	"if",
	"else",
	"for",
	"while",
	"do",
	"switch",
	"case",
	"break",
	"continue",
	"return",
	"function",
	"async",
	"await",
	"class",
	"extends",
	"import",
	"export",
	"from",
	"default",
	"try",
	"catch",
	"finally",
	"throw",
	"new",
	"this",
	"super",
	"typeof",
	"instanceof",
	"in",
	"of",
	"with",
	"void",
	"true",
	"false",
	"null",
	"undefined",
	"NaN",
	"Infinity",
	"type",
	"interface",
	"enum",
	"namespace",
	"declare",
	"as",
	"is",
	"satisfies",
	"keyof",
	"readonly",
	"abstract",
	"implements",
	"private",
	"protected",
	"public",
	"static",
	"override",
	"module",
	"global"
]);
var operators = new Set([
	"|>",
	"->",
	"->>",
	"-->",
	"<-",
	"<<-",
	"<-->",
	"=>",
	"==>",
	"<=>",
	"<=",
	">=",
	"<|",
	"<~",
	"~>",
	"<~>",
	"~~>",
	"<->",
	"==",
	"===",
	"!=",
	"!==",
	"<>",
	"<+",
	"+=",
	"-=",
	"*=",
	"/=",
	"**",
	"**=",
	"++",
	"--",
	"-+",
	"+-",
	"&&",
	"||",
	"!!",
	"&=",
	"|=",
	"^=",
	"~=",
	"=",
	"::",
	":::",
	"|->",
	"|",
	"...",
	"..<",
	"..<.",
	"!!!",
	"~~~",
	"<*>",
	"<$>",
	"<$!>",
	"+++",
	"^^",
	"+",
	"-",
	"*",
	"/",
	"%",
	"&",
	"|",
	"^",
	"~",
	"!",
	"<",
	">",
	"?",
	":"
]);
var operatorsByFirstChar = /* @__PURE__ */ new Map();
for (const op of operators) {
	const first = op.charCodeAt(0);
	const list = operatorsByFirstChar.get(first);
	if (list) list.push(op);
	else operatorsByFirstChar.set(first, [op]);
}
for (const [first, list] of operatorsByFirstChar) {
	list.sort((a$36, b$4) => b$4.length - a$36.length);
	operatorsByFirstChar.set(first, list);
}
function isWhitespaceCode(code) {
	return code === codeSpace || code === codeTab || code === codeLf || code === codeCr || code === codeVt || code === codeFf;
}
function isDigitCode(code) {
	return code >= 48 && code <= 57;
}
function isLetterCode(code) {
	return code >= 65 && code <= 90 || code >= 97 && code <= 122 || code === codeUnderscore;
}
function isIdentifierCode(code) {
	return isLetterCode(code) || isDigitCode(code) || code === codeDollar || code === codeHash;
}
function isPunctuationCode(code) {
	switch (code) {
		case 40:
		case 41:
		case 91:
		case 93:
		case 123:
		case 125:
		case 46:
		case 44:
		case 59:
		case 58: return true;
		default: return false;
	}
}
const tokenize = (input) => {
	const lines = [];
	let currentLine = [];
	let i$6 = 0;
	const n$4 = input.length;
	let lineNum = 1;
	let column = 1;
	while (i$6 < n$4) {
		const code = input.charCodeAt(i$6);
		const startLine = lineNum;
		const startColumn = column;
		if (code === codeDollar) {
			currentLine.push({
				text: "$",
				type: "special",
				line: startLine,
				column: startColumn
			});
			i$6++;
			column++;
			continue;
		}
		if (isWhitespaceCode(code)) {
			let segStart = i$6;
			let segLine = lineNum;
			let segColumn = column;
			while (i$6 < n$4 && isWhitespaceCode(input.charCodeAt(i$6))) if (input.charCodeAt(i$6) === codeLf) {
				if (segStart < i$6) currentLine.push({
					text: input.slice(segStart, i$6),
					type: "text",
					line: segLine,
					column: segColumn
				});
				lines.push(currentLine);
				currentLine = [];
				i$6++;
				lineNum++;
				column = 1;
				segStart = i$6;
				segLine = lineNum;
				segColumn = column;
			} else {
				i$6++;
				column++;
			}
			if (segStart < i$6) currentLine.push({
				text: input.slice(segStart, i$6),
				type: "text",
				line: segLine,
				column: segColumn
			});
			continue;
		}
		if (code === codeSlash && input.charCodeAt(i$6 + 1) === codeSlash) {
			const start = i$6;
			const end = input.indexOf("\n", i$6 + 2);
			i$6 = end === -1 ? n$4 : end;
			column += i$6 - start;
			currentLine.push({
				text: input.slice(start, i$6),
				type: "comment",
				line: startLine,
				column: startColumn
			});
			continue;
		}
		if (code === codeSlash && input.charCodeAt(i$6 + 1) === codeStar) {
			let segStart = i$6;
			i$6 += 2;
			column += 2;
			while (i$6 < n$4) {
				const c$7 = input.charCodeAt(i$6);
				if (c$7 === codeLf) {
					currentLine.push({
						text: input.slice(segStart, i$6 + 1),
						type: "comment",
						line: startLine,
						column: startColumn
					});
					lines.push(currentLine);
					currentLine = [];
					i$6++;
					lineNum++;
					column = 1;
					segStart = i$6;
					continue;
				}
				if (c$7 === codeStar && input.charCodeAt(i$6 + 1) === codeSlash) {
					i$6 += 2;
					column += 2;
					currentLine.push({
						text: input.slice(segStart, i$6),
						type: "comment",
						line: startLine,
						column: startColumn
					});
					segStart = i$6;
					break;
				}
				i$6++;
				column++;
			}
			if (segStart < i$6) currentLine.push({
				text: input.slice(segStart, i$6),
				type: "comment",
				line: startLine,
				column: startColumn
			});
			continue;
		}
		if (code === codeBacktick || code === codeSingleQuote || code === codeDoubleQuote) {
			const quote = code;
			let segStart = i$6;
			i$6++;
			column++;
			let escaped = false;
			while (i$6 < n$4) {
				const c$7 = input.charCodeAt(i$6);
				if (escaped) {
					escaped = false;
					i$6++;
					column++;
				} else if (c$7 === codeBackslash) {
					escaped = true;
					i$6++;
					column++;
				} else if (c$7 === codeLf) {
					currentLine.push({
						text: input.slice(segStart, i$6 + 1),
						type: "string",
						line: startLine,
						column: startColumn
					});
					lines.push(currentLine);
					currentLine = [];
					i$6++;
					lineNum++;
					column = 1;
					segStart = i$6;
				} else {
					i$6++;
					column++;
					if (c$7 === quote) {
						currentLine.push({
							text: input.slice(segStart, i$6),
							type: "string",
							line: startLine,
							column: startColumn
						});
						segStart = i$6;
						break;
					}
				}
			}
			if (segStart < i$6) currentLine.push({
				text: input.slice(segStart, i$6),
				type: "string",
				line: startLine,
				column: startColumn
			});
			continue;
		}
		if (isDigitCode(code) || code === codeDot && isDigitCode(input.charCodeAt(i$6 + 1))) {
			const start = i$6;
			if (code === codeDot) {
				i$6++;
				while (i$6 < n$4 && isDigitCode(input.charCodeAt(i$6))) i$6++;
			} else {
				while (i$6 < n$4 && isDigitCode(input.charCodeAt(i$6))) i$6++;
				if (input.charCodeAt(i$6) === codeDot && isDigitCode(input.charCodeAt(i$6 + 1))) {
					i$6++;
					while (i$6 < n$4 && isDigitCode(input.charCodeAt(i$6))) i$6++;
				}
			}
			const e$59 = input.charCodeAt(i$6);
			if (e$59 === codeLowerE || e$59 === codeUpperE) {
				i$6++;
				const sign = input.charCodeAt(i$6);
				if (sign === codePlus || sign === codeMinus) i$6++;
				while (i$6 < n$4 && isDigitCode(input.charCodeAt(i$6))) i$6++;
			}
			if (input.charCodeAt(i$6) === codeLowerK) i$6++;
			currentLine.push({
				text: input.slice(start, i$6),
				type: "number",
				line: startLine,
				column: startColumn
			});
			column += i$6 - start;
			continue;
		}
		const ops = operatorsByFirstChar.get(code);
		if (ops) {
			let matched = false;
			for (const op of ops) if (input.startsWith(op, i$6)) {
				currentLine.push({
					text: op,
					type: "operator",
					line: startLine,
					column: startColumn
				});
				i$6 += op.length;
				column += op.length;
				matched = true;
				break;
			}
			if (matched) continue;
		}
		if (isPunctuationCode(code)) {
			currentLine.push({
				text: input[i$6],
				type: "punctuation",
				line: startLine,
				column: startColumn
			});
			i$6++;
			column++;
			continue;
		}
		if (isLetterCode(code) || code === codeHash) {
			const start = i$6;
			i$6++;
			while (i$6 < n$4 && isIdentifierCode(input.charCodeAt(i$6))) i$6++;
			const identifier = input.slice(start, i$6);
			column += i$6 - start;
			let type = "identifier";
			if (keywords.has(identifier)) type = "keyword";
			else if (identifier === "true" || identifier === "false") type = "boolean";
			else if (identifier === "null" || identifier === "undefined") type = "null";
			else if (i$6 < n$4 && input.charCodeAt(i$6) === codeLParen) type = "function";
			currentLine.push({
				text: identifier,
				type,
				line: startLine,
				column: startColumn
			});
			continue;
		}
		currentLine.push({
			text: input[i$6],
			type: "text",
			line: startLine,
			column: startColumn
		});
		i$6++;
		column++;
	}
	lines.push(currentLine);
	return lines;
};
const projectsLoading = c$3(false);
var profileImageCache = /* @__PURE__ */ new Map();
var API = class {
	constructor(fetch$1) {
		this.fetch = fetch$1;
	}
	async requestJson(url, init) {
		const res = await this.fetch(url, init);
		const json = await res.json().catch(() => null);
		if (!res.ok) {
			const message = json && typeof json === "object" && typeof json.message === "string" ? json.message : `Request failed: ${res.status}`;
			throw new Error(message);
		}
		return json;
	}
	fetchSession = async () => {
		const res = await this.fetch("/api/session");
		const json = await res.json();
		if (res.status === 401) return null;
		if (!res.ok) throw new Error("Failed to fetch session: " + json.message);
		return json;
	};
	fetchProjects = async () => {
		if (projects.value.length === 0) projectsLoading.value = true;
		try {
			return await this.requestJson("/api/projects");
		} finally {
			projectsLoading.value = false;
		}
	};
	fetchUserProjects = async (userId) => {
		return await this.requestJson(`/api/user-projects/${userId}`);
	};
	fetchProject = async (id) => {
		return await this.requestJson(`/api/projects/${id}`);
	};
	fetchBrowseNewest = async () => {
		return await this.requestJson("/api/browse/newest");
	};
	fetchBrowsePopular = async () => {
		return await this.requestJson("/api/browse/popular");
	};
	fetchBrowseHottest = async () => {
		return await this.requestJson("/api/browse/hottest");
	};
	fetchBrowseLiked = async () => {
		return await this.requestJson("/api/browse/liked");
	};
	fetchBrowseOneLiners = async () => {
		return await this.requestJson("/api/browse/one-liners");
	};
	postBrowseOneLiner = async (code) => {
		return await this.requestJson("/api/browse/one-liners", {
			method: "POST",
			headers: { "content-type": "application/json" },
			body: JSON.stringify({ code })
		});
	};
	deleteBrowseOneLiner = async (oneLiner) => {
		return await this.requestJson("/api/browse/one-liners", {
			method: "DELETE",
			headers: { "content-type": "application/json" },
			body: JSON.stringify(oneLiner)
		});
	};
	generateAITrack = async (prompt, temperature, topP, model) => {
		return await this.requestJson("/api/ai/generate-track", {
			method: "POST",
			headers: { "content-type": "application/json" },
			body: JSON.stringify({
				prompt,
				temperature,
				topP,
				model
			})
		});
	};
	fetchAdminUsers = async () => {
		return await this.requestJson("/api/admin/users");
	};
	sendWelcomeEmail = async (userId) => {
		return await this.requestJson("/api/admin/send-welcome-email", {
			method: "POST",
			headers: { "content-type": "application/json" },
			body: JSON.stringify({ userId })
		});
	};
	sendBetaEmail = async (userId) => {
		return await this.requestJson("/api/admin/send-beta-email", {
			method: "POST",
			headers: { "content-type": "application/json" },
			body: JSON.stringify({ userId })
		});
	};
	deleteUser = async (userId) => {
		return await this.requestJson(`/api/admin/users/${userId}`, { method: "DELETE" });
	};
	fetchAdminProjects = async () => {
		return await this.requestJson("/api/admin/projects");
	};
	reindexPublicProjects = async () => {
		return await this.requestJson("/api/admin/reindex-public-projects", { method: "POST" });
	};
	resetMigrations = async () => {
		return await this.requestJson("/api/admin/reset-migrations", { method: "POST" });
	};
	removeAllUsers = async () => {
		return await this.requestJson("/api/admin/remove-all-users", { method: "POST" });
	};
	uploadUsersFromV1 = async (users, profileImages) => {
		return await this.requestJson("/api/admin/upload-users-v1", {
			method: "POST",
			headers: { "content-type": "application/json" },
			body: JSON.stringify({
				users,
				profileImages
			})
		});
	};
	fetchAdminPublicProjects = async () => {
		return await this.requestJson("/api/admin/public-projects");
	};
	restoreBackup = async (file) => {
		const formData = new FormData();
		formData.append("file", file);
		return await this.requestJson("/api/admin/restore-backup", {
			method: "POST",
			body: formData
		});
	};
	createProject = async (project) => {
		projectsLoading.value = true;
		try {
			return await this.requestJson("/api/projects", {
				method: "POST",
				headers: { "content-type": "application/json" },
				body: JSON.stringify({
					name: project.name,
					code: project.scratch.code,
					isPublic: project.isPublic,
					remixOfId: project.remixOfId
				})
			});
		} finally {
			projectsLoading.value = false;
		}
	};
	saveProject = async (project) => {
		if (!project.serverId) return await this.createProject(project);
		projectsLoading.value = true;
		try {
			return await this.requestJson(`/api/projects/${project.serverId}`, {
				method: "PUT",
				headers: { "content-type": "application/json" },
				body: JSON.stringify({
					name: project.name,
					code: project.scratch.code,
					isPublic: project.isPublic,
					remixOfId: project.remixOfId
				})
			});
		} finally {
			projectsLoading.value = false;
		}
	};
	deleteProject = async (serverId) => {
		projectsLoading.value = true;
		try {
			return await this.requestJson(`/api/projects/${serverId}`, { method: "DELETE" });
		} finally {
			projectsLoading.value = false;
		}
	};
	likeProject = async (id) => {
		return await this.requestJson(`/api/like/${id}`, { method: "POST" });
	};
	unlikeProject = async (id) => {
		return await this.requestJson(`/api/like/${id}`, { method: "DELETE" });
	};
	commentProject = async (id, comment) => {
		return await this.requestJson(`/api/comment/${id}`, {
			method: "POST",
			headers: { "content-type": "application/json" },
			body: JSON.stringify({ comment })
		});
	};
	deleteComment = async (id, commentId) => {
		return await this.requestJson(`/api/comment/${id}/${commentId}`, { method: "DELETE" });
	};
	login = async (email, password) => {
		return await this.requestJson("/api/auth/login", {
			method: "POST",
			headers: { "content-type": "application/json" },
			body: JSON.stringify({
				email,
				password
			})
		});
	};
	register = async (artistName, email, password) => {
		return await this.requestJson("/api/auth/register", {
			method: "POST",
			headers: { "content-type": "application/json" },
			body: JSON.stringify({
				artistName,
				email,
				password
			})
		});
	};
	logout = async () => {
		if ((await this.requestJson("/api/auth/logout", { method: "POST" })).ok) session.value = null;
		else throw new Error("Failed to logout");
	};
	fetchAvatar = async (userId, cacheBust$1) => {
		const cacheKey = `${userId}?c=${cacheBust$1}`;
		if (profileImageCache.has(cacheKey)) return profileImageCache.get(cacheKey);
		const deferred = Deferred();
		profileImageCache.set(cacheKey, deferred.promise);
		const response = await this.fetch(`/api/avatar/${userId}?c=${cacheBust$1}`);
		if (!response.ok) return deferred.reject(/* @__PURE__ */ new Error("Failed to fetch avatar"));
		const data = await response.blob();
		deferred.resolve(data);
		return data;
	};
	uploadAvatar = async (imageBlob) => {
		const arrayBuffer = await imageBlob.arrayBuffer();
		const base64 = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
		return this.requestJson("/api/avatar", {
			method: "POST",
			body: JSON.stringify({ image: base64 })
		});
	};
	updateArtistName = async (artistName) => {
		return this.requestJson("/api/artist-name", {
			method: "PUT",
			headers: { "content-type": "application/json" },
			body: JSON.stringify({ artistName })
		});
	};
	fetchAdminBackup = async () => {
		const response = await this.fetch("/api/admin/backup", { method: "GET" });
		if (!response.ok) throw new Error("Failed to fetch backup");
		return response.blob();
	};
};
const api = new API(async (input, init) => {
	busyLock();
	const res = await fetch(input, {
		...init,
		credentials: "include"
	});
	busyUnlock();
	return res;
});
queueMicrotask(() => {
	api.fetchSession().then((result) => {
		session.value = result;
	});
	m(() => {
		if (!session.value) return;
		queueMicrotask(() => {
			api.fetchProjects().then((result) => {
				n(() => {
					for (const project of result) {
						const found = projects.value.find((p$7) => p$7.serverId === project.id);
						if (found) {
							found.doc.code = project.code;
							if (!found.scratch.code) found.scratch.code = project.code;
							continue;
						}
						const doc = createDoc(tokenize);
						doc.code = project.code;
						const p$6 = createProject({
							serverId: project.id,
							userId: project.userId,
							id: project.id,
							name: project.name,
							doc,
							remixOfId: project.remixOf?.id,
							isPublic: project.isPublic,
							isSaved: true
						});
						if (!p$6.scratch.code) p$6.scratch.code = p$6.doc.code;
						projects.value.push(p$6);
					}
					for (const project of projects.value) {
						if (result.find((p$6) => p$6.id === project.serverId)) continue;
						project.serverId = null;
					}
					projects.value = [...projects.value];
				});
			});
		});
	});
});
function formatErrors(errors) {
	return errors.map((e$59) => {
		const { line, column, start, end } = e$59.loc;
		return {
			x: [column, column + (end - start)],
			y: line,
			message: e$59.message
		};
	});
}
function computeDocErrors(result, runtimeError) {
	const compileErrors = result?.errors.length ? formatErrors([
		...result.lex.errors,
		...result.parse.errors,
		...result.compile.errors
	]) : [];
	if (runtimeError != null) {
		const caret = activeEditor.value?.caret;
		if (caret) {
			const error$1 = signalify({
				get x() {
					return [caret.column.value + 1, caret.column.value + 1];
				},
				get y() {
					return caret.line.value + 1;
				},
				message: runtimeError
			});
			compileErrors.push(error$1);
		}
	}
	return compileErrors;
}
function indexToLoc(source, index) {
	let line = 1;
	let pos = 0;
	while (true) {
		const nl = source.indexOf("\n", pos);
		if (nl === -1 || nl >= index) break;
		line++;
		pos = nl + 1;
	}
	return {
		line,
		column: index - pos + 1
	};
}
var LINE_STARTS_CAP = 512;
var lineStartsCache = /* @__PURE__ */ new Map();
function getLineStarts(source) {
	let entry = lineStartsCache.get(source);
	if (entry) {
		lineStartsCache.delete(source);
		lineStartsCache.set(source, entry);
		return entry;
	}
	const starts = [0];
	for (let i$6 = 0; i$6 < source.length; i$6++) if (source[i$6] === "\n") starts.push(i$6 + 1);
	if (lineStartsCache.size >= LINE_STARTS_CAP) lineStartsCache.delete(lineStartsCache.keys().next().value);
	lineStartsCache.set(source, starts);
	return starts;
}
function locToIndex(source, line, column) {
	const starts = getLineStarts(source);
	if (line > starts.length) return source.length;
	return starts[line - 1] + (column - 1);
}
var PREFIX = "wk";
function makeWidgetCacheKey(kind, start, end, ...extra$1) {
	if (kind.includes(":")) throw new Error(`Widget cache key kind must not contain ":" (got ${JSON.stringify(kind)})`);
	const parts = [
		PREFIX,
		kind,
		String(start),
		String(end)
	];
	for (const item of extra$1) {
		if (item === null || item === void 0) continue;
		const s$4 = String(item);
		if (s$4.includes(":")) throw new Error(`Widget cache key extra must not contain ":" (got ${JSON.stringify(s$4)})`);
		parts.push(s$4);
	}
	return parts.join(":");
}
function parseWidgetCacheKey(key) {
	const parts = key.split(":");
	if (parts[0] !== PREFIX) return null;
	const kind = parts[1];
	const start = Number(parts[2]);
	const end = Number(parts[3]);
	if (!kind || !Number.isFinite(start) || !Number.isFinite(end)) return null;
	return {
		kind,
		start,
		end,
		extra: parts.slice(4)
	};
}
function relocateWidgetCacheKeys(cache, spliceStart, deletedLen, insertedLen) {
	if (deletedLen === 0 && insertedLen === 0) return;
	const prefixWithColon = PREFIX + ":";
	const kindStart = 3;
	const spliceEnd = spliceStart + deletedLen;
	const delta = insertedLen - deletedLen;
	const moves = [];
	for (const [key, value] of cache) {
		if (!key.startsWith(prefixWithColon)) continue;
		const kindEnd = key.indexOf(":", kindStart);
		if (kindEnd === -1) continue;
		const startStart = kindEnd + 1;
		const startEnd = key.indexOf(":", startStart);
		if (startEnd === -1) continue;
		const endStart = startEnd + 1;
		const maybeEndEnd = key.indexOf(":", endStart);
		const endEnd = maybeEndEnd === -1 ? key.length : maybeEndEnd;
		const tail = maybeEndEnd === -1 ? "" : key.slice(maybeEndEnd);
		const kind = key.slice(kindStart, kindEnd);
		if (!kind) continue;
		const startStr = key.slice(startStart, startEnd);
		const endStr = key.slice(endStart, endEnd);
		const start = Number(startStr);
		const end = Number(endStr);
		if (!Number.isFinite(start) || !Number.isFinite(end)) continue;
		let nextStart = start;
		if (start < spliceStart) {} else if (start > spliceEnd) nextStart = start + delta;
		else nextStart = spliceStart;
		let nextEnd = end;
		if (end < spliceStart) {} else if (end > spliceEnd) nextEnd = end + delta;
		else nextEnd = spliceStart + insertedLen;
		nextStart = Math.max(0, nextStart);
		nextEnd = Math.max(0, nextEnd);
		const nextStartStr = String(nextStart);
		const nextEndStr = String(nextEnd);
		if (nextStartStr === startStr && nextEndStr === endStr) continue;
		const nextKey = prefixWithColon + kind + ":" + nextStartStr + ":" + nextEndStr + tail;
		if (value === void 0) continue;
		moves.push([
			key,
			nextKey,
			value
		]);
	}
	for (const [from, to, value] of moves) {
		cache.delete(from);
		cache.set(to, value);
	}
}
const TIME_WINDOW_BARS = 5;
const FILL_ALPHA = .3;
function clamp(value, min, max) {
	return Math.max(min, Math.min(value, max));
}
function clamp01(value) {
	return clamp(value, 0, 1);
}
function clamp11(value) {
	return clamp(value, -1, 1);
}
function applyCurve(t$12, curve) {
	if (curve > 0) return Math.pow(t$12, curve);
	if (curve < 0) {
		const base = -curve;
		if (base > 0) return 1 - Math.pow(1 - t$12, base);
	}
	return t$12;
}
function getFunctionCallLength(source, line, column) {
	const lines = source.split("\n");
	if (line < 1 || line > lines.length) return 0;
	let pos = 0;
	for (let i$7 = 0; i$7 < line - 1; i$7++) pos += lines[i$7].length + 1;
	pos += column - 1;
	if (pos >= source.length) return 0;
	let i$6 = pos;
	let parenDepth = 0;
	let inSingleComment = false;
	let inMultiComment = false;
	let inString = false;
	let stringChar = "";
	let escaped = false;
	let startCol = column;
	let col = column;
	let maxCol = column;
	let hasNewlines = false;
	while (i$6 < source.length && source[i$6] !== "(") {
		if (source[i$6] === "\n") {
			col = 1;
			hasNewlines = true;
		} else col++;
		if (col > maxCol) maxCol = col;
		i$6++;
	}
	if (i$6 >= source.length || source[i$6] !== "(") return 0;
	i$6++;
	parenDepth = 1;
	col++;
	if (col > maxCol) maxCol = col;
	while (i$6 < source.length && parenDepth > 0) {
		const ch = source[i$6];
		const next = i$6 + 1 < source.length ? source[i$6 + 1] : "";
		if (escaped) {
			escaped = false;
			i$6++;
			if (ch === "\n") {
				col = 1;
				hasNewlines = true;
			} else col++;
			if (col > maxCol) maxCol = col;
			continue;
		}
		if (inString) {
			if (ch === "\\") {
				escaped = true;
				i$6++;
				col++;
				if (col > maxCol) maxCol = col;
				continue;
			}
			if (ch === stringChar) {
				inString = false;
				stringChar = "";
			}
			i$6++;
			if (ch === "\n") {
				col = 1;
				hasNewlines = true;
			} else col++;
			if (col > maxCol) maxCol = col;
			continue;
		}
		if (inSingleComment) {
			if (ch === "\n") {
				inSingleComment = false;
				col = 1;
				hasNewlines = true;
			} else col++;
			if (col > maxCol) maxCol = col;
			i$6++;
			continue;
		}
		if (inMultiComment) {
			if (ch === "*" && next === "/") {
				inMultiComment = false;
				i$6 += 2;
				col += 2;
				if (col > maxCol) maxCol = col;
				continue;
			}
			if (ch === "\n") {
				col = 1;
				hasNewlines = true;
			} else col++;
			if (col > maxCol) maxCol = col;
			i$6++;
			continue;
		}
		if (ch === "/" && next === "/") {
			inSingleComment = true;
			i$6 += 2;
			col += 2;
			if (col > maxCol) maxCol = col;
			continue;
		}
		if (ch === "/" && next === "*") {
			inMultiComment = true;
			i$6 += 2;
			col += 2;
			if (col > maxCol) maxCol = col;
			continue;
		}
		if (ch === "\"" || ch === "'" || ch === "`") {
			inString = true;
			stringChar = ch;
			i$6++;
			col++;
			if (col > maxCol) maxCol = col;
			continue;
		}
		if (ch === "(") {
			parenDepth++;
			i$6++;
			col++;
			if (col > maxCol) maxCol = col;
			continue;
		}
		if (ch === ")") {
			parenDepth--;
			i$6++;
			col++;
			if (col > maxCol) maxCol = col;
			if (parenDepth === 0) break;
			continue;
		}
		if (ch === "\n") {
			col = 1;
			hasNewlines = true;
		} else col++;
		if (col > maxCol) maxCol = col;
		i$6++;
	}
	if (hasNewlines) return maxCol - startCol;
	else return i$6 - pos;
}
function impulse(c$7, a$36, x$4, y$5, w$5, h$5) {
	if (a$36 > 0) {
		c$7.globalAlpha = a$36 ** 4;
		c$7.fillStyle = primaryMediumColor.value;
		c$7.fillRect(x$4, y$5, w$5, h$5 - 1);
		c$7.globalAlpha = 1;
	}
}
function createAdWidget(ad, target, doc, latency, cache) {
	const startCol = target.source.column;
	const endCol = startCol + getFunctionCallLength(doc.code, target.source.line, target.source.column);
	const line = target.source.line;
	const key = makeWidgetCacheKey("Ad", locToIndex(doc.code, line, startCol), locToIndex(doc.code, line, endCol));
	const cached = cache.get(key);
	if (cached?.doc === doc) {
		cached.historyRef.current = ad;
		cached.widget.pos = {
			x: [startCol, endCol],
			y: line
		};
		return cached.widget;
	}
	cache.delete(key);
	const historyRef = { current: ad };
	const reader = createHistoryReader(ad.size, ad.mask, {
		stage: 0,
		attack: 0,
		decay: 0,
		exponent: 1,
		env: 0
	}, (state) => {
		state.stage = 0;
		state.env = 0;
	}, () => latency.value.state, () => historyRef.current.writeIndex, (index) => historyRef.current.sampleCounts[index], (state, index) => {
		const h$5 = historyRef.current;
		state.stage = h$5.emit.stage.at(index);
		state.attack = h$5.params.attack.at(index);
		state.decay = h$5.params.decay.at(index);
		state.exponent = h$5.params.exponent.at(index);
		state.env = h$5.emit.env.at(index);
	});
	let epoch = 0;
	const draw$1 = (c$7, x$4, y$5, w$5, h$5) => {
		reader.run(++epoch);
		c$7.save();
		c$7.translate(x$4, y$5);
		c$7.lineCap = "round";
		c$7.lineJoin = "round";
		c$7.strokeStyle = primaryColor.value;
		c$7.lineWidth = 2;
		c$7.beginPath();
		const { stage, attack, decay, exponent, env } = reader.state;
		const total = attack + decay;
		const padding = 2 / 2;
		const plotW = w$5 - padding * 2;
		const plotH = h$5;
		const plotX = padding;
		const plotY = 0;
		let playX = 0;
		if (total > 0) {
			const attackW = attack / total * plotW;
			c$7.moveTo(plotX, plotY + plotH);
			const attackPoints = Math.max(2, Math.ceil(attackW));
			for (let i$6 = 0; i$6 <= attackPoints; i$6++) {
				const t$13 = i$6 / attackPoints;
				const x$5 = plotX + t$13 * attackW;
				const y$6 = plotY + plotH - applyCurve(t$13, exponent) * plotH;
				if (i$6 === 0) c$7.moveTo(x$5, y$6);
				else c$7.lineTo(x$5, y$6);
			}
			const decayW = plotW - attackW;
			const decayPoints = Math.max(2, Math.ceil(decayW));
			for (let i$6 = 1; i$6 <= decayPoints; i$6++) {
				const t$13 = i$6 / decayPoints;
				const x$5 = plotX + attackW + t$13 * decayW;
				const y$6 = plotY + plotH - applyCurve(1 - t$13, exponent) * plotH;
				c$7.lineTo(x$5, y$6);
			}
			const phase = stage | 0;
			const t$12 = env;
			if (phase === 0) {
				playX = plotX;
				plotY + plotH;
			} else {
				playX = phase === 1 ? plotX + t$12 * attackW : plotX + attackW + (1 - t$12) * decayW;
				plotY + plotH - env * plotH;
			}
		}
		c$7.fillStyle = primaryDarkColor.value;
		c$7.fill();
		c$7.strokeStyle = primaryColor.value;
		c$7.lineWidth = 2;
		c$7.beginPath();
		c$7.moveTo(playX, plotY);
		c$7.lineTo(playX, plotY + plotH);
		c$7.stroke();
		c$7.restore();
	};
	const widget = {
		type: "above",
		pos: {
			x: [startCol, endCol],
			y: line
		},
		draw: draw$1
	};
	cache.set(key, {
		doc,
		widget,
		historyRef
	});
	return widget;
}
function createAdsrWidget(adsr, target, doc, latency, cache) {
	const startCol = target.source.column;
	const endCol = startCol + getFunctionCallLength(doc.code, target.source.line, target.source.column);
	const line = target.source.line;
	const key = makeWidgetCacheKey("Adsr", locToIndex(doc.code, line, startCol), locToIndex(doc.code, line, endCol));
	const cached = cache.get(key);
	if (cached?.doc === doc) {
		cached.historyRef.current = adsr;
		cached.widget.pos = {
			x: [startCol, endCol],
			y: line
		};
		return cached.widget;
	}
	cache.delete(key);
	const historyRef = { current: adsr };
	const reader = createHistoryReader(adsr.size, adsr.mask, {
		stage: 0,
		attack: 0,
		decay: 0,
		sustain: 0,
		release: 0,
		exponent: 1,
		env: 0
	}, (state) => {
		state.stage = 0;
		state.env = 0;
	}, () => latency.value.state, () => historyRef.current.writeIndex, (index) => historyRef.current.sampleCounts[index], (state, index) => {
		const h$5 = historyRef.current;
		state.stage = h$5.emit.stage.at(index);
		state.attack = h$5.params.attack.at(index);
		state.decay = h$5.params.decay.at(index);
		state.sustain = h$5.params.sustain.at(index);
		state.release = h$5.params.release.at(index);
		state.exponent = h$5.params.exponent.at(index);
		state.env = h$5.emit.env.at(index);
	});
	let epoch = 0;
	const draw$1 = (c$7, x$4, y$5, w$5, h$5) => {
		reader.run(++epoch);
		c$7.save();
		c$7.translate(x$4, y$5);
		c$7.lineCap = "round";
		c$7.lineJoin = "round";
		c$7.strokeStyle = primaryColor.value;
		c$7.lineWidth = 2;
		c$7.beginPath();
		const { stage, attack, decay, sustain, release, exponent, env } = reader.state;
		const sustainCurved = applyCurve(clamp01(sustain), exponent);
		const attackMax = Math.max(0, attack);
		const decayMax = Math.max(0, decay);
		const releaseMax = Math.max(0, release);
		const adTotal = attackMax + decayMax;
		const padding = 2 / 2;
		const plotW = w$5 - padding * 2;
		const plotH = h$5;
		const plotX = padding;
		const plotY = 0;
		let playX = 0;
		if (adTotal > 0 || releaseMax > 0) {
			const totalTime = attackMax + decayMax + .5 + releaseMax;
			const attackRatio = attackMax / totalTime;
			const decayRatio = decayMax / totalTime;
			const sustainRatio = .5 / totalTime;
			const releaseRatio = releaseMax / totalTime;
			const attackW = attackRatio * plotW;
			const decayW = decayRatio * plotW;
			const sustainW = sustainRatio * plotW;
			const releaseW = releaseRatio * plotW;
			const sustainEndX = attackW + decayW + sustainW;
			c$7.moveTo(plotX, plotY + plotH);
			if (attackW > 0) {
				const attackPoints = Math.max(2, Math.ceil(attackW));
				for (let i$6 = 0; i$6 <= attackPoints; i$6++) {
					const t$13 = i$6 / attackPoints;
					const px = plotX + t$13 * attackW;
					const py = plotY + plotH - applyCurve(t$13, exponent) * plotH;
					if (i$6 === 0) c$7.moveTo(px, py);
					else c$7.lineTo(px, py);
				}
			}
			if (decayW > 0) {
				plotY + plotH - sustainCurved * plotH;
				const decayPoints = Math.max(2, Math.ceil(decayW));
				for (let i$6 = 0; i$6 <= decayPoints; i$6++) {
					const t$13 = i$6 / decayPoints;
					const px = plotX + attackW + t$13 * decayW;
					const py = plotY + plotH - (applyCurve(1 - t$13, exponent) * (1 - sustainCurved) + sustainCurved) * plotH;
					c$7.lineTo(px, py);
				}
			}
			const sustainY = plotY + plotH - sustainCurved * plotH;
			if (sustainW > 0) c$7.lineTo(plotX + sustainEndX, sustainY);
			if (releaseW > 0) {
				const releasePoints = Math.max(2, Math.ceil(releaseW));
				for (let i$6 = 0; i$6 <= releasePoints; i$6++) {
					const t$13 = i$6 / releasePoints;
					const px = plotX + sustainEndX + t$13 * releaseW;
					const py = plotY + plotH - applyCurve(1 - t$13, exponent) * sustainCurved * plotH;
					c$7.lineTo(px, py);
				}
			}
			const phase = stage | 0;
			const t$12 = clamp01(env);
			if (phase === 0) {
				playX = plotX;
				plotY + plotH;
			} else if (phase === 1) {
				playX = plotX + t$12 * attackW;
				plotY + plotH - applyCurve(t$12, exponent) * plotH;
			} else if (phase === 2) {
				playX = plotX + attackW + t$12 * decayW;
				plotY + plotH - (applyCurve(1 - t$12, exponent) * (1 - sustainCurved) + sustainCurved) * plotH;
			} else if (phase === 3) playX = plotX + attackW + decayW + t$12 * sustainW;
			else if (phase === 4) {
				playX = plotX + sustainEndX + t$12 * releaseW;
				plotY + plotH - applyCurve(1 - t$12, exponent) * sustainCurved * plotH;
			} else {
				playX = plotX;
				plotY + plotH;
			}
		}
		c$7.fillStyle = primaryDarkColor.value;
		c$7.fill();
		c$7.strokeStyle = primaryColor.value;
		c$7.lineWidth = 2;
		c$7.beginPath();
		c$7.moveTo(playX, plotY);
		c$7.lineTo(playX, plotY + plotH);
		c$7.stroke();
		c$7.restore();
	};
	const widget = {
		type: "above",
		pos: {
			x: [startCol, endCol],
			y: line
		},
		draw: draw$1
	};
	cache.set(key, {
		doc,
		widget,
		historyRef
	});
	return widget;
}
function createArrayGetWidgets(history$1, target, doc, latency, cache) {
	const mapping = history$1.elementMapping;
	if (!mapping || mapping.length === 0) return [];
	const line = target.source.line;
	const widgets = [];
	const historyRef = { current: history$1 };
	const reader = createHistoryReader(history$1.size, history$1.mask, /* @__PURE__ */ new Map(), (state) => {
		state.clear();
	}, () => latency.value.state, () => historyRef.current.writeIndex, (index) => historyRef.current.sampleCounts[index], (state, index, sampleCount) => {
		state.set(Math.round(historyRef.current.params.index.at(index)), sampleCount);
	});
	for (const el of mapping) {
		const key = makeWidgetCacheKey("ArrayGet", locToIndex(doc.code, line, el.startCol), locToIndex(doc.code, line, el.endCol));
		const cached = cache.get(key);
		if (cached?.doc === doc) {
			cached.historyRef.current = history$1;
			cached.widget.pos = {
				x: [el.startCol, el.endCol],
				y: line
			};
			widgets.push(cached.widget);
			continue;
		}
		cache.delete(key);
		let firedAt = el.index === 0 ? 0 : -Infinity;
		let elapsed = Infinity;
		let epoch = -1;
		const draw$1 = (c$7, x$4, y$5, w$5, h$5) => {
			reader.run(++epoch);
			if (reader.now < firedAt) firedAt = el.index === 0 ? 0 : -Infinity;
			if (reader.state.has(el.index)) firedAt = reader.state.get(el.index);
			elapsed = reader.now - firedAt;
			impulse(c$7, Math.max(0, 1 - elapsed / latency.value.state.sampleRate), x$4, y$5, w$5, h$5);
		};
		const widget = {
			type: "overlay",
			pos: {
				x: [el.startCol, el.endCol],
				y: line
			},
			draw: draw$1
		};
		cache.set(key, {
			doc,
			widget,
			historyRef
		});
		widgets.push(widget);
	}
	return widgets;
}
function createCompressorWidget(compressor, target, doc, latency, cache) {
	const startCol = target.source.column;
	const endCol = startCol + getFunctionCallLength(doc.code, target.source.line, target.source.column);
	const line = target.source.line;
	const key = makeWidgetCacheKey("Compressor", locToIndex(doc.code, line, startCol), locToIndex(doc.code, line, endCol));
	const cached = cache.get(key);
	if (cached?.doc === doc) {
		cached.historyRef.current = compressor;
		cached.widget.pos = {
			x: [startCol, endCol],
			y: line
		};
		return cached.widget;
	}
	cache.delete(key);
	const historyRef = { current: compressor };
	const reader = createHistoryReader(compressor.size, compressor.mask, {
		inputLevel: 0,
		gainReduction: 0,
		threshold: -12
	}, () => {}, () => latency.value.state, () => historyRef.current.writeIndex, (index) => historyRef.current.sampleCounts[index], (state, index) => {
		const h$5 = historyRef.current;
		state.inputLevel = h$5.emit.inputLevel.at(index);
		state.gainReduction = h$5.emit.gainReduction.at(index);
		state.threshold = h$5.params.threshold.at(index);
	});
	let epoch = 0;
	const draw$1 = (c$7, x$4, y$5, w$5, h$5) => {
		reader.run(++epoch);
		c$7.save();
		c$7.translate(x$4, y$5);
		c$7.lineCap = "round";
		c$7.lineJoin = "round";
		const { inputLevel, gainReduction, threshold } = reader.state;
		const input = clamp01(inputLevel);
		const gain = clamp01(gainReduction);
		const thresholdLinear = Math.pow(10, Math.max(-80, Math.min(0, threshold)) / 20);
		const barH = Math.max(2, (h$5 - 4) / 2);
		const pad = 2;
		const barW = w$5 - pad * 2;
		const barX = pad;
		c$7.fillStyle = primaryDarkColor.value;
		c$7.fillRect(barX, pad, input * barW, barH);
		c$7.fillRect(barX, pad + barH + pad, gain * barW, barH);
		c$7.strokeStyle = primaryColor.value;
		c$7.lineWidth = 2;
		const thX = barX + thresholdLinear * barW;
		c$7.beginPath();
		c$7.moveTo(thX, 0);
		c$7.lineTo(thX, h$5);
		c$7.stroke();
		c$7.restore();
	};
	const widget = {
		type: "above",
		pos: {
			x: [startCol, endCol],
			y: line
		},
		draw: draw$1
	};
	cache.set(key, {
		doc,
		widget,
		historyRef
	});
	return widget;
}
function createEveryWidget(every, target, doc, latency, cache) {
	const startCol = target.source.column;
	const endCol = startCol + getFunctionCallLength(doc.code, target.source.line, target.source.column);
	const line = target.source.line;
	const key = makeWidgetCacheKey("Every", locToIndex(doc.code, line, startCol), locToIndex(doc.code, line, endCol));
	const cached = cache.get(key);
	if (cached?.doc === doc) {
		cached.historyRef.current = every;
		cached.widget.pos = {
			x: [startCol, endCol],
			y: line
		};
		return cached.widget;
	}
	cache.delete(key);
	const historyRef = { current: every };
	const reader = createHistoryReader(every.size, every.mask, { firedAt: -Infinity }, (state) => {
		state.firedAt = -Infinity;
	}, () => latency.value.state, () => historyRef.current.writeIndex, (index) => historyRef.current.sampleCounts[index], (state, index, sampleCount) => {
		if (historyRef.current.emit.fired.at(index) > 0) state.firedAt = sampleCount;
	});
	let elapsed = Infinity;
	let epoch = -1;
	const widget = {
		type: "overlay",
		pos: {
			x: [startCol, endCol],
			y: line
		},
		draw: (c$7, x$4, y$5, w$5, h$5) => {
			reader.run(++epoch);
			elapsed = reader.now - reader.state.firedAt;
			impulse(c$7, Math.max(0, 1 - elapsed / latency.value.state.sampleRate), x$4, y$5, w$5, h$5);
		}
	};
	cache.set(key, {
		doc,
		widget,
		historyRef
	});
	return widget;
}
function clamp$1(n$4, min, max) {
	return Math.max(min, Math.min(max, n$4));
}
var DIODELADDER_Q_COMP = 2.5;
var DIODELADDER_K_COMP = 1;
function biquadCoeffs(type, cutHz, q$5, gainDb, sampleRate) {
	const freq = clamp$1(cutHz, 20, Math.max(1, sampleRate / 2));
	const Q$3 = clamp$1(q$5, .01, 20);
	const gain = clamp$1(gainDb, -40, 40);
	const omega = Math.PI * 2 * freq / sampleRate;
	const sn$1 = Math.sin(omega);
	const cs = Math.cos(omega);
	if (type === "lp") {
		const alpha = sn$1 / (2 * Q$3);
		return {
			b0: (1 - cs) / 2,
			b1: 1 - cs,
			b2: (1 - cs) / 2,
			a0: 1 + alpha,
			a1: -2 * cs,
			a2: 1 - alpha
		};
	}
	if (type === "hp") {
		const alpha = sn$1 / (2 * Q$3);
		return {
			b0: (1 + cs) / 2,
			b1: -(1 + cs),
			b2: (1 + cs) / 2,
			a0: 1 + alpha,
			a1: -2 * cs,
			a2: 1 - alpha
		};
	}
	if (type === "bp") {
		const alpha = sn$1 / (2 * Q$3);
		return {
			b0: alpha,
			b1: 0,
			b2: -alpha,
			a0: 1 + alpha,
			a1: -2 * cs,
			a2: 1 - alpha
		};
	}
	if (type === "bs") {
		const alpha = sn$1 / (2 * Q$3);
		return {
			b0: 1,
			b1: -2 * cs,
			b2: 1,
			a0: 1 + alpha,
			a1: -2 * cs,
			a2: 1 - alpha
		};
	}
	if (type === "ls") {
		const A$3 = Math.pow(10, gain / 40);
		const beta = Math.sqrt(A$3) / 1;
		return {
			b0: A$3 * (A$3 + 1 - (A$3 - 1) * cs + beta * sn$1),
			b1: 2 * A$3 * (A$3 - 1 - (A$3 + 1) * cs),
			b2: A$3 * (A$3 + 1 - (A$3 - 1) * cs - beta * sn$1),
			a0: A$3 + 1 + (A$3 - 1) * cs + beta * sn$1,
			a1: -2 * (A$3 - 1 + (A$3 + 1) * cs),
			a2: A$3 + 1 + (A$3 - 1) * cs - beta * sn$1
		};
	}
	if (type === "hs") {
		const A$3 = Math.pow(10, gain / 40);
		const beta = Math.sqrt(A$3) / 1;
		return {
			b0: A$3 * (A$3 + 1 + (A$3 - 1) * cs + beta * sn$1),
			b1: -2 * A$3 * (A$3 - 1 + (A$3 + 1) * cs),
			b2: A$3 * (A$3 + 1 + (A$3 - 1) * cs - beta * sn$1),
			a0: A$3 + 1 - (A$3 - 1) * cs + beta * sn$1,
			a1: 2 * (A$3 - 1 - (A$3 + 1) * cs),
			a2: A$3 + 1 - (A$3 - 1) * cs - beta * sn$1
		};
	}
	if (type === "peak") {
		const A$3 = Math.pow(10, gain / 40);
		const alpha = sn$1 / (2 * Q$3);
		return {
			b0: 1 + alpha * A$3,
			b1: -2 * cs,
			b2: 1 - alpha * A$3,
			a0: 1 + alpha / A$3,
			a1: -2 * cs,
			a2: 1 - alpha / A$3
		};
	}
	if (type === "ap") {
		const alpha = sn$1 / (2 * Q$3);
		return {
			b0: 1 - alpha,
			b1: -2 * cs,
			b2: 1 + alpha,
			a0: 1 + alpha,
			a1: -2 * cs,
			a2: 1 - alpha
		};
	}
	return {
		a0: 1,
		a1: 0,
		a2: 0,
		b0: 1,
		b1: 0,
		b2: 0
	};
}
function svfMagDb(type, freqHz, cutHz, q$5, sampleRate) {
	const nyquist = Math.max(1, sampleRate / 2);
	const cut = clamp$1(cutHz, 50, nyquist);
	const Q$3 = clamp$1(q$5, .01, .985);
	const g$5 = Math.tan(Math.PI * cut / sampleRate);
	const k$4 = 2 - 2 * Q$3;
	const a1 = 1 / (1 + g$5 * (g$5 + k$4));
	const a2 = g$5 * a1;
	const a3 = g$5 * a2;
	const A11 = 2 * a1 - 1;
	const A12 = -2 * a2;
	const A21 = 2 * a2;
	const A22 = 1 - 2 * a3;
	const B1 = 2 * a2;
	const B2 = 2 * a3;
	let C1 = 0;
	let C2 = 0;
	let D$4 = 0;
	if (type === "lps") {
		C1 = a2;
		C2 = 1 - a3;
		D$4 = a3;
	} else if (type === "bps") {
		C1 = a1;
		C2 = -a2;
		D$4 = a2;
	} else if (type === "hps") {
		C1 = -k$4 * a1 - a2;
		C2 = k$4 * a2 - (1 - a3);
		D$4 = 1 - k$4 * a2 - a3;
	} else if (type === "bss") {
		C1 = -k$4 * a1;
		C2 = k$4 * a2;
		D$4 = 1 - k$4 * a2;
	} else if (type === "peaks") {
		C1 = -k$4 * a1 - 2 * a2;
		C2 = k$4 * a2 - 2 * (1 - a3);
		D$4 = 1 - k$4 * a2 - 2 * a3;
	} else if (type === "aps") {
		C1 = -2 * k$4 * a1;
		C2 = 2 * k$4 * a2;
		D$4 = 1 - 2 * k$4 * a2;
	}
	const w$5 = Math.PI * 2 * clamp$1(freqHz, 1e-6, nyquist) / sampleRate;
	const zr = Math.cos(w$5);
	const zi = Math.sin(w$5);
	const m11r = zr - A11;
	const m11i = zi;
	const m22r = zr - A22;
	const m22i = zi;
	const m12r = -A12;
	const m21r = -A21;
	const p1r = m11r * m22r - m11i * m22i;
	const p1i = m11r * m22i + m11i * m22r;
	const detr = p1r - m12r * m21r;
	const deti = p1i;
	const den = detr * detr + deti * deti;
	if (den <= 0) return -240;
	const y1r = m22r * B1 + -m12r * B2;
	const y1i = m22i * B1;
	const y2r = -m21r * B1 + m11r * B2;
	const y2i = m11i * B2;
	const x1r = (y1r * detr + y1i * deti) / den;
	const x1i = (y1i * detr - y1r * deti) / den;
	const x2r = (y2r * detr + y2i * deti) / den;
	const x2i = (y2i * detr - y2r * deti) / den;
	const Hr = C1 * x1r + C2 * x2r + D$4;
	const Hi = C1 * x1i + C2 * x2i;
	const mag = Math.sqrt(Hr * Hr + Hi * Hi);
	return 20 * Math.log10(Math.max(1e-12, mag));
}
function moogMagDb(type, freqHz, cutHz, q$5, sampleRate) {
	const nyquist = Math.max(1, sampleRate / 2);
	const freq = clamp$1(cutHz, 50, nyquist);
	const Q$3 = clamp$1(q$5, .01, .985);
	const v2 = 3.2;
	const kfc = freq / sampleRate;
	const kfcr = 1.873 * (kfc * kfc * kfc) + .4955 * (kfc * kfc) - .649 * kfc + .9988;
	const k2vg = v2 * (1 - Math.exp(-2 * Math.PI * kfcr * kfc));
	const kacr = Q$3 * (-3.9364 * (kfc * kfc) + 1.8409 * kfc + .9968);
	const postGain = 1.0001784074555027 + .9331585678097162 * Q$3;
	const g$5 = k2vg / v2;
	const oneMinusG = 1 - g$5;
	if (Math.abs(oneMinusG) < 1e-9) return -240;
	const A11 = oneMinusG;
	const A12 = 0;
	const A13 = 0;
	const A14 = -g$5 * kacr;
	const A21 = g$5 * oneMinusG;
	const A22 = oneMinusG;
	const A23 = 0;
	const A24 = -(g$5 * g$5) * kacr;
	const A31 = g$5 * g$5 * oneMinusG;
	const A32 = g$5 * oneMinusG;
	const A33 = oneMinusG;
	const A34 = -(g$5 * g$5 * g$5) * kacr;
	const A41 = g$5 * g$5 * g$5 * oneMinusG;
	const A42 = g$5 * g$5 * oneMinusG;
	const A43 = g$5 * oneMinusG;
	const A44 = oneMinusG - g$5 * g$5 * g$5 * g$5 * kacr;
	const B1 = g$5 * oneMinusG;
	const B2 = g$5 * g$5 * oneMinusG;
	const B3 = g$5 * g$5 * g$5 * oneMinusG;
	const B4 = g$5 * g$5 * g$5 * g$5 * oneMinusG;
	let C1 = 0;
	let C2 = 0;
	let C3 = 0;
	let C4 = 0;
	let D$4 = 0;
	{
		const g2 = g$5 * g$5;
		const g3 = g2 * g$5;
		const g4 = g2 * g2;
		if (type === "lpm") {
			C1 = postGain * g3;
			C2 = postGain * g2;
			C3 = postGain * g$5;
			C4 = postGain * (1 - g4 * kacr / oneMinusG);
			D$4 = postGain * g4;
		} else {
			C1 = postGain * (g2 * (-3 + 2 * g$5));
			C2 = postGain * (g$5 * (-3 + 2 * g$5));
			C3 = postGain * (-3 + 2 * g$5);
			C4 = postGain * (2 + kacr * (-1 + 3 * g3 - 2 * g4) / oneMinusG);
			D$4 = postGain * (1 - 3 * g3 + 2 * g4);
		}
	}
	const w$5 = Math.PI * 2 * clamp$1(freqHz, 1e-6, nyquist) / sampleRate;
	const zr = Math.cos(w$5);
	const zi = Math.sin(w$5);
	const mr = new Float64Array(16);
	const mi = new Float64Array(16);
	const br = new Float64Array(4);
	const bi = new Float64Array(4);
	mr[0] = zr - A11;
	mi[0] = zi;
	mr[1] = -A12;
	mi[1] = 0;
	mr[2] = -A13;
	mi[2] = 0;
	mr[3] = -A14;
	mi[3] = 0;
	mr[4] = -A21;
	mi[4] = 0;
	mr[5] = zr - A22;
	mi[5] = zi;
	mr[6] = -A23;
	mi[6] = 0;
	mr[7] = -A24;
	mi[7] = 0;
	mr[8] = -A31;
	mi[8] = 0;
	mr[9] = -A32;
	mi[9] = 0;
	mr[10] = zr - A33;
	mi[10] = zi;
	mr[11] = -A34;
	mi[11] = 0;
	mr[12] = -A41;
	mi[12] = 0;
	mr[13] = -A42;
	mi[13] = 0;
	mr[14] = -A43;
	mi[14] = 0;
	mr[15] = zr - A44;
	mi[15] = zi;
	br[0] = B1;
	bi[0] = 0;
	br[1] = B2;
	bi[1] = 0;
	br[2] = B3;
	bi[2] = 0;
	br[3] = B4;
	bi[3] = 0;
	const n$4 = 4;
	for (let k$4 = 0; k$4 < n$4; k$4++) {
		let piv = k$4;
		let best = 0;
		for (let r$11 = k$4; r$11 < n$4; r$11++) {
			const idx = r$11 * 4 + k$4;
			const mag2 = mr[idx] * mr[idx] + mi[idx] * mi[idx];
			if (mag2 > best) {
				best = mag2;
				piv = r$11;
			}
		}
		if (best < 1e-18) return -240;
		if (piv !== k$4) {
			for (let c$7 = k$4; c$7 < n$4; c$7++) {
				const a$36 = k$4 * 4 + c$7;
				const b$4 = piv * 4 + c$7;
				const tr = mr[a$36];
				mr[a$36] = mr[b$4];
				mr[b$4] = tr;
				const ti = mi[a$36];
				mi[a$36] = mi[b$4];
				mi[b$4] = ti;
			}
			const trb = br[k$4];
			br[k$4] = br[piv];
			br[piv] = trb;
			const tib = bi[k$4];
			bi[k$4] = bi[piv];
			bi[piv] = tib;
		}
		const kk = k$4 * 4 + k$4;
		const pr = mr[kk];
		const pi = mi[kk];
		const inv = 1 / (pr * pr + pi * pi);
		const invr = pr * inv;
		const invi = -pi * inv;
		for (let c$7 = k$4; c$7 < n$4; c$7++) {
			const idx = k$4 * 4 + c$7;
			const ar = mr[idx];
			const ai = mi[idx];
			mr[idx] = ar * invr - ai * invi;
			mi[idx] = ar * invi + ai * invr;
		}
		{
			const ar = br[k$4];
			const ai = bi[k$4];
			br[k$4] = ar * invr - ai * invi;
			bi[k$4] = ar * invi + ai * invr;
		}
		for (let r$11 = 0; r$11 < n$4; r$11++) {
			if (r$11 === k$4) continue;
			const rk = r$11 * 4 + k$4;
			const fr = mr[rk];
			const fi = mi[rk];
			if (fr === 0 && fi === 0) continue;
			for (let c$7 = k$4; c$7 < n$4; c$7++) {
				const rc = r$11 * 4 + c$7;
				const kc = k$4 * 4 + c$7;
				const ar = mr[kc];
				const ai = mi[kc];
				mr[rc] -= fr * ar - fi * ai;
				mi[rc] -= fr * ai + fi * ar;
			}
			br[r$11] -= fr * br[k$4] - fi * bi[k$4];
			bi[r$11] -= fr * bi[k$4] + fi * br[k$4];
		}
	}
	const Hr = C1 * br[0] + C2 * br[1] + C3 * br[2] + C4 * br[3] + D$4;
	const Hi = C1 * bi[0] + C2 * bi[1] + C3 * bi[2] + C4 * bi[3];
	const mag = Math.sqrt(Hr * Hr + Hi * Hi);
	return 20 * Math.log10(Math.max(1e-12, mag));
}
function diodeLadderMagDb(freqHz, cutHz, q$5, k$4, sampleRate) {
	const nyquist = Math.max(1, sampleRate / 2);
	const cut = clamp$1(cutHz, 20, nyquist);
	const qClamped = clamp$1(q$5, 0, 1);
	const kClamped = clamp$1(k$4, 0, 1);
	const K$3 = kClamped * Math.PI;
	const ah = (K$3 - 2) / (K$3 + 2);
	const bh = 2 / (K$3 + 2);
	const fbk = 20 * qClamped;
	const outA = 1 + .5 * fbk;
	const cutComp = clamp$1(cut / nyquist / (1 + DIODELADDER_Q_COMP * (qClamped * qClamped) + DIODELADDER_K_COMP * (kClamped * qClamped)) * nyquist, 20, nyquist);
	let a$36 = Math.PI * (cutComp / nyquist);
	a$36 = 2 * Math.tan(.5 * a$36);
	const ainv = 1 / a$36;
	const a2 = a$36 * a$36;
	const b$4 = 2 * a$36 + 1;
	const b2 = b$4 * b$4;
	const c$7 = 1 / (2 * a2 * a2 - 4 * a2 * b2 + b2 * b2);
	const g0 = 2 * a2 * a2 * c$7;
	const g$5 = g0 * bh;
	const sat = 1;
	const soft = (x$4) => x$4 / (1 / sat + Math.abs(x$4));
	const step = (x$4, u$5) => {
		const z0 = x$4[0];
		const z1 = x$4[1];
		const z2 = x$4[2];
		const z3 = x$4[3];
		const z4 = x$4[4];
		const s0 = (a2 * a$36 * z0 + a2 * b$4 * z1 + z2 * (b2 - 2 * a2) * a$36 + z3 * (b2 - 3 * a2) * b$4) * c$7;
		const s$4 = bh * s0 - z4;
		let y5 = (g$5 * u$5 + s$4) / (1 + g$5 * fbk);
		const y0 = soft(u$5 - fbk * y5);
		y5 = g$5 * y0 + s$4;
		const y4 = g0 * y0 + s0;
		const y3 = (b$4 * y4 - z3) * ainv;
		const y2 = (b$4 * y3 - a$36 * y4 - z2) * ainv;
		const y1 = (b$4 * y2 - a$36 * y3 - z1) * ainv;
		const x1 = new Float64Array(5);
		x1[0] = z0 + 4 * a$36 * (y0 - y1 + y2);
		x1[1] = z1 + 2 * a$36 * (y1 - 2 * y2 + y3);
		x1[2] = z2 + 2 * a$36 * (y2 - 2 * y3 + y4);
		x1[3] = z3 + 2 * a$36 * (y3 - 2 * y4);
		x1[4] = bh * y4 + ah * y5;
		return {
			x1,
			y: outA * y4
		};
	};
	const n$4 = 5;
	const eps = 1e-6;
	const x0 = new Float64Array(n$4);
	const base = step(x0, 0);
	const A$3 = new Float64Array(n$4 * n$4);
	const B$4 = new Float64Array(n$4);
	const C$4 = new Float64Array(n$4);
	let D$4 = 0;
	for (let j$4 = 0; j$4 < n$4; j$4++) {
		const xj = new Float64Array(n$4);
		xj[j$4] = eps;
		const r$11 = step(xj, 0);
		for (let i$6 = 0; i$6 < n$4; i$6++) A$3[i$6 * n$4 + j$4] = (r$11.x1[i$6] - base.x1[i$6]) / eps;
		C$4[j$4] = (r$11.y - base.y) / eps;
	}
	{
		const r$11 = step(x0, eps);
		for (let i$6 = 0; i$6 < n$4; i$6++) B$4[i$6] = (r$11.x1[i$6] - base.x1[i$6]) / eps;
		D$4 = (r$11.y - base.y) / eps;
	}
	const w$5 = Math.PI * 2 * clamp$1(freqHz, 1e-6, nyquist) / sampleRate;
	const zr = Math.cos(w$5);
	const zi = Math.sin(w$5);
	const mr = new Float64Array(n$4 * n$4);
	const mi = new Float64Array(n$4 * n$4);
	const br = new Float64Array(n$4);
	const bi = new Float64Array(n$4);
	for (let r$11 = 0; r$11 < n$4; r$11++) {
		for (let c2 = 0; c2 < n$4; c2++) {
			const idx = r$11 * n$4 + c2;
			mr[idx] = (r$11 === c2 ? zr : 0) - A$3[idx];
			mi[idx] = r$11 === c2 ? zi : 0;
		}
		br[r$11] = B$4[r$11];
		bi[r$11] = 0;
	}
	for (let k2 = 0; k2 < n$4; k2++) {
		let piv = k2;
		let best = 0;
		for (let r$11 = k2; r$11 < n$4; r$11++) {
			const idx = r$11 * n$4 + k2;
			const mag2 = mr[idx] * mr[idx] + mi[idx] * mi[idx];
			if (mag2 > best) {
				best = mag2;
				piv = r$11;
			}
		}
		if (best < 1e-18) return -240;
		if (piv !== k2) {
			for (let c2 = k2; c2 < n$4; c2++) {
				const aidx = k2 * n$4 + c2;
				const bidx = piv * n$4 + c2;
				const tr = mr[aidx];
				mr[aidx] = mr[bidx];
				mr[bidx] = tr;
				const ti = mi[aidx];
				mi[aidx] = mi[bidx];
				mi[bidx] = ti;
			}
			const trb = br[k2];
			br[k2] = br[piv];
			br[piv] = trb;
			const tib = bi[k2];
			bi[k2] = bi[piv];
			bi[piv] = tib;
		}
		const kk = k2 * n$4 + k2;
		const pr = mr[kk];
		const pi = mi[kk];
		const inv = 1 / (pr * pr + pi * pi);
		const invr = pr * inv;
		const invi = -pi * inv;
		for (let c2 = k2; c2 < n$4; c2++) {
			const idx = k2 * n$4 + c2;
			const ar = mr[idx];
			const ai = mi[idx];
			mr[idx] = ar * invr - ai * invi;
			mi[idx] = ar * invi + ai * invr;
		}
		{
			const ar = br[k2];
			const ai = bi[k2];
			br[k2] = ar * invr - ai * invi;
			bi[k2] = ar * invi + ai * invr;
		}
		for (let r$11 = 0; r$11 < n$4; r$11++) {
			if (r$11 === k2) continue;
			const rk = r$11 * n$4 + k2;
			const fr = mr[rk];
			const fi = mi[rk];
			if (fr === 0 && fi === 0) continue;
			for (let c2 = k2; c2 < n$4; c2++) {
				const rc = r$11 * n$4 + c2;
				const kc = k2 * n$4 + c2;
				const ar = mr[kc];
				const ai = mi[kc];
				mr[rc] -= fr * ar - fi * ai;
				mi[rc] -= fr * ai + fi * ar;
			}
			br[r$11] -= fr * br[k2] - fi * bi[k2];
			bi[r$11] -= fr * bi[k2] + fi * br[k2];
		}
	}
	let Hr = D$4;
	let Hi = 0;
	for (let i$6 = 0; i$6 < n$4; i$6++) {
		Hr += C$4[i$6] * br[i$6];
		Hi += C$4[i$6] * bi[i$6];
	}
	const mag = Math.sqrt(Hr * Hr + Hi * Hi);
	return 20 * Math.log10(Math.max(1e-12, mag));
}
function onePoleMagDb(type, freqHz, cutHz, sampleRate) {
	const nyquist = sampleRate / 2;
	const cut = clamp$1(cutHz, 20, nyquist);
	const b$4 = 1 - Math.exp(-2 * Math.PI * cut / sampleRate);
	const w$5 = Math.PI * 2 * clamp$1(freqHz, 1e-6, nyquist) / sampleRate;
	const cos1 = Math.cos(w$5);
	const sin1 = Math.sin(w$5);
	let nr, ni, dr, di;
	if (type === "lp1") {
		nr = b$4;
		ni = 0;
		dr = 1 - (1 - b$4) * cos1;
		di = (1 - b$4) * sin1;
	} else {
		nr = (1 - b$4) * (1 - cos1);
		ni = (1 - b$4) * (0 + sin1);
		dr = 1 - (1 - b$4) * cos1;
		di = (1 - b$4) * sin1;
	}
	const n2 = nr * nr + ni * ni;
	const d2 = dr * dr + di * di;
	const mag = d2 > 0 ? Math.sqrt(n2 / d2) : 1;
	const m$5 = Math.max(1e-12, mag);
	return 20 * Math.log10(m$5);
}
function biquadMagDb(type, freqHz, cutHz, q$5, gainDb, sampleRate) {
	const { a0, a1, a2, b0, b1, b2 } = biquadCoeffs(type, cutHz, q$5, gainDb, sampleRate);
	const w$5 = Math.PI * 2 * clamp$1(freqHz, 1e-6, sampleRate / 2) / sampleRate;
	const cos1 = Math.cos(w$5);
	const sin1 = Math.sin(w$5);
	const cos2 = Math.cos(2 * w$5);
	const sin2 = Math.sin(2 * w$5);
	const nr = b0 + b1 * cos1 + b2 * cos2;
	const ni = -(b1 * sin1 + b2 * sin2);
	const dr = a0 + a1 * cos1 + a2 * cos2;
	const di = -(a1 * sin1 + a2 * sin2);
	const n2 = nr * nr + ni * ni;
	const d2 = dr * dr + di * di;
	const mag = d2 > 0 ? Math.sqrt(n2 / d2) : 1;
	const m$5 = Math.max(1e-12, mag);
	return 20 * Math.log10(m$5);
}
function filterMagDb(type, freqHz, cutHz, q$5, gainDb, sampleRate, resonance, kParam) {
	if (type === "lps" || type === "hps" || type === "bps" || type === "bss" || type === "peaks" || type === "aps") return svfMagDb(type, freqHz, cutHz, q$5, sampleRate);
	if (type === "lpm" || type === "hpm") return moogMagDb(type, freqHz, cutHz, q$5, sampleRate);
	if (type === "diodeladder") return diodeLadderMagDb(freqHz, cutHz, resonance ?? q$5, kParam ?? 0, sampleRate);
	if (type === "lp1" || type === "hp1") return onePoleMagDb(type, freqHz, cutHz, sampleRate);
	return biquadMagDb(type, freqHz, cutHz, q$5, gainDb, sampleRate);
}
function hzToX(hz, minHz, maxHz, w$5) {
	const a$36 = Math.max(1, minHz);
	const b$4 = Math.max(a$36 + 1e-6, maxHz);
	const h$5 = clamp$1(hz, a$36, b$4);
	return Math.log(h$5 / a$36) / Math.log(b$4 / a$36) * w$5;
}
function getFilterVizType(genName, variantName) {
	if (genName === "Biquad") {
		if (variantName === "lp" || variantName === "hp" || variantName === "bp" || variantName === "bs" || variantName === "ap") return variantName;
		return null;
	}
	if (genName === "Biquadshelf") {
		if (variantName === "ls" || variantName === "hs" || variantName === "peak") return variantName;
		return null;
	}
	if (genName === "Svf") return variantName;
	if (genName === "Onepole") return variantName;
	if (genName === "Moog") return variantName;
	if (genName === "Diodeladder") return "diodeladder";
	return null;
}
function clampDb(n$4, min, max) {
	return Math.max(min, Math.min(max, n$4));
}
function createFilterWidget(filter, target, doc, latency, cache) {
	const vizType = getFilterVizType(filter.genName, filter.variantName);
	if (vizType === null) return null;
	const startCol = target.source.column;
	const endCol = startCol + getFunctionCallLength(doc.code, target.source.line, target.source.column);
	const line = target.source.line;
	const key = makeWidgetCacheKey("Filter", locToIndex(doc.code, line, startCol), locToIndex(doc.code, line, endCol), filter.genName, filter.variantName ?? "");
	const cached = cache.get(key);
	if (cached?.doc === doc) {
		cached.historyRef.current = filter;
		cached.widget.pos = {
			x: [startCol, endCol],
			y: line
		};
		return cached.widget;
	}
	cache.delete(key);
	const historyRef = { current: filter };
	filter.params;
	const reader = createHistoryReader(filter.size, filter.mask, {
		cutoff: 0,
		q: .707,
		gain: 0,
		k: 0
	}, (state) => {}, () => latency.value.state, () => historyRef.current.writeIndex, (index) => historyRef.current.sampleCounts[index], (state, index) => {
		const p$6 = historyRef.current.params;
		state.cutoff = p$6.cutoff?.at(index) ?? state.cutoff;
		state.q = p$6.q?.at(index) ?? state.q;
		state.gain = p$6.gain?.at(index) ?? state.gain;
		state.k = p$6.k?.at(index) ?? state.k;
	});
	let epoch = 0;
	const draw$1 = (c$7, x$4, y$5, w$5, h$5) => {
		reader.run(++epoch);
		const { cutoff: rawCutoff, q: rawQ, gain: rawGain, k: rawK } = reader.state;
		const sr = latency.value.state.sampleRate ?? 48e3;
		const nyquist = Math.max(1, sr / 2);
		const minHz = 20;
		const maxHz = Math.min(2e4, nyquist);
		const isSvf = vizType === "lps" || vizType === "hps" || vizType === "bps" || vizType === "bss" || vizType === "peaks" || vizType === "aps";
		const isMoog = vizType === "lpm" || vizType === "hpm";
		const isDiodeLadder = vizType === "diodeladder";
		const cutoff = clamp(rawCutoff || 1e3, isSvf || isMoog || isDiodeLadder || vizType === "lp1" || vizType === "hp1" ? 20 : minHz, maxHz);
		const q$5 = clamp(rawQ || .707, .01, isSvf || isMoog || isDiodeLadder ? .985 : 20);
		const gain = rawGain ?? 0;
		const dlQ = isDiodeLadder ? clamp(rawQ ?? .5, 0, 1) : void 0;
		const dlK = isDiodeLadder ? clamp(rawK ?? 0, 0, 1) : void 0;
		c$7.save();
		c$7.translate(x$4, y$5);
		c$7.lineCap = "round";
		c$7.lineJoin = "round";
		const fullThreshold = 58;
		let padX = 4;
		let padY = 2;
		let leftLabelW = 20;
		let bottomLabelH = 9;
		let showDbLabels;
		let showParamLabels;
		padY = 0;
		leftLabelW = 0;
		bottomLabelH = 0;
		showDbLabels = false;
		showParamLabels = false;
		const chartX = leftLabelW > 0 ? leftLabelW : 0;
		const chartY = 0;
		const rightPad = padX;
		const chartW = Math.max(1, w$5 - chartX - rightPad);
		const chartH = Math.max(1, h$5 - chartY - bottomLabelH - padY);
		const minDb = -24;
		const maxDb = 16;
		const dbToY = (db) => {
			return chartY + (1 - (clampDb(db, minDb, maxDb) - minDb) / (maxDb - minDb)) * chartH;
		};
		c$7.save();
		c$7.translate(chartX, 0);
		const minMarkDy = clamp(chartH * .09, 8, 18);
		const stepChoices = [
			6,
			12,
			24
		];
		let stepDb = 6;
		for (const s$4 of stepChoices) {
			const dyUp = Math.abs(dbToY(s$4) - dbToY(0));
			const dyDown = Math.abs(dbToY(-s$4) - dbToY(0));
			if (Math.min(dyUp, dyDown) >= minMarkDy) {
				stepDb = s$4;
				break;
			}
			stepDb = s$4;
		}
		const markSet = new Set([
			minDb,
			0,
			maxDb
		]);
		for (let d$5 = stepDb; d$5 <= maxDb; d$5 += stepDb) markSet.add(d$5);
		for (let d$5 = -stepDb; d$5 >= minDb; d$5 -= stepDb) markSet.add(d$5);
		[...markSet].sort((a$36, b$4) => b$4 - a$36);
		if (showDbLabels) {
			c$7.font = h$5 >= fullThreshold ? "9px \"Outfit\"" : "8px \"Outfit\"";
			c$7.textBaseline = "middle";
			c$7.textAlign = "right";
			c$7.fillStyle = "rgba(180,180,180,0.7)";
		}
		c$7.strokeStyle = "rgba(180,180,180,0.18)";
		c$7.textAlign = "center";
		c$7.textBaseline = "top";
		c$7.strokeStyle = "rgba(180,180,180,0.14)";
		const cutX = hzToX(cutoff, minHz, maxHz, chartW);
		dbToY(filterMagDb(vizType, cutoff, cutoff, q$5, gain, sr, dlQ, dlK));
		const steps = Math.min(256, Math.max(64, chartW | 0));
		c$7.beginPath();
		for (let i$6 = 0; i$6 <= steps; i$6++) {
			const t$12 = i$6 / steps;
			const db = filterMagDb(vizType, minHz * Math.exp(Math.log(maxHz / minHz) * t$12), cutoff, q$5, gain, sr, dlQ, dlK);
			const px = t$12 * chartW;
			const py = dbToY(db);
			if (i$6 === 0) c$7.moveTo(px, py);
			else c$7.lineTo(px, py);
		}
		c$7.lineTo(chartW, chartH);
		c$7.lineTo(0, chartH);
		c$7.closePath();
		c$7.fillStyle = primaryDarkColor.value;
		c$7.fill();
		c$7.strokeStyle = primaryColor.value;
		c$7.lineWidth = 2;
		c$7.beginPath();
		c$7.moveTo(cutX, chartY);
		c$7.lineTo(cutX, chartY + chartH);
		c$7.stroke();
		if (showParamLabels) {
			c$7.fillStyle = "rgba(180,180,180,0.9)";
			c$7.font = "100 7px \"Space Mono\"";
			c$7.textBaseline = "bottom";
			c$7.textAlign = "left";
			const cutTxt = cutoff >= 1e3 ? `${(cutoff / 1e3).toFixed(cutoff % 1e3 === 0 ? 0 : 2)}kHz` : `${cutoff.toFixed(0)}Hz`;
			const l$10 = 2;
			const lh = 8;
			if (vizType === "peak") {
				c$7.fillText(`c:${cutTxt}`, l$10, chartH - lh * 2);
				c$7.fillText(`q:${q$5.toFixed(3)}`, l$10, chartH - lh);
				c$7.fillText(`g:${gain >= 0 ? "+" : ""}${gain.toFixed(1)}dB`, l$10, chartH);
			} else if (vizType === "ls" || vizType === "hs") {
				c$7.fillText(`c:${cutTxt}`, l$10, chartH - lh);
				c$7.fillText(`g:${gain >= 0 ? "+" : ""}${gain.toFixed(1)}dB`, l$10, chartH);
			} else if (vizType === "diodeladder") {
				c$7.fillText(`c:${cutTxt}`, l$10, chartH - lh * 2);
				c$7.fillText(`q:${(dlQ ?? .5).toFixed(3)}`, l$10, chartH - lh);
				c$7.fillText(`k:${(dlK ?? 0).toFixed(3)}`, l$10, chartH);
			} else if (vizType === "lp1" || vizType === "hp1") c$7.fillText(`c:${cutTxt}`, l$10, chartH);
			else {
				c$7.fillText(`c:${cutTxt}`, l$10, chartH - lh);
				c$7.fillText(`q:${q$5.toFixed(3)}`, l$10, chartH);
			}
		}
		c$7.restore();
		c$7.restore();
	};
	const widget = {
		type: "above",
		pos: {
			x: [startCol, endCol],
			y: line
		},
		draw: draw$1
	};
	cache.set(key, {
		doc,
		widget,
		historyRef
	});
	return widget;
}
var LINE_WIDTH$5 = 1.25;
function parseValueFromText(t$12) {
	const s$4 = t$12.trimEnd();
	const hasK = s$4.toLowerCase().endsWith("k");
	const numPart = hasK ? s$4.slice(0, -1) : s$4;
	const n$4 = parseFloat(numPart);
	return {
		value: Number.isNaN(n$4) ? 0 : hasK ? n$4 * 1e3 : n$4,
		hasK
	};
}
function createKnobWidgets(doc, result, cache) {
	if (!result) return [];
	const src = doc.code;
	const preludeLen = result.lex.preludeLen;
	const calls = result.compile.functionCalls;
	const numbers = result.parse.numberLiterals;
	const widgets = [];
	const knobs = /* @__PURE__ */ new Map();
	const createKnob = (value, param) => {
		if (knobs.has(value)) return;
		if (value.value === 0) return;
		const startIndex = value.loc.start - preludeLen;
		const endIndex = value.loc.end - preludeLen;
		const { line: startLine, column: startColumn } = indexToLoc(src, startIndex);
		const { line: endLine, column: endColumn } = indexToLoc(src, endIndex);
		const key = makeWidgetCacheKey("Knob", startIndex, endIndex);
		const cached = cache.get(key);
		if (cached?.doc === doc) {
			cached.value = value;
			cached.preludeLen = preludeLen;
			cached.widget.pos = {
				x: startColumn,
				y: startLine,
				width: 18
			};
			knobs.set(value, cached.widget);
			return;
		} else cache.delete(key);
		let initialNormal;
		let normal;
		let digitsAfterDecimal;
		let scale = 1;
		let min = 0;
		let text;
		let hasK = false;
		let hasLeadingZero = true;
		const entryRef = {
			doc,
			widget: null,
			value,
			preludeLen
		};
		const getStartIndex = () => {
			for (const [cacheKey, cacheEntry] of cache) if (cacheEntry === entryRef) {
				const parsed = parseWidgetCacheKey(cacheKey);
				if (parsed) return parsed.start;
			}
			const { value: v$4, preludeLen: plen } = entryRef;
			return v$4.loc.start - plen;
		};
		const getRange = () => {
			const { value: v$4 } = entryRef;
			const baseLen = v$4.loc.end - v$4.loc.start;
			const start = getStartIndex();
			return {
				start,
				end: start + baseLen
			};
		};
		const syncFromDoc = () => {
			const src$1 = doc.code;
			const { start, end } = getRange();
			text = src$1.slice(start, end);
			const { value: parsedVal, hasK: k$4 } = parseValueFromText(text);
			hasK = k$4;
			const numPartAbs = (hasK ? text.trimEnd().slice(0, -1) : text).replace(/^-/, "");
			hasLeadingZero = numPartAbs.startsWith("0.");
			const digitsSplit = numPartAbs.split(".");
			const digitsBeforeDecimal = digitsSplit[0]?.length ?? 0;
			digitsAfterDecimal = digitsSplit[1]?.length ?? 0;
			const firstSignificantPosition = digitsSplit[1]?.indexOf(digitsSplit[1]?.match(/[1-9]/)?.[0] ?? "") ?? 0;
			const literalVal = entryRef.value.value;
			const valForScale = hasK ? parsedVal / 1e3 : parsedVal || literalVal;
			if (valForScale >= 1) {
				scale = parseFloat("0.9e" + digitsBeforeDecimal) - 1;
				min = parseFloat("0.1e" + digitsBeforeDecimal);
			} else if (valForScale <= -1) {
				min = -(10 ** digitsBeforeDecimal - 1);
				scale = -(10 ** (digitsBeforeDecimal - 1)) - min;
			} else {
				scale = parseFloat("0.9e-" + firstSignificantPosition) - parseFloat("0.1e-" + (digitsAfterDecimal - 1));
				min = valForScale < 0 ? -parseFloat("0.9e-" + firstSignificantPosition) : parseFloat("0.1e-" + firstSignificantPosition);
			}
			normal = (valForScale - min) / scale;
			normal = Math.max(0, Math.min(1, normal));
			return normal;
		};
		const adjust = () => {
			syncFromDoc();
			initialNormal = normal;
		};
		adjust();
		const knob = {
			type: "before",
			pos: {
				x: startColumn,
				y: startLine,
				width: 18
			},
			draw: (c$7, x$4, y$5, w$5, h$5) => {
				syncFromDoc();
				w$5 -= 2;
				h$5 -= 2;
				x$4 += .5;
				y$5 += .5;
				const cx = x$4 + w$5 / 2;
				const cy = y$5 + h$5 / 2;
				const r$11 = w$5 / 2.6;
				c$7.save();
				c$7.lineWidth = LINE_WIDTH$5;
				c$7.beginPath();
				c$7.arc(cx, cy, r$11, 0, Math.PI * 2);
				c$7.fill();
				const a0 = Math.PI * .75;
				const a1 = Math.PI * 2.25;
				const a$36 = a0 + (a1 - a0) * normal;
				c$7.strokeStyle = "rgba(140,140,140,0.5)";
				c$7.beginPath();
				c$7.arc(cx, cy, r$11, a0, a1);
				c$7.stroke();
				c$7.strokeStyle = primaryColor.value;
				c$7.beginPath();
				c$7.arc(cx, cy, r$11, a0, a$36);
				c$7.stroke();
				c$7.fillStyle = secondaryColor.value;
				c$7.beginPath();
				c$7.arc(cx + Math.cos(a$36) * r$11, cy + Math.sin(a$36) * r$11, 1.1, 0, Math.PI * 2);
				c$7.fill();
				c$7.restore();
			},
			onMouseDown(event) {
				const y$5 = event.clientY;
				const handleMove = (e$59) => {
					skipSyncPreview();
					const { start, end } = getRange();
					const len = end - start;
					const dy = (y$5 - e$59.clientY) * .008;
					const vn = clamp01(initialNormal + dy);
					const val = vn * scale + min;
					let f$5;
					f$5 = val.toFixed(digitsAfterDecimal);
					if (!hasLeadingZero && (f$5.startsWith("0.") || f$5.startsWith("-0."))) f$5 = f$5.replace(/^(-?)0\./, "$1.");
					if (hasK) f$5 += "k";
					const index = start;
					if (f$5 !== text) {
						doc.replace(index, len, f$5);
						text = f$5;
						normal = vn;
					}
				};
				window.addEventListener("pointermove", handleMove);
				window.addEventListener("pointerup", () => {
					entryRef.value.value = min + normal * scale;
					adjust();
					entryRef.value.value = min + normal * scale;
					window.removeEventListener("pointermove", handleMove);
				}, { once: true });
			}
		};
		entryRef.widget = knob;
		knobs.set(value, knob);
		cache.set(key, entryRef);
	};
	const traverse = (gen, exprs, param) => {
		for (const expr of exprs) if (expr.type === "number") createKnob(expr, param);
		else if (expr.type === "binary") if (expr.op === "**") traverse(gen, [expr.left], param);
		else traverse(gen, [expr.left, expr.right], param);
		else if (expr.type === "call") traverse(gen, Array.from(expr.args.values()).map((x$4) => x$4.value), param);
	};
	for (const call of calls) {
		const gen = gens[call.name];
		if (!gen) continue;
		for (const name in call.args) {
			const param = gen.parameters.find((p$6) => p$6.name === name);
			if (param) traverse(gen, call.args[name], param);
		}
	}
	for (const number of numbers) createKnob(number);
	for (const knob of knobs.values()) widgets.push(knob);
	return widgets;
}
function fract(n$4) {
	return n$4 - Math.floor(n$4);
}
function lfoValue(type, phase01) {
	const p$6 = fract(phase01);
	if (type === "sine") return .5 + .5 * Math.sin(p$6 * Math.PI * 2);
	if (type === "tri") {
		const q$5 = fract(p$6 + .25);
		return .5 + .5 * (q$5 < .5 ? 4 * q$5 - 1 : 3 - 4 * q$5);
	}
	if (type === "saw") return fract(p$6 + .5);
	if (type === "ramp") return 1 - fract(p$6 + .5);
	if (type === "sqr") return p$6 < .5 ? phase01 >= 1 ? 0 : 1 : 0;
	return 0;
}
function createLfoWidget(lfo, target, doc, latency, lfoType, cache) {
	const startCol = target.source.column;
	const endCol = startCol + getFunctionCallLength(doc.code, target.source.line, target.source.column);
	const line = target.source.line;
	const key = makeWidgetCacheKey("Lfo", locToIndex(doc.code, line, startCol), locToIndex(doc.code, line, endCol), lfoType);
	const cached = cache.get(key);
	if (cached?.doc === doc) {
		cached.historyRef.current = lfo;
		cached.widget.pos = {
			x: [startCol, endCol],
			y: line
		};
		return cached.widget;
	}
	cache.delete(key);
	const historyRef = { current: lfo };
	const reader = createHistoryReader(lfo.size, lfo.mask, { phase: 0 }, () => {}, () => latency.value.state, () => historyRef.current.writeIndex, (index) => historyRef.current.sampleCounts[index], (state, index) => {
		state.phase = historyRef.current.emit.phase.at(index);
	});
	let epoch = 0;
	const draw$1 = (c$7, x$4, y$5, w$5, h$5) => {
		reader.run(++epoch);
		c$7.save();
		c$7.translate(x$4, y$5);
		c$7.lineCap = "round";
		c$7.lineJoin = "round";
		c$7.strokeStyle = primaryColor.value;
		c$7.lineWidth = 2;
		c$7.beginPath();
		const { phase } = reader.state;
		const plotW = w$5 - 2 / 2 * 2;
		const plotH = h$5;
		const plotY = 0;
		let playX = phase * plotW;
		const yToPx = (y$6) => plotY + (1 - clamp01(y$6)) * plotH;
		c$7.beginPath();
		const steps = 384;
		const isSaw = lfoType === "saw";
		const isRamp = lfoType === "ramp";
		const isSah = lfoType === "sah";
		const xWrap = plotW;
		c$7.moveTo(0, yToPx(0));
		for (let i$6 = 0; i$6 <= steps; i$6++) {
			const t$12 = i$6 / steps;
			let yy = 0;
			if (lfoType === "linear" || isSah) yy = t$12;
			else if (isSaw) yy = fract(t$12 + .5);
			else if (isRamp) yy = 1 - fract(t$12 + .5);
			else yy = lfoValue(lfoType, t$12);
			const px = t$12 * xWrap;
			const py = yToPx(yy);
			c$7.lineTo(px, py);
		}
		c$7.lineTo(xWrap, yToPx(0));
		c$7.closePath();
		c$7.lineWidth = 1.35;
		c$7.fillStyle = primaryDarkColor.value;
		c$7.fill();
		c$7.strokeStyle = primaryColor.value;
		c$7.lineWidth = 2;
		c$7.beginPath();
		c$7.moveTo(playX, plotY);
		c$7.lineTo(playX, plotY + plotH);
		c$7.stroke();
		c$7.fillStyle = primaryColor.value;
		c$7.beginPath();
		c$7.restore();
	};
	const widget = {
		type: "above",
		pos: {
			x: [startCol, endCol],
			y: line
		},
		draw: draw$1
	};
	cache.set(key, {
		doc,
		widget,
		historyRef
	});
	return widget;
}
function createLogWidget(history$1, target, doc, latency, mapFn) {
	const startCol = target.source.column;
	const endCol = startCol + getFunctionCallLength(doc.code, target.source.line, target.source.column);
	const line = target.source.line;
	const historyRef = { current: history$1 };
	const reader = createHistoryReader(history$1.size, history$1.mask, { value: 0 }, () => {}, () => latency.value.state, () => historyRef.current.writeIndex, (index) => historyRef.current.sampleCounts[index], (state, index) => {
		state.value = historyRef.current.params.value.at(index);
	});
	let epoch = -1;
	return {
		type: "above",
		pos: {
			x: [startCol, endCol],
			y: line
		},
		draw: (c$7, x$4, y$5, w$5, h$5) => {
			reader.run(++epoch);
			c$7.font = "12px \"Liga Space Mono\"";
			const v$4 = reader.state.value;
			drawText(c$7, mapFn(v$4), x$4, y$5 + h$5, grayColor.value);
		}
	};
}
const BLACK_KEY_STEPS = new Set([
	1,
	3,
	6,
	8,
	10
]);
var PADDING_SEMITONES = 2;
var MIN_RANGE = 16;
function isBlackKey(midi) {
	return BLACK_KEY_STEPS.has((midi % 12 + 12) % 12);
}
function countWhiteKeys(low, high) {
	let n$4 = 0;
	for (let m$5 = low; m$5 <= high; m$5++) if (!isBlackKey(m$5)) n$4++;
	return n$4;
}
function isCurrent(midi, current) {
	return typeof current === "number" ? midi === current : current.has(midi);
}
function computePianoRange(minNote, maxNote, currentNote) {
	if (minNote === null || maxNote === null) {
		const center$1 = currentNote;
		const span$1 = MIN_RANGE + PADDING_SEMITONES * 2;
		const low$1 = Math.round(center$1 - span$1 / 2);
		return {
			low: low$1,
			high: low$1 + span$1 - 1
		};
	}
	const span = Math.max(MIN_RANGE, maxNote - minNote + 1 + PADDING_SEMITONES * 2);
	const center = (minNote + maxNote) / 2;
	const low = Math.round(center - span / 2);
	return {
		low,
		high: low + span - 1
	};
}
function drawPianoViz(c$7, x$4, y$5, w$5, h$5, low, high, currentNotes) {
	const whiteCount = countWhiteKeys(low, high);
	const whiteW = w$5 / whiteCount;
	const blackW = whiteW * .5;
	const blackH = h$5 * .6;
	c$7.save();
	c$7.translate(x$4, y$5);
	c$7.rect(0, 0, w$5, h$5);
	c$7.clip();
	for (let midi = low; midi <= high; midi++) {
		if (isBlackKey(midi)) continue;
		const keyX = (countWhiteKeys(low, midi) - 1) * whiteW;
		c$7.fillStyle = isCurrent(midi, currentNotes) ? primaryColor.value : primaryDarkColor.value;
		c$7.fillRect(keyX, 0, whiteW, h$5);
	}
	const leftBoundaryBlack = low - 1;
	if (isBlackKey(leftBoundaryBlack)) {
		const keyX = -blackW / 2;
		c$7.fillStyle = isCurrent(leftBoundaryBlack, currentNotes) ? primaryColor.value : theme.value.black;
		c$7.fillRect(keyX, 0, blackW, blackH);
	}
	for (let midi = low; midi <= high; midi++) {
		if (!isBlackKey(midi)) continue;
		const keyX = countWhiteKeys(low, midi) * whiteW - blackW / 2;
		c$7.fillStyle = isCurrent(midi, currentNotes) ? primaryColor.value : theme.value.black + "bb";
		c$7.fillRect(keyX, 0, blackW, blackH);
	}
	const boundaryBlack = high + 1;
	if (isBlackKey(boundaryBlack)) {
		const keyX = whiteCount * whiteW - blackW / 2;
		c$7.fillStyle = isCurrent(boundaryBlack, currentNotes) ? primaryColor.value : theme.value.black;
		c$7.fillRect(keyX, 0, blackW, blackH);
	}
	c$7.fillStyle = theme.value.black + "bb";
	c$7.font = "bold 6px \"Outfit\"";
	c$7.textAlign = "center";
	c$7.textBaseline = "bottom";
	for (let midi = low; midi <= high; midi++) {
		if (isBlackKey(midi) || midi % 12 !== 0) continue;
		const keyCenterX = (countWhiteKeys(low, midi) - 1 + .5) * whiteW;
		c$7.fillText(String(Math.floor(midi / 12) - 1), keyCenterX, h$5);
	}
	c$7.restore();
}
var DEBUG_PREVIEW_TIMING = typeof window !== "undefined" && window.__DEBUG_PREVIEW_TIMING__;
function hzToNote(hz) {
	return Math.round(Math.log2(hz / 440) * 12 + 69);
}
function createMiniWidgets(mini, target, dsp, doc, currentResult, latency, timeSeconds, cache, options$2) {
	const noHeader = options$2?.noHeader ?? false;
	const line = target.source.line;
	const historyRef = { current: mini };
	const startCol = target.source.column;
	const endCol = startCol + getFunctionCallLength(doc.code, target.source.line, target.source.column);
	const startIndex = locToIndex(doc.code, line, startCol);
	const endIndex = locToIndex(doc.code, line, endCol);
	const fullKey = makeWidgetCacheKey("Mini.full", startIndex, endIndex, noHeader ? 1 : 0);
	const cachedFull = cache.get(fullKey);
	const activeOps = cachedFull?.doc === doc ? cachedFull.activeOps : /* @__PURE__ */ new Set();
	let ops = [];
	const opsKey = makeWidgetCacheKey("Mini.ops", startIndex, endIndex, noHeader ? 1 : 0);
	const cachedOps = cache.get(opsKey);
	const compileKey = historyRef.current.compileResult ? `${historyRef.current.compileResult.bytecode.length}:${historyRef.current.compileResult.sourceMap.length}` : "none";
	if (currentResult.value && historyRef.current.compileResult) {
		const src = currentResult.value.parse.src;
		let sequenceIndex = locToIndex(src, mini.source.line, mini.source.column);
		sequenceIndex = src.indexOf(`'`, sequenceIndex) + 1;
		const createOpWidget = (opIndex, x$4, y$5) => {
			let firedAt = -Infinity;
			let elapsed = Infinity;
			return {
				type: "overlay",
				pos: {
					x: x$4,
					y: y$5
				},
				draw: (c$7, x$5, y$6, w$5, h$5) => {
					if (activeOps.has(opIndex)) firedAt = performance.now();
					elapsed = performance.now() - firedAt;
					impulse(c$7, Math.max(0, 1 - elapsed / 1e3), x$5, y$6, w$5, h$5);
				}
			};
		};
		ops = historyRef.current.compileResult.sourceMap.filter((x$4) => x$4.source.text !== "").map((entry) => {
			let { line: startLine, column: startColumn } = indexToLoc(src, sequenceIndex + entry.source.start);
			let { line: endLine, column: endColumn } = indexToLoc(src, sequenceIndex + entry.source.start + entry.source.length);
			if (startLine !== endLine) return [createOpWidget(entry.eventIndex, [startColumn, src.split("\n")[startLine - 1].length], startLine), createOpWidget(entry.eventIndex, [0, endColumn], endLine)];
			return createOpWidget(entry.eventIndex, [startColumn, endColumn], startLine);
		}).flat();
		cache.set(opsKey, {
			doc,
			widget: ops[0] ?? {
				type: "overlay",
				pos: {
					x: [0, 0],
					y: line
				},
				draw: () => {}
			},
			widgets: ops,
			compileKey
		});
	} else if (cachedOps?.doc === doc && cachedOps.compileKey === compileKey) ops = cachedOps.widgets;
	const pianoAboveState = {
		noteMin: 60,
		noteMax: 72,
		currentNotes: /* @__PURE__ */ new Set()
	};
	let pianoroll;
	if (cachedFull?.doc === doc) {
		cachedFull.historyRef.current = mini;
		cachedFull.widget.pos = { y: line };
		pianoroll = cachedFull.widget;
	} else {
		cache.delete(fullKey);
		const reader = createHistoryReader(historyRef.current.size, historyRef.current.mask, { bars: 0 }, () => {}, () => latency.value.state, () => historyRef.current.writeIndex, (index) => historyRef.current.sampleCounts[index], (state, index) => {
			state.bars = historyRef.current.params.bars.at(index);
		});
		let epoch = 0;
		const miniPreviewCache = {
			key: "",
			entries: []
		};
		pianoroll = {
			type: "full",
			pos: { y: line },
			draw: (c$7, x$4, y$5, w$5, h$5, fw, contentLeft = 0) => {
				const m$5 = historyRef.current;
				if (!m$5.compileResult) return;
				reader.run(++epoch);
				const bars = reader.state.bars;
				if (bars === 0) return;
				const offsetX = noHeader || fw == null ? x$4 : 160 - contentLeft + x$4;
				if (!noHeader && fw != null) w$5 = fw - 160;
				c$7.save();
				c$7.translate(offsetX, y$5);
				const barLengthSeconds = 240 / (currentResult.value?.compile.bpm || 120);
				const windowStart = timeSeconds.value - 1 * barLengthSeconds;
				const windowEnd = timeSeconds.value + 4 * barLengthSeconds;
				const windowDuration = windowEnd - windowStart;
				const pxPerSecond = windowDuration > 0 ? w$5 / windowDuration : 0;
				const cacheKey = `${m$5.compileResult.bytecode.length}-${bars}-${windowStart.toFixed(1)}-${windowEnd.toFixed(1)}`;
				let entries$1;
				if (miniPreviewCache.key === cacheKey) entries$1 = miniPreviewCache.entries;
				else {
					const t0 = DEBUG_PREVIEW_TIMING ? performance.now() : 0;
					entries$1 = dsp.core.preview.runMiniPreview(m$5.compileResult, windowStart - 2, windowEnd, bars);
					if (DEBUG_PREVIEW_TIMING) console.log("[mini] runMiniPreview call", (performance.now() - t0).toFixed(2), "ms");
					miniPreviewCache.key = cacheKey;
					miniPreviewCache.entries = entries$1;
				}
				const entryToNote = /* @__PURE__ */ new Map();
				let noteMin = 128;
				let noteMax = 0;
				for (const entry of entries$1) {
					if (entry.voiceIndex < 0) continue;
					const note = hzToNote(entry.value);
					entryToNote.set(entry, note);
					if (note < noteMin) noteMin = note;
					if (note > noteMax) noteMax = note;
				}
				if (noteMin > noteMax) {
					noteMin = 60;
					noteMax = 72;
				}
				pianoAboveState.noteMin = noteMin;
				pianoAboveState.noteMax = noteMax;
				pianoAboveState.currentNotes.clear();
				for (const entry of entries$1) {
					if (entry.voiceIndex < 0) continue;
					if (entry.startSeconds <= timeSeconds.value && entry.endSeconds >= timeSeconds.value - .01) pianoAboveState.currentNotes.add(entryToNote.get(entry));
				}
				const scale = noteMax - noteMin;
				const nh = h$5 / (scale + 1);
				h$5 -= nh;
				activeOps.clear();
				for (const entry of entries$1) {
					if (entry.voiceIndex < 0) continue;
					const note = entryToNote.get(entry);
					const y$6 = (noteMax - note) / scale;
					const isPast = entry.startSeconds <= timeSeconds.value;
					if (isPast && entry.endSeconds >= timeSeconds.value - .01) activeOps.add(entry.opIndex);
					c$7.fillStyle = isPast ? secondaryColor.value : primaryColor.value;
					c$7.fillRect((entry.startSeconds - windowStart) * pxPerSecond, y$6 * h$5, (entry.endSeconds - entry.startSeconds) * pxPerSecond, nh);
				}
				c$7.restore();
			}
		};
		cache.set(fullKey, {
			doc,
			widget: pianoroll,
			historyRef,
			activeOps
		});
	}
	const pianoAboveKey = makeWidgetCacheKey("Mini.pianoAbove", startIndex, endIndex, noHeader ? 1 : 0);
	const cachedPianoAbove = cache.get(pianoAboveKey);
	let pianoAbove;
	if (cachedPianoAbove?.doc === doc) {
		cachedPianoAbove.historyRef.current = mini;
		cachedPianoAbove.widget.pos = {
			x: [startCol, endCol],
			y: line
		};
		pianoAbove = cachedPianoAbove.widget;
	} else {
		cache.delete(pianoAboveKey);
		pianoAbove = {
			type: "above",
			pos: {
				x: [startCol, endCol],
				y: line
			},
			draw: (c$7, x$4, y$5, w$5, h$5) => {
				if (!historyRef.current.compileResult) return;
				const { low, high } = computePianoRange(pianoAboveState.noteMin, pianoAboveState.noteMax, pianoAboveState.noteMin);
				drawPianoViz(c$7, x$4, y$5, w$5, h$5, low, high, pianoAboveState.currentNotes);
			}
		};
		cache.set(pianoAboveKey, {
			doc,
			widget: pianoAbove,
			historyRef
		});
	}
	return [
		ops,
		pianoAbove,
		pianoroll
	].flat();
}
function createPianoWidget(history$1, target, doc, latency, cache) {
	const startCol = target.source.column;
	const endCol = startCol + getFunctionCallLength(doc.code, target.source.line, target.source.column);
	const line = target.source.line;
	const key = makeWidgetCacheKey("Piano", locToIndex(doc.code, line, startCol), locToIndex(doc.code, line, endCol));
	const cached = cache.get(key);
	if (cached?.doc === doc) {
		if (cached.historyRef.current !== history$1) cached.notes.length = 0;
		cached.historyRef.current = history$1;
		cached.widget.pos = {
			x: [startCol, endCol],
			y: line
		};
		return cached.widget;
	}
	cache.delete(key);
	const historyRef = { current: history$1 };
	const notes = [];
	const reader = createHistoryReader(history$1.size, history$1.mask, { value: 0 }, () => {}, () => latency.value.state, () => historyRef.current.writeIndex, (index) => historyRef.current.sampleCounts[index], (state, index) => {
		state.value = historyRef.current.params.value.at(index);
	});
	let epoch = -1;
	const widget = {
		type: "above",
		pos: {
			x: [startCol, endCol],
			y: line
		},
		draw: (c$7, x$4, y$5, w$5, h$5) => {
			reader.run(++epoch);
			const v$4 = Math.round(reader.state.value);
			if (v$4 === 0) return;
			if (notes.length === 0 || notes[notes.length - 1] !== v$4) {
				notes.push(v$4);
				if (notes.length > 10) notes.shift();
			}
			const { low, high } = computePianoRange(Math.min(...notes), Math.max(...notes), v$4);
			drawPianoViz(c$7, x$4, y$5, w$5, h$5, low, high, v$4);
		}
	};
	cache.set(key, {
		doc,
		widget,
		historyRef,
		notes
	});
	return widget;
}
function createReverbWidget(reverb, target, doc, latency, cache) {
	const startCol = target.source.column;
	const endCol = startCol + getFunctionCallLength(doc.code, target.source.line, target.source.column);
	const line = target.source.line;
	const key = makeWidgetCacheKey("Reverb", locToIndex(doc.code, line, startCol), locToIndex(doc.code, line, endCol), reverb.genName);
	const cached = cache.get(key);
	if (cached?.doc === doc) {
		cached.historyRef.current = reverb;
		cached.widget.pos = {
			x: [startCol, endCol],
			y: line
		};
		return cached.widget;
	}
	cache.delete(key);
	const historyRef = { current: reverb };
	const reader = createHistoryReader(reverb.size, reverb.mask, { room: 0 }, () => {}, () => latency.value.state, () => historyRef.current.writeIndex, (index) => historyRef.current.sampleCounts[index], (state, index) => {
		state.room = historyRef.current.params.room.at(index);
	});
	let epoch = 0;
	const draw$1 = (c$7, x$4, y$5, w$5, h$5) => {
		reader.run(++epoch);
		const room = Math.tanh(clamp(reader.state.room, .05, 1) * 1.75);
		c$7.save();
		c$7.translate(x$4, y$5);
		const primary = primaryColor.value;
		const pad = 0;
		const c30 = .8660254037844386;
		const s30 = .35;
		const dxCoef = .68;
		const dzCoef = .48;
		const dyCoef = .48;
		const sumCoef = dxCoef + dzCoef;
		const maxSx = (w$5 - pad * 2) / Math.max(1e-6, c30 * sumCoef);
		const maxSy = (h$5 - pad * 2) / Math.max(1e-6, dyCoef + s30 * sumCoef);
		const maxS = Math.min(maxSx, maxSy);
		const s$4 = Math.max(0, room * (maxS - 6)) + 6;
		const ox = w$5 / 2;
		const dx = s$4 * dxCoef;
		const dz = s$4 * dzCoef;
		const dy = s$4 * dyCoef;
		const oyMin = pad + dy;
		const oy = oyMin + (h$5 - pad - s30 * (dx + dz) - oyMin) * .5;
		const proj = (xx, yy, zz) => {
			return [ox + xx * c30 - zz * c30, oy + xx * s30 + zz * s30 - yy];
		};
		const A$3 = proj(0, 0, 0);
		const B$4 = proj(dx, 0, 0);
		const Cc = proj(dx, 0, dz);
		const D$4 = proj(0, 0, dz);
		const A2 = proj(0, dy, 0);
		const B2 = proj(dx, dy, 0);
		const C2 = proj(dx, dy, dz);
		const D2 = proj(0, dy, dz);
		c$7.lineWidth = 2;
		c$7.save();
		c$7.fillStyle = primary;
		c$7.globalAlpha = .15;
		c$7.beginPath();
		c$7.moveTo(A$3[0], A$3[1]);
		c$7.lineTo(B$4[0], B$4[1]);
		c$7.lineTo(Cc[0], Cc[1]);
		c$7.lineTo(D$4[0], D$4[1]);
		c$7.closePath();
		c$7.fill();
		c$7.beginPath();
		c$7.moveTo(A$3[0], A$3[1]);
		c$7.lineTo(D$4[0], D$4[1]);
		c$7.lineTo(D2[0], D2[1]);
		c$7.lineTo(A2[0], A2[1]);
		c$7.closePath();
		c$7.fill();
		c$7.beginPath();
		c$7.moveTo(A$3[0], A$3[1]);
		c$7.lineTo(B$4[0], B$4[1]);
		c$7.lineTo(B2[0], B2[1]);
		c$7.lineTo(A2[0], A2[1]);
		c$7.closePath();
		c$7.fill();
		c$7.beginPath();
		c$7.moveTo(D$4[0], D$4[1]);
		c$7.lineTo(Cc[0], Cc[1]);
		c$7.lineTo(C2[0], C2[1]);
		c$7.lineTo(D2[0], D2[1]);
		c$7.closePath();
		c$7.fill();
		c$7.beginPath();
		c$7.lineTo(B$4[0], B$4[1]);
		c$7.lineTo(Cc[0], Cc[1]);
		c$7.lineTo(C2[0], C2[1]);
		c$7.lineTo(B2[0], B2[1]);
		c$7.closePath();
		c$7.fill();
		c$7.restore();
		c$7.strokeStyle = primary;
		c$7.lineCap = "round";
		c$7.lineJoin = "round";
		c$7.lineWidth = 1;
		c$7.beginPath();
		c$7.moveTo(A$3[0], A$3[1]);
		c$7.lineTo(B$4[0], B$4[1]);
		c$7.lineTo(Cc[0], Cc[1]);
		c$7.lineTo(D$4[0], D$4[1]);
		c$7.closePath();
		c$7.moveTo(A$3[0], A$3[1]);
		c$7.lineTo(A2[0], A2[1]);
		c$7.moveTo(B$4[0], B$4[1]);
		c$7.lineTo(B2[0], B2[1]);
		c$7.moveTo(D$4[0], D$4[1]);
		c$7.lineTo(D2[0], D2[1]);
		c$7.moveTo(Cc[0], Cc[1]);
		c$7.lineTo(C2[0], C2[1]);
		c$7.moveTo(A2[0], A2[1]);
		c$7.lineTo(B2[0], B2[1]);
		c$7.lineTo(C2[0], C2[1]);
		c$7.lineTo(D2[0], D2[1]);
		c$7.closePath();
		c$7.restore();
	};
	const widget = {
		type: "above",
		pos: {
			x: [startCol, endCol],
			y: line
		},
		draw: draw$1
	};
	cache.set(key, {
		doc,
		widget,
		historyRef
	});
	return widget;
}
var LINE_WIDTH$4 = 1.35;
function channelRefEqual(a$36, b$4) {
	return a$36.buffer === b$4.buffer && a$36.byteOffset === b$4.byteOffset && a$36.length === b$4.length;
}
function channelsEqual(a$36, b$4) {
	if (a$36 === b$4) return true;
	if (!a$36 || !b$4 || a$36.length !== b$4.length) return false;
	for (let i$6 = 0; i$6 < a$36.length; i$6++) if (!channelRefEqual(a$36[i$6], b$4[i$6])) return false;
	return true;
}
function drawWaveformToCache(ctx$1, w$5, h$5, dpr, channels, color) {
	const ch0 = channels[0];
	if (!ch0 || ch0.length < 2) return;
	const len = ch0.length;
	const mid = h$5 / 2;
	const amp = h$5 / 2 - 2;
	ctx$1.setTransform(dpr, 0, 0, dpr, 0, 0);
	ctx$1.strokeStyle = color;
	ctx$1.lineWidth = LINE_WIDTH$4;
	ctx$1.lineCap = "round";
	ctx$1.lineJoin = "round";
	ctx$1.beginPath();
	const step = w$5 > 100 ? .1 : .05;
	for (let i$6 = 0; i$6 < w$5; i$6 += step) {
		const sy = mid - clamp11(ch0[Math.floor(i$6 / w$5 * len)] ?? 0) * amp;
		if (i$6 === 0) ctx$1.moveTo(i$6, sy);
		else ctx$1.lineTo(i$6, sy);
	}
	ctx$1.stroke();
}
function updateWaveformCache(cache, w$5, h$5, dpr, channels) {
	const iw = Math.max(1, Math.round(w$5 * dpr));
	const ih = Math.max(1, Math.round(h$5 * dpr));
	if (iw <= 0 || ih <= 0) return cache;
	if (!(!cache || cache.width !== iw || cache.dpr !== dpr || cache.color !== theme.value.yellow || channels != null && !channelsEqual(cache.channelsRef, channels))) return cache;
	if (!cache || cache.canvas.width !== iw || cache.canvas.height !== ih) {
		const canvas = new OffscreenCanvas(iw, ih);
		cache = {
			canvas,
			ctx: canvas.getContext("2d"),
			channelsRef: null,
			width: iw,
			dpr,
			color: theme.value.yellow
		};
	}
	cache.channelsRef = channels;
	cache.width = iw;
	cache.dpr = dpr;
	cache.color = theme.value.yellow;
	cache.ctx.setTransform(1, 0, 0, 1, 0, 0);
	cache.ctx.clearRect(0, 0, iw, ih);
	if (channels?.length) drawWaveformToCache(cache.ctx, w$5, h$5, dpr, channels, cache.color);
	return cache;
}
var LINE_WIDTH$3 = 1.35;
function createSamplerWidget(sampler, target, dsp, doc, latency, waveformCaches, widgetsCache) {
	const startCol = target.source.column;
	const endCol = startCol + getFunctionCallLength(doc.code, target.source.line, target.source.column);
	const line = target.source.line;
	const key = makeWidgetCacheKey("Sampler", locToIndex(doc.code, line, startCol), locToIndex(doc.code, line, endCol));
	const cached = widgetsCache.get(key);
	if (cached?.doc === doc) {
		cached.historyRef.current = sampler;
		cached.widget.pos = {
			x: [startCol, endCol],
			y: line
		};
		return cached.widget;
	}
	widgetsCache.delete(key);
	const historyRef = { current: sampler };
	const reader = createHistoryReader(sampler.size, sampler.mask, {
		sample: 0,
		offset: 0,
		position: 0,
		playing: 0
	}, (state) => {
		state.sample = 0;
		state.offset = 0;
		state.position = 0;
		state.playing = 0;
	}, () => latency.value.state, () => historyRef.current.writeIndex, (index) => historyRef.current.sampleCounts[index], (state, index) => {
		const h$5 = historyRef.current;
		state.sample = h$5.params.sample.at(index);
		state.offset = h$5.params.offset.at(index);
		state.position = h$5.emit.position.at(index);
		state.playing = h$5.emit.playing.at(index);
	});
	let epoch = 0;
	let cache = waveformCaches.get(historyRef.current.index) ?? null;
	const draw$1 = (c$7, x$4, y$5, w$5, h$5) => {
		reader.run(++epoch);
		const { sample, offset, position, playing } = reader.state;
		const sampleData = dsp.sampleManager.getSample(sample);
		const channels = sampleData?.ready && sampleData.channels.length ? sampleData.channels : null;
		const dpr = typeof window !== "undefined" ? window.devicePixelRatio || 1 : 1;
		cache = updateWaveformCache(cache, w$5, h$5, dpr, channels);
		if (cache) {
			waveformCaches.set(historyRef.current.index, cache);
			c$7.drawImage(cache.canvas, x$4, y$5, w$5, h$5);
		}
		const length = sampleData?.length ?? 1;
		const playX = !playing ? x$4 + offset * w$5 : x$4 + position / length * w$5;
		c$7.strokeStyle = secondaryColor.value;
		c$7.lineWidth = LINE_WIDTH$3;
		c$7.beginPath();
		c$7.moveTo(playX, y$5);
		c$7.lineTo(playX, y$5 + h$5);
		c$7.stroke();
	};
	const widget = {
		type: "above",
		pos: {
			x: [startCol, endCol],
			y: line
		},
		draw: draw$1
	};
	widgetsCache.set(key, {
		doc,
		widget,
		historyRef
	});
	return widget;
}
var LINE_WIDTH$2 = 1.35;
var SLICE_LABEL_PADDING = 2;
function createSlicerWidget(slicer$1, target, dsp, doc, latency, waveformCaches, widgetsCache) {
	const startCol = target.source.column;
	const endCol = startCol + getFunctionCallLength(doc.code, target.source.line, target.source.column);
	const line = target.source.line;
	const key = makeWidgetCacheKey("Slicer", locToIndex(doc.code, line, startCol), locToIndex(doc.code, line, endCol));
	const cached = widgetsCache.get(key);
	if (cached?.doc === doc) {
		cached.historyRef.current = slicer$1;
		cached.widget.pos = {
			x: [startCol, endCol],
			y: line
		};
		return cached.widget;
	}
	widgetsCache.delete(key);
	const historyRef = { current: slicer$1 };
	const reader = createHistoryReader(slicer$1.size, slicer$1.mask, {
		sample: 0,
		threshold: 0,
		slice: 0,
		slicePosition: 0,
		slicePlaying: 0
	}, (state) => {
		state.sample = 0;
		state.threshold = 0;
		state.slice = 0;
		state.slicePosition = 0;
		state.slicePlaying = 0;
	}, () => latency.value.state, () => historyRef.current.writeIndex, (index) => historyRef.current.sampleCounts[index], (state, index) => {
		const h$5 = historyRef.current;
		state.sample = h$5.params.sample.at(index);
		state.threshold = h$5.params.threshold.at(index);
		state.slice = h$5.emit.currentSlice.at(index);
		state.slicePosition = h$5.emit.slicePosition.at(index);
		state.slicePlaying = h$5.emit.slicePlaying.at(index);
	});
	let epoch = 0;
	let cache = waveformCaches.get(historyRef.current.index) ?? null;
	const draw$1 = (c$7, x$4, y$5, w$5, h$5) => {
		reader.run(++epoch);
		const { sample, threshold, slice, slicePosition, slicePlaying } = reader.state;
		const sampleData = dsp.sampleManager.getSample(sample);
		const channels = sampleData?.ready && sampleData.channels.length ? sampleData.channels : null;
		const dpr = typeof window !== "undefined" ? window.devicePixelRatio || 1 : 1;
		const length = sampleData?.length ?? 1;
		const { points, count } = dsp.sampleManager.getSlices(sample, threshold);
		if (w$5 > 300) {
			c$7.strokeStyle = grayColor.value;
			c$7.lineWidth = LINE_WIDTH$2;
			for (let i$6 = 0; i$6 < count; i$6++) {
				const sliceX = x$4 + (points[i$6] ?? 0) / length * w$5;
				c$7.beginPath();
				c$7.moveTo(sliceX, y$5);
				c$7.lineTo(sliceX, y$5 + h$5);
				c$7.stroke();
			}
		}
		cache = updateWaveformCache(cache, w$5, h$5, dpr, channels);
		if (cache) {
			waveformCaches.set(historyRef.current.index, cache);
			c$7.drawImage(cache.canvas, x$4, y$5, w$5, h$5);
		}
		if (w$5 > 300) {
			c$7.font = "8px Outfit";
			for (let i$6 = 0; i$6 < count; i$6++) {
				const isEven = i$6 % 2 === 0;
				c$7.textBaseline = isEven ? "top" : "bottom";
				const sliceX = x$4 + (points[i$6] ?? 0) / length * w$5;
				const label = (i$6 / count).toFixed(2).slice(2);
				const labelY = isEven ? y$5 + SLICE_LABEL_PADDING : y$5 + h$5;
				c$7.strokeStyle = theme.value.black;
				c$7.lineWidth = .5;
				c$7.strokeText(label, sliceX + SLICE_LABEL_PADDING, labelY);
				c$7.fillStyle = theme.value.white;
				c$7.fillText(label, sliceX + SLICE_LABEL_PADDING, labelY);
				c$7.fillStyle = primaryColor.value;
				c$7.beginPath();
				c$7.arc(sliceX, labelY, 1.5, 0, 2 * Math.PI);
				c$7.fill();
			}
		}
		if (slicePlaying && slice >= 0 && slice < count) {
			const playX = x$4 + ((points[slice * count | 0] ?? 0) + slicePosition) / length * w$5;
			c$7.strokeStyle = secondaryColor.value;
			c$7.lineWidth = LINE_WIDTH$2;
			c$7.beginPath();
			c$7.moveTo(playX, y$5);
			c$7.lineTo(playX, y$5 + h$5);
			c$7.stroke();
		}
	};
	const widget = {
		type: "above",
		pos: {
			x: [startCol, endCol],
			y: line
		},
		draw: draw$1
	};
	widgetsCache.set(key, {
		doc,
		widget,
		historyRef
	});
	return widget;
}
function createTimelineWidgets(timeline, target, doc, result, latency, timeSeconds, cache, options$2) {
	const noHeader = options$2?.noHeader ?? false;
	const line = target.source.line;
	const widgets = [];
	const dataRef = { current: {
		timeline,
		compiled: compileTimelineNotation(timeline.sequence)
	} };
	const callStart = locToIndex(doc.code, timeline.source.line, timeline.source.column);
	const fullKey = makeWidgetCacheKey("Timeline.full", callStart, callStart + 1, noHeader ? 1 : 0);
	const cachedFull = cache.get(fullKey);
	if (cachedFull?.doc === doc) {
		cachedFull.dataRef.current = {
			timeline,
			compiled: compileTimelineNotation(timeline.sequence)
		};
		cachedFull.widget.pos = { y: line };
		widgets.push(cachedFull.widget);
	} else cache.delete(fullKey);
	const quoteIdx = doc.code.indexOf("'", callStart);
	const patternStartIndex = quoteIdx >= 0 ? quoteIdx + 1 : callStart;
	const compiled = dataRef.current.compiled;
	const bytecode$1 = compiled.bytecode;
	const segsForWindow = (windowStartTime, windowEndTime) => {
		const bpm$1 = result.value?.compile.bpm ?? 120;
		const sampleRate = latency.value.state.sampleRate || 44100;
		return readTimelineSegsFromCompiledTimeline(dataRef.current.compiled.bytecode, sampleRate, bpm$1, windowStartTime, windowEndTime);
	};
	const fullWidget = {
		type: "full",
		pos: { y: line },
		draw: (c$7, x$4, y$5, w$5, h$5, fw, contentLeft = 0) => {
			const bpm$1 = result.value?.compile.bpm ?? 120;
			const sampleRate = latency.value.state.sampleRate || 44100;
			const barLengthSeconds = 240 / bpm$1;
			const windowStartTime = timeSeconds.value - 1 * barLengthSeconds;
			const windowEndTime = timeSeconds.value + 4 * barLengthSeconds;
			const windowDuration = windowEndTime - windowStartTime;
			const offsetX = noHeader || fw == null ? x$4 : 160 - contentLeft + x$4;
			const drawW = Math.max(1, noHeader || fw == null ? w$5 : fw - 160);
			windowDuration > 0 && drawW / windowDuration;
			1 * barLengthSeconds / (TIME_WINDOW_BARS * barLengthSeconds) * drawW;
			const segs = segsForWindow(windowStartTime - barLengthSeconds * 3, windowEndTime + barLengthSeconds);
			const windowStartSample = windowStartTime * sampleRate;
			c$7.save();
			c$7.translate(offsetX, y$5);
			const drawH = h$5;
			c$7.strokeStyle = getTimelineColor(dataRef.current.timeline.colorIndex);
			c$7.lineWidth = 1.35;
			const timeWindowSeconds = TIME_WINDOW_BARS * barLengthSeconds;
			const sampleToPx = (samp) => (samp - windowStartSample) / (timeWindowSeconds * sampleRate) * drawW;
			const minVerticalGap = .5;
			c$7.beginPath();
			let prevSample = windowStartSample;
			let started = false;
			let lastX = 0;
			let si = 0;
			for (let px = -offsetX; px <= drawW; px += 2) {
				let sample = windowStartSample + px / drawW * timeWindowSeconds * sampleRate;
				if (px >= drawW) sample -= .001;
				if (sample < -offsetX) continue;
				const r$11 = getTimelineValue(segs, si, sample);
				si = r$11.si;
				const vy = (1 - r$11.v) * (drawH - 2) + 1;
				if (!started) {
					c$7.moveTo(px, vy);
					prevSample = sample;
					lastX = px;
					started = true;
					continue;
				}
				const boundaries = [];
				for (let k$4 = 0; k$4 < segs.length; k$4++) {
					const ss = segs[k$4];
					if (ss.startSample > prevSample && ss.startSample <= sample) boundaries.push(ss.startSample);
				}
				if (boundaries.length === 0) {
					c$7.lineTo(px, vy);
					prevSample = sample;
					lastX = px;
				} else {
					for (const boundarySample of boundaries) {
						const boundaryPx = sampleToPx(boundarySample);
						if (Math.abs(boundaryPx - lastX) < minVerticalGap) continue;
						const beforeVal = getTimelineValueAtSample(segs, boundarySample - 1);
						const afterVal = getTimelineValueAtSample(segs, boundarySample);
						const yBefore = (1 - beforeVal) * (drawH - 2) + 1;
						const yAfter = (1 - afterVal) * (drawH - 2) + 1;
						c$7.lineTo(boundaryPx, yBefore);
						c$7.lineTo(boundaryPx, yAfter);
						lastX = boundaryPx;
					}
					c$7.lineTo(px, vy);
					prevSample = sample;
					lastX = px;
				}
			}
			c$7.stroke();
			c$7.restore();
		}
	};
	if (!cachedFull?.doc || cachedFull.doc !== doc) {
		cache.set(fullKey, {
			doc,
			widget: fullWidget,
			dataRef
		});
		widgets.push(fullWidget);
	}
	const tokens = dataRef.current.timeline.segmentTokens ?? compiled.tokens;
	const wraps = bytecode$1[3] >= 0;
	const lastSegIdx = tokens.length - 1;
	for (let segIdx = 0; segIdx < tokens.length; segIdx++) {
		const t$12 = tokens[segIdx];
		const renderToken = (tokenStart, tokenLength, isFrom) => {
			if (tokenStart < 0) return;
			const length = Math.max(1, tokenLength);
			const absStart = patternStartIndex + tokenStart;
			const locStart = indexToLoc(doc.code, absStart);
			const locEnd = indexToLoc(doc.code, absStart + length);
			if (locStart.line !== line) return;
			const startCol = locStart.column;
			const endCol = locEnd.line === line ? locEnd.column : startCol + length;
			const isLastTo = !isFrom && segIdx === lastSegIdx;
			const overlayKey = makeWidgetCacheKey("Timeline.overlay", absStart, absStart + length, segIdx, isFrom ? 1 : 0, noHeader ? 1 : 0);
			const cachedOverlay = cache.get(overlayKey);
			if (cachedOverlay?.doc === doc) {
				cachedOverlay.dataRef.current = dataRef.current;
				cachedOverlay.widget.pos = {
					x: [startCol, endCol],
					y: line
				};
				widgets.push(cachedOverlay.widget);
				return;
			}
			cache.delete(overlayKey);
			const overlayWidget = {
				type: "overlay",
				pos: {
					x: [startCol, endCol],
					y: line
				},
				draw: (c$7, x$4, y$5, w$5, h$5) => {
					const bc = dataRef.current.compiled.bytecode;
					const sampleRate = latency.value.state.sampleRate || 44100;
					const bpm$1 = result.value?.compile.bpm ?? 120;
					const sampleCount = Math.round(timeSeconds.value * sampleRate);
					const active = getActiveTimelineSegIndex(bc, sampleCount, sampleRate, bpm$1);
					if (!active) return;
					const tt = active.tt;
					let alpha;
					if (active.si === segIdx) alpha = isFrom ? .25 * (1 - tt) : .25 * tt;
					else if (wraps && isLastTo && active.si === 0) {
						const cycleBeats = Math.abs(bc[3]) * bc[4];
						const beatAbs = sampleCount * (bpm$1 / 60) / sampleRate;
						if (Math.floor(beatAbs / cycleBeats) < 1) return;
						alpha = .25 * (1 - tt);
					} else return;
					c$7.fillStyle = `rgba(255,255,255,${alpha})`;
					c$7.fillRect(x$4 - 2, y$5 - 2, w$5 + 4, h$5 - 1);
				}
			};
			cache.set(overlayKey, {
				doc,
				widget: overlayWidget,
				dataRef
			});
			widgets.push(overlayWidget);
		};
		renderToken(t$12.fromTokenStart, t$12.fromTokenLength, true);
		if (t$12.fromTokenStart !== t$12.toTokenStart || t$12.fromTokenLength !== t$12.toTokenLength) renderToken(t$12.toTokenStart, t$12.toTokenLength, false);
	}
	return widgets;
}
function createTramWidgets(tram, target, doc, latency, cache) {
	if (!tram.beatMapping || tram.beatMapping.length === 0) return [];
	const line = target.source.line;
	const widgets = [];
	const historyRef = { current: tram };
	const reader = createHistoryReader(tram.size, tram.mask, /* @__PURE__ */ new Map(), (state) => {
		state.clear();
	}, () => latency.value.state, () => historyRef.current.writeIndex, (index) => historyRef.current.sampleCounts[index], (state, index, sampleCount) => {
		state.set(historyRef.current.emit.fired.at(index), sampleCount);
	});
	for (const beat of tram.beatMapping) {
		const key = makeWidgetCacheKey("Tram", locToIndex(doc.code, line, beat.startCol), locToIndex(doc.code, line, beat.endCol), beat.linearIndex);
		const cached = cache.get(key);
		if (cached?.doc === doc) {
			cached.historyRef.current = tram;
			cached.widget.pos = {
				x: [beat.startCol, beat.endCol],
				y: line
			};
			widgets.push(cached.widget);
			continue;
		}
		cache.delete(key);
		let firedAt = beat.linearIndex === 0 ? 0 : -Infinity;
		let elapsed = Infinity;
		let epoch = -1;
		const draw$1 = (c$7, x$4, y$5, w$5, h$5) => {
			reader.run(++epoch);
			if (reader.now < firedAt) firedAt = beat.linearIndex === 0 ? 0 : -Infinity;
			if (reader.state.has(beat.linearIndex)) firedAt = reader.state.get(beat.linearIndex);
			elapsed = reader.now - firedAt;
			impulse(c$7, Math.max(0, 1 - elapsed / latency.value.state.sampleRate), x$4, y$5, w$5, h$5);
		};
		const widget = {
			type: "overlay",
			pos: {
				x: [beat.startCol, beat.endCol],
				y: line
			},
			draw: draw$1
		};
		cache.set(key, {
			doc,
			widget,
			historyRef
		});
		widgets.push(widget);
	}
	return widgets;
}
function toRing(buffer, chunkSize = 128) {
	const length = buffer.length / chunkSize;
	if ((length | 0) !== length) throw new Error("Ring \"buffer\" must be divisible exactly by the \"chunkSize\".");
	return Object.assign(Array.from({ length }, (_$5, x$4) => buffer.subarray(x$4 * chunkSize, (x$4 + 1) * chunkSize)), { buffer });
}
var WaveformBuffer = class {
	buffer;
	writeIdx = 0;
	readChunkPtr = 0;
	initialized = false;
	cachedDisplayBuffer = null;
	cachedWriteIdx = -1;
	out = new Float32Array(8192);
	constructor(size = 32768) {
		this.buffer = new Float32Array(size);
	}
	update(ring, currentChunkPos) {
		if (!ring) return null;
		const ringLength = ring.length;
		const safetyLagChunks = 4;
		const targetBufferChunks = 16;
		const maxReadChunks = 7;
		if (!this.initialized) {
			this.readChunkPtr = (currentChunkPos - safetyLagChunks + ringLength) % ringLength;
			this.initialized = true;
			return null;
		}
		let distance = currentChunkPos - this.readChunkPtr;
		if (distance < 0) distance = ringLength - this.readChunkPtr + currentChunkPos;
		const availableChunks = distance - safetyLagChunks;
		if (availableChunks > 0) {
			const bufferLevel = availableChunks;
			let chunksToRead = 0;
			if (bufferLevel < targetBufferChunks) chunksToRead = Math.min(availableChunks, Math.ceil((targetBufferChunks - bufferLevel) / 2));
			else chunksToRead = Math.min(availableChunks - targetBufferChunks, maxReadChunks);
			if (chunksToRead > 0) {
				for (let c$7 = 0; c$7 < chunksToRead; c$7++) {
					const chunk = ring[(this.readChunkPtr + c$7) % ringLength];
					const remaining = this.buffer.length - this.writeIdx;
					if (remaining >= ring[0].length) {
						this.buffer.set(chunk, this.writeIdx);
						this.writeIdx = (this.writeIdx + ring[0].length) % this.buffer.length;
					} else {
						this.buffer.set(chunk.subarray(0, remaining), this.writeIdx);
						this.buffer.set(chunk.subarray(remaining), 0);
						this.writeIdx = ring[0].length - remaining;
					}
				}
				this.readChunkPtr = (this.readChunkPtr + chunksToRead) % ringLength;
				this.cachedDisplayBuffer = null;
			}
		}
		return this.getDisplayBuffer();
	}
	getDisplayBuffer() {
		if (this.cachedDisplayBuffer && this.cachedWriteIdx === this.writeIdx) return this.cachedDisplayBuffer;
		const samplesToRead = this.out.length;
		const readIdx = (this.writeIdx - samplesToRead + this.buffer.length) % this.buffer.length;
		if (readIdx + samplesToRead <= this.buffer.length) this.out.set(this.buffer.subarray(readIdx, readIdx + samplesToRead));
		else {
			const firstPart = this.buffer.length - readIdx;
			this.out.set(this.buffer.subarray(readIdx), 0);
			this.out.set(this.buffer.subarray(0, samplesToRead - firstPart), firstPart);
		}
		this.cachedDisplayBuffer = this.out;
		this.cachedWriteIdx = this.writeIdx;
		return this.out;
	}
	reset() {
		this.initialized = false;
		this.readChunkPtr = 0;
		this.writeIdx = 0;
	}
};
var LINE_WIDTH$1 = 1.35;
function drawWaveform(c$7, x$4, y$5, w$5, h$5, multiplier, floats, isPlayingThis) {
	const len = floats.length;
	if (len < 2) return 0;
	let max = .001;
	if (isActuallyPlaying.value && isPlayingThis) {
		for (let i$6 = 0; i$6 < w$5; i$6++) {
			const value = floats[floats.length - Math.floor(i$6 / w$5 * len)] ?? 0;
			const abs = Math.abs(value);
			if (abs > max) max = abs;
		}
		const multiplierTarget = 1 / max;
		if (multiplierTarget > multiplier) multiplier += (multiplierTarget - multiplier) * .1;
		else multiplier = multiplierTarget;
	}
	const mid = y$5 + h$5 / 2;
	const amp = h$5 / 2 - 2;
	c$7.strokeStyle = theme.value.yellow;
	c$7.lineWidth = LINE_WIDTH$1;
	c$7.lineCap = "round";
	c$7.lineJoin = "round";
	c$7.beginPath();
	for (let i$6 = 0; i$6 < w$5; i$6++) {
		const sy = mid - clamp11((floats[Math.floor(i$6 / w$5 * len)] ?? 0) * multiplier) * amp;
		if (i$6 === 0) c$7.moveTo(x$4 + i$6, sy);
		else c$7.lineTo(x$4 + i$6, sy);
	}
	c$7.stroke();
	return multiplier;
}
var INV_LN10 = 1 / Math.LN10;
function drawSpectrum(c$7, x$4, y$5, w$5, h$5, floats, animatedHeightsArr, analyserIndex, sampleRate, cacheMap) {
	if (w$5 <= 1 || h$5 <= 1) return;
	if (!waveFFT.value) return;
	w$5 += 1;
	const { fft: fft$1, window: window$1, windowed } = waveFFT.value;
	const fftSize$1 = windowed.length;
	if (floats.length < fftSize$1) return;
	for (let i$6 = 0; i$6 < fftSize$1; i$6++) windowed[i$6] = floats[i$6] * window$1[i$6];
	const result = fft$1.fft(windowed);
	const magnitudes = fft$1.getMagnitudeSpectrum(result);
	const frequencyBinCount = magnitudes.length;
	if (frequencyBinCount <= 1) return;
	const sr = (sampleRate ?? 48e3) | 0;
	const nyquist = Math.max(1, sr / 2);
	const minFreq = 20;
	const maxFreq = Math.min(2e4, nyquist);
	const w0 = w$5 | 0;
	const barCount = Math.max(1, Math.min(256, w0, frequencyBinCount));
	const barWidth = w$5 / barCount;
	let animatedHeights = animatedHeightsArr[analyserIndex];
	if (!animatedHeights || animatedHeights.length !== barCount) {
		animatedHeights = new Float32Array(barCount);
		animatedHeightsArr[analyserIndex] = animatedHeights;
	}
	const minDecibels = -40;
	const maxDecibels = 65;
	const gravity = .025 * h$5;
	const cacheKey = barCount * 1e9 + sr * 1e4 + frequencyBinCount;
	let cache = cacheMap.get(cacheKey);
	if (!cache) {
		const binIndex = new Int32Array(barCount);
		const binFrac = new Float32Array(barCount);
		const ratio = maxFreq / minFreq;
		const logRatio = Math.log(ratio);
		const binScale = (frequencyBinCount - 1) / nyquist;
		const maxIdx = Math.max(0, frequencyBinCount - 2);
		for (let i$6 = 0; i$6 < barCount; i$6++) {
			const t$12 = i$6 / barCount;
			const exact = minFreq * Math.exp(logRatio * t$12) * binScale;
			let idx = Math.floor(exact);
			let frac = exact - idx;
			if (idx < 0) {
				idx = 0;
				frac = 0;
			} else if (idx > maxIdx) {
				idx = maxIdx;
				frac = 1;
			} else if (frac < 0) frac = 0;
			else if (frac > 1) frac = 1;
			binIndex[i$6] = idx;
			binFrac[i$6] = frac;
		}
		cache = {
			barCount,
			sr,
			frequencyBinCount,
			binIndex,
			binFrac,
			prefix: new Float32Array(barCount + 1),
			avgHeights: new Float32Array(barCount)
		};
		cacheMap.set(cacheKey, cache);
	}
	c$7.strokeStyle = theme.value.yellow;
	c$7.beginPath();
	for (let i$6 = 0; i$6 < barCount; i$6++) {
		const idx = cache.binIndex[i$6];
		const frac = cache.binFrac[i$6];
		const value1 = magnitudes[idx];
		const interpolatedValue = value1 + (magnitudes[idx + 1] - value1) * frac;
		const norm = (20 * Math.log(interpolatedValue + 1e-10) * INV_LN10 - minDecibels) / (maxDecibels - minDecibels);
		const targetHeight = (norm < 0 ? 0 : norm > 1 ? 1 : norm) * h$5;
		const currentHeight = animatedHeights[i$6];
		const newHeight = targetHeight > currentHeight ? targetHeight : Math.max(0, currentHeight - gravity);
		animatedHeights[i$6] = newHeight;
		(i$6 + 1) * barWidth;
		const drawHeight = newHeight;
		const bx = x$4 + i$6 * barWidth;
		const by = y$5 + h$5 - drawHeight;
		if (i$6 === 0) c$7.moveTo(bx, by);
		else c$7.lineTo(bx, by);
	}
	c$7.lineJoin = "round";
	c$7.lineCap = "round";
	c$7.lineWidth = LINE_WIDTH$1;
	c$7.stroke();
}
function drawAmplitudeScroller(c$7, floats, x$4, y$5, w$5, h$5, ampCanvasArr, analyserIndex, playbackState, bg) {
	if (w$5 <= 1 || h$5 <= 1) return;
	const dpr = typeof window !== "undefined" ? window.devicePixelRatio || 1 : 1;
	const pxW = Math.max(1, Math.floor(w$5 * dpr));
	const pxH = Math.max(1, Math.floor(h$5 * dpr));
	const key = analyserIndex;
	let st = ampCanvasArr[key];
	const ensureInitialized = (state) => {
		const { canvas, ctx: ctx$1 } = state;
		canvas.width = state.pxW;
		canvas.height = state.pxH;
		ctx$1.imageSmoothingEnabled = false;
		ctx$1.setTransform(1, 0, 0, 1, 0, 0);
		ctx$1.fillStyle = state.bg;
		ctx$1.fillRect(0, 0, state.pxW, state.pxH);
		const cy$1 = state.pxH / 2 | 0;
		ctx$1.strokeStyle = theme.value.yellow;
		ctx$1.lineWidth = LINE_WIDTH$1 * dpr;
		ctx$1.beginPath();
		ctx$1.moveTo(0, cy$1);
		ctx$1.lineTo(state.pxW, cy$1);
		ctx$1.stroke();
	};
	if (!st) {
		const canvas = typeof OffscreenCanvas !== "undefined" ? new OffscreenCanvas(pxW, pxH) : (() => {
			const el = document.createElement("canvas");
			el.width = pxW;
			el.height = pxH;
			return el;
		})();
		const ctx2 = canvas.getContext("2d");
		if (!ctx2) return;
		st = {
			canvas,
			ctx: ctx2,
			pxW,
			pxH,
			dpr,
			col: pxW - 1,
			bg
		};
		ensureInitialized(st);
		ampCanvasArr[key] = st;
	} else if (st.pxW !== pxW || st.pxH !== pxH || st.dpr !== dpr || st.bg !== bg) {
		st.pxW = pxW;
		st.pxH = pxH;
		st.dpr = dpr;
		st.bg = bg;
		st.col = Math.min(st.col, pxW - 1);
		ensureInitialized(st);
	}
	const offscreen = st.canvas;
	const offCtx = st.ctx;
	const N$3 = Math.min(floats.length, 1024);
	const step = w$5 > 300 ? 3 : 1;
	if (playbackState === "running") st.col = (st.col + step) % st.pxW;
	const cy = st.pxH / 2 | 0;
	offCtx.strokeStyle = theme.value.yellow;
	offCtx.lineWidth = LINE_WIDTH$1 * dpr;
	for (let b$4 = 0; b$4 < step; b$4++) {
		const drawX = (st.col + b$4) % st.pxW;
		const sliceStart = Math.floor(b$4 * N$3 / step);
		const sliceEnd = Math.floor((b$4 + 1) * N$3 / step);
		let peak = 0;
		for (let i$6 = sliceStart; i$6 < sliceEnd; i$6++) peak = Math.max(peak, Math.abs(floats[i$6]));
		offCtx.fillStyle = st.bg;
		offCtx.fillRect(drawX, 0, 1, st.pxH);
		offCtx.beginPath();
		offCtx.moveTo(drawX, cy);
		offCtx.lineTo(drawX + 1, cy);
		offCtx.stroke();
		const ampBarHeight = Math.max(1, Math.min(st.pxH, peak * st.pxH));
		const ampY = (st.pxH - ampBarHeight) / 2;
		if (Number.isFinite(peak) && Number.isFinite(ampBarHeight) && Number.isFinite(ampY)) {
			offCtx.fillStyle = peak > 1 ? "#f00" : theme.value.yellow;
			offCtx.fillRect(drawX, ampY, 1, ampBarHeight);
		}
	}
	const smoothing = c$7.imageSmoothingEnabled;
	c$7.imageSmoothingEnabled = false;
	const start = (st.col + step) % st.pxW;
	const w1 = st.pxW - start;
	const dw1 = w$5 * (w1 / st.pxW);
	c$7.drawImage(offscreen, start, 0, w1, st.pxH, x$4, y$5, dw1, h$5);
	if (start > 0) c$7.drawImage(offscreen, 0, 0, start, st.pxH, x$4 + dw1, y$5, w$5 - dw1, h$5);
	c$7.imageSmoothingEnabled = smoothing;
}
function createWaveWidget(history$1, target, doc, type, buffers, animatedHeightsArrMap, ampCanvasArrMap, multiplierMap, isPlayingThis, waveBackground, cache) {
	const startCol = target.source.column;
	const endCol = startCol + getFunctionCallLength(doc.code, target.source.line, target.source.column);
	const line = target.source.line;
	const key = makeWidgetCacheKey("Wave", locToIndex(doc.code, line, startCol), locToIndex(doc.code, line, endCol), history$1.genName, type);
	const cached = cache.get(key);
	if (cached?.doc === doc) {
		cached.historyRef.current = history$1;
		cached.widget.pos = type === "full" ? { y: line } : {
			x: [startCol, endCol],
			y: line
		};
		return cached.widget;
	}
	cache.delete(key);
	const historyRef = { current: history$1 };
	const getBuffer = (idx) => {
		let b$4 = buffers.get(idx);
		if (!b$4) {
			b$4 = new WaveformBuffer();
			buffers.set(idx, b$4);
		}
		return b$4;
	};
	const getAnimatedHeightsArr = (idx) => {
		let arr = animatedHeightsArrMap.get(idx);
		if (!arr) {
			arr = new Array();
			animatedHeightsArrMap.set(idx, arr);
		}
		return arr;
	};
	const getAmpCanvasArr = (idx) => {
		let arr = ampCanvasArrMap.get(idx);
		if (!arr) {
			arr = new Array();
			ampCanvasArrMap.set(idx, arr);
		}
		return arr;
	};
	let ring = null;
	let lastOutRing = null;
	const draw$1 = (c$7, x$4, y$5, w$5, h$5) => {
		const hh = historyRef.current;
		const buffer = getBuffer(hh.index);
		const animatedHeightsArr = getAnimatedHeightsArr(hh.index);
		const ampCanvasArr = getAmpCanvasArr(hh.index);
		let didPaint = false;
		try {
			const outRing = hh.view.getOutputRingView();
			w$5 -= 2;
			if (!outRing || !hh.view.chunkSamples) return;
			if (!ring || lastOutRing !== outRing) {
				lastOutRing = outRing;
				ring = toRing(outRing, hh.view.chunkSamples);
			}
			const floats = buffer.update(ring, hh.view.outputChunkPos);
			if (floats) {
				didPaint = true;
				if (settings.analyserType === "waveform") {
					const multiplier = multiplierMap.get(hh.index) ?? 1;
					const next = drawWaveform(c$7, x$4, y$5, w$5, h$5, multiplier, floats, isPlayingThis.value);
					multiplierMap.set(hh.index, next);
				} else if (settings.analyserType === "spectrum") drawSpectrum(c$7, x$4, y$5, w$5, h$5, floats, animatedHeightsArr, 0, 48e3, /* @__PURE__ */ new Map());
				else if (settings.analyserType === "amplitude") drawAmplitudeScroller(c$7, floats, x$4, y$5, w$5, h$5, ampCanvasArr, 0, isPlaying.value ? "running" : "stopped", waveBackground.value);
			}
		} finally {
			if (!didPaint) {
				c$7.lineWidth = LINE_WIDTH$1;
				c$7.lineCap = "round";
				c$7.lineJoin = "round";
				c$7.strokeStyle = theme.value.yellow;
				c$7.beginPath();
				c$7.moveTo(x$4, y$5 + h$5 / 2);
				c$7.lineTo(x$4 + w$5, y$5 + h$5 / 2);
				c$7.stroke();
			}
		}
	};
	const widget = type === "full" ? {
		type,
		pos: { y: line },
		draw: draw$1
	} : {
		type,
		pos: {
			x: [startCol, endCol],
			y: line
		},
		draw: draw$1
	};
	cache.set(key, {
		doc,
		widget,
		historyRef
	});
	return widget;
}
async function createDspProgramContextImpl(dsp, createWidgets, opts, historiesRefreshed) {
	const program = await dsp.createProgram();
	const doc = opts.doc ?? createDoc(tokenize);
	const result = c$3(null);
	const latency = c$3(program.latency);
	const timeSeconds = c$3(0);
	const histories = c$3([]);
	const userCallHistories = c$3([]);
	const fullResync = c$3(true);
	const waveformBuffers = /* @__PURE__ */ new Map();
	const animatedHeightsArrMap = /* @__PURE__ */ new Map();
	const ampCanvasArrMap = /* @__PURE__ */ new Map();
	const waveformCaches = /* @__PURE__ */ new Map();
	const waveMultiplierMap = /* @__PURE__ */ new Map();
	const widgetsCache = /* @__PURE__ */ new Map();
	const unsubscribeDocChanges = doc.buffer.onChange((change) => {
		if (change.type === "reset") {
			widgetsCache.clear();
			return;
		}
		relocateWidgetCacheKeys(widgetsCache, change.start, change.deletedText.length, change.insertedText.length);
	});
	const tooltipWaveformBuffers = /* @__PURE__ */ new Map();
	const tooltipAnimatedHeightsArrMap = /* @__PURE__ */ new Map();
	const tooltipAmpCanvasArrMap = /* @__PURE__ */ new Map();
	const tooltipWaveformCaches = /* @__PURE__ */ new Map();
	const tooltipWaveMultiplierMap = /* @__PURE__ */ new Map();
	const waveBackground = opts.waveBackground ?? b(() => backgroundColor.value);
	const tooltipWaveBackground = b(() => backgroundColor.value);
	const widgetContext = {
		doc,
		result,
		latency,
		timeSeconds,
		waveformBuffers,
		animatedHeightsArrMap,
		ampCanvasArrMap,
		waveformCaches,
		waveMultiplierMap,
		widgetsCache,
		isPlayingThis: opts.isPlayingThis,
		waveBackground
	};
	const tooltipWidgetContext = {
		doc,
		result,
		latency,
		timeSeconds,
		waveformBuffers: tooltipWaveformBuffers,
		animatedHeightsArrMap: tooltipAnimatedHeightsArrMap,
		ampCanvasArrMap: tooltipAmpCanvasArrMap,
		waveformCaches: tooltipWaveformCaches,
		waveMultiplierMap: tooltipWaveMultiplierMap,
		widgetsCache,
		isPlayingThis: opts.isPlayingThis,
		waveBackground: tooltipWaveBackground
	};
	const dispose = () => {
		unsubscribeDocChanges();
		dsp.stop([program]);
	};
	const p$6 = {
		opts,
		program,
		doc,
		result,
		latency,
		timeSeconds,
		histories,
		userCallHistories,
		widgetContext,
		tooltipWidgetContext,
		fullResync,
		dispose
	};
	m(() => {
		if (!opts.isPlayingThis.value) return;
		tickCount.value;
		o$24(() => {
			program.latency.update();
			latency.value = program.latency;
			timeSeconds.value = program.latency.state.timeSeconds ?? 0;
		});
	});
	m(() => {
		historiesRefreshed.value;
		program.refreshHistories();
		if (program.histories.length > 0 && opts.isPlayingThis.value && isActuallyPlaying.value) {
			histories.value = program.histories;
			userCallHistories.value = program.userCallHistories;
		}
	});
	m(() => {
		doc.widgets = createWidgets(widgetContext, histories.value, userCallHistories.value);
	});
	m(() => {
		shouldSkipSyncPreview.value;
		doc.code;
		const epoch = doc.epoch;
		queueMicrotask(async () => {
			if (epoch !== doc.epoch) return;
			try {
				const ccs = controlPipeline.compileSource(doc.code, { projectId: opts.projectId ?? void 0 });
				result.value = ccs;
				if (ccs.errors.length > 0) {
					doc.errors = computeDocErrors(ccs);
					return;
				} else doc.errors = [];
				if (!shouldSkipSyncPreview.value) {
					dsp.core.preview.setControlCompileSnapshot(ccs);
					const previewResult = dsp.core.preview.runPreview(opts.vmId);
					n(() => {
						histories.value = previewResult.histories;
						userCallHistories.value = previewResult.userCallHistories;
					});
				}
				await program.setControlCompileSnapshot(ccs);
				historiesRefreshed.value++;
			} catch (error$1) {
				doc.errors = computeDocErrors(null, (error$1 instanceof Error ? error$1.message : String(error$1)).split(" in ")[0]);
			}
		});
	});
	return p$6;
}
async function createDspContext() {
	await new Promise(queueMicrotask);
	const dspState = await createDspState({ latencyHint: settings.audioLatency });
	const historiesRefreshed = c$3(0);
	dspState.onHistoriesRefreshed = () => {
		historiesRefreshed.value++;
	};
	const dsp = await createDsp(dspState);
	const targetSeconds = c$3(0);
	const createWidgets = (ctx$1, histories, userCallHistories) => {
		busyBounce();
		const widgets = [];
		if (widgetOptions.showVisuals) {
			const createHistoryWidgets = (h$5, target) => {
				if (h$5.genName === "Ad") widgets.push(createAdWidget(h$5, target, ctx$1.doc, ctx$1.latency, ctx$1.widgetsCache));
				else if (h$5.genName === "Adsr") widgets.push(createAdsrWidget(h$5, target, ctx$1.doc, ctx$1.latency, ctx$1.widgetsCache));
				else if (h$5.genName === "Tram") widgets.push(...createTramWidgets(h$5, target, ctx$1.doc, ctx$1.latency, ctx$1.widgetsCache));
				else if (h$5.genName === "Timeline") widgets.push(...createTimelineWidgets(h$5, target, ctx$1.doc, ctx$1.result, ctx$1.latency, ctx$1.timeSeconds, ctx$1.widgetsCache));
				else if (h$5.genName === "ArrayGet") widgets.push(...createArrayGetWidgets(h$5, target, ctx$1.doc, ctx$1.latency, ctx$1.widgetsCache));
				else if (h$5.genName === "Out" || h$5.genName === "Solo" || h$5.genName === "Analyser" || h$5.genName === "Mix") widgets.push(createWaveWidget(h$5, target, ctx$1.doc, h$5.genName === "Mix" ? "full" : "above", ctx$1.waveformBuffers, ctx$1.animatedHeightsArrMap, ctx$1.ampCanvasArrMap, ctx$1.waveMultiplierMap, ctx$1.isPlayingThis, ctx$1.waveBackground, ctx$1.widgetsCache));
				else if (h$5.genName === "Mini") widgets.push(...createMiniWidgets(h$5, target, dsp, ctx$1.doc, ctx$1.result, ctx$1.latency, ctx$1.timeSeconds, ctx$1.widgetsCache, { noHeader: widgetOptions.noHeader }));
				else if (h$5.genName === "Sampler") widgets.push(createSamplerWidget(h$5, target, dsp, ctx$1.doc, ctx$1.latency, ctx$1.waveformCaches, ctx$1.widgetsCache));
				else if (h$5.genName === "Slicer") widgets.push(createSlicerWidget(h$5, target, dsp, ctx$1.doc, ctx$1.latency, ctx$1.waveformCaches, ctx$1.widgetsCache));
				else if (h$5.genName === "Dattorro" || h$5.genName === "Freeverb" || h$5.genName === "Fdn" || h$5.genName === "Velvet") widgets.push(createReverbWidget(h$5, target, ctx$1.doc, ctx$1.latency, ctx$1.widgetsCache));
				else if (h$5.genName === "Every" || h$5.genName === "At") widgets.push(createEveryWidget(h$5, target, ctx$1.doc, ctx$1.latency, ctx$1.widgetsCache));
				else if (h$5.genName === "Emit") {
					if (h$5 !== target) {
						if ("funcName" in target) {
							if (target.funcName === "ntof") widgets.push(createPianoWidget(h$5, target, ctx$1.doc, ctx$1.latency, ctx$1.widgetsCache));
							else if (target.funcName === "print") widgets.push(createLogWidget(h$5, target, ctx$1.doc, ctx$1.latency, (v$4) => v$4.toFixed(2)));
						}
					}
				} else if (h$5.genName === "Biquad" || h$5.genName === "Biquadshelf" || h$5.genName === "Svf" || h$5.genName === "Onepole" || h$5.genName === "Moog" || h$5.genName === "Diodeladder") {
					const w$5 = createFilterWidget(h$5, target, ctx$1.doc, ctx$1.latency, ctx$1.widgetsCache);
					if (w$5) widgets.push(w$5);
				} else if (h$5.genName === "Compressor") widgets.push(createCompressorWidget(h$5, target, ctx$1.doc, ctx$1.latency, ctx$1.widgetsCache));
				else if (h$5.genName === "Lfosine" || h$5.genName === "Lfotri" || h$5.genName === "Lfosaw" || h$5.genName === "Lforamp" || h$5.genName === "Lfosqr" || h$5.genName === "Lfosah" || h$5.genName === "Inc" || h$5.genName === "Phasor" || h$5.genName === "Fractal" || h$5.genName === "Smooth") widgets.push(createLfoWidget(h$5, target, ctx$1.doc, ctx$1.latency, h$5.genName.startsWith("Lfo") ? h$5.genName.slice(3) : "linear", ctx$1.widgetsCache));
			};
			for (const h$5 of histories.sort((a$36, b$4) => b$4.view.id - a$36.view.id)) createHistoryWidgets(h$5, h$5);
			for (const h$5 of userCallHistories) for (const innerH of h$5.inner.sort((a$36, b$4) => b$4.view.id - a$36.view.id)) createHistoryWidgets(innerH, h$5);
		}
		if (widgetOptions.showKnobs) widgets.push(...createKnobWidgets(ctx$1.doc, ctx$1.result.value, ctx$1.widgetsCache));
		return widgets;
	};
	const tooltipWaveGens = new Set([
		"Out",
		"Solo",
		"Analyser",
		"Mix",
		"Sine",
		"Saw",
		"Sqr",
		"Tri",
		"Pwm",
		"Ramp",
		"Phasor",
		"Inc",
		"Impulse"
	]);
	const createTooltipWidget = (h$5, target = h$5, ctx$1) => {
		if (h$5.genName === "Ad") return createAdWidget(h$5, target, ctx$1.doc, ctx$1.latency, ctx$1.widgetsCache);
		if (h$5.genName === "Adsr") return createAdsrWidget(h$5, target, ctx$1.doc, ctx$1.latency, ctx$1.widgetsCache);
		if (h$5.genName === "Biquad" || h$5.genName === "Biquadshelf" || h$5.genName === "Svf" || h$5.genName === "Onepole" || h$5.genName === "Moog" || h$5.genName === "Diodeladder") return createFilterWidget(h$5, target, ctx$1.doc, ctx$1.latency, ctx$1.widgetsCache);
		if (h$5.genName === "Compressor") return createCompressorWidget(h$5, target, ctx$1.doc, ctx$1.latency, ctx$1.widgetsCache);
		if (tooltipWaveGens.has(h$5.genName)) return createWaveWidget(h$5, target, ctx$1.doc, h$5.genName === "Mix" ? "full" : "above", ctx$1.waveformBuffers, ctx$1.animatedHeightsArrMap, ctx$1.ampCanvasArrMap, ctx$1.waveMultiplierMap, ctx$1.isPlayingThis, ctx$1.waveBackground, ctx$1.widgetsCache);
		if (h$5.genName === "Mini") return createMiniWidgets(h$5, target, dsp, ctx$1.doc, ctx$1.result, ctx$1.latency, ctx$1.timeSeconds, ctx$1.widgetsCache, { noHeader: true }).at(-1) ?? null;
		if (h$5.genName === "Timeline") {
			const arr = createTimelineWidgets(h$5, target, ctx$1.doc, ctx$1.result, ctx$1.latency, ctx$1.timeSeconds, ctx$1.widgetsCache, { noHeader: true });
			return arr.find((w$5) => w$5.type === "full") ?? arr[0] ?? null;
		}
		if (h$5.genName === "Sampler") return createSamplerWidget(h$5, target, dsp, ctx$1.doc, ctx$1.latency, ctx$1.waveformCaches, ctx$1.widgetsCache);
		if (h$5.genName === "Slicer") return createSlicerWidget(h$5, target, dsp, ctx$1.doc, ctx$1.latency, ctx$1.waveformCaches, ctx$1.widgetsCache);
		if (h$5.genName === "Dattorro" || h$5.genName === "Freeverb" || h$5.genName === "Fdn" || h$5.genName === "Velvet") return createReverbWidget(h$5, target, ctx$1.doc, ctx$1.latency, ctx$1.widgetsCache);
		return null;
	};
	const dispose = () => {
		dsp.state.audioContext.close();
	};
	const createDspProgramContext = (opts) => createDspProgramContextImpl(dsp, createWidgets, opts, historiesRefreshed);
	return {
		dispose,
		dsp,
		targetSeconds,
		historiesRefreshed,
		createWidgets,
		createTooltipWidget,
		createDspProgramContext
	};
}
function blendHex(top, bottom, alpha) {
	alpha = Math.max(0, Math.min(1, alpha));
	const parseHex = (hex) => {
		hex = hex.replace(/^#/, "");
		if (hex.length === 3) hex = hex.split("").map((c$7) => c$7 + c$7).join("");
		if (hex.length !== 6) throw new Error(`Invalid hex color: ${hex}`);
		return [
			parseInt(hex.slice(0, 2), 16),
			parseInt(hex.slice(2, 4), 16),
			parseInt(hex.slice(4, 6), 16)
		];
	};
	const [tr, tg, tb] = parseHex(top);
	const [br, bg, bb] = parseHex(bottom);
	const blend = (t$12, b$4) => Math.round(t$12 * alpha + b$4 * (1 - alpha));
	return "#" + [
		blend(tr, br),
		blend(tg, bg),
		blend(tb, bb)
	].map((v$4) => v$4.toString(16).padStart(2, "0")).join("");
}
function createId() {
	let s$4 = "";
	const alphabet = "abcdefghijklmnopqrstuvwxyz0123456789";
	for (let i$6 = 0; i$6 < 8; i$6++) s$4 += alphabet[Math.floor(Math.random() * 36)];
	return s$4;
}
function getDocPath(def) {
	return def.arrayMethod ? `[].${def.name.toLowerCase()}` : def.name.toLowerCase();
}
const definitions = /* @__PURE__ */ new Map();
function definitionToCode(def, withReturn = true) {
	if (def.parameters?.length) {
		const params = (def.arrayMethod ? def.parameters.filter((p$6) => p$6.name !== "array") : def.parameters).map((p$6) => p$6.default !== void 0 && !p$6.name.endsWith("?") ? `${p$6.name}?` : p$6.name);
		return `${def.arrayMethod ? `[].${def.name.toLowerCase()}(${params.join(", ")})` : `${def.name}(${params.join(", ")})`}${withReturn ? ` -> ${def.return ?? "signal"}` : ""}`;
	}
	return def.arrayMethod ? `[].${def.name.toLowerCase()}` : def.name;
}
var getDefinitionFromGen = (name, description, g$5) => {
	return [name, {
		type: "function",
		name,
		category: g$5.category ?? "misc",
		description: [description],
		parameters: g$5.parameters.map((p$6) => ({
			name: p$6.name,
			default: p$6.default,
			min: p$6.min,
			max: p$6.max,
			unit: p$6.unit,
			description: [p$6.description ?? ""]
		}))
	}];
};
for (const g$5 of Object.values(gens)) {
	if ((g$5.category ?? "misc") === "test") continue;
	if (g$5.variants) for (const [name, description] of Object.entries(g$5.variants)) definitions.set(...getDefinitionFromGen(name.toLowerCase(), description ?? "", g$5));
	else definitions.set(...getDefinitionFromGen(g$5.name.toLowerCase(), g$5.description ?? "", g$5));
}
const extra = [
	["t", {
		type: "variable",
		name: "t",
		category: "utilities",
		description: ["BPM adjusted time elapsed: 1 t = 1 bar."],
		parameters: [],
		return: "number"
	}],
	["map", {
		type: "function",
		name: "map",
		arrayMethod: true,
		category: "utilities",
		description: ["Applies a function to each element of an array."],
		return: "array",
		parameters: [{
			name: "fn",
			description: ["The function to apply."],
			type: "function"
		}]
	}],
	["shuffle", {
		type: "function",
		name: "shuffle",
		arrayMethod: true,
		category: "utilities",
		description: ["Shuffles array in place using Fisher-Yates. Optional seed for deterministic shuffle."],
		return: "array",
		parameters: [{
			name: "seed",
			description: ["Random seed for reproducibility."],
			default: 0
		}]
	}],
	["reverse", {
		type: "function",
		name: "reverse",
		arrayMethod: true,
		category: "utilities",
		description: ["Returns a new array with elements in reverse order."],
		return: "array",
		parameters: []
	}],
	["print", {
		type: "function",
		name: "print",
		category: "utilities",
		description: ["Emit value for debugging; returns the value."],
		parameters: [{
			name: "value",
			description: ["Value to emit."]
		}]
	}],
	["play", {
		type: "function",
		name: "play",
		category: "utilities",
		description: ["Multi-voice playback. x is [hz,vel,trig] or array of such. Calls cb(hz,vel,trig) per voice, sums and averages."],
		return: "signal",
		parameters: [
			{
				name: "x",
				description: ["[hz,vel,trig] or array of [hz,vel,trig] per voice."]
			},
			{
				name: "cb",
				description: ["Callback (hz, vel, trig) -> signal."],
				type: "function"
			},
			{
				name: "voices",
				description: ["Number of voices."],
				default: 1
			}
		]
	}],
	["ntof", {
		type: "function",
		name: "ntof",
		category: "utilities",
		description: ["Converts a midi note to a frequency in Hz. Applies transpose and tune from globals."],
		return: "hz",
		parameters: [{
			name: "note",
			min: 0,
			max: 256,
			description: ["The midi note to convert to a frequency in Hz."]
		}]
	}],
	["dtof", {
		type: "function",
		name: "dtof",
		category: "utilities",
		description: ["Degree to frequency: converts scale degree (1-based) to Hz using global scale and root. Desugars to midiToHz(degreeToMidi(...))."],
		return: "hz",
		parameters: [{
			name: "degree",
			description: ["Scale degree (1-based)."]
		}]
	}],
	["#i", {
		type: "variable",
		name: "#i",
		category: "utilities",
		description: ["Roman numeral chord I as Hz array in octave -1. Also #ii..#vii, suffixes like #i7sus2."]
	}],
	["#1", {
		type: "variable",
		name: "#1",
		category: "utilities",
		description: ["Scale degree 1 as Hz scalar in octave -1. Also #2..#9."]
	}],
	["#scale", {
		type: "variable",
		name: "#scale",
		category: "utilities",
		description: ["Full scale degrees 1..N as Hz array in octave -1."]
	}],
	["o0", {
		type: "variable",
		name: "o0",
		category: "utilities",
		description: ["Octave multipliers: o0=1, o1=2, o2=4, ... o11=2048 (2^0..2^11)."]
	}],
	["c4", {
		type: "variable",
		name: "c4",
		category: "utilities",
		description: ["Note names as Hz: c4, e#5, eb3, a-1. Format [a-gA-G][#b]?-?\\d+. User vars shadow."]
	}],
	["scale", {
		type: "variable",
		name: "scale",
		category: "utilities",
		description: ["Set scale by name, e.g: scale='minor'.\n\nDefault: 'major'.\n\nAvailable:\n\n" + Object.keys(SCALE_INTERVALS).join(", ") + "."]
	}],
	["root", {
		type: "variable",
		name: "root",
		category: "utilities",
		description: ["Set root note: root='a4'. Default: c4."]
	}],
	["transpose", {
		type: "variable",
		name: "transpose",
		category: "utilities",
		description: ["Shift pitch by N semitones. Affects c4, # vars, dtof, mini. Default: 0."]
	}],
	["tune", {
		type: "variable",
		name: "tune",
		category: "utilities",
		description: ["Multiply frequencies (e.g. tune=2 = octave up). Default: 1."]
	}],
	["out", {
		type: "function",
		name: "out",
		category: "mixing",
		description: ["Sends a signal to the speakers."],
		parameters: [{
			name: "signal",
			description: ["The signal to send to the speakers."]
		}]
	}],
	["bus", {
		type: "function",
		name: "bus",
		category: "mixing",
		description: ["Read bus: bus(index). Write and accumulate: bus(index, in)."],
		parameters: [{
			name: "index",
			description: ["Bus index 09."]
		}, {
			name: "in",
			description: ["Signal to add (when writing). Omit to read."],
			type: "signal"
		}]
	}],
	["buss", {
		type: "function",
		name: "buss",
		category: "mixing",
		description: ["Solo a signal from a bus."],
		parameters: [{
			name: "index",
			description: ["Bus index."]
		}, {
			name: "in",
			description: ["Signal to solo."]
		}]
	}],
	["outs", {
		type: "function",
		name: "outs",
		category: "mixing",
		description: ["Alias for `solo`."],
		parameters: [{
			name: "signal",
			description: ["The signal to solo."]
		}]
	}],
	["solo", {
		type: "function",
		name: "solo",
		category: "mixing",
		description: ["Solo a signal."],
		parameters: [{
			name: "signal",
			description: ["The signal to solo."]
		}]
	}],
	["sout", {
		type: "function",
		name: "sout",
		category: "mixing",
		description: ["Alias for solo. Solo a signal."],
		parameters: [{
			name: "signal",
			description: ["The signal to solo."]
		}]
	}],
	["mini", {
		type: "function",
		name: "mini",
		category: "sequencers",
		description: ["Plays a sequence of notes."],
		parameters: [{
			name: "sequence",
			description: ["The sequence of notes to play."]
		}, {
			name: "bars",
			description: ["The number of bars to fit the sequence in."]
		}]
	}],
	["tram", {
		type: "function",
		name: "tram",
		category: "sequencers",
		description: ["Plays a sequence of beats."],
		parameters: [{
			name: "sequence",
			description: ["The sequence of beats to play."]
		}, {
			name: "bars",
			description: ["The number of bars to fit the sequence in."]
		}]
	}],
	["label", {
		type: "function",
		name: "label",
		category: "sequencers",
		description: ["Compile-time only. Creates a label for timeline header/minimap visualization. Bar 1-based: label(1, 'intro'), label(5, 'verse', 2). Color 05, default 1."],
		parameters: [
			{
				name: "bar",
				description: ["Bar position (1-based)."],
				type: "number"
			},
			{
				name: "text",
				description: ["Label text."],
				type: "string"
			},
			{
				name: "color",
				description: ["Theme color index 05."],
				default: 1,
				min: 0,
				max: 5,
				type: "number"
			}
		]
	}],
	["timeline", {
		type: "function",
		name: "timeline",
		category: "sequencers",
		description: ["Value curve over time. Pattern: value pairs and glides, e.g. `0,0 1,1` (hold 0, glide to 1). Use `-` for one-shot (no wrap). Outputs 01. Color 05."],
		parameters: [{
			name: "pattern",
			description: ["Pattern string: space-separated segments. Each segment is `value` (hold) or `from,to` (glide). Optional `-` for no wrap."]
		}, {
			name: "color",
			description: ["Optional theme color index 05: red, green, yellow, blue, purple, cyan."],
			default: 1,
			min: 0,
			max: 5,
			type: "number"
		}],
		return: "signal"
	}],
	["oversample", {
		type: "function",
		name: "oversample",
		category: "utilities",
		description: ["Oversamples a function by a factor."],
		parameters: [{
			name: "factor",
			description: ["The factor to oversample by. Must be a scalar."]
		}, {
			name: "fn",
			type: "function",
			description: ["The function to oversample."]
		}]
	}],
	["record", {
		type: "function",
		name: "record",
		category: "samplers",
		description: ["Records a function."],
		parameters: [{
			name: "duration: seconds",
			description: ["The duration of the recording in seconds."]
		}, {
			name: "fn: () -> signal",
			description: ["The function to record."]
		}]
	}],
	["Walk", {
		type: "function",
		name: "Walk",
		arrayMethod: true,
		category: "sequencers",
		description: ["Tempo-synced walk over an array."],
		parameters: [
			{
				name: "array",
				description: ["Array to walk."]
			},
			{
				name: "bar",
				description: ["Bars per step."]
			},
			{
				name: "swing",
				description: ["Optional swing amount."]
			},
			{
				name: "offset",
				description: ["Optional phase offset."]
			}
		]
	}],
	["Step", {
		type: "function",
		name: "Step",
		arrayMethod: true,
		category: "sequencers",
		description: ["Step through array on each trigger."],
		parameters: [{
			name: "array",
			description: ["Array to step."]
		}, {
			name: "trig",
			description: ["Trigger impulse."]
		}]
	}],
	["Random", {
		type: "function",
		name: "Random",
		arrayMethod: true,
		category: "sequencers",
		description: ["Pick a random element from the array on trigger."],
		return: "signal",
		parameters: [{
			name: "trig",
			description: ["Trigger. On rising edge, pick new element."]
		}, {
			name: "seed",
			description: ["Seed for deterministic random."],
			default: 0
		}]
	}],
	["Glide", {
		type: "function",
		name: "Glide",
		arrayMethod: true,
		category: "sequencers",
		description: ["Tempo-synced glide through array. Steps through elements over bar length, interpolates between consecutive elements with curve. Wraps index."],
		return: "signal",
		parameters: [{
			name: "bar",
			description: ["Length of each step in bars."]
		}, {
			name: "exponent",
			description: ["Interpolation curve."],
			default: 1
		}]
	}],
	["alloc", {
		type: "function",
		name: "alloc",
		category: "utilities",
		description: ["Allocate a buffer for the given duration in seconds."],
		parameters: [{
			name: "seconds",
			description: ["Buffer length in seconds."]
		}]
	}],
	["write", {
		type: "function",
		name: "write",
		category: "utilities",
		description: ["Write input signal into buffer."],
		parameters: [{
			name: "input",
			description: ["Input signal."]
		}, {
			name: "buffer",
			description: ["Buffer from alloc()."]
		}]
	}],
	["read", {
		type: "function",
		name: "read",
		category: "utilities",
		description: ["Read from buffer at time offset in seconds."],
		parameters: [{
			name: "buffer",
			description: ["Buffer from alloc()."]
		}, {
			name: "offset",
			description: ["Read position in seconds."]
		}]
	}],
	["freesound", {
		type: "function",
		name: "freesound",
		category: "samplers",
		description: ["Load sample by Freesound ID."],
		parameters: [{
			name: "id",
			description: ["Freesound sample ID."]
		}]
	}],
	["espeak", {
		type: "function",
		name: "espeak",
		category: "samplers",
		description: ["Text-to-speech using eSpeak."],
		return: "sample",
		parameters: [
			{
				name: "text",
				description: ["Text to speak. Must be a literal string."],
				type: "string"
			},
			{
				name: "variant",
				description: ["Variants: m1 m2 m3 m4 m5 m6 m7 f1 f2 f3 f4 f5 croak klatt klatt2 klatt3 whisper whisperf"],
				default: "m1",
				type: "string"
			},
			{
				name: "speed",
				description: ["Speech rate."],
				default: .5,
				min: 0,
				max: 1,
				type: "number",
				unit: "normal"
			},
			{
				name: "pitch",
				description: ["Pitch."],
				default: .5,
				min: 0,
				max: 1,
				type: "number",
				unit: "normal"
			}
		]
	}],
	["sam", {
		type: "function",
		name: "sam",
		category: "samplers",
		description: ["Classic SAM (Software Automatic Mouth) speech synthesis."],
		return: "sample",
		parameters: [
			{
				name: "text",
				description: ["Text to speak"],
				type: "string"
			},
			{
				name: "pitch",
				description: ["Pitch."],
				default: .5,
				min: 0,
				max: 1,
				type: "number",
				unit: "normal"
			},
			{
				name: "speed",
				description: ["Speed."],
				default: .5,
				min: 0,
				max: 1,
				type: "number",
				unit: "normal"
			},
			{
				name: "mouth",
				description: ["Mouth shape."],
				default: .5,
				min: 0,
				max: 1,
				type: "number",
				unit: "normal"
			},
			{
				name: "throat",
				description: ["Throat shape."],
				default: .5,
				min: 0,
				max: 1,
				type: "number",
				unit: "normal"
			},
			{
				name: "singmode",
				description: ["Sing mode."],
				min: 0,
				max: 1,
				type: "number",
				unit: "normal"
			},
			{
				name: "phonetic",
				description: ["Phonetic input flag."],
				default: 0,
				min: 0,
				max: 1,
				type: "number",
				unit: "flag"
			}
		]
	}],
	["isundefined", {
		type: "function",
		name: "isundefined",
		category: "utilities",
		description: ["True if value is undefined."],
		parameters: [{
			name: "value",
			description: ["Value to check."]
		}]
	}],
	["isscalar", {
		type: "function",
		name: "isscalar",
		category: "utilities",
		description: ["True if value is a scalar."],
		parameters: [{
			name: "value",
			description: ["Value to check."]
		}]
	}],
	["isaudio", {
		type: "function",
		name: "isaudio",
		category: "utilities",
		description: ["True if value is an audio rate signal."],
		parameters: [{
			name: "value",
			description: ["Value to check."]
		}]
	}],
	["isarray", {
		type: "function",
		name: "isarray",
		category: "utilities",
		description: ["True if value is an array."],
		parameters: [{
			name: "value",
			description: ["Value to check."]
		}]
	}],
	["isfunction", {
		type: "function",
		name: "isfunction",
		category: "utilities",
		description: ["True if value is a function."],
		parameters: [{
			name: "value",
			description: ["Value to check."]
		}]
	}],
	["avg", {
		type: "function",
		name: "avg",
		category: "utilities",
		description: ["Average of array elements."],
		parameters: [{
			name: "array",
			description: ["Array of numbers."]
		}]
	}],
	["delay", {
		type: "function",
		name: "delay",
		category: "effects",
		description: ["Delay effect."],
		parameters: [
			{
				name: "input",
				description: ["Input signal"]
			},
			{
				name: "seconds",
				description: ["Delay time"],
				default: .5,
				min: 0,
				max: "size",
				unit: "s"
			},
			{
				name: "feedback",
				description: ["Feedback amount"],
				default: 0,
				unit: "normal"
			},
			{
				name: "cb",
				description: ["Feedback callback"],
				default: "x -> x",
				unit: "callback"
			},
			{
				name: "size",
				description: ["Buffer size"],
				default: 1,
				unit: "s"
			}
		]
	}],
	["tube", {
		type: "function",
		name: "tube",
		category: "effects",
		description: ["Soft saturation / tube-style distortion."],
		parameters: [
			{
				name: "in",
				description: ["Input signal."]
			},
			{
				name: "drive",
				description: ["Drive amount."],
				default: 3
			},
			{
				name: "bias",
				description: ["DC bias."],
				default: .2
			}
		]
	}],
	["moddelay", {
		type: "function",
		name: "moddelay",
		category: "effects",
		description: ["Modulated delay with LFO-controlled delay time."],
		parameters: [
			{
				name: "in",
				description: ["Input signal."]
			},
			{
				name: "base",
				description: ["Base delay time in seconds."]
			},
			{
				name: "depth",
				description: ["LFO modulation depth."]
			},
			{
				name: "rate",
				description: ["LFO rate."]
			},
			{
				name: "feedback",
				description: ["Feedback amount."]
			},
			{
				name: "offset",
				description: ["LFO phase offset."],
				default: 0
			}
		]
	}],
	["flanger", {
		type: "function",
		name: "flanger",
		category: "effects",
		description: ["Classic flanger (modulated comb filter)."],
		parameters: [
			{
				name: "in",
				description: ["Input signal."]
			},
			{
				name: "rate",
				description: ["Modulation rate."],
				default: 1
			},
			{
				name: "depth",
				description: ["Modulation depth."],
				default: .00125
			},
			{
				name: "base",
				description: ["Base delay time."],
				default: .00125
			},
			{
				name: "feedback",
				description: ["Feedback amount."],
				default: .7
			}
		]
	}],
	["chorus", {
		type: "function",
		name: "chorus",
		category: "effects",
		description: ["Multi-voice chorus with spread and modulation."],
		parameters: [
			{
				name: "in",
				description: ["Input signal."]
			},
			{
				name: "voices",
				description: ["Number of chorus voices."],
				default: 3
			},
			{
				name: "base",
				description: ["Base delay time."],
				default: .02
			},
			{
				name: "depth",
				description: ["Modulation depth."],
				default: .006
			},
			{
				name: "rate",
				description: ["Modulation rate."],
				default: .25
			},
			{
				name: "spread",
				description: ["Phase spread between voices."],
				default: .5
			}
		]
	}],
	["karplus", {
		type: "function",
		name: "karplus",
		category: "synths",
		description: ["Karplus-Strong plucked string synthesis."],
		parameters: [
			{
				name: "hz",
				description: ["Frequency."]
			},
			{
				name: "pluck",
				description: ["Pluck source (default pink)."]
			},
			{
				name: "seed",
				description: ["Random seed."]
			},
			{
				name: "attack",
				description: ["Attack time."]
			},
			{
				name: "decay",
				description: ["Decay time."]
			},
			{
				name: "exponent",
				description: ["Decay curve."]
			},
			{
				name: "damping",
				description: ["Damping amount."]
			},
			{
				name: "trig",
				description: ["Trigger."]
			}
		]
	}],
	["rhodes", {
		type: "function",
		name: "rhodes",
		category: "synths",
		description: ["Rhodes-style electric piano. Tine FM, tone-bar resonances, chorus."],
		parameters: [
			{
				name: "hz",
				description: ["Frequency."]
			},
			{
				name: "vel",
				description: ["Velocity 01."],
				default: 1
			},
			{
				name: "trig",
				description: ["Trigger."]
			}
		]
	}],
	["rhodes70", {
		type: "function",
		name: "rhodes70",
		category: "synths",
		description: ["Vintage Rhodes-style (70s): purer fundamental, tone-bar resonances, subtle chorus."],
		parameters: [
			{
				name: "hz",
				description: ["Frequency."]
			},
			{
				name: "vel",
				description: ["Velocity 01."],
				default: 1
			},
			{
				name: "trig",
				description: ["Trigger."]
			}
		]
	}],
	["supersaw", {
		type: "function",
		name: "supersaw",
		category: "synths",
		description: ["Supersaw oscillator with detuned voices."],
		parameters: [
			{
				name: "hz",
				description: ["Frequency."]
			},
			{
				name: "voices",
				description: ["Number of detuned voices."],
				default: 5
			},
			{
				name: "spread",
				description: ["Detune spread."],
				default: .05
			}
		]
	}],
	["bdsynth", {
		type: "function",
		name: "bdsynth",
		category: "synths",
		description: ["Kick/bass drum synth. Used internally by bd()."],
		parameters: [
			{
				name: "base",
				description: ["Base frequency."],
				default: "ntof(60)"
			},
			{
				name: "punch",
				description: ["Punch frequency."],
				default: "25000k"
			},
			{
				name: "offset",
				description: ["Pitch offset."],
				default: 6e-4
			},
			{
				name: "cutoff",
				description: ["Filter cutoff."],
				default: "5k"
			},
			{
				name: "q",
				description: ["Filter Q."],
				default: .25
			},
			{
				name: "amp",
				description: ["Amp envelope (trig -> signal)."]
			},
			{
				name: "fm",
				description: ["FM envelope (trig -> signal)."]
			},
			{
				name: "filter",
				description: ["Filter envelope (trig -> signal)."]
			},
			{
				name: "trig",
				description: ["Trigger pattern."],
				default: "tram('x-x-x-x-')"
			}
		]
	}],
	["bd", {
		type: "function",
		name: "bd",
		category: "synths",
		description: ["Kick drum. Records bdsynth and plays back on trigger."],
		parameters: [{
			name: "trig",
			description: ["Trigger. Default every 1/4 bar."],
			default: "every(1/4)"
		}]
	}],
	["hhsynth", {
		type: "function",
		name: "hhsynth",
		category: "synths",
		description: ["Hi-hat synthesis. Used by ch and oh."],
		parameters: [{
			name: "width",
			description: ["Pulse width."],
			default: .4
		}, {
			name: "trig",
			description: ["Trigger."]
		}]
	}],
	["ch", {
		type: "function",
		name: "ch",
		category: "synths",
		description: ["Closed hi-hat. Recorded hhsynth, played on trigger."],
		parameters: [{
			name: "width",
			description: ["Hi-hat width."],
			default: .9
		}, {
			name: "trig",
			description: ["Trigger pattern."],
			default: "tram('xxxx',1/4)"
		}]
	}],
	["oh", {
		type: "function",
		name: "oh",
		category: "synths",
		description: ["Open hi-hat."],
		parameters: [{
			name: "width",
			description: ["Hi-hat width."],
			default: .4
		}, {
			name: "trig",
			description: ["Trigger pattern."],
			default: "tram('-x',1/4)"
		}]
	}],
	["sdsynth", {
		type: "function",
		name: "sdsynth",
		category: "synths",
		description: ["Snare drum synthesis. Used by sd."],
		parameters: [
			{
				name: "seed",
				description: ["Random seed."],
				default: 7
			},
			{
				name: "base",
				description: ["Base frequency."],
				default: "ntof(70)"
			},
			{
				name: "trig",
				description: ["Trigger."],
				default: "step(1-phasor(1),.9)"
			}
		]
	}],
	["sd", {
		type: "function",
		name: "sd",
		category: "synths",
		description: ["Snare drum. Recorded sdsynth, played on trigger."],
		parameters: [{
			name: "seed",
			description: ["Random seed."]
		}, {
			name: "trig",
			description: ["Trigger pattern."],
			default: "tram('-x',1/2)"
		}]
	}],
	["drums", {
		type: "function",
		name: "drums",
		category: "synths",
		description: ["Full drum kit: kick, snare, closed hi-hat, open hi-hat."],
		parameters: [{
			name: "seed",
			description: ["Random seed for variation."],
			default: 1
		}]
	}],
	["mix", {
		type: "variable",
		name: "mix",
		category: "utilities",
		description: ["Mix bus; receives the main mix."]
	}],
	["bpm", {
		type: "variable",
		name: "bpm",
		category: "utilities",
		description: ["Global BPM (default 120)."]
	}],
	["sin", {
		type: "function",
		name: "sin",
		category: "math",
		description: ["Sine."],
		parameters: [{
			name: "x",
			description: ["Radians."]
		}]
	}],
	["cos", {
		type: "function",
		name: "cos",
		category: "math",
		description: ["Cosine."],
		parameters: [{
			name: "x",
			description: ["Radians."]
		}]
	}],
	["tan", {
		type: "function",
		name: "tan",
		category: "math",
		description: ["Tangent."],
		parameters: [{
			name: "x",
			description: ["Radians."]
		}]
	}],
	["asin", {
		type: "function",
		name: "asin",
		category: "math",
		description: ["Arc sine."],
		parameters: [{
			name: "x",
			description: ["Value in [-1,1]."]
		}]
	}],
	["acos", {
		type: "function",
		name: "acos",
		category: "math",
		description: ["Arc cosine."],
		parameters: [{
			name: "x",
			description: ["Value in [-1,1]."]
		}]
	}],
	["atan", {
		type: "function",
		name: "atan",
		category: "math",
		description: ["Arc tangent."],
		parameters: [{
			name: "x",
			description: ["Value."]
		}]
	}],
	["tanh", {
		type: "function",
		name: "tanh",
		category: "math",
		description: ["Hyperbolic tangent."],
		parameters: [{
			name: "x",
			description: ["Value."]
		}]
	}],
	["abs", {
		type: "function",
		name: "abs",
		category: "math",
		description: ["Absolute value."],
		parameters: [{
			name: "x",
			description: ["Value."]
		}]
	}],
	["sqrt", {
		type: "function",
		name: "sqrt",
		category: "math",
		description: ["Square root."],
		parameters: [{
			name: "x",
			description: ["Value."]
		}]
	}],
	["square", {
		type: "function",
		name: "square",
		category: "math",
		description: ["x squared."],
		parameters: [{
			name: "x",
			description: ["Value."]
		}]
	}],
	["cube", {
		type: "function",
		name: "cube",
		category: "math",
		description: ["x cubed."],
		parameters: [{
			name: "x",
			description: ["Value."]
		}]
	}],
	["log", {
		type: "function",
		name: "log",
		category: "math",
		description: ["Natural logarithm."],
		parameters: [{
			name: "x",
			description: ["Value."]
		}]
	}],
	["exp", {
		type: "function",
		name: "exp",
		category: "math",
		description: ["e to the power of x."],
		parameters: [{
			name: "x",
			description: ["Value."]
		}]
	}],
	["log10", {
		type: "function",
		name: "log10",
		category: "math",
		description: ["Base-10 logarithm."],
		parameters: [{
			name: "x",
			description: ["Value."]
		}]
	}],
	["log2", {
		type: "function",
		name: "log2",
		category: "math",
		description: ["Base-2 logarithm."],
		parameters: [{
			name: "x",
			description: ["Value."]
		}]
	}],
	["exp2", {
		type: "function",
		name: "exp2",
		category: "math",
		description: ["2 to the power of x."],
		parameters: [{
			name: "x",
			description: ["Value."]
		}]
	}],
	["floor", {
		type: "function",
		name: "floor",
		category: "math",
		description: ["Round down."],
		parameters: [{
			name: "x",
			description: ["Value."]
		}]
	}],
	["ceil", {
		type: "function",
		name: "ceil",
		category: "math",
		description: ["Round up."],
		parameters: [{
			name: "x",
			description: ["Value."]
		}]
	}],
	["round", {
		type: "function",
		name: "round",
		category: "math",
		description: ["Round to nearest."],
		parameters: [{
			name: "x",
			description: ["Value."]
		}]
	}],
	["trunc", {
		type: "function",
		name: "trunc",
		category: "math",
		description: ["Truncate toward zero."],
		parameters: [{
			name: "x",
			description: ["Value."]
		}]
	}],
	["fract", {
		type: "function",
		name: "fract",
		category: "math",
		description: ["Fractional part."],
		parameters: [{
			name: "x",
			description: ["Value."]
		}]
	}],
	["sign", {
		type: "function",
		name: "sign",
		category: "math",
		description: ["Sign of x (-1, 0, or 1)."],
		parameters: [{
			name: "x",
			description: ["Value."]
		}]
	}],
	["isnan", {
		type: "function",
		name: "isnan",
		category: "math",
		description: ["1 if x is NaN. 0 otherwise."],
		return: "1 | 0",
		parameters: [{
			name: "x",
			description: ["Value."]
		}]
	}],
	["isinf", {
		type: "function",
		name: "isinf",
		category: "math",
		description: ["1 if x is infinite. 0 otherwise."],
		return: "1 | 0",
		parameters: [{
			name: "x",
			description: ["Value."]
		}]
	}],
	["heaviside", {
		type: "function",
		name: "heaviside",
		category: "math",
		description: ["Step function: 0 if x<0 else 1."],
		parameters: [{
			name: "x",
			description: ["Value."]
		}]
	}],
	["min", {
		type: "function",
		name: "min",
		category: "math",
		description: ["Minimum of x and y."],
		parameters: [{
			name: "x",
			description: ["Value."]
		}, {
			name: "y",
			description: ["Value."]
		}]
	}],
	["max", {
		type: "function",
		name: "max",
		category: "math",
		description: ["Maximum of x and y."],
		parameters: [{
			name: "x",
			description: ["Value."]
		}, {
			name: "y",
			description: ["Value."]
		}]
	}],
	["hypot", {
		type: "function",
		name: "hypot",
		category: "math",
		description: ["Hypotenuse sqrt(x*x+y*y)."],
		parameters: [{
			name: "x",
			description: ["Value."]
		}, {
			name: "y",
			description: ["Value."]
		}]
	}],
	["mod", {
		type: "function",
		name: "mod",
		category: "math",
		description: ["Modulo."],
		parameters: [{
			name: "x",
			description: ["Value."]
		}, {
			name: "y",
			description: ["Divisor."]
		}]
	}],
	["snap", {
		type: "function",
		name: "snap",
		category: "math",
		description: ["Snap x to nearest multiple of y."],
		parameters: [{
			name: "x",
			description: ["Value."]
		}, {
			name: "y",
			description: ["Grid size."]
		}]
	}],
	["step", {
		type: "function",
		name: "step",
		category: "math",
		description: ["0 if x < edge else 1."],
		parameters: [{
			name: "edge",
			description: ["Threshold."]
		}, {
			name: "x",
			description: ["Value."]
		}]
	}],
	["safediv", {
		type: "function",
		name: "safediv",
		category: "math",
		description: ["Division; 0 if y is 0."],
		parameters: [{
			name: "x",
			description: ["Numerator."]
		}, {
			name: "y",
			description: ["Denominator."]
		}]
	}],
	["swing", {
		type: "function",
		name: "swing",
		category: "math",
		description: ["Swing amount."],
		parameters: [{
			name: "x",
			description: ["Phase."]
		}, {
			name: "y",
			description: ["Amount."]
		}]
	}],
	["clamp", {
		type: "function",
		name: "clamp",
		category: "math",
		description: ["Clamp x to [lo, hi]."],
		parameters: [
			{
				name: "x",
				description: ["Value."]
			},
			{
				name: "lo",
				description: ["Min."]
			},
			{
				name: "hi",
				description: ["Max."]
			}
		]
	}],
	["lerp", {
		type: "function",
		name: "lerp",
		category: "math",
		description: ["Linear interpolation."],
		parameters: [
			{
				name: "a",
				description: ["Start."]
			},
			{
				name: "b",
				description: ["End."]
			},
			{
				name: "t",
				description: ["Factor 0..1."]
			}
		]
	}],
	["wrap", {
		type: "function",
		name: "wrap",
		category: "math",
		description: ["Wrap x into [lo, hi)."],
		parameters: [
			{
				name: "x",
				description: ["Value."]
			},
			{
				name: "lo",
				description: ["Min."]
			},
			{
				name: "hi",
				description: ["Max."]
			}
		]
	}],
	["pingpong", {
		type: "function",
		name: "pingpong",
		category: "math",
		description: ["Ping-pong between lo and hi."],
		parameters: [
			{
				name: "x",
				description: ["Value."]
			},
			{
				name: "lo",
				description: ["Min."]
			},
			{
				name: "hi",
				description: ["Max."]
			}
		]
	}],
	["fold", {
		type: "function",
		name: "fold",
		category: "math",
		description: ["Fold x into [lo, hi]."],
		parameters: [
			{
				name: "x",
				description: ["Value."]
			},
			{
				name: "lo",
				description: ["Min."]
			},
			{
				name: "hi",
				description: ["Max."]
			}
		]
	}],
	["smoothstep", {
		type: "function",
		name: "smoothstep",
		category: "math",
		description: ["Smooth Hermite step."],
		parameters: [
			{
				name: "edge0",
				description: ["Start edge."]
			},
			{
				name: "edge1",
				description: ["End edge."]
			},
			{
				name: "x",
				description: ["Value."]
			}
		]
	}],
	["smootherstep", {
		type: "function",
		name: "smootherstep",
		category: "math",
		description: ["Smoother step (5th order)."],
		parameters: [
			{
				name: "edge0",
				description: ["Start edge."]
			},
			{
				name: "edge1",
				description: ["End edge."]
			},
			{
				name: "x",
				description: ["Value."]
			}
		]
	}],
	["select", {
		type: "function",
		name: "select",
		category: "math",
		description: ["a if cond else b."],
		parameters: [
			{
				name: "cond",
				description: ["Condition."]
			},
			{
				name: "a",
				description: ["If true."]
			},
			{
				name: "b",
				description: ["If false."]
			}
		]
	}],
	["dec", {
		type: "function",
		name: "dec",
		category: "math",
		description: ["Decrement from offset to floor at hz rate, trigger reset."],
		parameters: [
			{
				name: "hz",
				description: ["Rate."],
				default: 1
			},
			{
				name: "floor",
				description: ["Floor value."],
				default: 0
			},
			{
				name: "offset",
				description: ["Value on trigger."],
				default: 1
			},
			{
				name: "trig",
				description: ["Trigger impulse."]
			}
		]
	}]
];
extra.forEach(([name, definition]) => {
	definitions.set(name, definition);
});
for (const def of definitions.values()) if (def.arrayMethod) definitions.set(getDocPath(def), def);
function getDefinitionByDocPath(docPath) {
	const decoded = decodeURIComponent(docPath);
	return definitions.get(decoded) ?? definitions.get(decoded.toLowerCase());
}
const gens$1 = c$3(gens);
queueMicrotask(() => {
	for (const [name, def] of extra) gens$1.value[def.name] = {
		name: def.name,
		category: def.category,
		description: def.description.join("\n"),
		parameters: def.parameters?.map((p$6) => ({
			name: p$6.name,
			description: p$6.description.join("\n")
		})) ?? []
	};
	gens$1.value = Object.fromEntries(Object.entries(gens$1.value).filter(([, g$5]) => (g$5.category ?? "misc") !== "test"));
});
const nameToGenMap = b(() => new Map(Object.entries(gens$1.value).flatMap(([name, gen]) => gen.variants ? Object.entries(gen.variants).map(([variantName, description]) => [variantName.toLowerCase(), {
	...gen,
	description
}]) : [[name.toLowerCase(), gen]])));
function toPascalCase(s$4) {
	return s$4.charAt(0).toUpperCase() + s$4.slice(1).toLowerCase();
}
function withPeriod(s$4) {
	const t$12 = s$4.trimEnd();
	if (!t$12 || /[.!?]$/.test(t$12)) return s$4;
	return t$12 + ".";
}
var VISUAL_HEIGHT = 35;
var VISUAL_SPACING = 0;
var AUTCOMPLETE_GAP = 8;
var AUTCOMPLETE_ITEM_HEIGHT = 20;
var AUTCOMPLETE_PADDING = 8;
var AUTCOMPLETE_MAX_ITEMS = 12;
const autocompleteState = {
	visible: false,
	selectedIndex: -1,
	matches: [],
	replaceStart: {
		line: 0,
		column: 0
	},
	replaceEnd: {
		line: 0,
		column: 0
	},
	doc: null
};
function collectMatches(docCode, prefix) {
	const set = /* @__PURE__ */ new Set();
	for (const name of definitions.keys()) if (prefix === "" || name.startsWith(prefix)) set.add(name);
	const tokenLines = tokenize(docCode);
	for (const line of tokenLines) for (const t$12 of line) if ((t$12.type === "identifier" || t$12.type === "function") && t$12.text && (prefix === "" || t$12.text.startsWith(prefix))) set.add(t$12.text);
	set.delete(prefix);
	return [...set].sort();
}
function drawAutocompleteList(overlayCanvas, anchorX, y$5, matches, selectedIndex, editor$1, leftAlignedBelow) {
	if (matches.length === 0) return 0;
	const { c: c$7 } = overlayCanvas;
	const settings$1 = editor$1.settings;
	const caches = createSimpleCache();
	const codeFont = `${settings$1.fontSize} '${settings$1.fontFamilyName}', monospace`;
	c$7.font = codeFont;
	let maxW = 0;
	for (const m$5 of matches) {
		const w$6 = measureText(c$7, settings$1, caches, {
			text: m$5,
			type: "identifier"
		}).width;
		maxW = Math.max(maxW, w$6);
	}
	const listWidth = maxW + AUTCOMPLETE_PADDING * 2;
	const visibleCount = Math.min(matches.length, AUTCOMPLETE_MAX_ITEMS);
	const listHeight = visibleCount * AUTCOMPLETE_ITEM_HEIGHT + AUTCOMPLETE_PADDING * 2;
	const listY = y$5 + settings$1.lineHeight;
	const listX = leftAlignedBelow ? anchorX : anchorX - listWidth;
	const viewport = window.visualViewport;
	const MARGIN$1 = 4;
	const left = Math.max(viewport.offsetLeft + MARGIN$1, listX);
	const top = Math.max(viewport.offsetTop + MARGIN$1, listY);
	const right = Math.min(viewport.offsetLeft + viewport.width - MARGIN$1, listX + listWidth);
	const bottom = Math.min(viewport.offsetTop + viewport.height - MARGIN$1, listY + listHeight);
	const w$5 = right - left;
	const h$5 = bottom - top;
	if (w$5 <= 0 || h$5 <= 0) return listWidth;
	c$7.save();
	c$7.fillStyle = backgroundColor.value;
	c$7.strokeStyle = grayColor.value;
	c$7.lineWidth = 1.35;
	drawRoundedRect(c$7, left, top, w$5, h$5, 6);
	c$7.fill();
	c$7.stroke();
	c$7.font = codeFont;
	c$7.textBaseline = "middle";
	for (let i$6 = 0; i$6 < visibleCount; i$6++) if (selectedIndex >= 0 && (selectedIndex % matches.length + matches.length) % matches.length === i$6) {
		const selY = top + AUTCOMPLETE_PADDING + i$6 * AUTCOMPLETE_ITEM_HEIGHT;
		c$7.fillStyle = "#ffffff18";
		c$7.fillRect(left + 2, selY, w$5 - 4, AUTCOMPLETE_ITEM_HEIGHT);
	}
	for (let i$6 = 0; i$6 < visibleCount; i$6++) {
		const text = matches[i$6];
		const itemY = top + AUTCOMPLETE_PADDING + i$6 * AUTCOMPLETE_ITEM_HEIGHT + AUTCOMPLETE_ITEM_HEIGHT / 2;
		c$7.fillStyle = selectedIndex >= 0 && (selectedIndex % matches.length + matches.length) % matches.length === i$6 ? secondaryColor.value : textColor.value;
		c$7.fillText(text, left + AUTCOMPLETE_PADDING, itemY);
	}
	c$7.restore();
	return listWidth;
}
var tooltipWidgetCache = null;
function wrapText(c$7, text, maxWidth, font) {
	c$7.save();
	c$7.font = font;
	const words = text.split(" ");
	const lines = [];
	let currentLine = "";
	for (const word of words) {
		const testLine = currentLine ? `${currentLine} ${word}` : word;
		if (c$7.measureText(testLine).width > maxWidth && currentLine) {
			lines.push(currentLine);
			currentLine = word;
		} else currentLine = testLine;
	}
	if (currentLine) lines.push(currentLine);
	c$7.restore();
	return lines;
}
function wrapTextWithNewlines(c$7, text, maxWidth, font) {
	const lines = [];
	const justify = [];
	for (const segment of text.split("\n")) {
		const s$4 = segment.trim();
		const block = s$4 ? wrapText(c$7, s$4, maxWidth, font) : [""];
		for (let i$6 = 0; i$6 < block.length; i$6++) {
			lines.push(block[i$6]);
			justify.push(block.length > 1 && i$6 < block.length - 1);
		}
	}
	return {
		lines,
		justify
	};
}
function drawJustifiedLine(c$7, line, x$4, y$5, width, color, justify) {
	const words = line.split(" ");
	if (words.length === 0) return;
	if (!justify || words.length === 1) {
		drawText(c$7, line, x$4, y$5, color);
		return;
	}
	const gap = (width - words.reduce((sum, w$5) => sum + c$7.measureText(w$5).width, 0)) / (words.length - 1);
	let currentX = x$4;
	for (let i$6 = 0; i$6 < words.length; i$6++) {
		drawText(c$7, words[i$6], currentX, y$5, color);
		currentX += c$7.measureText(words[i$6]).width + gap;
	}
}
function isSpaceToken(t$12) {
	return t$12.type === "text" && /^\s*$/.test(t$12.text);
}
function isTokenNestedInCall(callBlock, token) {
	let parenDepth = 0;
	let bracketDepth = 0;
	let braceDepth = 0;
	for (const t$12 of callBlock) {
		if (t$12 === token) return parenDepth > 1 || bracketDepth > 0 || braceDepth > 0;
		for (let j$4 = 0; j$4 < t$12.text.length; j$4++) {
			const c$7 = t$12.text[j$4];
			if (c$7 === "(") parenDepth++;
			else if (c$7 === ")") parenDepth--;
			else if (c$7 === "[") bracketDepth++;
			else if (c$7 === "]") bracketDepth--;
			else if (c$7 === "{") braceDepth++;
			else if (c$7 === "}") braceDepth--;
		}
	}
	return true;
}
function isParameterDeclaredBeforeToken(callBlock, token, paramName) {
	let parenDepth = 0;
	for (let i$6 = 0; i$6 < callBlock.length; i$6++) {
		const t$12 = callBlock[i$6];
		if (t$12 === token) break;
		const atDepth1 = parenDepth === 1;
		for (let j$4 = 0; j$4 < t$12.text.length; j$4++) {
			const c$7 = t$12.text[j$4];
			if (c$7 === "(") parenDepth++;
			else if (c$7 === ")") parenDepth--;
		}
		if (atDepth1 && (t$12.type === "identifier" || t$12.type === "function") && t$12.text === paramName) {
			if (callBlock[i$6 + 1]?.text === ":") return true;
		}
	}
	return false;
}
function wrapCodeLine(c$7, settings$1, caches, lineTokens, maxWidth) {
	if (lineTokens.length === 0) return [];
	const segments = [];
	let current = [];
	let currentWidth = 0;
	let lastSpaceIdx = -1;
	for (const token of lineTokens) {
		const w$5 = measureText(c$7, settings$1, caches, token).width;
		if (currentWidth + w$5 > maxWidth && lastSpaceIdx >= 0) {
			const breakAt = lastSpaceIdx + 1;
			const head = current.slice(0, breakAt);
			const headWidth = head.reduce((sum, t$12) => sum + measureText(c$7, settings$1, caches, t$12).width, 0);
			segments.push({
				tokens: head,
				width: headWidth
			});
			current = current.slice(breakAt);
			currentWidth = current.reduce((sum, t$12) => sum + measureText(c$7, settings$1, caches, t$12).width, 0);
			const idx = current.findLastIndex((t$12) => isSpaceToken(t$12));
			lastSpaceIdx = idx >= 0 ? idx : -1;
		}
		current.push(token);
		currentWidth += w$5;
		if (isSpaceToken(token)) lastSpaceIdx = current.length - 1;
	}
	if (current.length > 0) segments.push({
		tokens: current,
		width: currentWidth
	});
	return segments;
}
function createSimpleCache() {
	return { measureTextCache: /* @__PURE__ */ new Map() };
}
function resolveTooltipSource(line, column, pascalName, definition, histories, userCallHistories) {
	let history$1;
	let target;
	let isUserCallSite = false;
	if (definition) {
		history$1 = histories.find((h$5) => h$5.source.line === line && h$5.source.column === column && h$5.genName === pascalName);
		target = history$1;
		if (!history$1) for (const uh of userCallHistories) {
			const lastH = uh.inner.at(-1);
			if (lastH && lastH.source.line === line && lastH.source.column === column && lastH.genName === pascalName) {
				history$1 = lastH;
				target = uh;
				break;
			}
		}
	}
	if (!history$1) {
		for (const uh of userCallHistories) if (uh.source.line === line && uh.source.column === column) {
			isUserCallSite = true;
			target = uh;
			break;
		}
	}
	return {
		history: history$1,
		target,
		isUserCallSite
	};
}
function isPrevCharDot(docCode, token) {
	const line = (token.line ?? 1) - 1;
	const column = (token.column ?? 1) - 1;
	if (column < 1) return false;
	return docCode.split("\n")[line]?.[column - 1] === ".";
}
function resolveDefinitionKey(docCode, token) {
	if (isPrevCharDot(docCode, token)) {
		const arrayKey = `[].${token.text.toLowerCase()}`;
		if (definitions.get(arrayKey)) return arrayKey;
	}
	return token.text;
}
function hasTooltipBody(token, callBlock, dspContext, programContext, inline) {
	const definition = definitions.get(token.text);
	const program = inline ?? programContext;
	if (definition) return true;
	if (!callBlock?.length || !dspContext || !program) return false;
	const parenI = callBlock.findIndex((t$12) => t$12.text === "(");
	if (parenI <= 0) return false;
	const callee = callBlock[parenI - 1];
	const line = callee?.line;
	const column = callee?.column;
	if (line == null || column == null) return false;
	return resolveTooltipSource(line, column, nameToGenMap.value.get(callee?.text ?? "")?.name || toPascalCase(callee?.text ?? ""), definition, program.histories.value, program.userCallHistories.value).target !== void 0;
}
function drawDefinitionTooltip(overlayCanvas, editor$1, x$4, y$5, token, parameterIndex = -1, callBlock, dspContext, programContext, inline, tooltipBodyLeftX, tokenIsDefinition, caretLine, anchorLine, caretX, caretY) {
	const definition = definitions.get(token.text);
	const program = inline ?? programContext;
	const effectiveParamIndex = tokenIsDefinition ? -1 : parameterIndex;
	let tooltipWidgets = [];
	if (callBlock?.length && dspContext && program) {
		const parenI = callBlock.findIndex((t$12) => t$12.text === "(");
		if (parenI > 0) {
			const callee = callBlock[parenI - 1];
			const line = callee?.line;
			const column = callee?.column;
			if (line != null && column != null) {
				const resolved = resolveTooltipSource(line, column, toPascalCase(nameToGenMap.value.get(callee?.text ?? "")?.name ?? callee?.text ?? ""), definition, program.histories.value, program.userCallHistories.value);
				const widgetContext = program.tooltipWidgetContext;
				const { history: history$1, target, isUserCallSite } = resolved;
				if (target !== void 0) {
					const key = `${line}:${column}`;
					const widgets = isUserCallSite && "inner" in target ? target.inner.map((h$5) => dspContext.createTooltipWidget(h$5, target, widgetContext)).filter((w$5) => w$5 != null) : (() => {
						const w$5 = dspContext.createTooltipWidget(history$1, target ?? history$1, widgetContext);
						return w$5 ? [w$5] : [];
					})();
					if (tooltipWidgetCache?.key !== key || tooltipWidgetCache?.ref !== target || tooltipWidgetCache?.widgets.length !== widgets.length) tooltipWidgetCache = widgets.length ? {
						key,
						ref: target,
						widgets
					} : null;
					tooltipWidgets = tooltipWidgetCache?.widgets ?? [];
				} else tooltipWidgetCache = null;
			}
		}
	} else tooltipWidgetCache = null;
	if (!definition && tooltipWidgets.length === 0) return null;
	const { c: c$7 } = overlayCanvas;
	const settings$1 = editor$1.settings;
	const caches = createSimpleCache();
	const PADDING$1 = 12;
	const TOP_PADDING = 12;
	const ARROW_SIZE$1 = 6;
	const MAX_WIDTH$1 = 450;
	const MARGIN$1 = 4;
	const TOOLTIP_GAP$1 = 0;
	const RADIUS$1 = 8;
	const CODE_PADDING = 12;
	const CODE_PADDING_BOTTOM = 8;
	const PARAGRAPH_SPACING = 8;
	const CODE_SPACING = 12;
	const PARAM_HIGHLIGHT_COLOR = "#ffffff22";
	const PARAM_HIGHLIGHT_PADDING = 2;
	const TEXT_LINE_HEIGHT = 18;
	const CODE_LINE_HEIGHT = 20;
	const viewport = window.visualViewport;
	const overlayRect = overlayCanvas.rect;
	const viewportLeft = viewport.offsetLeft - overlayRect.left;
	const viewportTop = viewport.offsetTop - overlayRect.top;
	const viewportWidth = viewport.width;
	const viewportHeight = viewport.height;
	const xLocal = x$4 - overlayRect.left;
	const yLocal = y$5 - overlayRect.top;
	const tooltipBodyLeftXLocal = tooltipBodyLeftX != null ? tooltipBodyLeftX - overlayRect.left : void 0;
	const caretXLocal = caretX != null ? caretX - overlayRect.left : void 0;
	const caretYLocal = caretY != null ? caretY - overlayRect.top : void 0;
	const codeFont = `${settings$1.fontSize} '${settings$1.fontFamilyName}', monospace`;
	const textFont = `400 normal 10pt 'Space Grotesk', sans-serif`;
	const textFontBold = `600 normal 10pt 'Space Grotesk', sans-serif`;
	c$7.save();
	let contentY = TOP_PADDING;
	let tooltipWidth = MAX_WIDTH$1;
	let contentWidth = MAX_WIDTH$1 - PADDING$1 * 2;
	const code = definition ? definitionToCode(definition) : "";
	const codeLineWidth = MAX_WIDTH$1 - PADDING$1 * 2 - CODE_PADDING * 2;
	let wrappedCodeSegments = [];
	if (code) {
		const codeTokens = tokenize(code);
		for (const lineTokens of codeTokens) {
			const segments = wrapCodeLine(c$7, settings$1, caches, lineTokens, codeLineWidth);
			const onlySegment = segments.length === 1;
			for (let i$6 = 0; i$6 < segments.length; i$6++) wrappedCodeSegments.push({
				...segments[i$6],
				isLastInLogicalLine: i$6 === segments.length - 1,
				isOnlySegment: onlySegment
			});
		}
		contentWidth = MAX_WIDTH$1 - PADDING$1 * 2;
		const codeBgHeight = wrappedCodeSegments.length * CODE_LINE_HEIGHT + CODE_PADDING + CODE_PADDING_BOTTOM;
		contentY += codeBgHeight + CODE_SPACING;
	}
	c$7.font = textFont;
	if (definition) for (const paragraph of definition.description) {
		const { lines } = wrapTextWithNewlines(c$7, withPeriod(paragraph), contentWidth, textFont);
		contentY += lines.length * TEXT_LINE_HEIGHT + PARAGRAPH_SPACING;
	}
	if (definition && effectiveParamIndex >= 0 && definition.parameters && definition.parameters[effectiveParamIndex]) {
		const param = definition.parameters[effectiveParamIndex];
		const prefix = `${param.name}: `;
		c$7.font = textFontBold;
		const prefixWidth = c$7.measureText(prefix).width;
		c$7.font = textFont;
		const firstParamDesc = withPeriod(param.description[0] ?? "");
		const restParamDesc = param.description.slice(1);
		const { lines: firstLines } = wrapTextWithNewlines(c$7, firstParamDesc, contentWidth - prefixWidth, textFont);
		contentY += firstLines.length * TEXT_LINE_HEIGHT + PARAGRAPH_SPACING;
		if (!firstLines.length && restParamDesc.length) contentY += TEXT_LINE_HEIGHT;
		for (const paragraph of restParamDesc) {
			const { lines } = wrapTextWithNewlines(c$7, withPeriod(paragraph), contentWidth, textFont);
			contentY += lines.length * TEXT_LINE_HEIGHT + PARAGRAPH_SPACING;
		}
	}
	if (tooltipWidgets.length > 0) contentY += VISUAL_SPACING + VISUAL_HEIGHT;
	const tooltipHeight = tooltipWidgets.length > 0 ? contentY + PADDING$1 : contentY - PARAGRAPH_SPACING + PADDING$1;
	const tooltipYAbove = yLocal - tooltipHeight - ARROW_SIZE$1 - TOOLTIP_GAP$1;
	const tooltipYBelow = yLocal + settings$1.lineHeight + ARROW_SIZE$1 + TOOLTIP_GAP$1;
	const viewportTopWithMargin = viewportTop + MARGIN$1;
	const viewportBottomWithMargin = viewportTop + viewportHeight - MARGIN$1;
	const fitsAbove = tooltipYAbove >= viewportTopWithMargin && tooltipYAbove + tooltipHeight <= viewportBottomWithMargin;
	const fitsBelow = tooltipYBelow >= viewportTopWithMargin && tooltipYBelow + tooltipHeight <= viewportBottomWithMargin;
	const caretAboveAnchor = caretLine != null && anchorLine != null && caretLine < anchorLine;
	const anchorX = tooltipBodyLeftXLocal ?? xLocal;
	let tooltipX = anchorX;
	let tooltipY;
	let tooltipAbove;
	let arrowRight;
	if (caretAboveAnchor && fitsBelow) {
		tooltipAbove = false;
		tooltipY = tooltipYBelow;
		arrowRight = false;
	} else if (fitsAbove) {
		tooltipAbove = true;
		tooltipY = tooltipYAbove;
		arrowRight = false;
	} else if (fitsBelow) {
		tooltipAbove = false;
		tooltipY = tooltipYBelow;
		arrowRight = false;
	} else {
		tooltipAbove = tooltipYAbove >= viewportTopWithMargin;
		tooltipY = tooltipAbove ? tooltipYAbove : tooltipYBelow;
		arrowRight = false;
	}
	const xRight = anchorX;
	const xLeft = anchorX - tooltipWidth;
	const rightFits = xRight >= viewportLeft + MARGIN$1 && xRight + tooltipWidth <= viewportLeft + viewportWidth - MARGIN$1;
	const leftFits = xLeft >= viewportLeft + MARGIN$1 && xLeft + tooltipWidth <= viewportLeft + viewportWidth - MARGIN$1;
	function rectContainsCaret(tx, ty) {
		if (caretXLocal == null || caretYLocal == null) return false;
		return caretXLocal >= tx && caretXLocal <= tx + tooltipWidth && caretYLocal >= ty && caretYLocal <= ty + tooltipHeight;
	}
	const rightCoversCaret = rectContainsCaret(xRight, tooltipY);
	const leftCoversCaret = rectContainsCaret(xLeft, tooltipY);
	if (rightCoversCaret && !leftCoversCaret) {
		tooltipX = xLeft;
		arrowRight = true;
	} else if (leftCoversCaret && !rightCoversCaret) {
		tooltipX = xRight;
		arrowRight = false;
	} else if (!rightCoversCaret && rightFits) {
		tooltipX = xRight;
		arrowRight = false;
	} else if (!leftCoversCaret && leftFits) {
		tooltipX = xLeft;
		arrowRight = true;
	} else if (rightFits) {
		tooltipX = xRight;
		arrowRight = false;
	} else if (leftFits) {
		tooltipX = xLeft;
		arrowRight = true;
	}
	if (!arrowRight) {
		if (tooltipX < viewportLeft + MARGIN$1) tooltipX = viewportLeft + MARGIN$1;
		if (tooltipX + tooltipWidth > viewportLeft + viewportWidth - MARGIN$1) tooltipX = viewportLeft + viewportWidth - tooltipWidth - MARGIN$1;
	} else {
		if (tooltipX + tooltipWidth > viewportLeft + viewportWidth - MARGIN$1) tooltipX = viewportLeft + viewportWidth - tooltipWidth - MARGIN$1;
		if (tooltipX < viewportLeft + MARGIN$1) tooltipX = viewportLeft + MARGIN$1;
	}
	if (!tooltipAbove && tooltipY < viewportTopWithMargin) tooltipY = viewportTopWithMargin;
	if (tooltipY + tooltipHeight > viewportBottomWithMargin) tooltipY = viewportBottomWithMargin - tooltipHeight;
	const arrowClamped = arrowRight ? Math.abs(anchorX - (tooltipX + tooltipWidth)) > .5 : Math.abs(anchorX - tooltipX) > .5;
	const arrowCenterX = Math.max(tooltipX + ARROW_SIZE$1, Math.min(anchorX, tooltipX + tooltipWidth - ARROW_SIZE$1));
	const position = tooltipAbove ? arrowRight ? Position.TopLeft : Position.TopRight : arrowRight ? Position.BottomLeft : Position.BottomRight;
	const BG_COLOR = backgroundColor.value;
	const STROKE_COLOR = grayColor.value;
	c$7.fillStyle = BG_COLOR;
	c$7.strokeStyle = STROKE_COLOR;
	c$7.lineWidth = 1.35;
	c$7.beginPath();
	if (arrowClamped) if (tooltipAbove) {
		c$7.moveTo(tooltipX + RADIUS$1, tooltipY);
		c$7.lineTo(tooltipX + tooltipWidth - RADIUS$1, tooltipY);
		c$7.quadraticCurveTo(tooltipX + tooltipWidth, tooltipY, tooltipX + tooltipWidth, tooltipY + RADIUS$1);
		c$7.lineTo(tooltipX + tooltipWidth, tooltipY + tooltipHeight - RADIUS$1);
		c$7.quadraticCurveTo(tooltipX + tooltipWidth, tooltipY + tooltipHeight, tooltipX + tooltipWidth - RADIUS$1, tooltipY + tooltipHeight);
		c$7.lineTo(arrowCenterX + ARROW_SIZE$1, tooltipY + tooltipHeight);
		c$7.lineTo(arrowCenterX, tooltipY + tooltipHeight + ARROW_SIZE$1);
		c$7.lineTo(arrowCenterX - ARROW_SIZE$1, tooltipY + tooltipHeight);
		c$7.lineTo(tooltipX, tooltipY + tooltipHeight);
		c$7.lineTo(tooltipX, tooltipY + RADIUS$1);
		c$7.quadraticCurveTo(tooltipX, tooltipY, tooltipX + RADIUS$1, tooltipY);
		c$7.closePath();
	} else {
		c$7.moveTo(arrowCenterX - ARROW_SIZE$1, tooltipY);
		c$7.lineTo(arrowCenterX, tooltipY - ARROW_SIZE$1);
		c$7.lineTo(arrowCenterX + ARROW_SIZE$1, tooltipY);
		c$7.lineTo(tooltipX + tooltipWidth - RADIUS$1, tooltipY);
		c$7.quadraticCurveTo(tooltipX + tooltipWidth, tooltipY, tooltipX + tooltipWidth, tooltipY + RADIUS$1);
		c$7.lineTo(tooltipX + tooltipWidth, tooltipY + tooltipHeight - RADIUS$1);
		c$7.quadraticCurveTo(tooltipX + tooltipWidth, tooltipY + tooltipHeight, tooltipX + tooltipWidth - RADIUS$1, tooltipY + tooltipHeight);
		c$7.lineTo(tooltipX + RADIUS$1, tooltipY + tooltipHeight);
		c$7.quadraticCurveTo(tooltipX, tooltipY + tooltipHeight, tooltipX, tooltipY + tooltipHeight - RADIUS$1);
		c$7.lineTo(tooltipX, tooltipY + RADIUS$1);
		c$7.quadraticCurveTo(tooltipX, tooltipY, tooltipX + RADIUS$1, tooltipY);
		c$7.lineTo(arrowCenterX - ARROW_SIZE$1, tooltipY);
		c$7.closePath();
	}
	else if (tooltipAbove) {
		c$7.moveTo(tooltipX + RADIUS$1, tooltipY);
		c$7.lineTo(tooltipX + tooltipWidth - RADIUS$1, tooltipY);
		c$7.quadraticCurveTo(tooltipX + tooltipWidth, tooltipY, tooltipX + tooltipWidth, tooltipY + RADIUS$1);
		c$7.lineTo(tooltipX + tooltipWidth, tooltipY + tooltipHeight - RADIUS$1);
		if (arrowRight) {
			c$7.lineTo(tooltipX + tooltipWidth, tooltipY + tooltipHeight);
			c$7.lineTo(tooltipX + tooltipWidth, tooltipY + tooltipHeight + ARROW_SIZE$1);
			c$7.lineTo(tooltipX + tooltipWidth - ARROW_SIZE$1, tooltipY + tooltipHeight);
			c$7.lineTo(tooltipX + RADIUS$1, tooltipY + tooltipHeight);
			c$7.quadraticCurveTo(tooltipX, tooltipY + tooltipHeight, tooltipX, tooltipY + tooltipHeight - RADIUS$1);
		} else {
			c$7.quadraticCurveTo(tooltipX + tooltipWidth, tooltipY + tooltipHeight, tooltipX + tooltipWidth - RADIUS$1, tooltipY + tooltipHeight);
			c$7.lineTo(tooltipX + ARROW_SIZE$1, tooltipY + tooltipHeight);
			c$7.lineTo(tooltipX, tooltipY + tooltipHeight + ARROW_SIZE$1);
			c$7.lineTo(tooltipX, tooltipY + tooltipHeight);
		}
		c$7.lineTo(tooltipX, tooltipY + RADIUS$1);
		c$7.quadraticCurveTo(tooltipX, tooltipY, tooltipX + RADIUS$1, tooltipY);
		c$7.closePath();
	} else {
		if (arrowRight) {
			c$7.moveTo(tooltipX + tooltipWidth - ARROW_SIZE$1, tooltipY);
			c$7.lineTo(tooltipX + tooltipWidth, tooltipY - ARROW_SIZE$1);
			c$7.lineTo(tooltipX + tooltipWidth, tooltipY);
			c$7.lineTo(tooltipX + tooltipWidth, tooltipY + tooltipHeight - RADIUS$1);
			c$7.quadraticCurveTo(tooltipX + tooltipWidth, tooltipY + tooltipHeight, tooltipX + tooltipWidth - RADIUS$1, tooltipY + tooltipHeight);
			c$7.lineTo(tooltipX + RADIUS$1, tooltipY + tooltipHeight);
			c$7.quadraticCurveTo(tooltipX, tooltipY + tooltipHeight, tooltipX, tooltipY + tooltipHeight - RADIUS$1);
			c$7.lineTo(tooltipX, tooltipY + RADIUS$1);
			c$7.quadraticCurveTo(tooltipX, tooltipY, tooltipX + RADIUS$1, tooltipY);
			c$7.lineTo(tooltipX + tooltipWidth - ARROW_SIZE$1, tooltipY);
		} else {
			c$7.moveTo(tooltipX + ARROW_SIZE$1, tooltipY);
			c$7.lineTo(tooltipX, tooltipY - ARROW_SIZE$1);
			c$7.lineTo(tooltipX, tooltipY);
			c$7.lineTo(tooltipX, tooltipY + tooltipHeight - RADIUS$1);
			c$7.quadraticCurveTo(tooltipX, tooltipY + tooltipHeight, tooltipX + RADIUS$1, tooltipY + tooltipHeight);
			c$7.lineTo(tooltipX + tooltipWidth - RADIUS$1, tooltipY + tooltipHeight);
			c$7.quadraticCurveTo(tooltipX + tooltipWidth, tooltipY + tooltipHeight, tooltipX + tooltipWidth, tooltipY + tooltipHeight - RADIUS$1);
			c$7.lineTo(tooltipX + tooltipWidth, tooltipY + RADIUS$1);
			c$7.quadraticCurveTo(tooltipX + tooltipWidth, tooltipY, tooltipX + tooltipWidth - RADIUS$1, tooltipY);
			c$7.lineTo(tooltipX + ARROW_SIZE$1, tooltipY);
		}
		c$7.closePath();
	}
	c$7.fill();
	c$7.stroke();
	c$7.translate(tooltipX, tooltipY);
	contentY = TOP_PADDING;
	if (code) {
		const codeBgHeight = wrappedCodeSegments.length * CODE_LINE_HEIGHT + CODE_PADDING + CODE_PADDING_BOTTOM;
		c$7.fillStyle = "#ffffff11";
		drawRoundedRect(c$7, PADDING$1, contentY, contentWidth, codeBgHeight, 4);
		c$7.fill();
		let codeY = contentY + CODE_PADDING;
		const paramHighlightRects = [];
		const paramTokenHighlights = /* @__PURE__ */ new Set();
		let parenDepth = 0;
		let bracketDepth = 0;
		let currentParamIndex = -1;
		let inParameter = false;
		let paramStartX = 0;
		let paramWidth = 0;
		let paramHeight = 0;
		for (const segment of wrappedCodeSegments) {
			const tokens = segment.tokens;
			const n$4 = tokens.length;
			const wordGapCount = !segment.isLastInLogicalLine ? tokens.filter((t$12, i$6) => i$6 < n$4 - 1 && isSpaceToken(t$12)).length : 0;
			const drawnWidth = n$4 > 0 && isSpaceToken(tokens[n$4 - 1]) ? segment.width - measureText(c$7, settings$1, caches, tokens[n$4 - 1]).width : segment.width;
			const gapSize = wordGapCount > 0 ? (codeLineWidth - drawnWidth) / wordGapCount : 0;
			let codeX = segment.isLastInLogicalLine && !segment.isOnlySegment ? PADDING$1 + CODE_PADDING + codeLineWidth - segment.width : PADDING$1 + CODE_PADDING;
			for (let i$6 = 0; i$6 < n$4; i$6++) {
				const token$1 = tokens[i$6];
				if (i$6 === n$4 - 1 && isSpaceToken(token$1)) continue;
				if (token$1.text === "(") {
					parenDepth++;
					if (parenDepth === 1) currentParamIndex = 0;
				} else if (token$1.text === ")") {
					if (inParameter && currentParamIndex === effectiveParamIndex) paramHighlightRects.push({
						x: paramStartX - PARAM_HIGHLIGHT_PADDING,
						y: codeY - PARAM_HIGHLIGHT_PADDING,
						width: paramWidth + PARAM_HIGHLIGHT_PADDING * 2,
						height: paramHeight + PARAM_HIGHLIGHT_PADDING * 2
					});
					parenDepth--;
					inParameter = false;
				} else if (token$1.text === "[") {
					bracketDepth++;
					if (parenDepth === 1 && currentParamIndex === effectiveParamIndex && !inParameter) {
						inParameter = true;
						paramStartX = codeX;
						paramWidth = 0;
						paramHeight = 0;
					}
				} else if (token$1.text === "]") bracketDepth--;
				else if (token$1.text === "," && parenDepth === 1 && bracketDepth === 0) {
					if (inParameter && currentParamIndex === effectiveParamIndex) paramHighlightRects.push({
						x: paramStartX - PARAM_HIGHLIGHT_PADDING,
						y: codeY - PARAM_HIGHLIGHT_PADDING,
						width: paramWidth + PARAM_HIGHLIGHT_PADDING * 2,
						height: paramHeight + PARAM_HIGHLIGHT_PADDING * 2
					});
					inParameter = false;
					currentParamIndex++;
				} else if (parenDepth === 1 && currentParamIndex === effectiveParamIndex) {
					if (!inParameter && (token$1.type === "identifier" || token$1.text === "...")) {
						inParameter = true;
						paramStartX = codeX;
						paramWidth = 0;
						paramHeight = 0;
					}
				}
				const metrics = measureText(c$7, settings$1, caches, token$1);
				if (inParameter) {
					paramWidth += metrics.width;
					paramHeight = Math.max(paramHeight, metrics.height);
					paramTokenHighlights.add(token$1);
				}
				codeX += metrics.width;
				if (i$6 < n$4 - 1 && isSpaceToken(token$1)) codeX += gapSize;
			}
			if (inParameter && currentParamIndex === effectiveParamIndex) paramHighlightRects.push({
				x: paramStartX - PARAM_HIGHLIGHT_PADDING,
				y: codeY - PARAM_HIGHLIGHT_PADDING,
				width: paramWidth + PARAM_HIGHLIGHT_PADDING * 2,
				height: paramHeight + PARAM_HIGHLIGHT_PADDING * 2
			});
			codeY += CODE_LINE_HEIGHT;
		}
		if (effectiveParamIndex >= 0 && paramHighlightRects.length > 0) {
			c$7.fillStyle = PARAM_HIGHLIGHT_COLOR;
			for (const rect of paramHighlightRects) {
				drawRoundedRect(c$7, rect.x, rect.y, rect.width, rect.height, 3);
				c$7.fill();
			}
		}
		codeY = contentY + CODE_PADDING;
		for (const segment of wrappedCodeSegments) {
			const tokens = segment.tokens;
			const n$4 = tokens.length;
			const wordGapCount = !segment.isLastInLogicalLine ? tokens.filter((t$12, i$6) => i$6 < n$4 - 1 && isSpaceToken(t$12)).length : 0;
			const drawnWidth = n$4 > 0 && isSpaceToken(tokens[n$4 - 1]) ? segment.width - measureText(c$7, settings$1, caches, tokens[n$4 - 1]).width : segment.width;
			const gapSize = wordGapCount > 0 ? (codeLineWidth - drawnWidth) / wordGapCount : 0;
			let codeX = segment.isLastInLogicalLine && !segment.isOnlySegment ? PADDING$1 + CODE_PADDING + codeLineWidth - segment.width : PADDING$1 + CODE_PADDING;
			for (let i$6 = 0; i$6 < n$4; i$6++) {
				const token$1 = tokens[i$6];
				if (i$6 === n$4 - 1 && isSpaceToken(token$1)) continue;
				const { color, style, weight } = settings$1.theme[token$1.type];
				c$7.font = `${weight === "bold" ? 700 : 400} ${style} ${codeFont}`;
				c$7.textBaseline = "top";
				drawText(c$7, token$1.text, codeX, codeY, paramTokenHighlights.has(token$1) ? secondaryColor.value : color);
				const metrics = measureText(c$7, settings$1, caches, token$1);
				codeX += metrics.width;
				if (i$6 < n$4 - 1 && isSpaceToken(token$1)) codeX += gapSize;
			}
			codeY += CODE_LINE_HEIGHT;
		}
		contentY += codeBgHeight + CODE_SPACING;
	}
	c$7.font = textFont;
	c$7.textBaseline = "top";
	if (definition) for (const paragraph of definition.description) {
		const { lines, justify } = wrapTextWithNewlines(c$7, withPeriod(paragraph), contentWidth, textFont);
		for (let i$6 = 0; i$6 < lines.length; i$6++) {
			drawJustifiedLine(c$7, lines[i$6], PADDING$1, contentY, contentWidth, textColor.value, justify[i$6]);
			contentY += TEXT_LINE_HEIGHT;
		}
		contentY += PARAGRAPH_SPACING;
	}
	if (definition && effectiveParamIndex >= 0 && definition.parameters && definition.parameters[effectiveParamIndex]) {
		const param = definition.parameters[effectiveParamIndex];
		const prefix = `${param.name}: `;
		c$7.font = textFontBold;
		const prefixWidth = c$7.measureText(prefix).width;
		drawText(c$7, prefix, PADDING$1, contentY, secondaryColor.value);
		c$7.font = textFont;
		const firstParamDesc = withPeriod(param.description[0] ?? "");
		const restParamDesc = param.description.slice(1);
		const { lines: firstLines, justify: firstJustify } = wrapTextWithNewlines(c$7, firstParamDesc, contentWidth - prefixWidth, textFont);
		const firstLineWidth = contentWidth - prefixWidth;
		for (let i$6 = 0; i$6 < firstLines.length; i$6++) {
			const x$5 = i$6 === 0 ? PADDING$1 + prefixWidth : PADDING$1;
			const w$5 = i$6 === 0 ? firstLineWidth : contentWidth;
			drawJustifiedLine(c$7, firstLines[i$6], x$5, contentY, w$5, textColor.value, firstJustify[i$6]);
			contentY += TEXT_LINE_HEIGHT;
		}
		if (!firstLines.length && restParamDesc.length) contentY += TEXT_LINE_HEIGHT;
		contentY += PARAGRAPH_SPACING;
		for (const paragraph of restParamDesc) {
			const { lines, justify } = wrapTextWithNewlines(c$7, withPeriod(paragraph), contentWidth, textFont);
			for (let i$6 = 0; i$6 < lines.length; i$6++) {
				drawJustifiedLine(c$7, lines[i$6], PADDING$1, contentY, contentWidth, textColor.value, justify[i$6]);
				contentY += TEXT_LINE_HEIGHT;
			}
			contentY += PARAGRAPH_SPACING;
		}
	}
	if (tooltipWidgets.length > 0) {
		contentY += VISUAL_SPACING;
		const padding = 4;
		const n$4 = tooltipWidgets.length;
		const gap = n$4 > 1 ? 2 : 0;
		const segmentWidth = (contentWidth - (n$4 - 1) * gap) / n$4;
		const widgetDraw = (w$5) => w$5.draw(c$7, padding, padding, segmentWidth - padding * 2, VISUAL_HEIGHT - padding * 2, segmentWidth - padding * 2, padding);
		for (let i$6 = 0; i$6 < n$4; i$6++) {
			c$7.save();
			c$7.translate(PADDING$1 + i$6 * (segmentWidth + gap), contentY);
			c$7.beginPath();
			c$7.rect(0, 0, segmentWidth, VISUAL_HEIGHT);
			c$7.clip();
			widgetDraw(tooltipWidgets[i$6]);
			c$7.restore();
		}
	}
	c$7.restore();
	return position;
}
function createDefinitionTooltipHandlers(editor$1, getInline) {
	const drawBody = (canvas, ed, x$4, y$5, token, callBlock, parameterIndex, callBlockX, callBlockY, dspContext, programContext, inline, tooltipBodyLeftX, tokenIsDefinition, caretLine, anchorLine, caretX, caretY) => {
		return drawDefinitionTooltip(canvas, ed, x$4, y$5, token, parameterIndex, callBlock, dspContext, programContext, inline, tooltipBodyLeftX, tokenIsDefinition, caretLine, anchorLine, caretX, caretY);
	};
	const resolveAndDraw = (canvas, x$4, y$5, token, callBlock, parameterIndex, callBlockX, callBlockY, doc, paramX, paramY, bodyLeftX, caretLine, caretX, caretY) => {
		const isFunctionCall = callBlock.length > 0;
		const resolvedKey = resolveDefinitionKey(doc.code, token);
		const tokenDef = definitions.get(resolvedKey);
		let definitionKey = null;
		if (tokenDef) definitionKey = resolvedKey;
		else if (isFunctionCall) definitionKey = resolveDefinitionKey(doc.code, callBlock[0]);
		if (!definitionKey) definitionKey = resolvedKey;
		const tokenWithKey = {
			...token,
			text: definitionKey
		};
		const definition = definitions.get(definitionKey);
		let resolvedParamIndex = tokenDef ? -1 : parameterIndex;
		if (!tokenDef && definition?.parameters && isFunctionCall && parameterIndex >= 0 && !isTokenNestedInCall(callBlock, token)) {
			const exact = definition.parameters.findIndex((p$6) => p$6.name === token.text);
			if (exact >= 0) {
				const param = definition.parameters[exact];
				if (!isParameterDeclaredBeforeToken(callBlock, token, param.name)) resolvedParamIndex = exact;
			} else {
				const labelMatch = definition.parameters.findIndex((p$6) => p$6.name.startsWith(token.text));
				if (labelMatch >= 0) {
					const param = definition.parameters[labelMatch];
					if (!isParameterDeclaredBeforeToken(callBlock, token, param.name)) resolvedParamIndex = labelMatch;
				}
			}
		}
		const dspContext = ctx.value;
		const programContext = currentProgramContext.value;
		const inline = getInline?.() ?? null;
		const tooltipX = tokenDef ? x$4 : resolvedParamIndex >= 0 ? paramX ?? x$4 : callBlockX;
		const tooltipY = tokenDef ? y$5 : resolvedParamIndex >= 0 ? paramY ?? y$5 : callBlockY;
		const tokenAnchorLine = (token.line ?? 1) - 1;
		const parenI = callBlock.findIndex((t$12) => t$12.text === "(");
		const callAnchorLine = ((parenI > 0 ? callBlock[parenI - 1] : null)?.line ?? callBlock[0]?.line ?? 1) - 1;
		if (definition) {
			const useCallBlock = !tokenDef;
			if (definition.type === "function" && isFunctionCall && useCallBlock) return drawBody(canvas, editor$1, tooltipX, tooltipY, tokenWithKey, callBlock, resolvedParamIndex, callBlockX, callBlockY, dspContext, programContext, inline, bodyLeftX, false, caretLine, callAnchorLine, caretX, caretY);
			return drawBody(canvas, editor$1, x$4, y$5, tokenWithKey, isFunctionCall ? callBlock : [], resolvedParamIndex, callBlockX, callBlockY, dspContext, programContext, inline, bodyLeftX, !!tokenDef, caretLine, tokenAnchorLine, caretX, caretY);
		}
		if (isFunctionCall && callBlock.length && dspContext) return drawBody(canvas, editor$1, callBlockX, callBlockY, tokenWithKey, callBlock, -1, callBlockX, callBlockY, dspContext, programContext, inline, bodyLeftX, false, caretLine, callAnchorLine, caretX, caretY);
		return null;
	};
	const onHoverToken = (canvas, x$4, y$5, token, callBlock, parameterIndex, callBlockX, callBlockY, _doc, paramX, paramY, caretX, caretY) => {
		if (!settings.showDocs) return null;
		return resolveAndDraw(canvas, x$4, y$5, token, callBlock, parameterIndex, callBlockX, callBlockY, _doc, paramX, paramY, void 0, activeEditor.value?.caret.line.value, caretX, caretY);
	};
	const onCaretToken = (canvas, x$4, y$5, token, callBlock, parameterIndex, callBlockX, callBlockY, doc, _paramX, _paramY, caretX, caretY) => {
		if (!settings.showDocs) {
			autocompleteState.visible = false;
			return null;
		}
		const matches = collectMatches(doc.code, token.text);
		if (matches.length === 0) {
			autocompleteState.visible = false;
			return resolveAndDraw(canvas, x$4, y$5, token, callBlock, parameterIndex, callBlockX, callBlockY, doc, void 0, void 0, void 0, activeEditor.value?.caret.line.value, void 0, void 0);
		}
		const line = (token.line ?? 1) - 1;
		const column = (token.column ?? 1) - 1;
		if (!autocompleteState.visible) autocompleteState.selectedIndex = -1;
		autocompleteState.visible = true;
		autocompleteState.matches = matches;
		autocompleteState.replaceStart = {
			line,
			column
		};
		autocompleteState.replaceEnd = {
			line,
			column: column + token.text.length
		};
		autocompleteState.doc = doc;
		const calleeToken = callBlock.length > 0 ? callBlock[0] : token;
		const definitionKey = resolveDefinitionKey(doc.code, calleeToken);
		const tokenWithKey = {
			...token,
			text: definitionKey
		};
		const dspContext = ctx.value;
		const programContext = currentProgramContext.value;
		const hasBody = hasTooltipBody(tokenWithKey, callBlock, dspContext, programContext, getInline?.() ?? null);
		drawAutocompleteList(canvas, x$4 - (hasBody ? AUTCOMPLETE_GAP : 0), y$5, matches, autocompleteState.selectedIndex, editor$1, !hasBody);
		const drew = resolveAndDraw(canvas, x$4, y$5, token, callBlock, parameterIndex, callBlockX, callBlockY, doc, void 0, void 0, hasBody ? x$4 : void 0, activeEditor.value?.caret.line.value, caretX, caretY);
		if (drew == null) autocompleteState.visible = true;
		return drew ?? Position.BottomLeft;
	};
	return {
		onHoverToken,
		onCaretToken
	};
}
var debouncedSetItem = debounce(50, (key, json) => {
	localStorage.setItem(key, JSON.stringify(json()));
});
function persist(key, watch, json, read) {
	o$24(() => n(() => read(JSON.parse(localStorage.getItem(key) || "{}"))));
	m(() => {
		watch();
		debouncedSetItem(key, json);
	});
}
function persistKeyed(getKey, watch, json, read) {
	let lastKey = null;
	m(() => {
		const key = getKey();
		if (key === null) return;
		if (key !== lastKey) {
			lastKey = key;
			o$24(() => n(() => read(JSON.parse(localStorage.getItem(key) || "{}"))));
		}
		watch();
		debouncedSetItem(key, json);
	});
}
function safeJsonParse(json) {
	if (json == null) return null;
	try {
		return JSON.parse(json);
	} catch (error$1) {
		return null;
	}
}
var _all_default = /* @__PURE__ */ JSON.parse("[{\"name\":\"3024 Day\",\"black\":\"#090300\",\"red\":\"#db2d20\",\"green\":\"#01a252\",\"yellow\":\"#fded02\",\"blue\":\"#01a0e4\",\"purple\":\"#a16a94\",\"cyan\":\"#b5e4f4\",\"white\":\"#a5a2a2\",\"brightBlack\":\"#5c5855\",\"brightRed\":\"#e8bbd0\",\"brightGreen\":\"#3a3432\",\"brightYellow\":\"#4a4543\",\"brightBlue\":\"#807d7c\",\"brightPurple\":\"#d6d5d4\",\"brightCyan\":\"#cdab53\",\"brightWhite\":\"#f7f7f7\",\"background\":\"#f7f7f7\",\"foreground\":\"#4a4543\",\"cursorColor\":\"#4a4543\",\"selectionBackground\":\"#a5a2a2\",\"meta\":{\"isDark\":false,\"credits\":[{\"name\":\"0x3024\",\"link\":\"https://github.com/0x3024\"}]}},{\"name\":\"3024 Night\",\"black\":\"#090300\",\"red\":\"#db2d20\",\"green\":\"#01a252\",\"yellow\":\"#fded02\",\"blue\":\"#01a0e4\",\"purple\":\"#a16a94\",\"cyan\":\"#b5e4f4\",\"white\":\"#a5a2a2\",\"brightBlack\":\"#5c5855\",\"brightRed\":\"#e8bbd0\",\"brightGreen\":\"#3a3432\",\"brightYellow\":\"#4a4543\",\"brightBlue\":\"#807d7c\",\"brightPurple\":\"#d6d5d4\",\"brightCyan\":\"#cdab53\",\"brightWhite\":\"#f7f7f7\",\"background\":\"#090300\",\"foreground\":\"#a5a2a2\",\"cursorColor\":\"#a5a2a2\",\"selectionBackground\":\"#4a4543\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"0x3024\",\"link\":\"https://github.com/0x3024\"}]}},{\"name\":\"Aci\",\"black\":\"#363636\",\"red\":\"#ff0883\",\"green\":\"#83ff08\",\"yellow\":\"#ff8308\",\"blue\":\"#0883ff\",\"purple\":\"#8308ff\",\"cyan\":\"#08ff83\",\"white\":\"#b6b6b6\",\"brightBlack\":\"#424242\",\"brightRed\":\"#ff1e8e\",\"brightGreen\":\"#8eff1e\",\"brightYellow\":\"#ff8e1e\",\"brightBlue\":\"#1e8eff\",\"brightPurple\":\"#8e1eff\",\"brightCyan\":\"#1eff8e\",\"brightWhite\":\"#c2c2c2\",\"foreground\":\"#b4e1fd\",\"background\":\"#0d1926\",\"cursorColor\":\"#b4e1fd\"},{\"name\":\"Aco\",\"black\":\"#3f3f3f\",\"red\":\"#ff0883\",\"green\":\"#83ff08\",\"yellow\":\"#ff8308\",\"blue\":\"#0883ff\",\"purple\":\"#8308ff\",\"cyan\":\"#08ff83\",\"white\":\"#bebebe\",\"brightBlack\":\"#474747\",\"brightRed\":\"#ff1e8e\",\"brightGreen\":\"#8eff1e\",\"brightYellow\":\"#ff8e1e\",\"brightBlue\":\"#1e8eff\",\"brightPurple\":\"#8e1eff\",\"brightCyan\":\"#1eff8e\",\"brightWhite\":\"#c4c4c4\",\"foreground\":\"#b4e1fd\",\"background\":\"#1f1305\",\"cursorColor\":\"#b4e1fd\"},{\"name\":\"Adventure\",\"black\":\"#040404\",\"red\":\"#d84a33\",\"green\":\"#5da602\",\"yellow\":\"#eebb6e\",\"blue\":\"#417ab3\",\"purple\":\"#e5c499\",\"cyan\":\"#bdcfe5\",\"white\":\"#dbded8\",\"brightBlack\":\"#685656\",\"brightRed\":\"#d76b42\",\"brightGreen\":\"#99b52c\",\"brightYellow\":\"#ffb670\",\"brightBlue\":\"#97d7ef\",\"brightPurple\":\"#aa7900\",\"brightCyan\":\"#bdcfe5\",\"brightWhite\":\"#e4d5c7\",\"background\":\"#040404\",\"foreground\":\"#feffff\",\"cursorColor\":\"#feffff\",\"selectionBackground\":\"#606060\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"hongzimao\",\"link\":\"https://github.com/hongzimao/iTerm2-Color-Schemes\"}]}},{\"name\":\"AdventureTime\",\"black\":\"#050404\",\"red\":\"#bd0013\",\"green\":\"#4ab118\",\"yellow\":\"#e7741e\",\"blue\":\"#0f4ac6\",\"purple\":\"#665993\",\"cyan\":\"#70a598\",\"white\":\"#f8dcc0\",\"brightBlack\":\"#4e7cbf\",\"brightRed\":\"#fc5f5a\",\"brightGreen\":\"#9eff6e\",\"brightYellow\":\"#efc11a\",\"brightBlue\":\"#1997c6\",\"brightPurple\":\"#9b5953\",\"brightCyan\":\"#c8faf4\",\"brightWhite\":\"#f6f5fb\",\"background\":\"#1f1d45\",\"foreground\":\"#f8dcc0\",\"cursorColor\":\"#efbf38\",\"selectionBackground\":\"#706b4e\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"zdj\",\"link\":\"https://github.com/zdj/themes/tree/master/iterm2\"}]}},{\"name\":\"Afterglow\",\"black\":\"#151515\",\"red\":\"#ac4142\",\"green\":\"#7e8e50\",\"yellow\":\"#e5b567\",\"blue\":\"#6c99bb\",\"purple\":\"#9f4e85\",\"cyan\":\"#7dd6cf\",\"white\":\"#d0d0d0\",\"brightBlack\":\"#505050\",\"brightRed\":\"#ac4142\",\"brightGreen\":\"#7e8e50\",\"brightYellow\":\"#e5b567\",\"brightBlue\":\"#6c99bb\",\"brightPurple\":\"#9f4e85\",\"brightCyan\":\"#7dd6cf\",\"brightWhite\":\"#f5f5f5\",\"background\":\"#212121\",\"foreground\":\"#d0d0d0\",\"cursorColor\":\"#d0d0d0\",\"selectionBackground\":\"#303030\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"yabatadesign\",\"link\":\"https://github.com/YabataDesign/afterglow-itermcolors\"}]}},{\"name\":\"AlienBlood\",\"black\":\"#112616\",\"red\":\"#7f2b27\",\"green\":\"#2f7e25\",\"yellow\":\"#717f24\",\"blue\":\"#2f6a7f\",\"purple\":\"#47587f\",\"cyan\":\"#327f77\",\"white\":\"#647d75\",\"brightBlack\":\"#3c4812\",\"brightRed\":\"#e08009\",\"brightGreen\":\"#18e000\",\"brightYellow\":\"#bde000\",\"brightBlue\":\"#00aae0\",\"brightPurple\":\"#0058e0\",\"brightCyan\":\"#00e0c4\",\"brightWhite\":\"#73fa91\",\"background\":\"#0f1610\",\"foreground\":\"#637d75\",\"cursorColor\":\"#73fa91\",\"selectionBackground\":\"#1d4125\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"zdj\",\"link\":\"https://github.com/zdj/themes/tree/master/iterm2\"}]}},{\"name\":\"Andromeda\",\"black\":\"#000000\",\"red\":\"#cd3131\",\"green\":\"#05bc79\",\"yellow\":\"#e5e512\",\"blue\":\"#2472c8\",\"purple\":\"#bc3fbc\",\"cyan\":\"#0fa8cd\",\"white\":\"#e5e5e5\",\"brightBlack\":\"#666666\",\"brightRed\":\"#cd3131\",\"brightGreen\":\"#05bc79\",\"brightYellow\":\"#e5e512\",\"brightBlue\":\"#2472c8\",\"brightPurple\":\"#bc3fbc\",\"brightCyan\":\"#0fa8cd\",\"brightWhite\":\"#e5e5e5\",\"background\":\"#262a33\",\"foreground\":\"#e5e5e5\",\"cursorColor\":\"#f8f8f0\",\"selectionBackground\":\"#5a5c62\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"memije\",\"link\":\"https://github.com/memije\"},{\"name\":\"EliverLara\",\"link\":\"https://github.com/EliverLara/\"}]}},{\"name\":\"Argonaut\",\"black\":\"#232323\",\"red\":\"#ff000f\",\"green\":\"#8ce10b\",\"yellow\":\"#ffb900\",\"blue\":\"#008df8\",\"purple\":\"#6d43a6\",\"cyan\":\"#00d8eb\",\"white\":\"#ffffff\",\"brightBlack\":\"#444444\",\"brightRed\":\"#ff2740\",\"brightGreen\":\"#abe15b\",\"brightYellow\":\"#ffd242\",\"brightBlue\":\"#0092ff\",\"brightPurple\":\"#9a5feb\",\"brightCyan\":\"#67fff0\",\"brightWhite\":\"#ffffff\",\"background\":\"#0e1019\",\"foreground\":\"#fffaf4\",\"cursorColor\":\"#ff0018\",\"selectionBackground\":\"#002a3b\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"effkay\",\"link\":\"https://github.com/effkay/iTerm-argonaut\"}]}},{\"name\":\"Arthur\",\"black\":\"#3d352a\",\"red\":\"#cd5c5c\",\"green\":\"#86af80\",\"yellow\":\"#e8ae5b\",\"blue\":\"#6495ed\",\"purple\":\"#deb887\",\"cyan\":\"#b0c4de\",\"white\":\"#bbaa99\",\"brightBlack\":\"#554444\",\"brightRed\":\"#cc5533\",\"brightGreen\":\"#88aa22\",\"brightYellow\":\"#ffa75d\",\"brightBlue\":\"#87ceeb\",\"brightPurple\":\"#996600\",\"brightCyan\":\"#b0c4de\",\"brightWhite\":\"#ddccbb\",\"background\":\"#1c1c1c\",\"foreground\":\"#ddeedd\",\"cursorColor\":\"#e2bbef\",\"selectionBackground\":\"#4d4d4d\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"baskerville\",\"link\":\"https://github.com/baskerville/iTerm-2-Color-Themes\"}]}},{\"name\":\"AtelierSulphurpool\",\"black\":\"#202746\",\"red\":\"#c94922\",\"green\":\"#ac9739\",\"yellow\":\"#c08b30\",\"blue\":\"#3d8fd1\",\"purple\":\"#6679cc\",\"cyan\":\"#22a2c9\",\"white\":\"#979db4\",\"brightBlack\":\"#6b7394\",\"brightRed\":\"#c76b29\",\"brightGreen\":\"#293256\",\"brightYellow\":\"#5e6687\",\"brightBlue\":\"#898ea4\",\"brightPurple\":\"#dfe2f1\",\"brightCyan\":\"#9c637a\",\"brightWhite\":\"#f5f7ff\",\"background\":\"#202746\",\"foreground\":\"#979db4\",\"cursorColor\":\"#979db4\",\"selectionBackground\":\"#5e6687\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"atelierbram\",\"link\":\"http://atelierbram.github.io/syntax-highlighting/atelier-schemes/sulphurpool/\"}]}},{\"name\":\"Atom\",\"black\":\"#000000\",\"red\":\"#fd5ff1\",\"green\":\"#87c38a\",\"yellow\":\"#ffd7b1\",\"blue\":\"#85befd\",\"purple\":\"#b9b6fc\",\"cyan\":\"#85befd\",\"white\":\"#e0e0e0\",\"brightBlack\":\"#000000\",\"brightRed\":\"#fd5ff1\",\"brightGreen\":\"#94fa36\",\"brightYellow\":\"#f5ffa8\",\"brightBlue\":\"#96cbfe\",\"brightPurple\":\"#b9b6fc\",\"brightCyan\":\"#85befd\",\"brightWhite\":\"#e0e0e0\",\"background\":\"#161719\",\"foreground\":\"#c5c8c6\",\"cursorColor\":\"#d0d0d0\",\"selectionBackground\":\"#444444\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"bahlo\",\"link\":\"https://github.com/bahlo/iterm-colors\"}]}},{\"name\":\"AtomOneLight\",\"black\":\"#000000\",\"red\":\"#de3e35\",\"green\":\"#3f953a\",\"yellow\":\"#d2b67c\",\"blue\":\"#2f5af3\",\"purple\":\"#950095\",\"cyan\":\"#3f953a\",\"white\":\"#bbbbbb\",\"brightBlack\":\"#000000\",\"brightRed\":\"#de3e35\",\"brightGreen\":\"#3f953a\",\"brightYellow\":\"#d2b67c\",\"brightBlue\":\"#2f5af3\",\"brightPurple\":\"#a00095\",\"brightCyan\":\"#3f953a\",\"brightWhite\":\"#ffffff\",\"background\":\"#f9f9f9\",\"foreground\":\"#2a2c33\",\"cursorColor\":\"#bbbbbb\",\"selectionBackground\":\"#ededed\",\"meta\":{\"isDark\":false,\"credits\":[{\"name\":\"iamstarkov\",\"link\":\"https://github.com/iamstarkov\"}]}},{\"name\":\"Aura\",\"black\":\"#110f18\",\"red\":\"#ff6767\",\"green\":\"#61ffca\",\"yellow\":\"#ffca85\",\"blue\":\"#a277ff\",\"purple\":\"#a277ff\",\"cyan\":\"#61ffca\",\"white\":\"#edecee\",\"brightBlack\":\"#6d6d6d\",\"brightRed\":\"#ffca85\",\"brightGreen\":\"#a277ff\",\"brightYellow\":\"#ffca85\",\"brightBlue\":\"#a277ff\",\"brightPurple\":\"#a277ff\",\"brightCyan\":\"#61ffca\",\"brightWhite\":\"#edecee\",\"foreground\":\"#edecee\",\"background\":\"#15141B\",\"cursorColor\":\"#edecee\"},{\"name\":\"Aurora\",\"black\":\"#23262e\",\"red\":\"#f0266f\",\"green\":\"#8fd46d\",\"yellow\":\"#ffe66d\",\"blue\":\"#0321d7\",\"purple\":\"#ee5d43\",\"cyan\":\"#03d6b8\",\"white\":\"#c74ded\",\"brightBlack\":\"#292e38\",\"brightRed\":\"#f92672\",\"brightGreen\":\"#8fd46d\",\"brightYellow\":\"#ffe66d\",\"brightBlue\":\"#03d6b8\",\"brightPurple\":\"#ee5d43\",\"brightCyan\":\"#03d6b8\",\"brightWhite\":\"#c74ded\",\"background\":\"#23262e\",\"foreground\":\"#ffca28\",\"cursorColor\":\"#ee5d43\",\"selectionBackground\":\"#292e38\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"fcsmJS\",\"link\":\"https://github.com/fcsmJS/iTerm2-Color-Schemes\"}]}},{\"name\":\"ayu\",\"black\":\"#000000\",\"red\":\"#ff3333\",\"green\":\"#b8cc52\",\"yellow\":\"#e7c547\",\"blue\":\"#36a3d9\",\"purple\":\"#f07178\",\"cyan\":\"#95e6cb\",\"white\":\"#ffffff\",\"brightBlack\":\"#323232\",\"brightRed\":\"#ff6565\",\"brightGreen\":\"#eafe84\",\"brightYellow\":\"#fff779\",\"brightBlue\":\"#68d5ff\",\"brightPurple\":\"#ffa3aa\",\"brightCyan\":\"#c7fffd\",\"brightWhite\":\"#ffffff\",\"background\":\"#0f1419\",\"foreground\":\"#e6e1cf\",\"cursorColor\":\"#f29718\",\"selectionBackground\":\"#253340\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"alebcay\",\"link\":\"https://github.com/alebcay\"}]}},{\"name\":\"AyuDark\",\"black\":\"#0A0E14\",\"red\":\"#FF3333\",\"green\":\"#C2D94C\",\"yellow\":\"#FF8F40\",\"blue\":\"#59C2FF\",\"purple\":\"#FFEE99\",\"cyan\":\"#95E6CB\",\"white\":\"#B3B1AD\",\"brightBlack\":\"#4D5566\",\"brightRed\":\"#FF3333\",\"brightGreen\":\"#C2D94C\",\"brightYellow\":\"#FF8F40\",\"brightBlue\":\"#59C2FF\",\"brightPurple\":\"#FFEE99\",\"brightCyan\":\"#95E6CB\",\"brightWhite\":\"#B3B1AD\",\"foreground\":\"#B3B1AD\",\"background\":\"#0A0E14\",\"cursorColor\":\"#E6B450\"},{\"name\":\"ayu_light\",\"black\":\"#000000\",\"red\":\"#ff3333\",\"green\":\"#86b300\",\"yellow\":\"#f29718\",\"blue\":\"#41a6d9\",\"purple\":\"#f07178\",\"cyan\":\"#4dbf99\",\"white\":\"#ffffff\",\"brightBlack\":\"#323232\",\"brightRed\":\"#ff6565\",\"brightGreen\":\"#b8e532\",\"brightYellow\":\"#ffc94a\",\"brightBlue\":\"#73d8ff\",\"brightPurple\":\"#ffa3aa\",\"brightCyan\":\"#7ff1cb\",\"brightWhite\":\"#ffffff\",\"background\":\"#fafafa\",\"foreground\":\"#5c6773\",\"cursorColor\":\"#ff6a00\",\"selectionBackground\":\"#f0eee4\",\"meta\":{\"isDark\":false,\"credits\":[{\"name\":\"alebcay\",\"link\":\"https://github.com/alebcay\"}]}},{\"name\":\"AyuMirage\",\"black\":\"#1F2430\",\"red\":\"#FF3333\",\"green\":\"#BAE67E\",\"yellow\":\"#FFA759\",\"blue\":\"#73D0FF\",\"purple\":\"#D4BFFF\",\"cyan\":\"#95E6CB\",\"white\":\"#CBCCC6\",\"brightBlack\":\"#707A8C\",\"brightRed\":\"#FF3333\",\"brightGreen\":\"#BAE67E\",\"brightYellow\":\"#FFA759\",\"brightBlue\":\"#73D0FF\",\"brightPurple\":\"#D4BFFF\",\"brightCyan\":\"#95E6CB\",\"brightWhite\":\"#CBCCC6\",\"foreground\":\"#CBCCC6\",\"background\":\"#1F2430\",\"cursorColor\":\"#FFCC66\"},{\"name\":\"Azu\",\"black\":\"#000000\",\"red\":\"#ac6d74\",\"green\":\"#74ac6d\",\"yellow\":\"#aca46d\",\"blue\":\"#6d74ac\",\"purple\":\"#a46dac\",\"cyan\":\"#6daca4\",\"white\":\"#e6e6e6\",\"brightBlack\":\"#262626\",\"brightRed\":\"#d6b8bc\",\"brightGreen\":\"#bcd6b8\",\"brightYellow\":\"#d6d3b8\",\"brightBlue\":\"#b8bcd6\",\"brightPurple\":\"#d3b8d6\",\"brightCyan\":\"#b8d6d3\",\"brightWhite\":\"#ffffff\",\"foreground\":\"#d9e6f2\",\"background\":\"#09111a\",\"cursorColor\":\"#d9e6f2\"},{\"name\":\"Banana Blueberry\",\"black\":\"#17141f\",\"red\":\"#ff6b7f\",\"green\":\"#00bd9c\",\"yellow\":\"#e6c62f\",\"blue\":\"#22e8df\",\"purple\":\"#dc396a\",\"cyan\":\"#56b6c2\",\"white\":\"#f1f1f1\",\"brightBlack\":\"#495162\",\"brightRed\":\"#fe9ea1\",\"brightGreen\":\"#98c379\",\"brightYellow\":\"#f9e46b\",\"brightBlue\":\"#91fff4\",\"brightPurple\":\"#da70d6\",\"brightCyan\":\"#bcf3ff\",\"brightWhite\":\"#ffffff\",\"background\":\"#191323\",\"foreground\":\"#cccccc\",\"cursorColor\":\"#e07d13\",\"selectionBackground\":\"#220525\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"ReagentX\",\"link\":\"https://github.com/ReagentX\"}]}},{\"name\":\"Batman\",\"black\":\"#1b1d1e\",\"red\":\"#e6dc44\",\"green\":\"#c8be46\",\"yellow\":\"#f4fd22\",\"blue\":\"#737174\",\"purple\":\"#747271\",\"cyan\":\"#62605f\",\"white\":\"#c6c5bf\",\"brightBlack\":\"#505354\",\"brightRed\":\"#fff78e\",\"brightGreen\":\"#fff27d\",\"brightYellow\":\"#feed6c\",\"brightBlue\":\"#919495\",\"brightPurple\":\"#9a9a9d\",\"brightCyan\":\"#a3a3a6\",\"brightWhite\":\"#dadbd6\",\"background\":\"#1b1d1e\",\"foreground\":\"#6f6f6f\",\"cursorColor\":\"#fcef0c\",\"selectionBackground\":\"#4d504c\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"pyrophos\",\"link\":\"https://github.com/pyrophos\"}]}},{\"name\":\"Belafonte Day\",\"black\":\"#20111b\",\"red\":\"#be100e\",\"green\":\"#858162\",\"yellow\":\"#eaa549\",\"blue\":\"#426a79\",\"purple\":\"#97522c\",\"cyan\":\"#989a9c\",\"white\":\"#968c83\",\"brightBlack\":\"#5e5252\",\"brightRed\":\"#be100e\",\"brightGreen\":\"#858162\",\"brightYellow\":\"#eaa549\",\"brightBlue\":\"#426a79\",\"brightPurple\":\"#97522c\",\"brightCyan\":\"#989a9c\",\"brightWhite\":\"#d5ccba\",\"background\":\"#d5ccba\",\"foreground\":\"#45373c\",\"cursorColor\":\"#45373c\",\"selectionBackground\":\"#968c83\",\"meta\":{\"isDark\":false,\"credits\":[{\"name\":\"idleberg\",\"link\":\"https://github.com/idleberg\"}]}},{\"name\":\"Belafonte Night\",\"black\":\"#20111b\",\"red\":\"#be100e\",\"green\":\"#858162\",\"yellow\":\"#eaa549\",\"blue\":\"#426a79\",\"purple\":\"#97522c\",\"cyan\":\"#989a9c\",\"white\":\"#968c83\",\"brightBlack\":\"#5e5252\",\"brightRed\":\"#be100e\",\"brightGreen\":\"#858162\",\"brightYellow\":\"#eaa549\",\"brightBlue\":\"#426a79\",\"brightPurple\":\"#97522c\",\"brightCyan\":\"#989a9c\",\"brightWhite\":\"#d5ccba\",\"background\":\"#20111b\",\"foreground\":\"#968c83\",\"cursorColor\":\"#968c83\",\"selectionBackground\":\"#45373c\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"idleberg\",\"link\":\"https://github.com/idleberg\"}]}},{\"name\":\"Bim\",\"black\":\"#2c2423\",\"red\":\"#f557a0\",\"green\":\"#a9ee55\",\"yellow\":\"#f5a255\",\"blue\":\"#5ea2ec\",\"purple\":\"#a957ec\",\"cyan\":\"#5eeea0\",\"white\":\"#918988\",\"brightBlack\":\"#918988\",\"brightRed\":\"#f579b2\",\"brightGreen\":\"#bbee78\",\"brightYellow\":\"#f5b378\",\"brightBlue\":\"#81b3ec\",\"brightPurple\":\"#bb79ec\",\"brightCyan\":\"#81eeb2\",\"brightWhite\":\"#f5eeec\",\"foreground\":\"#a9bed8\",\"background\":\"#012849\",\"cursorColor\":\"#a9bed8\"},{\"name\":\"BirdsOfParadise\",\"black\":\"#573d26\",\"red\":\"#be2d26\",\"green\":\"#6ba18a\",\"yellow\":\"#e99d2a\",\"blue\":\"#5a86ad\",\"purple\":\"#ac80a6\",\"cyan\":\"#74a6ad\",\"white\":\"#e0dbb7\",\"brightBlack\":\"#9b6c4a\",\"brightRed\":\"#e84627\",\"brightGreen\":\"#95d8ba\",\"brightYellow\":\"#d0d150\",\"brightBlue\":\"#b8d3ed\",\"brightPurple\":\"#d19ecb\",\"brightCyan\":\"#93cfd7\",\"brightWhite\":\"#fff9d5\",\"background\":\"#2a1f1d\",\"foreground\":\"#e0dbb7\",\"cursorColor\":\"#573d26\",\"selectionBackground\":\"#563c27\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"zdj\",\"link\":\"https://github.com/zdj/themes/tree/master/iterm2\"}]}},{\"name\":\"Blazer\",\"black\":\"#000000\",\"red\":\"#b87a7a\",\"green\":\"#7ab87a\",\"yellow\":\"#b8b87a\",\"blue\":\"#7a7ab8\",\"purple\":\"#b87ab8\",\"cyan\":\"#7ab8b8\",\"white\":\"#d9d9d9\",\"brightBlack\":\"#262626\",\"brightRed\":\"#dbbdbd\",\"brightGreen\":\"#bddbbd\",\"brightYellow\":\"#dbdbbd\",\"brightBlue\":\"#bdbddb\",\"brightPurple\":\"#dbbddb\",\"brightCyan\":\"#bddbdb\",\"brightWhite\":\"#ffffff\",\"background\":\"#0d1926\",\"foreground\":\"#d9e6f2\",\"cursorColor\":\"#d9e6f2\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"BlueBerryPie\",\"black\":\"#0a4c62\",\"red\":\"#99246e\",\"green\":\"#5cb1b3\",\"yellow\":\"#eab9a8\",\"blue\":\"#90a5bd\",\"purple\":\"#9d54a7\",\"cyan\":\"#7e83cc\",\"white\":\"#f0e8d6\",\"brightBlack\":\"#201637\",\"brightRed\":\"#c87272\",\"brightGreen\":\"#0a6c7e\",\"brightYellow\":\"#7a3188\",\"brightBlue\":\"#39173d\",\"brightPurple\":\"#bc94b7\",\"brightCyan\":\"#5e6071\",\"brightWhite\":\"#0a6c7e\",\"background\":\"#1c0c28\",\"foreground\":\"#babab9\",\"cursorColor\":\"#fcfad6\",\"selectionBackground\":\"#606060\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"murmurlilia\",\"link\":\"https://www.instagram.com/the.julias\"},{\"name\":\"fitz123\",\"link\":\"https://github.com/fitz123\"}]}},{\"name\":\"Blue Matrix\",\"black\":\"#101116\",\"red\":\"#ff5680\",\"green\":\"#00ff9c\",\"yellow\":\"#fffc58\",\"blue\":\"#00b0ff\",\"purple\":\"#d57bff\",\"cyan\":\"#76c1ff\",\"white\":\"#c7c7c7\",\"brightBlack\":\"#686868\",\"brightRed\":\"#ff6e67\",\"brightGreen\":\"#5ffa68\",\"brightYellow\":\"#fffc67\",\"brightBlue\":\"#6871ff\",\"brightPurple\":\"#d682ec\",\"brightCyan\":\"#60fdff\",\"brightWhite\":\"#ffffff\",\"background\":\"#101116\",\"foreground\":\"#00a2ff\",\"cursorColor\":\"#76ff9f\",\"selectionBackground\":\"#c1deff\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"ReagentX\",\"link\":\"https://github.com/ReagentX\"}]}},{\"name\":\"BlulocoDark\",\"black\":\"#4a505d\",\"red\":\"#f81141\",\"green\":\"#23974a\",\"yellow\":\"#fd7e57\",\"blue\":\"#285bff\",\"purple\":\"#8c62fd\",\"cyan\":\"#366f9a\",\"white\":\"#ccd5e5\",\"brightBlack\":\"#61697a\",\"brightRed\":\"#fc4a6d\",\"brightGreen\":\"#37bd58\",\"brightYellow\":\"#f6be48\",\"brightBlue\":\"#199ffd\",\"brightPurple\":\"#fc58f6\",\"brightCyan\":\"#50acae\",\"brightWhite\":\"#ffffff\",\"background\":\"#1e2127\",\"foreground\":\"#abb2bf\",\"cursorColor\":\"#fec309\",\"selectionBackground\":\"#2f3441\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"BlulocoLight\",\"black\":\"#cbccd5\",\"red\":\"#c90e42\",\"green\":\"#21883a\",\"yellow\":\"#d54d17\",\"blue\":\"#1e44dd\",\"purple\":\"#6d1bed\",\"cyan\":\"#1f4d7a\",\"white\":\"#000000\",\"brightBlack\":\"#dedfe8\",\"brightRed\":\"#fc4a6d\",\"brightGreen\":\"#34b354\",\"brightYellow\":\"#b89427\",\"brightBlue\":\"#1085d9\",\"brightPurple\":\"#c00db3\",\"brightCyan\":\"#5b80ad\",\"brightWhite\":\"#1d1d22\",\"background\":\"#f7f7f7\",\"foreground\":\"#2a2c33\",\"cursorColor\":\"#ed0047\",\"selectionBackground\":\"#d2ecff\",\"meta\":{\"isDark\":false,\"credits\":null}},{\"name\":\"BlulocoZshLight\",\"black\":\"#e4e5f1\",\"red\":\"#d52753\",\"green\":\"#23974a\",\"yellow\":\"#df631c\",\"blue\":\"#275fe4\",\"purple\":\"#823ff1\",\"cyan\":\"#27618d\",\"white\":\"#000000\",\"brightBlack\":\"#5794de\",\"brightRed\":\"#ff6480\",\"brightGreen\":\"#3cbc66\",\"brightYellow\":\"#c5a332\",\"brightBlue\":\"#0099e1\",\"brightPurple\":\"#ce33c0\",\"brightCyan\":\"#6d93bb\",\"brightWhite\":\"#26272d\",\"foreground\":\"#383a42\",\"background\":\"#f9f9f9\",\"cursorColor\":\"#383a42\"},{\"name\":\"Borland\",\"black\":\"#4f4f4f\",\"red\":\"#ff6c60\",\"green\":\"#a8ff60\",\"yellow\":\"#ffffb6\",\"blue\":\"#96cbfe\",\"purple\":\"#ff73fd\",\"cyan\":\"#c6c5fe\",\"white\":\"#eeeeee\",\"brightBlack\":\"#7c7c7c\",\"brightRed\":\"#ffb6b0\",\"brightGreen\":\"#ceffac\",\"brightYellow\":\"#ffffcc\",\"brightBlue\":\"#b5dcff\",\"brightPurple\":\"#ff9cfe\",\"brightCyan\":\"#dfdffe\",\"brightWhite\":\"#ffffff\",\"background\":\"#0000a4\",\"foreground\":\"#ffff4e\",\"cursorColor\":\"#ffa560\",\"selectionBackground\":\"#a4a4a4\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"delip\",\"link\":\"https://gist.github.com/delip/9e16c606d9331d69d681\"}]}},{\"name\":\"Breeze\",\"black\":\"#31363b\",\"red\":\"#ed1515\",\"green\":\"#11d116\",\"yellow\":\"#f67400\",\"blue\":\"#1d99f3\",\"purple\":\"#9b59b6\",\"cyan\":\"#1abc9c\",\"white\":\"#eff0f1\",\"brightBlack\":\"#7f8c8d\",\"brightRed\":\"#c0392b\",\"brightGreen\":\"#1cdc9a\",\"brightYellow\":\"#fdbc4b\",\"brightBlue\":\"#3daee9\",\"brightPurple\":\"#8e44ad\",\"brightCyan\":\"#16a085\",\"brightWhite\":\"#fcfcfc\",\"background\":\"#31363b\",\"foreground\":\"#eff0f1\",\"cursorColor\":\"#eff0f1\",\"selectionBackground\":\"#eff0f1\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"KDE\",\"link\":\"https://kde.org\"},{\"name\":\"nieltg\",\"link\":\"https://github.com/nieltg\"}]}},{\"name\":\"Bright Lights\",\"black\":\"#191919\",\"red\":\"#ff355b\",\"green\":\"#b7e876\",\"yellow\":\"#ffc251\",\"blue\":\"#76d4ff\",\"purple\":\"#ba76e7\",\"cyan\":\"#6cbfb5\",\"white\":\"#c2c8d7\",\"brightBlack\":\"#191919\",\"brightRed\":\"#ff355b\",\"brightGreen\":\"#b7e876\",\"brightYellow\":\"#ffc251\",\"brightBlue\":\"#76d5ff\",\"brightPurple\":\"#ba76e7\",\"brightCyan\":\"#6cbfb5\",\"brightWhite\":\"#c2c8d7\",\"background\":\"#191919\",\"foreground\":\"#b3c9d7\",\"cursorColor\":\"#f34b00\",\"selectionBackground\":\"#b3c9d7\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"tw15egan\",\"link\":\"https://github.com/tw15egan\"}]}},{\"name\":\"Broadcast\",\"black\":\"#000000\",\"red\":\"#da4939\",\"green\":\"#519f50\",\"yellow\":\"#ffd24a\",\"blue\":\"#6d9cbe\",\"purple\":\"#d0d0ff\",\"cyan\":\"#6e9cbe\",\"white\":\"#ffffff\",\"brightBlack\":\"#323232\",\"brightRed\":\"#ff7b6b\",\"brightGreen\":\"#83d182\",\"brightYellow\":\"#ffff7c\",\"brightBlue\":\"#9fcef0\",\"brightPurple\":\"#ffffff\",\"brightCyan\":\"#a0cef0\",\"brightWhite\":\"#ffffff\",\"background\":\"#2b2b2b\",\"foreground\":\"#e6e1dc\",\"cursorColor\":\"#ffffff\",\"selectionBackground\":\"#5a647e\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"vinkla\",\"link\":\"https://github.com/vinkla/broadcast-theme\"}]}},{\"name\":\"Brogrammer\",\"black\":\"#1f1f1f\",\"red\":\"#f81118\",\"green\":\"#2dc55e\",\"yellow\":\"#ecba0f\",\"blue\":\"#2a84d2\",\"purple\":\"#4e5ab7\",\"cyan\":\"#1081d6\",\"white\":\"#d6dbe5\",\"brightBlack\":\"#d6dbe5\",\"brightRed\":\"#de352e\",\"brightGreen\":\"#1dd361\",\"brightYellow\":\"#f3bd09\",\"brightBlue\":\"#1081d6\",\"brightPurple\":\"#5350b9\",\"brightCyan\":\"#0f7ddb\",\"brightWhite\":\"#ffffff\",\"background\":\"#131313\",\"foreground\":\"#d6dbe5\",\"cursorColor\":\"#b9b9b9\",\"selectionBackground\":\"#1f1f1f\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"bahlo\",\"link\":\"https://github.com/bahlo/iterm-colors\"}]}},{\"name\":\"Bubbles\",\"background\":\"#161D38\",\"black\":\"#000000\",\"blue\":\"#589DF6\",\"brightBlack\":\"#555555\",\"brightBlue\":\"#589DF6\",\"brightCyan\":\"#3979BC\",\"brightGreen\":\"#35BB9A\",\"brightPurple\":\"#E75699\",\"brightRed\":\"#FA8C8F\",\"brightWhite\":\"#FFFFFF\",\"brightYellow\":\"#FFFF55\",\"cursorColor\":\"#BBBBBB\",\"cyan\":\"#1F9EE7\",\"foreground\":\"#FFFFFF\",\"green\":\"#21B089\",\"purple\":\"#944D95\",\"red\":\"#F9555F\",\"selectionBackground\":\"#B5D5FF\",\"white\":\"#BBBBBB\",\"yellow\":\"#FEF02A\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"jos3s\",\"link\":\"https://github.com/jos3s\"}]}},{\"name\":\"Builtin Dark\",\"black\":\"#000000\",\"red\":\"#bb0000\",\"green\":\"#00bb00\",\"yellow\":\"#bbbb00\",\"blue\":\"#0000bb\",\"purple\":\"#bb00bb\",\"cyan\":\"#00bbbb\",\"white\":\"#bbbbbb\",\"brightBlack\":\"#555555\",\"brightRed\":\"#ff5555\",\"brightGreen\":\"#55ff55\",\"brightYellow\":\"#ffff55\",\"brightBlue\":\"#5555ff\",\"brightPurple\":\"#ff55ff\",\"brightCyan\":\"#55ffff\",\"brightWhite\":\"#ffffff\",\"background\":\"#000000\",\"foreground\":\"#bbbbbb\",\"cursorColor\":\"#bbbbbb\",\"selectionBackground\":\"#b5d5ff\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"Builtin Light\",\"black\":\"#000000\",\"red\":\"#bb0000\",\"green\":\"#00bb00\",\"yellow\":\"#bbbb00\",\"blue\":\"#0000bb\",\"purple\":\"#bb00bb\",\"cyan\":\"#00bbbb\",\"white\":\"#bbbbbb\",\"brightBlack\":\"#555555\",\"brightRed\":\"#ff5555\",\"brightGreen\":\"#55ff55\",\"brightYellow\":\"#ffff55\",\"brightBlue\":\"#5555ff\",\"brightPurple\":\"#ff55ff\",\"brightCyan\":\"#55ffff\",\"brightWhite\":\"#ffffff\",\"background\":\"#ffffff\",\"foreground\":\"#000000\",\"cursorColor\":\"#000000\",\"selectionBackground\":\"#b5d5ff\",\"meta\":{\"isDark\":false,\"credits\":null}},{\"name\":\"Builtin Pastel Dark\",\"black\":\"#4f4f4f\",\"red\":\"#ff6c60\",\"green\":\"#a8ff60\",\"yellow\":\"#ffffb6\",\"blue\":\"#96cbfe\",\"purple\":\"#ff73fd\",\"cyan\":\"#c6c5fe\",\"white\":\"#eeeeee\",\"brightBlack\":\"#7c7c7c\",\"brightRed\":\"#ffb6b0\",\"brightGreen\":\"#ceffac\",\"brightYellow\":\"#ffffcc\",\"brightBlue\":\"#b5dcff\",\"brightPurple\":\"#ff9cfe\",\"brightCyan\":\"#dfdffe\",\"brightWhite\":\"#ffffff\",\"background\":\"#000000\",\"foreground\":\"#bbbbbb\",\"cursorColor\":\"#ffa560\",\"selectionBackground\":\"#363983\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"Builtin Solarized Dark\",\"black\":\"#073642\",\"red\":\"#dc322f\",\"green\":\"#859900\",\"yellow\":\"#b58900\",\"blue\":\"#268bd2\",\"purple\":\"#d33682\",\"cyan\":\"#2aa198\",\"white\":\"#eee8d5\",\"brightBlack\":\"#002b36\",\"brightRed\":\"#cb4b16\",\"brightGreen\":\"#586e75\",\"brightYellow\":\"#657b83\",\"brightBlue\":\"#839496\",\"brightPurple\":\"#6c71c4\",\"brightCyan\":\"#93a1a1\",\"brightWhite\":\"#fdf6e3\",\"background\":\"#002b36\",\"foreground\":\"#839496\",\"cursorColor\":\"#839496\",\"selectionBackground\":\"#073642\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Solarized web site\",\"link\":\"http://ethanschoonover.com/solarized\"}]}},{\"name\":\"Builtin Solarized Light\",\"black\":\"#073642\",\"red\":\"#dc322f\",\"green\":\"#859900\",\"yellow\":\"#b58900\",\"blue\":\"#268bd2\",\"purple\":\"#d33682\",\"cyan\":\"#2aa198\",\"white\":\"#eee8d5\",\"brightBlack\":\"#002b36\",\"brightRed\":\"#cb4b16\",\"brightGreen\":\"#586e75\",\"brightYellow\":\"#657b83\",\"brightBlue\":\"#839496\",\"brightPurple\":\"#6c71c4\",\"brightCyan\":\"#93a1a1\",\"brightWhite\":\"#fdf6e3\",\"background\":\"#fdf6e3\",\"foreground\":\"#657b83\",\"cursorColor\":\"#657b83\",\"selectionBackground\":\"#eee8d5\",\"meta\":{\"isDark\":false,\"credits\":[{\"name\":\"Solarized web site\",\"link\":\"http://ethanschoonover.com/solarized\"}]}},{\"name\":\"Builtin Tango Dark\",\"black\":\"#000000\",\"red\":\"#cc0000\",\"green\":\"#4e9a06\",\"yellow\":\"#c4a000\",\"blue\":\"#3465a4\",\"purple\":\"#75507b\",\"cyan\":\"#06989a\",\"white\":\"#d3d7cf\",\"brightBlack\":\"#555753\",\"brightRed\":\"#ef2929\",\"brightGreen\":\"#8ae234\",\"brightYellow\":\"#fce94f\",\"brightBlue\":\"#729fcf\",\"brightPurple\":\"#ad7fa8\",\"brightCyan\":\"#34e2e2\",\"brightWhite\":\"#eeeeec\",\"background\":\"#000000\",\"foreground\":\"#ffffff\",\"cursorColor\":\"#ffffff\",\"selectionBackground\":\"#b5d5ff\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"Builtin Tango Light\",\"black\":\"#000000\",\"red\":\"#cc0000\",\"green\":\"#4e9a06\",\"yellow\":\"#c4a000\",\"blue\":\"#3465a4\",\"purple\":\"#75507b\",\"cyan\":\"#06989a\",\"white\":\"#d3d7cf\",\"brightBlack\":\"#555753\",\"brightRed\":\"#ef2929\",\"brightGreen\":\"#8ae234\",\"brightYellow\":\"#fce94f\",\"brightBlue\":\"#729fcf\",\"brightPurple\":\"#ad7fa8\",\"brightCyan\":\"#34e2e2\",\"brightWhite\":\"#eeeeec\",\"background\":\"#ffffff\",\"foreground\":\"#000000\",\"cursorColor\":\"#000000\",\"selectionBackground\":\"#b5d5ff\",\"meta\":{\"isDark\":false,\"credits\":null}},{\"name\":\"C64\",\"black\":\"#090300\",\"red\":\"#883932\",\"green\":\"#55a049\",\"yellow\":\"#bfce72\",\"blue\":\"#40318d\",\"purple\":\"#8b3f96\",\"cyan\":\"#67b6bd\",\"white\":\"#ffffff\",\"brightBlack\":\"#000000\",\"brightRed\":\"#883932\",\"brightGreen\":\"#55a049\",\"brightYellow\":\"#bfce72\",\"brightBlue\":\"#40318d\",\"brightPurple\":\"#8b3f96\",\"brightCyan\":\"#67b6bd\",\"brightWhite\":\"#f7f7f7\",\"background\":\"#40318d\",\"foreground\":\"#7869c4\",\"cursorColor\":\"#7869c4\",\"selectionBackground\":\"#7869c4\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"idleberg\",\"link\":\"https://github.com/idleberg\"}]}},{\"name\":\"Cai\",\"black\":\"#000000\",\"red\":\"#ca274d\",\"green\":\"#4dca27\",\"yellow\":\"#caa427\",\"blue\":\"#274dca\",\"purple\":\"#a427ca\",\"cyan\":\"#27caa4\",\"white\":\"#808080\",\"brightBlack\":\"#808080\",\"brightRed\":\"#e98da3\",\"brightGreen\":\"#a3e98d\",\"brightYellow\":\"#e9d48d\",\"brightBlue\":\"#8da3e9\",\"brightPurple\":\"#d48de9\",\"brightCyan\":\"#8de9d4\",\"brightWhite\":\"#ffffff\",\"foreground\":\"#d9e6f2\",\"background\":\"#09111a\",\"cursorColor\":\"#d9e6f2\"},{\"name\":\"Calamity\",\"black\":\"#2f2833\",\"red\":\"#fc644d\",\"green\":\"#a5f69c\",\"yellow\":\"#e9d7a5\",\"blue\":\"#3b79c7\",\"purple\":\"#f92672\",\"cyan\":\"#74d3de\",\"white\":\"#d5ced9\",\"brightBlack\":\"#7e6c88\",\"brightRed\":\"#fc644d\",\"brightGreen\":\"#a5f69c\",\"brightYellow\":\"#e9d7a5\",\"brightBlue\":\"#3b79c7\",\"brightPurple\":\"#f92672\",\"brightCyan\":\"#74d3de\",\"brightWhite\":\"#ffffff\",\"background\":\"#2f2833\",\"foreground\":\"#d5ced9\",\"cursorColor\":\"#d5ced9\",\"selectionBackground\":\"#7e6c88\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Pustur\",\"link\":\"https://github.com/Pustur\"}]}},{\"name\":\"Chalk\",\"black\":\"#7d8b8f\",\"red\":\"#b23a52\",\"green\":\"#789b6a\",\"yellow\":\"#b9ac4a\",\"blue\":\"#2a7fac\",\"purple\":\"#bd4f5a\",\"cyan\":\"#44a799\",\"white\":\"#d2d8d9\",\"brightBlack\":\"#888888\",\"brightRed\":\"#f24840\",\"brightGreen\":\"#80c470\",\"brightYellow\":\"#ffeb62\",\"brightBlue\":\"#4196ff\",\"brightPurple\":\"#fc5275\",\"brightCyan\":\"#53cdbd\",\"brightWhite\":\"#d2d8d9\",\"background\":\"#2b2d2e\",\"foreground\":\"#d2d8d9\",\"cursorColor\":\"#708284\",\"selectionBackground\":\"#e4e8ed\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"achalv\",\"link\":\"https://github.com/achalv/chalk\"}]}},{\"name\":\"Chalkboard\",\"black\":\"#000000\",\"red\":\"#c37372\",\"green\":\"#72c373\",\"yellow\":\"#c2c372\",\"blue\":\"#7372c3\",\"purple\":\"#c372c2\",\"cyan\":\"#72c2c3\",\"white\":\"#d9d9d9\",\"brightBlack\":\"#323232\",\"brightRed\":\"#dbaaaa\",\"brightGreen\":\"#aadbaa\",\"brightYellow\":\"#dadbaa\",\"brightBlue\":\"#aaaadb\",\"brightPurple\":\"#dbaada\",\"brightCyan\":\"#aadadb\",\"brightWhite\":\"#ffffff\",\"background\":\"#29262f\",\"foreground\":\"#d9e6f2\",\"cursorColor\":\"#d9e6f2\",\"selectionBackground\":\"#073642\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"ChallengerDeep\",\"black\":\"#141228\",\"red\":\"#ff5458\",\"green\":\"#62d196\",\"yellow\":\"#ffb378\",\"blue\":\"#65b2ff\",\"purple\":\"#906cff\",\"cyan\":\"#63f2f1\",\"white\":\"#a6b3cc\",\"brightBlack\":\"#565575\",\"brightRed\":\"#ff8080\",\"brightGreen\":\"#95ffa4\",\"brightYellow\":\"#ffe9aa\",\"brightBlue\":\"#91ddff\",\"brightPurple\":\"#c991e1\",\"brightCyan\":\"#aaffe4\",\"brightWhite\":\"#cbe3e7\",\"background\":\"#1e1c31\",\"foreground\":\"#cbe1e7\",\"cursorColor\":\"#fbfcfc\",\"selectionBackground\":\"#cbe1e7\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"challenger-deep-theme\",\"link\":\"https://github.com/challenger-deep-theme/vim\"},{\"name\":\"eendroroy\",\"link\":\"https://github.com/eendroroy\"}]}},{\"name\":\"Chameleon\",\"black\":\"#2C2C2C\",\"red\":\"#CC231C\",\"green\":\"#689D69\",\"yellow\":\"#D79922\",\"blue\":\"#366B71\",\"purple\":\"#4E5165\",\"cyan\":\"#458587\",\"white\":\"#C8BB97\",\"brightBlack\":\"#777777\",\"brightRed\":\"#CC231C\",\"brightGreen\":\"#689D69\",\"brightYellow\":\"#D79922\",\"brightBlue\":\"#366B71\",\"brightPurple\":\"#4E5165\",\"brightCyan\":\"#458587\",\"brightWhite\":\"#C8BB97\",\"foreground\":\"#DEDEDE\",\"background\":\"#2C2C2C\",\"cursorColor\":\"#DEDEDE\"},{\"name\":\"Chester\",\"black\":\"#080200\",\"red\":\"#fa5e5b\",\"green\":\"#16c98d\",\"yellow\":\"#ffc83f\",\"blue\":\"#288ad6\",\"purple\":\"#d34590\",\"cyan\":\"#28ddde\",\"white\":\"#e7e7e7\",\"brightBlack\":\"#6f6b68\",\"brightRed\":\"#fa5e5b\",\"brightGreen\":\"#16c98d\",\"brightYellow\":\"#feef6d\",\"brightBlue\":\"#278ad6\",\"brightPurple\":\"#d34590\",\"brightCyan\":\"#27dede\",\"brightWhite\":\"#ffffff\",\"background\":\"#2c3643\",\"foreground\":\"#ffffff\",\"cursorColor\":\"#b4b1b1\",\"selectionBackground\":\"#67747c\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"KH\",\"link\":\"https://github.com/spectralkh\"}]}},{\"name\":\"Ciapre\",\"black\":\"#181818\",\"red\":\"#810009\",\"green\":\"#48513b\",\"yellow\":\"#cc8b3f\",\"blue\":\"#576d8c\",\"purple\":\"#724d7c\",\"cyan\":\"#5c4f4b\",\"white\":\"#aea47f\",\"brightBlack\":\"#555555\",\"brightRed\":\"#ac3835\",\"brightGreen\":\"#a6a75d\",\"brightYellow\":\"#dcdf7c\",\"brightBlue\":\"#3097c6\",\"brightPurple\":\"#d33061\",\"brightCyan\":\"#f3dbb2\",\"brightWhite\":\"#f4f4f4\",\"background\":\"#191c27\",\"foreground\":\"#aea47a\",\"cursorColor\":\"#92805b\",\"selectionBackground\":\"#172539\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"zdj\",\"link\":\"https://github.com/zdj/themes/tree/master/iterm2\"}]}},{\"name\":\"CloneofUbuntu\",\"black\":\"#2E3436\",\"red\":\"#CC0000\",\"green\":\"#4E9A06\",\"yellow\":\"#C4A000\",\"blue\":\"#3465A4\",\"purple\":\"#75507B\",\"cyan\":\"#06989A\",\"white\":\"#D3D7CF\",\"brightBlack\":\"#555753\",\"brightRed\":\"#EF2929\",\"brightGreen\":\"#8AE234\",\"brightYellow\":\"#FCE94F\",\"brightBlue\":\"#729FCF\",\"brightPurple\":\"#AD7FA8\",\"brightCyan\":\"#34E2E2\",\"brightWhite\":\"#EEEEEC\",\"foreground\":\"#ffffff\",\"background\":\"#300a24\",\"cursorColor\":\"#ffffff\"},{\"name\":\"CLRS\",\"black\":\"#000000\",\"red\":\"#f8282a\",\"green\":\"#328a5d\",\"yellow\":\"#fa701d\",\"blue\":\"#135cd0\",\"purple\":\"#9f00bd\",\"cyan\":\"#33c3c1\",\"white\":\"#b3b3b3\",\"brightBlack\":\"#555753\",\"brightRed\":\"#fb0416\",\"brightGreen\":\"#2cc631\",\"brightYellow\":\"#fdd727\",\"brightBlue\":\"#1670ff\",\"brightPurple\":\"#e900b0\",\"brightCyan\":\"#3ad5ce\",\"brightWhite\":\"#eeeeec\",\"background\":\"#ffffff\",\"foreground\":\"#262626\",\"cursorColor\":\"#6fd3fc\",\"selectionBackground\":\"#6fd3fc\",\"meta\":{\"isDark\":false,\"credits\":[{\"name\":\"jasonlong\",\"link\":\"https://github.com/jasonlong/iterm-clrs\"}]}},{\"name\":\"Cobalt2\",\"black\":\"#000000\",\"red\":\"#ff0000\",\"green\":\"#38de21\",\"yellow\":\"#ffe50a\",\"blue\":\"#1460d2\",\"purple\":\"#ff005d\",\"cyan\":\"#00bbbb\",\"white\":\"#bbbbbb\",\"brightBlack\":\"#555555\",\"brightRed\":\"#f40e17\",\"brightGreen\":\"#3bd01d\",\"brightYellow\":\"#edc809\",\"brightBlue\":\"#5555ff\",\"brightPurple\":\"#ff55ff\",\"brightCyan\":\"#6ae3fa\",\"brightWhite\":\"#ffffff\",\"background\":\"#132738\",\"foreground\":\"#ffffff\",\"cursorColor\":\"#f0cc09\",\"selectionBackground\":\"#18354f\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"wesbos\",\"link\":\"https://github.com/wesbos/Cobalt2-iterm\"}]}},{\"name\":\"Cobalt Neon\",\"black\":\"#142631\",\"red\":\"#ff2320\",\"green\":\"#3ba5ff\",\"yellow\":\"#e9e75c\",\"blue\":\"#8ff586\",\"purple\":\"#781aa0\",\"cyan\":\"#8ff586\",\"white\":\"#ba46b2\",\"brightBlack\":\"#fff688\",\"brightRed\":\"#d4312e\",\"brightGreen\":\"#8ff586\",\"brightYellow\":\"#e9f06d\",\"brightBlue\":\"#3c7dd2\",\"brightPurple\":\"#8230a7\",\"brightCyan\":\"#6cbc67\",\"brightWhite\":\"#8ff586\",\"background\":\"#142838\",\"foreground\":\"#8ff586\",\"cursorColor\":\"#c4206f\",\"selectionBackground\":\"#094fb1\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"vazquez\",\"link\":\"https://github.com/vazquez/cobalt-neon-iterm\"}]}},{\"name\":\"coffee_theme\",\"black\":\"#000000\",\"red\":\"#c91b00\",\"green\":\"#00c200\",\"yellow\":\"#c7c400\",\"blue\":\"#0225c7\",\"purple\":\"#ca30c7\",\"cyan\":\"#00c5c7\",\"white\":\"#c7c7c7\",\"brightBlack\":\"#686868\",\"brightRed\":\"#ff6e67\",\"brightGreen\":\"#5ffa68\",\"brightYellow\":\"#fffc67\",\"brightBlue\":\"#6871ff\",\"brightPurple\":\"#ff77ff\",\"brightCyan\":\"#60fdff\",\"brightWhite\":\"#ffffff\",\"background\":\"#f5deb3\",\"foreground\":\"#000000\",\"cursorColor\":\"#c7c7c7\",\"selectionBackground\":\"#c1deff\",\"meta\":{\"isDark\":false,\"credits\":[{\"name\":\"cbitterfield\",\"link\":\"https://github.com/cbitterfield\"}]}},{\"name\":\"Colorcli\",\"black\":\"#000000\",\"red\":\"#D70000\",\"green\":\"#5FAF00\",\"yellow\":\"#5FAF00\",\"blue\":\"#005F87\",\"purple\":\"#D70000\",\"cyan\":\"#5F5F5F\",\"white\":\"#E4E4E4\",\"brightBlack\":\"#5F5F5F\",\"brightRed\":\"#D70000\",\"brightGreen\":\"#5F5F5F\",\"brightYellow\":\"#FFFF00\",\"brightBlue\":\"#0087AF\",\"brightPurple\":\"#0087AF\",\"brightCyan\":\"#0087AF\",\"brightWhite\":\"#FFFFFF\",\"foreground\":\"#005F87\",\"background\":\"#FFFFFF\",\"cursorColor\":\"#005F87\"},{\"name\":\"CrayonPonyFish\",\"black\":\"#2b1b1d\",\"red\":\"#91002b\",\"green\":\"#579524\",\"yellow\":\"#ab311b\",\"blue\":\"#8c87b0\",\"purple\":\"#692f50\",\"cyan\":\"#e8a866\",\"white\":\"#68525a\",\"brightBlack\":\"#3d2b2e\",\"brightRed\":\"#c5255d\",\"brightGreen\":\"#8dff57\",\"brightYellow\":\"#c8381d\",\"brightBlue\":\"#cfc9ff\",\"brightPurple\":\"#fc6cba\",\"brightCyan\":\"#ffceaf\",\"brightWhite\":\"#b0949d\",\"background\":\"#150707\",\"foreground\":\"#68525a\",\"cursorColor\":\"#68525a\",\"selectionBackground\":\"#2b1b1d\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"zdj\",\"link\":\"https://github.com/zdj/themes/tree/master/iterm2\"}]}},{\"name\":\"Cyberdyne\",\"black\":\"#080808\",\"red\":\"#ff8373\",\"green\":\"#00c172\",\"yellow\":\"#d2a700\",\"blue\":\"#0071cf\",\"purple\":\"#ff90fe\",\"cyan\":\"#6bffdd\",\"white\":\"#f1f1f1\",\"brightBlack\":\"#2e2e2e\",\"brightRed\":\"#ffc4be\",\"brightGreen\":\"#d6fcba\",\"brightYellow\":\"#fffed5\",\"brightBlue\":\"#c2e3ff\",\"brightPurple\":\"#ffb2fe\",\"brightCyan\":\"#e6e7fe\",\"brightWhite\":\"#ffffff\",\"background\":\"#151144\",\"foreground\":\"#00ff92\",\"cursorColor\":\"#00ff9c\",\"selectionBackground\":\"#454d96\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"ReagentX\",\"link\":\"https://github.com/ReagentX\"}]}},{\"name\":\"cyberpunk\",\"black\":\"#000000\",\"red\":\"#ff7092\",\"green\":\"#00fbac\",\"yellow\":\"#fffa6a\",\"blue\":\"#00bfff\",\"purple\":\"#df95ff\",\"cyan\":\"#86cbfe\",\"white\":\"#ffffff\",\"brightBlack\":\"#000000\",\"brightRed\":\"#ff8aa4\",\"brightGreen\":\"#21f6bc\",\"brightYellow\":\"#fff787\",\"brightBlue\":\"#1bccfd\",\"brightPurple\":\"#e6aefe\",\"brightCyan\":\"#99d6fc\",\"brightWhite\":\"#ffffff\",\"background\":\"#332a57\",\"foreground\":\"#e5e5e5\",\"cursorColor\":\"#21f6bc\",\"selectionBackground\":\"#c1deff\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Murderlon\",\"link\":\"https://github.com/Murderlon/cyberpunk-iterm\"}]}},{\"name\":\"Dark+\",\"black\":\"#000000\",\"red\":\"#cd3131\",\"green\":\"#0dbc79\",\"yellow\":\"#e5e510\",\"blue\":\"#2472c8\",\"purple\":\"#bc3fbc\",\"cyan\":\"#11a8cd\",\"white\":\"#e5e5e5\",\"brightBlack\":\"#666666\",\"brightRed\":\"#f14c4c\",\"brightGreen\":\"#23d18b\",\"brightYellow\":\"#f5f543\",\"brightBlue\":\"#3b8eea\",\"brightPurple\":\"#d670d6\",\"brightCyan\":\"#29b8db\",\"brightWhite\":\"#e5e5e5\",\"background\":\"#0e0e0e\",\"foreground\":\"#cccccc\",\"cursorColor\":\"#ffffff\",\"selectionBackground\":\"#3a3d41\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"Dark Pastel\",\"black\":\"#000000\",\"red\":\"#ff5555\",\"green\":\"#55ff55\",\"yellow\":\"#ffff55\",\"blue\":\"#5555ff\",\"purple\":\"#ff55ff\",\"cyan\":\"#55ffff\",\"white\":\"#bbbbbb\",\"brightBlack\":\"#555555\",\"brightRed\":\"#ff5555\",\"brightGreen\":\"#55ff55\",\"brightYellow\":\"#ffff55\",\"brightBlue\":\"#5555ff\",\"brightPurple\":\"#ff55ff\",\"brightCyan\":\"#55ffff\",\"brightWhite\":\"#ffffff\",\"background\":\"#000000\",\"foreground\":\"#ffffff\",\"cursorColor\":\"#bbbbbb\",\"selectionBackground\":\"#b5d5ff\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"Darkside\",\"black\":\"#000000\",\"red\":\"#e8341c\",\"green\":\"#68c256\",\"yellow\":\"#f2d42c\",\"blue\":\"#1c98e8\",\"purple\":\"#8e69c9\",\"cyan\":\"#1c98e8\",\"white\":\"#bababa\",\"brightBlack\":\"#000000\",\"brightRed\":\"#e05a4f\",\"brightGreen\":\"#77b869\",\"brightYellow\":\"#efd64b\",\"brightBlue\":\"#387cd3\",\"brightPurple\":\"#957bbe\",\"brightCyan\":\"#3d97e2\",\"brightWhite\":\"#bababa\",\"background\":\"#222324\",\"foreground\":\"#bababa\",\"cursorColor\":\"#bbbbbb\",\"selectionBackground\":\"#303333\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"bahlo\",\"link\":\"https://github.com/bahlo/iterm-colors\"}]}},{\"name\":\"deep\",\"black\":\"#000000\",\"red\":\"#d70005\",\"green\":\"#1cd915\",\"yellow\":\"#d9bd26\",\"blue\":\"#5665ff\",\"purple\":\"#b052da\",\"cyan\":\"#50d2da\",\"white\":\"#e0e0e0\",\"brightBlack\":\"#535353\",\"brightRed\":\"#fb0007\",\"brightGreen\":\"#22ff18\",\"brightYellow\":\"#fedc2b\",\"brightBlue\":\"#9fa9ff\",\"brightPurple\":\"#e09aff\",\"brightCyan\":\"#8df9ff\",\"brightWhite\":\"#ffffff\",\"background\":\"#090909\",\"foreground\":\"#cdcdcd\",\"cursorColor\":\"#d0d0d0\",\"selectionBackground\":\"#780002\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"ADoyle\",\"link\":\"https://github.com/adoyle-h\"}]}},{\"name\":\"DeHydration\",\"black\":\"#333333\",\"red\":\"#ff5555\",\"green\":\"#5fd38d\",\"yellow\":\"#ff9955\",\"blue\":\"#3771c8\",\"purple\":\"#bc5fd3\",\"cyan\":\"#5fd3bc\",\"white\":\"#999999\",\"brightBlack\":\"#666666\",\"brightRed\":\"#ff8080\",\"brightGreen\":\"#87deaa\",\"brightYellow\":\"#ffb380\",\"brightBlue\":\"#5f8dd3\",\"brightPurple\":\"#cd87de\",\"brightCyan\":\"#87decd\",\"brightWhite\":\"#cccccc\",\"foreground\":\"#cccccc\",\"background\":\"#333333\",\"cursorColor\":\"#cccccc\"},{\"name\":\"Desert\",\"black\":\"#4d4d4d\",\"red\":\"#ff2b2b\",\"green\":\"#98fb98\",\"yellow\":\"#f0e68c\",\"blue\":\"#cd853f\",\"purple\":\"#ffdead\",\"cyan\":\"#ffa0a0\",\"white\":\"#f5deb3\",\"brightBlack\":\"#555555\",\"brightRed\":\"#ff5555\",\"brightGreen\":\"#55ff55\",\"brightYellow\":\"#ffff55\",\"brightBlue\":\"#87ceff\",\"brightPurple\":\"#ff55ff\",\"brightCyan\":\"#ffd700\",\"brightWhite\":\"#ffffff\",\"background\":\"#333333\",\"foreground\":\"#ffffff\",\"cursorColor\":\"#00ff00\",\"selectionBackground\":\"#b5d5ff\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"DimmedMonokai\",\"black\":\"#3a3d43\",\"red\":\"#be3f48\",\"green\":\"#879a3b\",\"yellow\":\"#c5a635\",\"blue\":\"#4f76a1\",\"purple\":\"#855c8d\",\"cyan\":\"#578fa4\",\"white\":\"#b9bcba\",\"brightBlack\":\"#888987\",\"brightRed\":\"#fb001f\",\"brightGreen\":\"#0f722f\",\"brightYellow\":\"#c47033\",\"brightBlue\":\"#186de3\",\"brightPurple\":\"#fb0067\",\"brightCyan\":\"#2e706d\",\"brightWhite\":\"#fdffb9\",\"background\":\"#1f1f1f\",\"foreground\":\"#b9bcba\",\"cursorColor\":\"#f83e19\",\"selectionBackground\":\"#2a2d32\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"zdj\",\"link\":\"https://github.com/zdj/themes/tree/master/iterm2\"}]}},{\"name\":\"Dissonance\",\"black\":\"#000000\",\"red\":\"#dc322f\",\"green\":\"#56db3a\",\"yellow\":\"#ff8400\",\"blue\":\"#0084d4\",\"purple\":\"#b729d9\",\"cyan\":\"#ccccff\",\"white\":\"#ffffff\",\"brightBlack\":\"#d6dbe5\",\"brightRed\":\"#dc322f\",\"brightGreen\":\"#56db3a\",\"brightYellow\":\"#ff8400\",\"brightBlue\":\"#0084d4\",\"brightPurple\":\"#b729d9\",\"brightCyan\":\"#ccccff\",\"brightWhite\":\"#ffffff\",\"foreground\":\"#ffffff\",\"background\":\"#000000\",\"cursorColor\":\"#dc322f\"},{\"name\":\"Django\",\"black\":\"#000000\",\"red\":\"#fd6209\",\"green\":\"#41a83e\",\"yellow\":\"#ffe862\",\"blue\":\"#245032\",\"purple\":\"#f8f8f8\",\"cyan\":\"#9df39f\",\"white\":\"#ffffff\",\"brightBlack\":\"#323232\",\"brightRed\":\"#ff943b\",\"brightGreen\":\"#73da70\",\"brightYellow\":\"#ffff94\",\"brightBlue\":\"#568264\",\"brightPurple\":\"#ffffff\",\"brightCyan\":\"#cfffd1\",\"brightWhite\":\"#ffffff\",\"background\":\"#0b2f20\",\"foreground\":\"#f8f8f8\",\"cursorColor\":\"#336442\",\"selectionBackground\":\"#245032\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Jannis Leidel\",\"link\":\"https://code.djangoproject.com/wiki/TextMate\"},{\"name\":\"threespot.com\",\"link\":\"https://threespot.com\"}]}},{\"name\":\"DjangoRebornAgain\",\"black\":\"#000000\",\"red\":\"#fd6209\",\"green\":\"#41a83e\",\"yellow\":\"#ffe862\",\"blue\":\"#245032\",\"purple\":\"#f8f8f8\",\"cyan\":\"#9df39f\",\"white\":\"#ffffff\",\"brightBlack\":\"#323232\",\"brightRed\":\"#ff943b\",\"brightGreen\":\"#73da70\",\"brightYellow\":\"#ffff94\",\"brightBlue\":\"#568264\",\"brightPurple\":\"#ffffff\",\"brightCyan\":\"#cfffd1\",\"brightWhite\":\"#ffffff\",\"background\":\"#051f14\",\"foreground\":\"#dadedc\",\"cursorColor\":\"#ffcc00\",\"selectionBackground\":\"#203727\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"christopherscott\",\"link\":\"https://github.com/christopherscott/django-reborn\"},{\"name\":\"Jannis Leidel\",\"link\":\"https://code.djangoproject.com/wiki/TextMate\"}]}},{\"name\":\"DjangoSmooth\",\"black\":\"#000000\",\"red\":\"#fd6209\",\"green\":\"#41a83e\",\"yellow\":\"#ffe862\",\"blue\":\"#989898\",\"purple\":\"#f8f8f8\",\"cyan\":\"#9df39f\",\"white\":\"#e8e8e7\",\"brightBlack\":\"#323232\",\"brightRed\":\"#ff943b\",\"brightGreen\":\"#73da70\",\"brightYellow\":\"#ffff94\",\"brightBlue\":\"#cacaca\",\"brightPurple\":\"#ffffff\",\"brightCyan\":\"#cfffd1\",\"brightWhite\":\"#ffffff\",\"background\":\"#245032\",\"foreground\":\"#f8f8f8\",\"cursorColor\":\"#336442\",\"selectionBackground\":\"#336442\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Jannis Leidel\",\"link\":\"https://code.djangoproject.com/wiki/TextMate\"},{\"name\":\"threespot.com\",\"link\":\"https://threespot.com\"}]}},{\"name\":\"DoomOne\",\"black\":\"#000000\",\"red\":\"#ff6c6b\",\"green\":\"#98be65\",\"yellow\":\"#ecbe7b\",\"blue\":\"#a9a1e1\",\"purple\":\"#c678dd\",\"cyan\":\"#51afef\",\"white\":\"#bbc2cf\",\"brightBlack\":\"#000000\",\"brightRed\":\"#ff6655\",\"brightGreen\":\"#99bb66\",\"brightYellow\":\"#ecbe7b\",\"brightBlue\":\"#a9a1e1\",\"brightPurple\":\"#c678dd\",\"brightCyan\":\"#51afef\",\"brightWhite\":\"#bfbfbf\",\"background\":\"#282c34\",\"foreground\":\"#bbc2cf\",\"cursorColor\":\"#51afef\",\"selectionBackground\":\"#42444b\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Emacs Doom default theme\",\"link\":\"https://github.com/hlissner/emacs-doom-themes\"}]}},{\"name\":\"Doom Peacock\",\"black\":\"#1c1f24\",\"red\":\"#cb4b16\",\"green\":\"#26a6a6\",\"yellow\":\"#bcd42a\",\"blue\":\"#2a6cc6\",\"purple\":\"#a9a1e1\",\"cyan\":\"#5699af\",\"white\":\"#ede0ce\",\"brightBlack\":\"#2b2a27\",\"brightRed\":\"#ff5d38\",\"brightGreen\":\"#98be65\",\"brightYellow\":\"#e6f972\",\"brightBlue\":\"#51afef\",\"brightPurple\":\"#c678dd\",\"brightCyan\":\"#46d9ff\",\"brightWhite\":\"#dfdfdf\",\"background\":\"#2b2a27\",\"foreground\":\"#ede0ce\",\"cursorColor\":\"#9c9c9d\",\"selectionBackground\":\"#a60033\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Emacs Doom Peacock theme\",\"link\":\"https://github.com/hlissner/emacs-doom-themes\"}]}},{\"name\":\"DotGov\",\"black\":\"#191919\",\"red\":\"#bf091d\",\"green\":\"#3d9751\",\"yellow\":\"#f6bb34\",\"blue\":\"#17b2e0\",\"purple\":\"#7830b0\",\"cyan\":\"#8bd2ed\",\"white\":\"#ffffff\",\"brightBlack\":\"#191919\",\"brightRed\":\"#bf091d\",\"brightGreen\":\"#3d9751\",\"brightYellow\":\"#f6bb34\",\"brightBlue\":\"#17b2e0\",\"brightPurple\":\"#7830b0\",\"brightCyan\":\"#8bd2ed\",\"brightWhite\":\"#ffffff\",\"background\":\"#262c35\",\"foreground\":\"#ebebeb\",\"cursorColor\":\"#d9002f\",\"selectionBackground\":\"#1a4080\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"U.S. Web Design Standards\",\"link\":\"https://standards.usa.gov/visual-style/\"}]}},{\"name\":\"Dracula+\",\"black\":\"#21222c\",\"red\":\"#ff5555\",\"green\":\"#50fa7b\",\"yellow\":\"#ffcb6b\",\"blue\":\"#82aaff\",\"purple\":\"#c792ea\",\"cyan\":\"#8be9fd\",\"white\":\"#f8f8f2\",\"brightBlack\":\"#545454\",\"brightRed\":\"#ff6e6e\",\"brightGreen\":\"#69ff94\",\"brightYellow\":\"#ffcb6b\",\"brightBlue\":\"#d6acff\",\"brightPurple\":\"#ff92df\",\"brightCyan\":\"#a4ffff\",\"brightWhite\":\"#f8f8f2\",\"background\":\"#212121\",\"foreground\":\"#f8f8f2\",\"cursorColor\":\"#eceff4\",\"selectionBackground\":\"#f8f8f2\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"zenorocha\",\"link\":\"https://github.com/zenorocha/dracula-theme\"}]}},{\"name\":\"DraculaPlus\",\"background\":\"#212121\",\"black\":\"#21222C\",\"blue\":\"#82aaff\",\"cyan\":\"#8BE9FD\",\"foreground\":\"#F8F8F2\",\"green\":\"#50FA7B\",\"purple\":\"#c792ea\",\"red\":\"#FF5555\",\"white\":\"#F8F8F2\",\"yellow\":\"#ffcb6b\",\"brightBlack\":\"#545454\",\"brightBlue\":\"#D6ACFF\",\"brightCyan\":\"#A4FFFF\",\"brightGreen\":\"#69FF94\",\"brightPurple\":\"#FF92DF\",\"brightRed\":\"#FF6E6E\",\"brightWhite\":\"#F8F8F2\",\"brightYellow\":\"#ffcb6b\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"jos3s\",\"link\":\"https://github.com/jos3s\"}]}},{\"name\":\"Duotone Dark\",\"black\":\"#1f1d27\",\"red\":\"#d9393e\",\"green\":\"#2dcd73\",\"yellow\":\"#d9b76e\",\"blue\":\"#ffc284\",\"purple\":\"#de8d40\",\"cyan\":\"#2488ff\",\"white\":\"#b7a1ff\",\"brightBlack\":\"#353147\",\"brightRed\":\"#d9393e\",\"brightGreen\":\"#2dcd73\",\"brightYellow\":\"#d9b76e\",\"brightBlue\":\"#ffc284\",\"brightPurple\":\"#de8d40\",\"brightCyan\":\"#2488ff\",\"brightWhite\":\"#eae5ff\",\"background\":\"#1f1d27\",\"foreground\":\"#b7a1ff\",\"cursorColor\":\"#ff9839\",\"selectionBackground\":\"#353147\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"chibicode\",\"link\":\"http://chibicode.com\"},{\"name\":\"simurai\",\"link\":\"https://github.com/simurai\"}]}},{\"name\":\"Earthsong\",\"black\":\"#121418\",\"red\":\"#c94234\",\"green\":\"#85c54c\",\"yellow\":\"#f5ae2e\",\"blue\":\"#1398b9\",\"purple\":\"#d0633d\",\"cyan\":\"#509552\",\"white\":\"#e5c6aa\",\"brightBlack\":\"#675f54\",\"brightRed\":\"#ff645a\",\"brightGreen\":\"#98e036\",\"brightYellow\":\"#e0d561\",\"brightBlue\":\"#5fdaff\",\"brightPurple\":\"#ff9269\",\"brightCyan\":\"#84f088\",\"brightWhite\":\"#f6f7ec\",\"background\":\"#292520\",\"foreground\":\"#e5c7a9\",\"cursorColor\":\"#f6f7ec\",\"selectionBackground\":\"#121418\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"zdj\",\"link\":\"https://github.com/zdj/themes/tree/master/iterm2\"}]}},{\"name\":\"Elemental\",\"black\":\"#3c3c30\",\"red\":\"#98290f\",\"green\":\"#479a43\",\"yellow\":\"#7f7111\",\"blue\":\"#497f7d\",\"purple\":\"#7f4e2f\",\"cyan\":\"#387f58\",\"white\":\"#807974\",\"brightBlack\":\"#555445\",\"brightRed\":\"#e0502a\",\"brightGreen\":\"#61e070\",\"brightYellow\":\"#d69927\",\"brightBlue\":\"#79d9d9\",\"brightPurple\":\"#cd7c54\",\"brightCyan\":\"#59d599\",\"brightWhite\":\"#fff1e9\",\"background\":\"#22211d\",\"foreground\":\"#807a74\",\"cursorColor\":\"#facb80\",\"selectionBackground\":\"#413829\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"zdj\",\"link\":\"https://github.com/zdj/themes/tree/master/iterm2\"}]}},{\"name\":\"Elementary\",\"black\":\"#242424\",\"red\":\"#d71c15\",\"green\":\"#5aa513\",\"yellow\":\"#fdb40c\",\"blue\":\"#063b8c\",\"purple\":\"#e40038\",\"cyan\":\"#2595e1\",\"white\":\"#efefef\",\"brightBlack\":\"#4b4b4b\",\"brightRed\":\"#fc1c18\",\"brightGreen\":\"#6bc219\",\"brightYellow\":\"#fec80e\",\"brightBlue\":\"#0955ff\",\"brightPurple\":\"#fb0050\",\"brightCyan\":\"#3ea8fc\",\"brightWhite\":\"#8c00ec\",\"background\":\"#181818\",\"foreground\":\"#efefef\",\"cursorColor\":\"#bbbbbb\",\"selectionBackground\":\"#b5d5ff\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"elementary.io\",\"link\":\"https://elementary.io/\"},{\"name\":\"987poiuytrewq\",\"link\":\"https://github.com/987poiuytrewq\"}]}},{\"name\":\"Elic\",\"black\":\"#303030\",\"red\":\"#e1321a\",\"green\":\"#6ab017\",\"yellow\":\"#ffc005\",\"blue\":\"#729FCF\",\"purple\":\"#ec0048\",\"cyan\":\"#f2f2f2\",\"white\":\"#2aa7e7\",\"brightBlack\":\"#5d5d5d\",\"brightRed\":\"#ff361e\",\"brightGreen\":\"#7bc91f\",\"brightYellow\":\"#ffd00a\",\"brightBlue\":\"#0071ff\",\"brightPurple\":\"#ff1d62\",\"brightCyan\":\"#4bb8fd\",\"brightWhite\":\"#a020f0\",\"foreground\":\"#f2f2f2\",\"background\":\"#4A453E\",\"cursorColor\":\"#f2f2f2\"},{\"name\":\"Elio\",\"black\":\"#303030\",\"red\":\"#e1321a\",\"green\":\"#6ab017\",\"yellow\":\"#ffc005\",\"blue\":\"#729FCF\",\"purple\":\"#ec0048\",\"cyan\":\"#2aa7e7\",\"white\":\"#f2f2f2\",\"brightBlack\":\"#5d5d5d\",\"brightRed\":\"#ff361e\",\"brightGreen\":\"#7bc91f\",\"brightYellow\":\"#ffd00a\",\"brightBlue\":\"#0071ff\",\"brightPurple\":\"#ff1d62\",\"brightCyan\":\"#4bb8fd\",\"brightWhite\":\"#a020f0\",\"foreground\":\"#f2f2f2\",\"background\":\"#041A3B\",\"cursorColor\":\"#f2f2f2\"},{\"name\":\"ENCOM\",\"black\":\"#000000\",\"red\":\"#9f0000\",\"green\":\"#008b00\",\"yellow\":\"#ffd000\",\"blue\":\"#0081ff\",\"purple\":\"#bc00ca\",\"cyan\":\"#008b8b\",\"white\":\"#bbbbbb\",\"brightBlack\":\"#555555\",\"brightRed\":\"#ff0000\",\"brightGreen\":\"#00ee00\",\"brightYellow\":\"#ffff00\",\"brightBlue\":\"#0000ff\",\"brightPurple\":\"#ff00ff\",\"brightCyan\":\"#00cdcd\",\"brightWhite\":\"#ffffff\",\"background\":\"#000000\",\"foreground\":\"#00a595\",\"cursorColor\":\"#bbbbbb\",\"selectionBackground\":\"#00a48c\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Josh Braun\",\"link\":\"http://wideaperture.net\"}]}},{\"name\":\"Espresso\",\"black\":\"#353535\",\"red\":\"#d25252\",\"green\":\"#a5c261\",\"yellow\":\"#ffc66d\",\"blue\":\"#6c99bb\",\"purple\":\"#d197d9\",\"cyan\":\"#bed6ff\",\"white\":\"#eeeeec\",\"brightBlack\":\"#535353\",\"brightRed\":\"#f00c0c\",\"brightGreen\":\"#c2e075\",\"brightYellow\":\"#e1e48b\",\"brightBlue\":\"#8ab7d9\",\"brightPurple\":\"#efb5f7\",\"brightCyan\":\"#dcf4ff\",\"brightWhite\":\"#ffffff\",\"background\":\"#323232\",\"foreground\":\"#ffffff\",\"cursorColor\":\"#d6d6d6\",\"selectionBackground\":\"#5b5b5b\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"Espresso Libre\",\"black\":\"#000000\",\"red\":\"#cc0000\",\"green\":\"#1a921c\",\"yellow\":\"#f0e53a\",\"blue\":\"#0066ff\",\"purple\":\"#c5656b\",\"cyan\":\"#06989a\",\"white\":\"#d3d7cf\",\"brightBlack\":\"#555753\",\"brightRed\":\"#ef2929\",\"brightGreen\":\"#9aff87\",\"brightYellow\":\"#fffb5c\",\"brightBlue\":\"#43a8ed\",\"brightPurple\":\"#ff818a\",\"brightCyan\":\"#34e2e2\",\"brightWhite\":\"#eeeeec\",\"background\":\"#2a211c\",\"foreground\":\"#b8a898\",\"cursorColor\":\"#ffffff\",\"selectionBackground\":\"#c3dcff\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"jurgemaister\",\"link\":\"https://github.com/jurgemaister/Espresso-Libre\"}]}},{\"name\":\"Fahrenheit\",\"black\":\"#1d1d1d\",\"red\":\"#cda074\",\"green\":\"#9e744d\",\"yellow\":\"#fecf75\",\"blue\":\"#720102\",\"purple\":\"#734c4d\",\"cyan\":\"#979797\",\"white\":\"#ffffce\",\"brightBlack\":\"#000000\",\"brightRed\":\"#fecea0\",\"brightGreen\":\"#cc734d\",\"brightYellow\":\"#fd9f4d\",\"brightBlue\":\"#cb4a05\",\"brightPurple\":\"#4e739f\",\"brightCyan\":\"#fed04d\",\"brightWhite\":\"#ffffff\",\"background\":\"#000000\",\"foreground\":\"#ffffce\",\"cursorColor\":\"#bbbbbb\",\"selectionBackground\":\"#4e739f\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"jonascarpay\",\"link\":\"https://github.com/jonascarpay\"},{\"name\":\"fcpg\",\"link\":\"https://github.com/fcpg\"}]}},{\"name\":\"FairyFloss\",\"black\":\"#42395D\",\"red\":\"#A8757B\",\"green\":\"#FF857F\",\"yellow\":\"#E6C000\",\"blue\":\"#AE81FF\",\"purple\":\"#716799\",\"cyan\":\"#C2FFDF\",\"white\":\"#F8F8F2\",\"brightBlack\":\"#75507B\",\"brightRed\":\"#FFB8D1\",\"brightGreen\":\"#F1568E\",\"brightYellow\":\"#D5A425\",\"brightBlue\":\"#C5A3FF\",\"brightPurple\":\"#8077A8\",\"brightCyan\":\"#C2FFFF\",\"brightWhite\":\"#F8F8F0\",\"foreground\":\"#C2FFDF\",\"background\":\"#5A5475\",\"cursorColor\":\"#FFB8D1\"},{\"name\":\"FairyFlossDark\",\"black\":\"#42395D\",\"red\":\"#A8757B\",\"green\":\"#FF857F\",\"yellow\":\"#E6C000\",\"blue\":\"#AE81FF\",\"purple\":\"#716799\",\"cyan\":\"#C2FFDF\",\"white\":\"#F8F8F2\",\"brightBlack\":\"#75507B\",\"brightRed\":\"#FFB8D1\",\"brightGreen\":\"#F1568E\",\"brightYellow\":\"#D5A425\",\"brightBlue\":\"#C5A3FF\",\"brightPurple\":\"#8077A8\",\"brightCyan\":\"#C2FFFF\",\"brightWhite\":\"#F8F8F0\",\"foreground\":\"#C2FFDF\",\"background\":\"#42395D\",\"cursorColor\":\"#FFB8D1\"},{\"name\":\"Fideloper\",\"black\":\"#292f33\",\"red\":\"#cb1e2d\",\"green\":\"#edb8ac\",\"yellow\":\"#b7ab9b\",\"blue\":\"#2e78c2\",\"purple\":\"#c0236f\",\"cyan\":\"#309186\",\"white\":\"#eae3ce\",\"brightBlack\":\"#092028\",\"brightRed\":\"#d4605a\",\"brightGreen\":\"#d4605a\",\"brightYellow\":\"#a86671\",\"brightBlue\":\"#7c85c4\",\"brightPurple\":\"#5c5db2\",\"brightCyan\":\"#819090\",\"brightWhite\":\"#fcf4df\",\"background\":\"#292f33\",\"foreground\":\"#dbdae0\",\"cursorColor\":\"#d4605a\",\"selectionBackground\":\"#efb8ac\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Fideloper\",\"link\":\"http://fideloper.com/\"}]}},{\"name\":\"FirefoxDev\",\"black\":\"#002831\",\"red\":\"#e63853\",\"green\":\"#5eb83c\",\"yellow\":\"#a57706\",\"blue\":\"#359ddf\",\"purple\":\"#d75cff\",\"cyan\":\"#4b73a2\",\"white\":\"#dcdcdc\",\"brightBlack\":\"#001e27\",\"brightRed\":\"#e1003f\",\"brightGreen\":\"#1d9000\",\"brightYellow\":\"#cd9409\",\"brightBlue\":\"#006fc0\",\"brightPurple\":\"#a200da\",\"brightCyan\":\"#005794\",\"brightWhite\":\"#e2e2e2\",\"background\":\"#0e1011\",\"foreground\":\"#7c8fa4\",\"cursorColor\":\"#708284\",\"selectionBackground\":\"#163c61\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Or3stis\",\"link\":\"https://github.com/Or3stis\"}]}},{\"name\":\"Firewatch\",\"black\":\"#585f6d\",\"red\":\"#d95360\",\"green\":\"#5ab977\",\"yellow\":\"#dfb563\",\"blue\":\"#4d89c4\",\"purple\":\"#d55119\",\"cyan\":\"#44a8b6\",\"white\":\"#e6e5ff\",\"brightBlack\":\"#585f6d\",\"brightRed\":\"#d95360\",\"brightGreen\":\"#5ab977\",\"brightYellow\":\"#dfb563\",\"brightBlue\":\"#4c89c5\",\"brightPurple\":\"#d55119\",\"brightCyan\":\"#44a8b6\",\"brightWhite\":\"#e6e5ff\",\"background\":\"#1e2027\",\"foreground\":\"#9ba2b2\",\"cursorColor\":\"#f6f7ec\",\"selectionBackground\":\"#2f363e\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Sebastian Szturo\",\"link\":\"https://github.com/SebastianSzturo\"},{\"name\":\"Ben Styles\",\"link\":\"https://github.com/leeds-ebooks\"},{\"name\":\"Firewatch game\",\"link\":\"http://www.firewatchgame.com/\"}]}},{\"name\":\"FishTank\",\"black\":\"#03073c\",\"red\":\"#c6004a\",\"green\":\"#acf157\",\"yellow\":\"#fecd5e\",\"blue\":\"#525fb8\",\"purple\":\"#986f82\",\"cyan\":\"#968763\",\"white\":\"#ecf0fc\",\"brightBlack\":\"#6c5b30\",\"brightRed\":\"#da4b8a\",\"brightGreen\":\"#dbffa9\",\"brightYellow\":\"#fee6a9\",\"brightBlue\":\"#b2befa\",\"brightPurple\":\"#fda5cd\",\"brightCyan\":\"#a5bd86\",\"brightWhite\":\"#f6ffec\",\"background\":\"#232537\",\"foreground\":\"#ecf0fe\",\"cursorColor\":\"#fecd5e\",\"selectionBackground\":\"#fcf7e9\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"zdj\",\"link\":\"https://github.com/zdj/themes/tree/master/iterm2\"}]}},{\"name\":\"Flat\",\"black\":\"#222d3f\",\"red\":\"#a82320\",\"green\":\"#32a548\",\"yellow\":\"#e58d11\",\"blue\":\"#3167ac\",\"purple\":\"#781aa0\",\"cyan\":\"#2c9370\",\"white\":\"#b0b6ba\",\"brightBlack\":\"#212c3c\",\"brightRed\":\"#d4312e\",\"brightGreen\":\"#2d9440\",\"brightYellow\":\"#e5be0c\",\"brightBlue\":\"#3c7dd2\",\"brightPurple\":\"#8230a7\",\"brightCyan\":\"#35b387\",\"brightWhite\":\"#e7eced\",\"background\":\"#002240\",\"foreground\":\"#2cc55d\",\"cursorColor\":\"#e5be0c\",\"selectionBackground\":\"#792b9c\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"ahmetsulek\",\"link\":\"https://github.com/ahmetsulek/flat-terminal\"}]}},{\"name\":\"Flatland\",\"black\":\"#1d1d19\",\"red\":\"#f18339\",\"green\":\"#9fd364\",\"yellow\":\"#f4ef6d\",\"blue\":\"#5096be\",\"purple\":\"#695abc\",\"cyan\":\"#d63865\",\"white\":\"#ffffff\",\"brightBlack\":\"#1d1d19\",\"brightRed\":\"#d22a24\",\"brightGreen\":\"#a7d42c\",\"brightYellow\":\"#ff8949\",\"brightBlue\":\"#61b9d0\",\"brightPurple\":\"#695abc\",\"brightCyan\":\"#d63865\",\"brightWhite\":\"#ffffff\",\"background\":\"#1d1f21\",\"foreground\":\"#b8dbef\",\"cursorColor\":\"#708284\",\"selectionBackground\":\"#2b2a24\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"realchaseadams\",\"link\":\"http://www.snip2code.com/Snippet/148193/Flatland-color-scheme-for-iTerm2\"}]}},{\"name\":\"FlatRemix\",\"black\":\"#1F2229\",\"red\":\"#D41919\",\"green\":\"#5EBDAB\",\"yellow\":\"#FEA44C\",\"blue\":\"#367bf0\",\"purple\":\"#BF2E5D\",\"cyan\":\"#49AEE6\",\"white\":\"#E6E6E6\",\"brightBlack\":\"#8C42AB\",\"brightRed\":\"#EC0101\",\"brightGreen\":\"#47D4B9\",\"brightYellow\":\"#FF8A18\",\"brightBlue\":\"#277FFF\",\"brightPurple\":\"#D71655\",\"brightCyan\":\"#05A1F7\",\"brightWhite\":\"#FFFFFF\",\"foreground\":\"#FFFFFF\",\"background\":\"#272a34\",\"cursorColor\":\"#FFFFFF\"},{\"name\":\"Floraverse\",\"black\":\"#08002e\",\"red\":\"#64002c\",\"green\":\"#5d731a\",\"yellow\":\"#cd751c\",\"blue\":\"#1d6da1\",\"purple\":\"#b7077e\",\"cyan\":\"#42a38c\",\"white\":\"#f3e0b8\",\"brightBlack\":\"#331e4d\",\"brightRed\":\"#d02063\",\"brightGreen\":\"#b4ce59\",\"brightYellow\":\"#fac357\",\"brightBlue\":\"#40a4cf\",\"brightPurple\":\"#f12aae\",\"brightCyan\":\"#62caa8\",\"brightWhite\":\"#fff5db\",\"background\":\"#0e0d15\",\"foreground\":\"#dbd1b9\",\"cursorColor\":\"#bbbbbb\",\"selectionBackground\":\"#f3e0b8\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"papayakitty\",\"link\":\"http://floraverse.com/\"}]}},{\"name\":\"ForestBlue\",\"black\":\"#333333\",\"red\":\"#f8818e\",\"green\":\"#92d3a2\",\"yellow\":\"#1a8e63\",\"blue\":\"#8ed0ce\",\"purple\":\"#5e468c\",\"cyan\":\"#31658c\",\"white\":\"#e2d8cd\",\"brightBlack\":\"#3d3d3d\",\"brightRed\":\"#fb3d66\",\"brightGreen\":\"#6bb48d\",\"brightYellow\":\"#30c85a\",\"brightBlue\":\"#39a7a2\",\"brightPurple\":\"#7e62b3\",\"brightCyan\":\"#6096bf\",\"brightWhite\":\"#e2d8cd\",\"background\":\"#051519\",\"foreground\":\"#e2d8cd\",\"cursorColor\":\"#9e9ecb\",\"selectionBackground\":\"#4d4d4d\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"olkinn\",\"link\":\"https://github.com/olkinn/forest-blue-iTerm\"}]}},{\"name\":\"Foxnightly\",\"black\":\"#2A2A2E\",\"red\":\"#B98EFF\",\"green\":\"#FF7DE9\",\"yellow\":\"#729FCF\",\"blue\":\"#66A05B\",\"purple\":\"#75507B\",\"cyan\":\"#ACACAE\",\"white\":\"#FFFFFF\",\"brightBlack\":\"#A40000\",\"brightRed\":\"#BF4040\",\"brightGreen\":\"#66A05B\",\"brightYellow\":\"#FFB86C\",\"brightBlue\":\"#729FCF\",\"brightPurple\":\"#8F5902\",\"brightCyan\":\"#C4A000\",\"brightWhite\":\"#5C3566\",\"foreground\":\"#D7D7DB\",\"background\":\"#2A2A2E\",\"cursorColor\":\"#D7D7DB\"},{\"name\":\"Framer\",\"black\":\"#141414\",\"red\":\"#ff5555\",\"green\":\"#98ec65\",\"yellow\":\"#ffcc33\",\"blue\":\"#00aaff\",\"purple\":\"#aa88ff\",\"cyan\":\"#88ddff\",\"white\":\"#cccccc\",\"brightBlack\":\"#414141\",\"brightRed\":\"#ff8888\",\"brightGreen\":\"#b6f292\",\"brightYellow\":\"#ffd966\",\"brightBlue\":\"#33bbff\",\"brightPurple\":\"#cebbff\",\"brightCyan\":\"#bbecff\",\"brightWhite\":\"#ffffff\",\"background\":\"#111111\",\"foreground\":\"#777777\",\"cursorColor\":\"#fcdc08\",\"selectionBackground\":\"#666666\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"markogresak\",\"link\":\"https://github.com/markogresak\"},{\"name\":\"Framer\",\"link\":\"https://framer.com\"}]}},{\"name\":\"Freya\",\"black\":\"#073642\",\"red\":\"#dc322f\",\"green\":\"#859900\",\"yellow\":\"#b58900\",\"blue\":\"#268bd2\",\"purple\":\"#ec0048\",\"cyan\":\"#2aa198\",\"white\":\"#94a3a5\",\"brightBlack\":\"#586e75\",\"brightRed\":\"#cb4b16\",\"brightGreen\":\"#859900\",\"brightYellow\":\"#b58900\",\"brightBlue\":\"#268bd2\",\"brightPurple\":\"#d33682\",\"brightCyan\":\"#2aa198\",\"brightWhite\":\"#6c71c4\",\"foreground\":\"#94a3a5\",\"background\":\"#252e32\",\"cursorColor\":\"#839496\"},{\"name\":\"FrontEndDelight\",\"black\":\"#242526\",\"red\":\"#f8511b\",\"green\":\"#565747\",\"yellow\":\"#fa771d\",\"blue\":\"#2c70b7\",\"purple\":\"#f02e4f\",\"cyan\":\"#3ca1a6\",\"white\":\"#adadad\",\"brightBlack\":\"#5fac6d\",\"brightRed\":\"#f74319\",\"brightGreen\":\"#74ec4c\",\"brightYellow\":\"#fdc325\",\"brightBlue\":\"#3393ca\",\"brightPurple\":\"#e75e4f\",\"brightCyan\":\"#4fbce6\",\"brightWhite\":\"#8c735b\",\"background\":\"#1b1c1d\",\"foreground\":\"#adadad\",\"cursorColor\":\"#cdcdcd\",\"selectionBackground\":\"#ea6154\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"zdj\",\"link\":\"https://github.com/zdj/themes/tree/master/iterm2\"}]}},{\"name\":\"FrontendFunForrest\",\"black\":\"#000000\",\"red\":\"#d6262b\",\"green\":\"#919c00\",\"yellow\":\"#be8a13\",\"blue\":\"#4699a3\",\"purple\":\"#8d4331\",\"cyan\":\"#da8213\",\"white\":\"#ddc265\",\"brightBlack\":\"#7f6a55\",\"brightRed\":\"#e55a1c\",\"brightGreen\":\"#bfc65a\",\"brightYellow\":\"#ffcb1b\",\"brightBlue\":\"#7cc9cf\",\"brightPurple\":\"#d26349\",\"brightCyan\":\"#e6a96b\",\"brightWhite\":\"#ffeaa3\",\"foreground\":\"#dec165\",\"background\":\"#251200\",\"cursorColor\":\"#dec165\"},{\"name\":\"FrontendGalaxy\",\"black\":\"#000000\",\"red\":\"#f9555f\",\"green\":\"#21b089\",\"yellow\":\"#fef02a\",\"blue\":\"#589df6\",\"purple\":\"#944d95\",\"cyan\":\"#1f9ee7\",\"white\":\"#bbbbbb\",\"brightBlack\":\"#555555\",\"brightRed\":\"#fa8c8f\",\"brightGreen\":\"#35bb9a\",\"brightYellow\":\"#ffff55\",\"brightBlue\":\"#589df6\",\"brightPurple\":\"#e75699\",\"brightCyan\":\"#3979bc\",\"brightWhite\":\"#ffffff\",\"foreground\":\"#ffffff\",\"background\":\"#1d2837\",\"cursorColor\":\"#ffffff\"},{\"name\":\"FunForrest\",\"black\":\"#000000\",\"red\":\"#d6262b\",\"green\":\"#919c00\",\"yellow\":\"#be8a13\",\"blue\":\"#4699a3\",\"purple\":\"#8d4331\",\"cyan\":\"#da8213\",\"white\":\"#ddc265\",\"brightBlack\":\"#7f6a55\",\"brightRed\":\"#e55a1c\",\"brightGreen\":\"#bfc65a\",\"brightYellow\":\"#ffcb1b\",\"brightBlue\":\"#7cc9cf\",\"brightPurple\":\"#d26349\",\"brightCyan\":\"#e6a96b\",\"brightWhite\":\"#ffeaa3\",\"background\":\"#251200\",\"foreground\":\"#dec165\",\"cursorColor\":\"#e5591c\",\"selectionBackground\":\"#e5591c\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"zdj\",\"link\":\"https://github.com/zdj/themes/tree/master/iterm2\"}]}},{\"name\":\"Galaxy\",\"black\":\"#000000\",\"red\":\"#f9555f\",\"green\":\"#21b089\",\"yellow\":\"#fef02a\",\"blue\":\"#589df6\",\"purple\":\"#944d95\",\"cyan\":\"#1f9ee7\",\"white\":\"#bbbbbb\",\"brightBlack\":\"#555555\",\"brightRed\":\"#fa8c8f\",\"brightGreen\":\"#35bb9a\",\"brightYellow\":\"#ffff55\",\"brightBlue\":\"#589df6\",\"brightPurple\":\"#e75699\",\"brightCyan\":\"#3979bc\",\"brightWhite\":\"#ffffff\",\"background\":\"#1d2837\",\"foreground\":\"#ffffff\",\"cursorColor\":\"#bbbbbb\",\"selectionBackground\":\"#b5d5ff\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"jglovier\",\"link\":\"https://github.com/jglovier/galaxy-theme-iterm\"}]}},{\"name\":\"Galizur\",\"black\":\"#223344\",\"red\":\"#aa1122\",\"green\":\"#33aa11\",\"yellow\":\"#ccaa22\",\"blue\":\"#2255cc\",\"purple\":\"#7755aa\",\"cyan\":\"#22bbdd\",\"white\":\"#8899aa\",\"brightBlack\":\"#556677\",\"brightRed\":\"#ff1133\",\"brightGreen\":\"#33ff11\",\"brightYellow\":\"#ffdd33\",\"brightBlue\":\"#3377ff\",\"brightPurple\":\"#aa77ff\",\"brightCyan\":\"#33ddff\",\"brightWhite\":\"#bbccdd\",\"background\":\"#071317\",\"foreground\":\"#ddeeff\",\"cursorColor\":\"#ddeeff\",\"selectionBackground\":\"#071317\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Raziel Anarki\",\"link\":\"https://github.com/razielanarki\"}]}},{\"name\":\"GeoHot\",\"black\":\"#F9F5F5\",\"red\":\"#CC0000\",\"green\":\"#1F1E1F\",\"yellow\":\"#ADA110\",\"blue\":\"#FF004E\",\"purple\":\"#75507B\",\"cyan\":\"#06919A\",\"white\":\"#FFFFFF\",\"brightBlack\":\"#555753\",\"brightRed\":\"#EF2929\",\"brightGreen\":\"#FF0000\",\"brightYellow\":\"#ADA110\",\"brightBlue\":\"#5F4AA6\",\"brightPurple\":\"#B74438\",\"brightCyan\":\"#408F0C\",\"brightWhite\":\"#FFFFFF\",\"foreground\":\"#FFFFFF\",\"background\":\"#1F1E1F\",\"cursorColor\":\"#FFFFFF\"},{\"name\":\"Github\",\"black\":\"#3e3e3e\",\"red\":\"#970b16\",\"green\":\"#07962a\",\"yellow\":\"#f8eec7\",\"blue\":\"#003e8a\",\"purple\":\"#e94691\",\"cyan\":\"#89d1ec\",\"white\":\"#ffffff\",\"brightBlack\":\"#666666\",\"brightRed\":\"#de0000\",\"brightGreen\":\"#87d5a2\",\"brightYellow\":\"#f1d007\",\"brightBlue\":\"#2e6cba\",\"brightPurple\":\"#ffa29f\",\"brightCyan\":\"#1cfafe\",\"brightWhite\":\"#ffffff\",\"background\":\"#f4f4f4\",\"foreground\":\"#3e3e3e\",\"cursorColor\":\"#3f3f3f\",\"selectionBackground\":\"#a9c1e2\",\"meta\":{\"isDark\":false,\"credits\":[{\"name\":\"Github\",\"link\":\"https://github.com/\"}]}},{\"name\":\"Glacier\",\"black\":\"#2e343c\",\"red\":\"#bd0f2f\",\"green\":\"#35a770\",\"yellow\":\"#fb9435\",\"blue\":\"#1f5872\",\"purple\":\"#bd2523\",\"cyan\":\"#778397\",\"white\":\"#ffffff\",\"brightBlack\":\"#404a55\",\"brightRed\":\"#bd0f2f\",\"brightGreen\":\"#49e998\",\"brightYellow\":\"#fddf6e\",\"brightBlue\":\"#2a8bc1\",\"brightPurple\":\"#ea4727\",\"brightCyan\":\"#a0b6d3\",\"brightWhite\":\"#ffffff\",\"background\":\"#0c1115\",\"foreground\":\"#ffffff\",\"cursorColor\":\"#6c6c6c\",\"selectionBackground\":\"#bd2523\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"bahlo\",\"link\":\"https://github.com/bahlo/iterm-colors\"}]}},{\"name\":\"Glorious\",\"black\":\"#1e1e1e\",\"red\":\"#be0f17\",\"green\":\"#868715\",\"yellow\":\"#cc881a\",\"blue\":\"#16777a\",\"purple\":\"#a04b73\",\"cyan\":\"#578e57\",\"white\":\"#978771\",\"brightBlack\":\"#7f7061\",\"brightRed\":\"#f73028\",\"brightGreen\":\"#d5d5d7\",\"brightYellow\":\"#f7b125\",\"brightBlue\":\"#4e917c\",\"brightPurple\":\"#c77089\",\"brightCyan\":\"#7db669\",\"brightWhite\":\"#e6d4a3\",\"background\":\"#201d27\",\"foreground\":\"#c8c8c9\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"alex\",\"link\":\"https://github.com/AlexMailo\"}]}},{\"name\":\"Gogh\",\"black\":\"#292D3E\",\"red\":\"#F07178\",\"green\":\"#62DE84\",\"yellow\":\"#FFCB6B\",\"blue\":\"#75A1FF\",\"purple\":\"#F580FF\",\"cyan\":\"#60BAEC\",\"white\":\"#ABB2BF\",\"brightBlack\":\"#959DCB\",\"brightRed\":\"#F07178\",\"brightGreen\":\"#C3E88D\",\"brightYellow\":\"#FF5572\",\"brightBlue\":\"#82AAFF\",\"brightPurple\":\"#FFCB6B\",\"brightCyan\":\"#676E95\",\"brightWhite\":\"#FFFEFE\",\"foreground\":\"#BFC7D5\",\"background\":\"#292D3E\",\"cursorColor\":\"#BFC7D5\"},{\"name\":\"gooey\",\"black\":\"#000009\",\"red\":\"#BB4F6C\",\"green\":\"#72CCAE\",\"yellow\":\"#C65E3D\",\"blue\":\"#58B6CA\",\"purple\":\"#6488C4\",\"cyan\":\"#8D84C6\",\"white\":\"#858893\",\"brightBlack\":\"#1f222d\",\"brightRed\":\"#ee829f\",\"brightGreen\":\"#a5ffe1\",\"brightYellow\":\"#f99170\",\"brightBlue\":\"#8be9fd\",\"brightPurple\":\"#97bbf7\",\"brightCyan\":\"#c0b7f9\",\"brightWhite\":\"#ffffff\",\"foreground\":\"#EBEEF9\",\"background\":\"#0D101B\",\"cursorColor\":\"#EBEEF9\"},{\"name\":\"GoogleDark\",\"black\":\"#202124\",\"red\":\"#EA4335\",\"green\":\"#34A853\",\"yellow\":\"#FBBC04\",\"blue\":\"#4285F4\",\"purple\":\"#A142F4\",\"cyan\":\"#24C1E0\",\"white\":\"#E8EAED\",\"brightBlack\":\"#5F6368\",\"brightRed\":\"#EA4335\",\"brightGreen\":\"#34A853\",\"brightYellow\":\"#FBBC05\",\"brightBlue\":\"#4285F4\",\"brightPurple\":\"#A142F4\",\"brightCyan\":\"#24C1E0\",\"brightWhite\":\"#FFFFFF\",\"foreground\":\"#E8EAED\",\"background\":\"#202124\",\"cursorColor\":\"#E8EAED\"},{\"name\":\"GoogleLight\",\"black\":\"#202124\",\"red\":\"#EA4335\",\"green\":\"#34A853\",\"yellow\":\"#FBBC04\",\"blue\":\"#4285F4\",\"purple\":\"#A142F4\",\"cyan\":\"#24C1E0\",\"white\":\"#E8EAED\",\"brightBlack\":\"#5F6368\",\"brightRed\":\"#EA4335\",\"brightGreen\":\"#34A853\",\"brightYellow\":\"#FBBC05\",\"brightBlue\":\"#4285F4\",\"brightPurple\":\"#A142F4\",\"brightCyan\":\"#24C1E0\",\"brightWhite\":\"#FFFFFF\",\"foreground\":\"#5F6368\",\"background\":\"#FFFFFF\",\"cursorColor\":\"#5F6368\"},{\"name\":\"gotham\",\"black\":\"#0a0f14\",\"red\":\"#c33027\",\"green\":\"#26a98b\",\"yellow\":\"#edb54b\",\"blue\":\"#195465\",\"purple\":\"#4e5165\",\"cyan\":\"#33859d\",\"white\":\"#98d1ce\",\"brightBlack\":\"#10151b\",\"brightRed\":\"#d26939\",\"brightGreen\":\"#081f2d\",\"brightYellow\":\"#245361\",\"brightBlue\":\"#093748\",\"brightPurple\":\"#888ba5\",\"brightCyan\":\"#599caa\",\"brightWhite\":\"#d3ebe9\",\"foreground\":\"#98d1ce\",\"background\":\"#0a0f14\",\"cursorColor\":\"#98d1ce\"},{\"name\":\"Grape\",\"black\":\"#2d283f\",\"red\":\"#ed2261\",\"green\":\"#1fa91b\",\"yellow\":\"#8ddc20\",\"blue\":\"#487df4\",\"purple\":\"#8d35c9\",\"cyan\":\"#3bdeed\",\"white\":\"#9e9ea0\",\"brightBlack\":\"#59516a\",\"brightRed\":\"#f0729a\",\"brightGreen\":\"#53aa5e\",\"brightYellow\":\"#b2dc87\",\"brightBlue\":\"#a9bcec\",\"brightPurple\":\"#ad81c2\",\"brightCyan\":\"#9de3eb\",\"brightWhite\":\"#a288f7\",\"background\":\"#171423\",\"foreground\":\"#9f9fa1\",\"cursorColor\":\"#a288f7\",\"selectionBackground\":\"#493d70\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"zdj\",\"link\":\"https://github.com/zdj/themes/tree/master/iterm2\"}]}},{\"name\":\"Grass\",\"black\":\"#000000\",\"red\":\"#bb0000\",\"green\":\"#00bb00\",\"yellow\":\"#e7b000\",\"blue\":\"#0000a3\",\"purple\":\"#950062\",\"cyan\":\"#00bbbb\",\"white\":\"#bbbbbb\",\"brightBlack\":\"#555555\",\"brightRed\":\"#bb0000\",\"brightGreen\":\"#00bb00\",\"brightYellow\":\"#e7b000\",\"brightBlue\":\"#0000bb\",\"brightPurple\":\"#ff55ff\",\"brightCyan\":\"#55ffff\",\"brightWhite\":\"#ffffff\",\"background\":\"#13773d\",\"foreground\":\"#fff0a5\",\"cursorColor\":\"#8c2800\",\"selectionBackground\":\"#b64926\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"Gruvbox\",\"black\":\"#fbf1c7\",\"red\":\"#cc241d\",\"green\":\"#98971a\",\"yellow\":\"#d79921\",\"blue\":\"#458588\",\"purple\":\"#b16286\",\"cyan\":\"#689d6a\",\"white\":\"#7c6f64\",\"brightBlack\":\"#928374\",\"brightRed\":\"#9d0006\",\"brightGreen\":\"#79740e\",\"brightYellow\":\"#b57614\",\"brightBlue\":\"#076678\",\"brightPurple\":\"#8f3f71\",\"brightCyan\":\"#427b58\",\"brightWhite\":\"#3c3836\",\"foreground\":\"#3c3836\",\"background\":\"#fbf1c7\",\"cursorColor\":\"#3c3836\"},{\"name\":\"Gruvbox Dark\",\"black\":\"#1e1e1e\",\"red\":\"#be0f17\",\"green\":\"#868715\",\"yellow\":\"#cc881a\",\"blue\":\"#377375\",\"purple\":\"#a04b73\",\"cyan\":\"#578e57\",\"white\":\"#978771\",\"brightBlack\":\"#7f7061\",\"brightRed\":\"#f73028\",\"brightGreen\":\"#aab01e\",\"brightYellow\":\"#f7b125\",\"brightBlue\":\"#719586\",\"brightPurple\":\"#c77089\",\"brightCyan\":\"#7db669\",\"brightWhite\":\"#e6d4a3\",\"background\":\"#1e1e1e\",\"foreground\":\"#e6d4a3\",\"cursorColor\":\"#e6d4a3\",\"selectionBackground\":\"#e6d4a3\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"morhetz\",\"link\":\"https://github.com/morhetz\"},{\"name\":\"mcchrish\",\"link\":\"https://github.com/mcchrish\"}]}},{\"name\":\"Gruvbox Light\",\"black\":\"#fbf1c7\",\"red\":\"#9d0006\",\"green\":\"#79740e\",\"yellow\":\"#b57614\",\"blue\":\"#076678\",\"purple\":\"#8f3f71\",\"cyan\":\"#427b58\",\"white\":\"#3c3836\",\"brightBlack\":\"#9d8374\",\"brightRed\":\"#cc241d\",\"brightGreen\":\"#98971a\",\"brightYellow\":\"#d79921\",\"brightBlue\":\"#458588\",\"brightPurple\":\"#b16186\",\"brightCyan\":\"#689d69\",\"brightWhite\":\"#7c6f64\",\"background\":\"#fbf1c7\",\"foreground\":\"#282828\",\"cursorColor\":\"#282828\",\"selectionBackground\":\"#d5c4a1\",\"meta\":{\"isDark\":false,\"credits\":[{\"name\":\"morhetz\",\"link\":\"https://github.com/morhetz\"},{\"name\":\"reynn\",\"link\":\"https://github.com/reynn\"}]}},{\"name\":\"Guezwhoz\",\"black\":\"#080808\",\"red\":\"#ff5f5f\",\"green\":\"#87d7af\",\"yellow\":\"#d7d787\",\"blue\":\"#5fafd7\",\"purple\":\"#afafff\",\"cyan\":\"#5fd7d7\",\"white\":\"#dadada\",\"brightBlack\":\"#8a8a8a\",\"brightRed\":\"#d75f5f\",\"brightGreen\":\"#afd7af\",\"brightYellow\":\"#d7d7af\",\"brightBlue\":\"#87afd7\",\"brightPurple\":\"#afafd7\",\"brightCyan\":\"#87d7d7\",\"brightWhite\":\"#dadada\",\"background\":\"#1c1c1c\",\"foreground\":\"#d0d0d0\",\"cursorColor\":\"#eeeeee\",\"selectionBackground\":\"#005f5f\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Egor Lem\",\"link\":\"https://github.com/guesswhozzz/guezwhoz-iterm2-theme\"}]}},{\"name\":\"Hacktober\",\"black\":\"#191918\",\"red\":\"#b34538\",\"green\":\"#587744\",\"yellow\":\"#d08949\",\"blue\":\"#206ec5\",\"purple\":\"#864651\",\"cyan\":\"#ac9166\",\"white\":\"#f1eee7\",\"brightBlack\":\"#2c2b2a\",\"brightRed\":\"#b33323\",\"brightGreen\":\"#42824a\",\"brightYellow\":\"#c75a22\",\"brightBlue\":\"#5389c5\",\"brightPurple\":\"#e795a5\",\"brightCyan\":\"#ebc587\",\"brightWhite\":\"#ffffff\",\"background\":\"#141414\",\"foreground\":\"#c9c9c9\",\"cursorColor\":\"#c9c9c9\",\"selectionBackground\":\"#141414\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"Hardcore\",\"black\":\"#1b1d1e\",\"red\":\"#f92672\",\"green\":\"#a6e22e\",\"yellow\":\"#fd971f\",\"blue\":\"#66d9ef\",\"purple\":\"#9e6ffe\",\"cyan\":\"#5e7175\",\"white\":\"#ccccc6\",\"brightBlack\":\"#505354\",\"brightRed\":\"#ff669d\",\"brightGreen\":\"#beed5f\",\"brightYellow\":\"#e6db74\",\"brightBlue\":\"#66d9ef\",\"brightPurple\":\"#9e6ffe\",\"brightCyan\":\"#a3babf\",\"brightWhite\":\"#f8f8f2\",\"background\":\"#121212\",\"foreground\":\"#a0a0a0\",\"cursorColor\":\"#bbbbbb\",\"selectionBackground\":\"#453b39\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"hardcore\",\"link\":\"https://github.com/hardcore/iTerm-colors\"}]}},{\"name\":\"Harper\",\"black\":\"#010101\",\"red\":\"#f8b63f\",\"green\":\"#7fb5e1\",\"yellow\":\"#d6da25\",\"blue\":\"#489e48\",\"purple\":\"#b296c6\",\"cyan\":\"#f5bfd7\",\"white\":\"#a8a49d\",\"brightBlack\":\"#726e6a\",\"brightRed\":\"#f8b63f\",\"brightGreen\":\"#7fb5e1\",\"brightYellow\":\"#d6da25\",\"brightBlue\":\"#489e48\",\"brightPurple\":\"#b296c6\",\"brightCyan\":\"#f5bfd7\",\"brightWhite\":\"#fefbea\",\"background\":\"#010101\",\"foreground\":\"#a8a49d\",\"cursorColor\":\"#a8a49d\",\"selectionBackground\":\"#5a5753\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"idleberg\",\"link\":\"https://github.com/idleberg/Harper-iTerm2\"}]}},{\"name\":\"HemisuDark\",\"black\":\"#444444\",\"red\":\"#FF0054\",\"green\":\"#B1D630\",\"yellow\":\"#9D895E\",\"blue\":\"#67BEE3\",\"purple\":\"#B576BC\",\"cyan\":\"#569A9F\",\"white\":\"#EDEDED\",\"brightBlack\":\"#777777\",\"brightRed\":\"#D65E75\",\"brightGreen\":\"#BAFFAA\",\"brightYellow\":\"#ECE1C8\",\"brightBlue\":\"#9FD3E5\",\"brightPurple\":\"#DEB3DF\",\"brightCyan\":\"#B6E0E5\",\"brightWhite\":\"#FFFFFF\",\"foreground\":\"#FFFFFF\",\"background\":\"#000000\",\"cursorColor\":\"#BAFFAA\"},{\"name\":\"HemisuLight\",\"black\":\"#777777\",\"red\":\"#FF0055\",\"green\":\"#739100\",\"yellow\":\"#503D15\",\"blue\":\"#538091\",\"purple\":\"#5B345E\",\"cyan\":\"#538091\",\"white\":\"#999999\",\"brightBlack\":\"#999999\",\"brightRed\":\"#D65E76\",\"brightGreen\":\"#9CC700\",\"brightYellow\":\"#947555\",\"brightBlue\":\"#9DB3CD\",\"brightPurple\":\"#A184A4\",\"brightCyan\":\"#85B2AA\",\"brightWhite\":\"#BABABA\",\"foreground\":\"#444444\",\"background\":\"#EFEFEF\",\"cursorColor\":\"#FF0054\"},{\"name\":\"Highway\",\"black\":\"#000000\",\"red\":\"#d00e18\",\"green\":\"#138034\",\"yellow\":\"#ffcb3e\",\"blue\":\"#006bb3\",\"purple\":\"#6b2775\",\"cyan\":\"#384564\",\"white\":\"#ededed\",\"brightBlack\":\"#5d504a\",\"brightRed\":\"#f07e18\",\"brightGreen\":\"#b1d130\",\"brightYellow\":\"#fff120\",\"brightBlue\":\"#4fc2fd\",\"brightPurple\":\"#de0071\",\"brightCyan\":\"#5d504a\",\"brightWhite\":\"#ffffff\",\"background\":\"#222225\",\"foreground\":\"#ededed\",\"cursorColor\":\"#e0d9b9\",\"selectionBackground\":\"#384564\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"zdj\",\"link\":\"https://github.com/zdj/themes/tree/master/iterm2\"}]}},{\"name\":\"Hipster Green\",\"black\":\"#000000\",\"red\":\"#b6214a\",\"green\":\"#00a600\",\"yellow\":\"#bfbf00\",\"blue\":\"#246eb2\",\"purple\":\"#b200b2\",\"cyan\":\"#00a6b2\",\"white\":\"#bfbfbf\",\"brightBlack\":\"#666666\",\"brightRed\":\"#e50000\",\"brightGreen\":\"#86a93e\",\"brightYellow\":\"#e5e500\",\"brightBlue\":\"#0000ff\",\"brightPurple\":\"#e500e5\",\"brightCyan\":\"#00e5e5\",\"brightWhite\":\"#e5e5e5\",\"background\":\"#100b05\",\"foreground\":\"#84c138\",\"cursorColor\":\"#23ff18\",\"selectionBackground\":\"#083905\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Unkulunkulu\",\"link\":\"https://github.com/Unkulunkulu\"}]}},{\"name\":\"Hivacruz\",\"black\":\"#202746\",\"red\":\"#c94922\",\"green\":\"#ac9739\",\"yellow\":\"#c08b30\",\"blue\":\"#3d8fd1\",\"purple\":\"#6679cc\",\"cyan\":\"#22a2c9\",\"white\":\"#979db4\",\"brightBlack\":\"#6b7394\",\"brightRed\":\"#c76b29\",\"brightGreen\":\"#73ad43\",\"brightYellow\":\"#5e6687\",\"brightBlue\":\"#898ea4\",\"brightPurple\":\"#dfe2f1\",\"brightCyan\":\"#9c637a\",\"brightWhite\":\"#f5f7ff\",\"background\":\"#132638\",\"foreground\":\"#ede4e4\",\"cursorColor\":\"#979db4\",\"selectionBackground\":\"#5e6687\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Yann Defretin\",\"link\":\"https://github.com/kinoute/hivacruz-itermcolors\"}]}},{\"name\":\"Homebrew\",\"black\":\"#000000\",\"red\":\"#990000\",\"green\":\"#00a600\",\"yellow\":\"#999900\",\"blue\":\"#0000b2\",\"purple\":\"#b200b2\",\"cyan\":\"#00a6b2\",\"white\":\"#bfbfbf\",\"brightBlack\":\"#666666\",\"brightRed\":\"#e50000\",\"brightGreen\":\"#00d900\",\"brightYellow\":\"#e5e500\",\"brightBlue\":\"#0000ff\",\"brightPurple\":\"#e500e5\",\"brightCyan\":\"#00e5e5\",\"brightWhite\":\"#e5e5e5\",\"background\":\"#000000\",\"foreground\":\"#00ff00\",\"cursorColor\":\"#23ff18\",\"selectionBackground\":\"#083905\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"Hopscotch\",\"black\":\"#322931\",\"red\":\"#dd464c\",\"green\":\"#8fc13e\",\"yellow\":\"#fdcc59\",\"blue\":\"#1290bf\",\"purple\":\"#c85e7c\",\"cyan\":\"#149b93\",\"white\":\"#b9b5b8\",\"brightBlack\":\"#797379\",\"brightRed\":\"#fd8b19\",\"brightGreen\":\"#433b42\",\"brightYellow\":\"#5c545b\",\"brightBlue\":\"#989498\",\"brightPurple\":\"#d5d3d5\",\"brightCyan\":\"#b33508\",\"brightWhite\":\"#ffffff\",\"background\":\"#322931\",\"foreground\":\"#b9b5b8\",\"cursorColor\":\"#b9b5b8\",\"selectionBackground\":\"#5c545b\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Jan T. Sott\",\"link\":\"https://github.com/idleberg/Hopscotch\"}]}},{\"name\":\"Hopscotch.256\",\"black\":\"#322931\",\"red\":\"#dd464c\",\"green\":\"#8fc13e\",\"yellow\":\"#fdcc59\",\"blue\":\"#1290bf\",\"purple\":\"#c85e7c\",\"cyan\":\"#149b93\",\"white\":\"#b9b5b8\",\"brightBlack\":\"#797379\",\"brightRed\":\"#dd464c\",\"brightGreen\":\"#8fc13e\",\"brightYellow\":\"#fdcc59\",\"brightBlue\":\"#1290bf\",\"brightPurple\":\"#c85e7c\",\"brightCyan\":\"#149b93\",\"brightWhite\":\"#ffffff\",\"background\":\"#322931\",\"foreground\":\"#b9b5b8\",\"cursorColor\":\"#b9b5b8\",\"selectionBackground\":\"#5c545b\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Jan T. Sott\",\"link\":\"https://github.com/idleberg/Hopscotch\"}]}},{\"name\":\"Horizon\",\"black\":\"#0a0a0d\",\"red\":\"#E95678\",\"green\":\"#29D398\",\"yellow\":\"#FAB795\",\"blue\":\"#26BBD9\",\"purple\":\"#EE64AC\",\"cyan\":\"#59E1E3\",\"white\":\"#e5e5e5\",\"brightBlack\":\"#848484\",\"brightRed\":\"#EC6A88\",\"brightGreen\":\"#3FDAA4\",\"brightYellow\":\"#FBC3A7\",\"brightBlue\":\"#3FC4DE\",\"brightPurple\":\"#F075B5\",\"brightCyan\":\"#6BE4E6\",\"brightWhite\":\"#e5e5e5\",\"background\":\"#1c1e26\",\"foreground\":\"#bdc0c2\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"wafelack\",\"link\":\"https://github.com/wafelack\"}]}},{\"name\":\"HorizonBright\",\"black\":\"#16161C\",\"red\":\"#DA103F\",\"green\":\"#1EB980\",\"yellow\":\"#F6661E\",\"blue\":\"#26BBD9\",\"purple\":\"#EE64AE\",\"cyan\":\"#1D8991\",\"white\":\"#FADAD1\",\"brightBlack\":\"#1A1C23\",\"brightRed\":\"#F43E5C\",\"brightGreen\":\"#07DA8C\",\"brightYellow\":\"#F77D26\",\"brightBlue\":\"#3FC6DE\",\"brightPurple\":\"#F075B7\",\"brightCyan\":\"#1EAEAE\",\"brightWhite\":\"#FDF0ED\",\"foreground\":\"#1C1E26\",\"background\":\"#FDF0ED\",\"cursorColor\":\"#1C1E26\"},{\"name\":\"HorizonDark\",\"black\":\"#16161C\",\"red\":\"#E95678\",\"green\":\"#29D398\",\"yellow\":\"#FAB795\",\"blue\":\"#26BBD9\",\"purple\":\"#EE64AE\",\"cyan\":\"#59E3E3\",\"white\":\"#FADAD1\",\"brightBlack\":\"#232530\",\"brightRed\":\"#EC6A88\",\"brightGreen\":\"#3FDAA4\",\"brightYellow\":\"#FBC3A7\",\"brightBlue\":\"#3FC6DE\",\"brightPurple\":\"#F075B7\",\"brightCyan\":\"#6BE6E6\",\"brightWhite\":\"#FDF0ED\",\"foreground\":\"#FDF0ED\",\"background\":\"#1C1E26\",\"cursorColor\":\"#FDF0ED\"},{\"name\":\"Hurtado\",\"black\":\"#575757\",\"red\":\"#ff1b00\",\"green\":\"#a5e055\",\"yellow\":\"#fbe74a\",\"blue\":\"#496487\",\"purple\":\"#fd5ff1\",\"cyan\":\"#86e9fe\",\"white\":\"#cbcccb\",\"brightBlack\":\"#262626\",\"brightRed\":\"#d51d00\",\"brightGreen\":\"#a5df55\",\"brightYellow\":\"#fbe84a\",\"brightBlue\":\"#89beff\",\"brightPurple\":\"#c001c1\",\"brightCyan\":\"#86eafe\",\"brightWhite\":\"#dbdbdb\",\"background\":\"#000000\",\"foreground\":\"#dbdbdb\",\"cursorColor\":\"#bbbbbb\",\"selectionBackground\":\"#b5d5ff\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"juanghurtado\",\"link\":\"https://github.com/juanghurtado/dotfiles\"}]}},{\"name\":\"Hybrid\",\"black\":\"#2a2e33\",\"red\":\"#b84d51\",\"green\":\"#b3bf5a\",\"yellow\":\"#e4b55e\",\"blue\":\"#6e90b0\",\"purple\":\"#a17eac\",\"cyan\":\"#7fbfb4\",\"white\":\"#b5b9b6\",\"brightBlack\":\"#1d1f22\",\"brightRed\":\"#8d2e32\",\"brightGreen\":\"#798431\",\"brightYellow\":\"#e58a50\",\"brightBlue\":\"#4b6b88\",\"brightPurple\":\"#6e5079\",\"brightCyan\":\"#4d7b74\",\"brightWhite\":\"#5a626a\",\"background\":\"#161719\",\"foreground\":\"#b7bcba\",\"cursorColor\":\"#b7bcba\",\"selectionBackground\":\"#1e1f22\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"luan\",\"link\":\"https://gist.github.com/luan/6362811\"}]}},{\"name\":\"ibm3270\",\"black\":\"#222222\",\"red\":\"#F01818\",\"green\":\"#24D830\",\"yellow\":\"#F0D824\",\"blue\":\"#7890F0\",\"purple\":\"#F078D8\",\"cyan\":\"#54E4E4\",\"white\":\"#A5A5A5\",\"brightBlack\":\"#888888\",\"brightRed\":\"#EF8383\",\"brightGreen\":\"#7ED684\",\"brightYellow\":\"#EFE28B\",\"brightBlue\":\"#B3BFEF\",\"brightPurple\":\"#EFB3E3\",\"brightCyan\":\"#9CE2E2\",\"brightWhite\":\"#FFFFFF\",\"foreground\":\"#FDFDFD\",\"background\":\"#000000\",\"cursorColor\":\"#FDFDFD\"},{\"name\":\"IBM3270(HighContrast)\",\"black\":\"#000000\",\"red\":\"#FF0000\",\"green\":\"#00FF00\",\"yellow\":\"#FFFF00\",\"blue\":\"#00BFFF\",\"purple\":\"#FFC0CB\",\"cyan\":\"#40E0D0\",\"white\":\"#BEBEBE\",\"brightBlack\":\"#414141\",\"brightRed\":\"#FFA500\",\"brightGreen\":\"#98FB98\",\"brightYellow\":\"#FFFF00\",\"brightBlue\":\"#0000CD\",\"brightPurple\":\"#A020F0\",\"brightCyan\":\"#AEEEEE\",\"brightWhite\":\"#FFFFFF\",\"foreground\":\"#FDFDFD\",\"background\":\"#000000\",\"cursorColor\":\"#FDFDFD\"},{\"name\":\"iceberg-dark\",\"black\":\"#1e2132\",\"red\":\"#e27878\",\"green\":\"#b4be82\",\"yellow\":\"#e2a478\",\"blue\":\"#84a0c6\",\"purple\":\"#a093c7\",\"cyan\":\"#89b8c2\",\"white\":\"#c6c8d1\",\"brightBlack\":\"#6b7089\",\"brightRed\":\"#e98989\",\"brightGreen\":\"#c0ca8e\",\"brightYellow\":\"#e9b189\",\"brightBlue\":\"#91acd1\",\"brightPurple\":\"#ada0d3\",\"brightCyan\":\"#95c4ce\",\"brightWhite\":\"#d2d4de\",\"background\":\"#161821\",\"foreground\":\"#c6c8d1\",\"cursorColor\":\"#c6c8d1\",\"selectionBackground\":\"#c6c8d1\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"cocopon\",\"link\":\"https://github.com/cocopon/iceberg.vim\"},{\"name\":\"pbnj\",\"link\":\"https://github.com/pbnj\"}]}},{\"name\":\"iceberg-light\",\"black\":\"#dcdfe7\",\"red\":\"#cc517a\",\"green\":\"#668e3d\",\"yellow\":\"#c57339\",\"blue\":\"#2d539e\",\"purple\":\"#7759b4\",\"cyan\":\"#3f83a6\",\"white\":\"#33374c\",\"brightBlack\":\"#8389a3\",\"brightRed\":\"#cc3768\",\"brightGreen\":\"#598030\",\"brightYellow\":\"#b6662d\",\"brightBlue\":\"#22478e\",\"brightPurple\":\"#6845ad\",\"brightCyan\":\"#327698\",\"brightWhite\":\"#262a3f\",\"background\":\"#e8e9ec\",\"foreground\":\"#33374c\",\"cursorColor\":\"#33374c\",\"selectionBackground\":\"#33374c\",\"meta\":{\"isDark\":false,\"credits\":[{\"name\":\"cocopon\",\"link\":\"https://github.com/cocopon/iceberg.vim\"},{\"name\":\"pbnj\",\"link\":\"https://github.com/pbnj\"}]}},{\"name\":\"IC_Green_PPL\",\"black\":\"#014401\",\"red\":\"#ff2736\",\"green\":\"#41a638\",\"yellow\":\"#76a831\",\"blue\":\"#2ec3b9\",\"purple\":\"#50a096\",\"cyan\":\"#3ca078\",\"white\":\"#e6fef2\",\"brightBlack\":\"#035c03\",\"brightRed\":\"#b4fa5c\",\"brightGreen\":\"#aefb86\",\"brightYellow\":\"#dafa87\",\"brightBlue\":\"#2efaeb\",\"brightPurple\":\"#50fafa\",\"brightCyan\":\"#3cfac8\",\"brightWhite\":\"#e0f1dc\",\"background\":\"#2c2c2c\",\"foreground\":\"#e0f1dc\",\"cursorColor\":\"#47fa6b\",\"selectionBackground\":\"#116b41\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"zdj\",\"link\":\"https://github.com/zdj/themes/tree/master/iterm2\"}]}},{\"name\":\"IC_Orange_PPL\",\"black\":\"#000000\",\"red\":\"#c13900\",\"green\":\"#a4a900\",\"yellow\":\"#caaf00\",\"blue\":\"#bd6d00\",\"purple\":\"#fc5e00\",\"cyan\":\"#f79500\",\"white\":\"#ffc88a\",\"brightBlack\":\"#6a4f2a\",\"brightRed\":\"#ff8c68\",\"brightGreen\":\"#f6ff40\",\"brightYellow\":\"#ffe36e\",\"brightBlue\":\"#ffbe55\",\"brightPurple\":\"#fc874f\",\"brightCyan\":\"#c69752\",\"brightWhite\":\"#fafaff\",\"background\":\"#262626\",\"foreground\":\"#ffcb83\",\"cursorColor\":\"#fc531d\",\"selectionBackground\":\"#c14020\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"zdj\",\"link\":\"https://github.com/zdj/themes/tree/master/iterm2\"}]}},{\"name\":\"idea\",\"black\":\"#adadad\",\"red\":\"#fc5256\",\"green\":\"#98b61c\",\"yellow\":\"#ccb444\",\"blue\":\"#437ee7\",\"purple\":\"#9d74b0\",\"cyan\":\"#248887\",\"white\":\"#181818\",\"brightBlack\":\"#ffffff\",\"brightRed\":\"#fc7072\",\"brightGreen\":\"#98b61c\",\"brightYellow\":\"#ffff0b\",\"brightBlue\":\"#6c9ced\",\"brightPurple\":\"#fc7eff\",\"brightCyan\":\"#248887\",\"brightWhite\":\"#181818\",\"background\":\"#202020\",\"foreground\":\"#adadad\",\"cursorColor\":\"#bbbbbb\",\"selectionBackground\":\"#44475a\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"idleToes\",\"black\":\"#323232\",\"red\":\"#d25252\",\"green\":\"#7fe173\",\"yellow\":\"#ffc66d\",\"blue\":\"#4099ff\",\"purple\":\"#f680ff\",\"cyan\":\"#bed6ff\",\"white\":\"#eeeeec\",\"brightBlack\":\"#535353\",\"brightRed\":\"#f07070\",\"brightGreen\":\"#9dff91\",\"brightYellow\":\"#ffe48b\",\"brightBlue\":\"#5eb7f7\",\"brightPurple\":\"#ff9dff\",\"brightCyan\":\"#dcf4ff\",\"brightWhite\":\"#ffffff\",\"background\":\"#323232\",\"foreground\":\"#ffffff\",\"cursorColor\":\"#d6d6d6\",\"selectionBackground\":\"#5b5b5b\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"idleFingers\",\"link\":\"http://www.idlefingers.co.uk/\"}]}},{\"name\":\"IR_Black\",\"black\":\"#4f4f4f\",\"red\":\"#fa6c60\",\"green\":\"#a8ff60\",\"yellow\":\"#fffeb7\",\"blue\":\"#96cafe\",\"purple\":\"#fa73fd\",\"cyan\":\"#c6c5fe\",\"white\":\"#efedef\",\"brightBlack\":\"#7b7b7b\",\"brightRed\":\"#fcb6b0\",\"brightGreen\":\"#cfffab\",\"brightYellow\":\"#ffffcc\",\"brightBlue\":\"#b5dcff\",\"brightPurple\":\"#fb9cfe\",\"brightCyan\":\"#e0e0fe\",\"brightWhite\":\"#ffffff\",\"background\":\"#000000\",\"foreground\":\"#f1f1f1\",\"cursorColor\":\"#808080\",\"selectionBackground\":\"#b5d5ff\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"meqif\",\"link\":\"https://gist.github.com/meqif/1238378\"}]}},{\"name\":\"Jackie Brown\",\"black\":\"#2c1d16\",\"red\":\"#ef5734\",\"green\":\"#2baf2b\",\"yellow\":\"#bebf00\",\"blue\":\"#246eb2\",\"purple\":\"#d05ec1\",\"cyan\":\"#00acee\",\"white\":\"#bfbfbf\",\"brightBlack\":\"#666666\",\"brightRed\":\"#e50000\",\"brightGreen\":\"#86a93e\",\"brightYellow\":\"#e5e500\",\"brightBlue\":\"#0000ff\",\"brightPurple\":\"#e500e5\",\"brightCyan\":\"#00e5e5\",\"brightWhite\":\"#e5e5e5\",\"background\":\"#2c1d16\",\"foreground\":\"#ffcc2f\",\"cursorColor\":\"#23ff18\",\"selectionBackground\":\"#af8d21\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Unkulunkulu\",\"link\":\"https://github.com/Unkulunkulu\"}]}},{\"name\":\"Japanesque\",\"black\":\"#343935\",\"red\":\"#cf3f61\",\"green\":\"#7bb75b\",\"yellow\":\"#e9b32a\",\"blue\":\"#4c9ad4\",\"purple\":\"#a57fc4\",\"cyan\":\"#389aad\",\"white\":\"#fafaf6\",\"brightBlack\":\"#595b59\",\"brightRed\":\"#d18fa6\",\"brightGreen\":\"#767f2c\",\"brightYellow\":\"#78592f\",\"brightBlue\":\"#135979\",\"brightPurple\":\"#604291\",\"brightCyan\":\"#76bbca\",\"brightWhite\":\"#b2b5ae\",\"background\":\"#1e1e1e\",\"foreground\":\"#f7f6ec\",\"cursorColor\":\"#edcf4f\",\"selectionBackground\":\"#175877\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"aereal\",\"link\":\"https://github.com/aereal/dotfiles/blob/master/colors/Japanesque/Japanesque.itermcolors\"}]}},{\"name\":\"Jellybeans\",\"black\":\"#929292\",\"red\":\"#e27373\",\"green\":\"#94b979\",\"yellow\":\"#ffba7b\",\"blue\":\"#97bedc\",\"purple\":\"#e1c0fa\",\"cyan\":\"#00988e\",\"white\":\"#dedede\",\"brightBlack\":\"#bdbdbd\",\"brightRed\":\"#ffa1a1\",\"brightGreen\":\"#bddeab\",\"brightYellow\":\"#ffdca0\",\"brightBlue\":\"#b1d8f6\",\"brightPurple\":\"#fbdaff\",\"brightCyan\":\"#1ab2a8\",\"brightWhite\":\"#ffffff\",\"background\":\"#121212\",\"foreground\":\"#dedede\",\"cursorColor\":\"#ffa560\",\"selectionBackground\":\"#474e91\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"qtpi\",\"link\":\"https://github.com/qtpi/Jellybeans.itermcolors\"}]}},{\"name\":\"JetBrains Darcula\",\"black\":\"#000000\",\"red\":\"#fa5355\",\"green\":\"#126e00\",\"yellow\":\"#c2c300\",\"blue\":\"#4581eb\",\"purple\":\"#fa54ff\",\"cyan\":\"#33c2c1\",\"white\":\"#adadad\",\"brightBlack\":\"#555555\",\"brightRed\":\"#fb7172\",\"brightGreen\":\"#67ff4f\",\"brightYellow\":\"#ffff00\",\"brightBlue\":\"#6d9df1\",\"brightPurple\":\"#fb82ff\",\"brightCyan\":\"#60d3d1\",\"brightWhite\":\"#eeeeee\",\"background\":\"#202020\",\"foreground\":\"#adadad\",\"cursorColor\":\"#ffffff\",\"selectionBackground\":\"#1a3272\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"vitstr\",\"link\":\"https://github.com/vitstr\"}]}},{\"name\":\"jubi\",\"black\":\"#3b3750\",\"red\":\"#cf7b98\",\"green\":\"#90a94b\",\"yellow\":\"#6ebfc0\",\"blue\":\"#576ea6\",\"purple\":\"#bc4f68\",\"cyan\":\"#75a7d2\",\"white\":\"#c3d3de\",\"brightBlack\":\"#a874ce\",\"brightRed\":\"#de90ab\",\"brightGreen\":\"#bcdd61\",\"brightYellow\":\"#87e9ea\",\"brightBlue\":\"#8c9fcd\",\"brightPurple\":\"#e16c87\",\"brightCyan\":\"#b7c9ef\",\"brightWhite\":\"#d5e5f1\",\"background\":\"#262b33\",\"foreground\":\"#c3d3de\",\"cursorColor\":\"#c3d3de\",\"selectionBackground\":\"#5b5184\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Julia Tretel\",\"link\":\"https://github.com/jutretel\"}]}},{\"name\":\"Juicy Colors\",\"cursorColor\":\"#FFFFFF\",\"selectionBackground\":\"#FFFFFF\",\"background\":\"#292a24\",\"foreground\":\"#CCCCCC\",\"black\":\"#292a24\",\"blue\":\"#209DE5\",\"cyan\":\"#00D2FF\",\"green\":\"#68D644\",\"purple\":\"#AF80FF\",\"red\":\"#FF6249\",\"white\":\"#CCCCCC\",\"yellow\":\"#FCC223\",\"brightBlack\":\"#808080\",\"brightBlue\":\"#209DE5\",\"brightCyan\":\"#00D2FF\",\"brightGreen\":\"#68D644\",\"brightPurple\":\"#AF80FF\",\"brightRed\":\"#FF6249\",\"brightWhite\":\"#F2F2F2\",\"brightYellow\":\"#FCC223\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"Jup\",\"black\":\"#000000\",\"red\":\"#dd006f\",\"green\":\"#6fdd00\",\"yellow\":\"#dd6f00\",\"blue\":\"#006fdd\",\"purple\":\"#6f00dd\",\"cyan\":\"#00dd6f\",\"white\":\"#f2f2f2\",\"brightBlack\":\"#7d7d7d\",\"brightRed\":\"#ff74b9\",\"brightGreen\":\"#b9ff74\",\"brightYellow\":\"#ffb974\",\"brightBlue\":\"#74b9ff\",\"brightPurple\":\"#b974ff\",\"brightCyan\":\"#74ffb9\",\"brightWhite\":\"#ffffff\",\"foreground\":\"#23476a\",\"background\":\"#758480\",\"cursorColor\":\"#23476a\"},{\"name\":\"Kibble\",\"black\":\"#4d4d4d\",\"red\":\"#c70031\",\"green\":\"#29cf13\",\"yellow\":\"#d8e30e\",\"blue\":\"#3449d1\",\"purple\":\"#8400ff\",\"cyan\":\"#0798ab\",\"white\":\"#e2d1e3\",\"brightBlack\":\"#5a5a5a\",\"brightRed\":\"#f01578\",\"brightGreen\":\"#6ce05c\",\"brightYellow\":\"#f3f79e\",\"brightBlue\":\"#97a4f7\",\"brightPurple\":\"#c495f0\",\"brightCyan\":\"#68f2e0\",\"brightWhite\":\"#ffffff\",\"background\":\"#0e100a\",\"foreground\":\"#f7f7f7\",\"cursorColor\":\"#9fda9c\",\"selectionBackground\":\"#9ba787\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"kokuban\",\"black\":\"#2E8744\",\"red\":\"#D84E4C\",\"green\":\"#95DA5A\",\"yellow\":\"#D6E264\",\"blue\":\"#4B9ED7\",\"purple\":\"#945FC5\",\"cyan\":\"#D89B25\",\"white\":\"#D8E2D7\",\"brightBlack\":\"#34934F\",\"brightRed\":\"#FF4F59\",\"brightGreen\":\"#AFF56A\",\"brightYellow\":\"#FCFF75\",\"brightBlue\":\"#57AEFF\",\"brightPurple\":\"#AE63E9\",\"brightCyan\":\"#FFAA2B\",\"brightWhite\":\"#FFFEFE\",\"foreground\":\"#D8E2D7\",\"background\":\"#0D4A08\",\"cursorColor\":\"#D8E2D7\"},{\"name\":\"Kolorit\",\"black\":\"#1d1a1e\",\"red\":\"#ff5b82\",\"green\":\"#47d7a1\",\"yellow\":\"#e8e562\",\"blue\":\"#5db4ee\",\"purple\":\"#da6cda\",\"cyan\":\"#57e9eb\",\"white\":\"#ededed\",\"brightBlack\":\"#1d1a1e\",\"brightRed\":\"#ff5b82\",\"brightGreen\":\"#47d7a1\",\"brightYellow\":\"#e8e562\",\"brightBlue\":\"#5db4ee\",\"brightPurple\":\"#da6cda\",\"brightCyan\":\"#57e9eb\",\"brightWhite\":\"#ededed\",\"background\":\"#1d1a1e\",\"foreground\":\"#efecec\",\"cursorColor\":\"#c7c7c7\",\"selectionBackground\":\"#e1925c\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"thomaspaulmann\",\"link\":\"https://github.com/thomaspaulmann\"}]}},{\"name\":\"Konsolas\",\"black\":\"#000000\",\"red\":\"#aa1717\",\"green\":\"#18b218\",\"yellow\":\"#ebae1f\",\"blue\":\"#2323a5\",\"purple\":\"#ad1edc\",\"cyan\":\"#42b0c8\",\"white\":\"#c8c1c1\",\"brightBlack\":\"#7b716e\",\"brightRed\":\"#ff4141\",\"brightGreen\":\"#5fff5f\",\"brightYellow\":\"#ffff55\",\"brightBlue\":\"#4b4bff\",\"brightPurple\":\"#ff54ff\",\"brightCyan\":\"#69ffff\",\"brightWhite\":\"#ffffff\",\"background\":\"#060606\",\"foreground\":\"#c8c1c1\",\"cursorColor\":\"#c8c1c1\",\"selectionBackground\":\"#060606\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"Lab Fox\",\"black\":\"#2e2e2e\",\"red\":\"#fc6d26\",\"green\":\"#3eb383\",\"yellow\":\"#fca121\",\"blue\":\"#db3b21\",\"purple\":\"#380d75\",\"cyan\":\"#6e49cb\",\"white\":\"#ffffff\",\"brightBlack\":\"#464646\",\"brightRed\":\"#ff6517\",\"brightGreen\":\"#53eaa8\",\"brightYellow\":\"#fca013\",\"brightBlue\":\"#db501f\",\"brightPurple\":\"#441090\",\"brightCyan\":\"#7d53e7\",\"brightWhite\":\"#ffffff\",\"background\":\"#2e2e2e\",\"foreground\":\"#ffffff\",\"cursorColor\":\"#7f7f7f\",\"selectionBackground\":\"#cb392e\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"theatlasroom\",\"link\":\"https://github.com/theatlasroom\"},{\"name\":\"Gitlab design system\",\"link\":\"https://design.gitlab.com\"}]}},{\"name\":\"Laser\",\"black\":\"#626262\",\"red\":\"#ff8373\",\"green\":\"#b4fb73\",\"yellow\":\"#09b4bd\",\"blue\":\"#fed300\",\"purple\":\"#ff90fe\",\"cyan\":\"#d1d1fe\",\"white\":\"#f1f1f1\",\"brightBlack\":\"#8f8f8f\",\"brightRed\":\"#ffc4be\",\"brightGreen\":\"#d6fcba\",\"brightYellow\":\"#fffed5\",\"brightBlue\":\"#f92883\",\"brightPurple\":\"#ffb2fe\",\"brightCyan\":\"#e6e7fe\",\"brightWhite\":\"#ffffff\",\"background\":\"#030d18\",\"foreground\":\"#f106e3\",\"cursorColor\":\"#00ff9c\",\"selectionBackground\":\"#2e206a\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"ReagentX\",\"link\":\"https://github.com/ReagentX\"}]}},{\"name\":\"laserwave\",\"black\":\"#39243A\",\"red\":\"#EB64B9\",\"green\":\"#AFD686\",\"yellow\":\"#FEAE87\",\"blue\":\"#40B4C4\",\"purple\":\"#B381C5\",\"cyan\":\"#215969\",\"white\":\"#91889b\",\"brightBlack\":\"#716485\",\"brightRed\":\"#FC2377\",\"brightGreen\":\"#50FA7B\",\"brightYellow\":\"#FFE261\",\"brightBlue\":\"#74DFC4\",\"brightPurple\":\"#6D75E0\",\"brightCyan\":\"#B4DCE7\",\"brightWhite\":\"#FFFFFF\",\"foreground\":\"#E0E0E0\",\"background\":\"#1F1926\",\"cursorColor\":\"#C7C7C7\"},{\"name\":\"Later This Evening\",\"black\":\"#2b2b2b\",\"red\":\"#d45a60\",\"green\":\"#afba67\",\"yellow\":\"#e5d289\",\"blue\":\"#a0bad6\",\"purple\":\"#c092d6\",\"cyan\":\"#91bfb7\",\"white\":\"#3c3d3d\",\"brightBlack\":\"#454747\",\"brightRed\":\"#d3232f\",\"brightGreen\":\"#aabb39\",\"brightYellow\":\"#e5be39\",\"brightBlue\":\"#6699d6\",\"brightPurple\":\"#ab53d6\",\"brightCyan\":\"#5fc0ae\",\"brightWhite\":\"#c1c2c2\",\"background\":\"#222222\",\"foreground\":\"#959595\",\"cursorColor\":\"#424242\",\"selectionBackground\":\"#424242\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"vilhalmer\",\"link\":\"https://github.com/vilhalmer/System/tree/master/terminal-themes\"}]}},{\"name\":\"Lavandula\",\"black\":\"#230046\",\"red\":\"#7d1625\",\"green\":\"#337e6f\",\"yellow\":\"#7f6f49\",\"blue\":\"#4f4a7f\",\"purple\":\"#5a3f7f\",\"cyan\":\"#58777f\",\"white\":\"#736e7d\",\"brightBlack\":\"#372d46\",\"brightRed\":\"#e05167\",\"brightGreen\":\"#52e0c4\",\"brightYellow\":\"#e0c386\",\"brightBlue\":\"#8e87e0\",\"brightPurple\":\"#a776e0\",\"brightCyan\":\"#9ad4e0\",\"brightWhite\":\"#8c91fa\",\"background\":\"#050014\",\"foreground\":\"#736e7d\",\"cursorColor\":\"#8c91fa\",\"selectionBackground\":\"#37323c\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"zdj\",\"link\":\"https://github.com/zdj/themes/tree/master/iterm2\"}]}},{\"name\":\"LiquidCarbon\",\"black\":\"#000000\",\"red\":\"#ff3030\",\"green\":\"#559a70\",\"yellow\":\"#ccac00\",\"blue\":\"#0099cc\",\"purple\":\"#cc69c8\",\"cyan\":\"#7ac4cc\",\"white\":\"#bccccc\",\"brightBlack\":\"#000000\",\"brightRed\":\"#ff3030\",\"brightGreen\":\"#559a70\",\"brightYellow\":\"#ccac00\",\"brightBlue\":\"#0099cc\",\"brightPurple\":\"#cc69c8\",\"brightCyan\":\"#7ac4cc\",\"brightWhite\":\"#bccccc\",\"background\":\"#303030\",\"foreground\":\"#afc2c2\",\"cursorColor\":\"#ffffff\",\"selectionBackground\":\"#7dbeff\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"markcho\",\"link\":\"https://github.com/markcho/iTerm2_LiquidCarbon\"}]}},{\"name\":\"LiquidCarbonTransparent\",\"black\":\"#000000\",\"red\":\"#ff3030\",\"green\":\"#559a70\",\"yellow\":\"#ccac00\",\"blue\":\"#0099cc\",\"purple\":\"#cc69c8\",\"cyan\":\"#7ac4cc\",\"white\":\"#bccccc\",\"brightBlack\":\"#000000\",\"brightRed\":\"#ff3030\",\"brightGreen\":\"#559a70\",\"brightYellow\":\"#ccac00\",\"brightBlue\":\"#0099cc\",\"brightPurple\":\"#cc69c8\",\"brightCyan\":\"#7ac4cc\",\"brightWhite\":\"#bccccc\",\"background\":\"#000000\",\"foreground\":\"#afc2c2\",\"cursorColor\":\"#ffffff\",\"selectionBackground\":\"#7dbeff\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"markcho\",\"link\":\"https://github.com/markcho/iTerm2_LiquidCarbon\"}]}},{\"name\":\"LiquidCarbonTransparentInverse\",\"black\":\"#bccccd\",\"red\":\"#ff3030\",\"green\":\"#559a70\",\"yellow\":\"#ccac00\",\"blue\":\"#0099cc\",\"purple\":\"#cc69c8\",\"cyan\":\"#7ac4cc\",\"white\":\"#000000\",\"brightBlack\":\"#ffffff\",\"brightRed\":\"#ff3030\",\"brightGreen\":\"#559a70\",\"brightYellow\":\"#ccac00\",\"brightBlue\":\"#0099cc\",\"brightPurple\":\"#cc69c8\",\"brightCyan\":\"#7ac4cc\",\"brightWhite\":\"#000000\",\"background\":\"#000000\",\"foreground\":\"#afc2c2\",\"cursorColor\":\"#ffffff\",\"selectionBackground\":\"#7dbeff\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"markcho\",\"link\":\"https://github.com/markcho/iTerm2_LiquidCarbon\"}]}},{\"name\":\"lovelace\",\"black\":\"#282a36\",\"red\":\"#f37f97\",\"green\":\"#5adecd\",\"yellow\":\"#f2a272\",\"blue\":\"#8897f4\",\"purple\":\"#c574dd\",\"cyan\":\"#79e6f3\",\"white\":\"#fdfdfd\",\"brightBlack\":\"#414458\",\"brightRed\":\"#ff4971\",\"brightGreen\":\"#18e3c8\",\"brightYellow\":\"#ff8037\",\"brightBlue\":\"#556fff\",\"brightPurple\":\"#b043d1\",\"brightCyan\":\"#3fdcee\",\"brightWhite\":\"#bebec1\",\"background\":\"#1d1f28\",\"foreground\":\"#fdfdfd\",\"cursorColor\":\"#c574dd\",\"selectionBackground\":\"#c1deff\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"nalanbar\",\"link\":\"https://github.com/nalanbar\"},{\"name\":\"elenapan\",\"link\":\"https://github.com/elenapan\"}]}},{\"name\":\"LunariaDark\",\"black\":\"#36464E\",\"red\":\"#846560\",\"green\":\"#809984\",\"yellow\":\"#A79A79\",\"blue\":\"#555673\",\"purple\":\"#866C83\",\"cyan\":\"#7E98B4\",\"white\":\"#CACED8\",\"brightBlack\":\"#404F56\",\"brightRed\":\"#BB928B\",\"brightGreen\":\"#BFDCC2\",\"brightYellow\":\"#F1DFB6\",\"brightBlue\":\"#777798\",\"brightPurple\":\"#BF9DB9\",\"brightCyan\":\"#BDDCFF\",\"brightWhite\":\"#DFE2ED\",\"foreground\":\"#CACED8\",\"background\":\"#36464E\",\"cursorColor\":\"#CACED8\"},{\"name\":\"LunariaEclipse\",\"black\":\"#323F46\",\"red\":\"#83615B\",\"green\":\"#7F9781\",\"yellow\":\"#A69875\",\"blue\":\"#53516F\",\"purple\":\"#856880\",\"cyan\":\"#7D96B2\",\"white\":\"#C9CDD7\",\"brightBlack\":\"#3D4950\",\"brightRed\":\"#BA9088\",\"brightGreen\":\"#BEDBC1\",\"brightYellow\":\"#F1DFB4\",\"brightBlue\":\"#767495\",\"brightPurple\":\"#BE9CB8\",\"brightCyan\":\"#BCDBFF\",\"brightWhite\":\"#DFE2ED\",\"foreground\":\"#C9CDD7\",\"background\":\"#323F46\",\"cursorColor\":\"#C9CDD7\"},{\"name\":\"LunariaLight\",\"black\":\"#3E3C3D\",\"red\":\"#783C1F\",\"green\":\"#497D46\",\"yellow\":\"#8F750B\",\"blue\":\"#3F3566\",\"purple\":\"#793F62\",\"cyan\":\"#3778A9\",\"white\":\"#D5CFCC\",\"brightBlack\":\"#484646\",\"brightRed\":\"#B06240\",\"brightGreen\":\"#7BC175\",\"brightYellow\":\"#DCB735\",\"brightBlue\":\"#5C4F89\",\"brightPurple\":\"#B56895\",\"brightCyan\":\"#64BAFF\",\"brightWhite\":\"#EBE4E1\",\"foreground\":\"#484646\",\"background\":\"#EBE4E1\",\"cursorColor\":\"#484646\"},{\"name\":\"Maia\",\"black\":\"#232423\",\"red\":\"#BA2922\",\"green\":\"#7E807E\",\"yellow\":\"#4C4F4D\",\"blue\":\"#16A085\",\"purple\":\"#43746A\",\"cyan\":\"#00CCCC\",\"white\":\"#E0E0E0\",\"brightBlack\":\"#282928\",\"brightRed\":\"#CC372C\",\"brightGreen\":\"#8D8F8D\",\"brightYellow\":\"#4E524F\",\"brightBlue\":\"#13BF9D\",\"brightPurple\":\"#487D72\",\"brightCyan\":\"#00D1D1\",\"brightWhite\":\"#E8E8E8\",\"foreground\":\"#BDC3C7\",\"background\":\"#31363B\",\"cursorColor\":\"#BDC3C7\"},{\"name\":\"Man Page\",\"black\":\"#000000\",\"red\":\"#cc0000\",\"green\":\"#00a600\",\"yellow\":\"#999900\",\"blue\":\"#0000b2\",\"purple\":\"#b200b2\",\"cyan\":\"#00a6b2\",\"white\":\"#cccccc\",\"brightBlack\":\"#666666\",\"brightRed\":\"#e50000\",\"brightGreen\":\"#00d900\",\"brightYellow\":\"#e5e500\",\"brightBlue\":\"#0000ff\",\"brightPurple\":\"#e500e5\",\"brightCyan\":\"#00e5e5\",\"brightWhite\":\"#e5e5e5\",\"background\":\"#fef49c\",\"foreground\":\"#000000\",\"cursorColor\":\"#7f7f7f\",\"selectionBackground\":\"#a4c9cd\",\"meta\":{\"isDark\":false,\"credits\":null}},{\"name\":\"Mar\",\"black\":\"#000000\",\"red\":\"#b5407b\",\"green\":\"#7bb540\",\"yellow\":\"#b57b40\",\"blue\":\"#407bb5\",\"purple\":\"#7b40b5\",\"cyan\":\"#40b57b\",\"white\":\"#f8f8f8\",\"brightBlack\":\"#737373\",\"brightRed\":\"#cd73a0\",\"brightGreen\":\"#a0cd73\",\"brightYellow\":\"#cda073\",\"brightBlue\":\"#73a0cd\",\"brightPurple\":\"#a073cd\",\"brightCyan\":\"#73cda0\",\"brightWhite\":\"#ffffff\",\"foreground\":\"#23476a\",\"background\":\"#ffffff\",\"cursorColor\":\"#23476a\"},{\"name\":\"Material\",\"black\":\"#212121\",\"red\":\"#b7141f\",\"green\":\"#457b24\",\"yellow\":\"#f6981e\",\"blue\":\"#134eb2\",\"purple\":\"#560088\",\"cyan\":\"#0e717c\",\"white\":\"#efefef\",\"brightBlack\":\"#424242\",\"brightRed\":\"#e83b3f\",\"brightGreen\":\"#7aba3a\",\"brightYellow\":\"#ffea2e\",\"brightBlue\":\"#54a4f3\",\"brightPurple\":\"#aa4dbc\",\"brightCyan\":\"#26bbd1\",\"brightWhite\":\"#d9d9d9\",\"background\":\"#eaeaea\",\"foreground\":\"#232322\",\"cursorColor\":\"#16afca\",\"selectionBackground\":\"#c2c2c2\",\"meta\":{\"isDark\":false,\"credits\":[{\"name\":\"stoeffel\",\"link\":\"https://github.com/stoeffel/material-iterm\"}]}},{\"name\":\"MaterialDark\",\"black\":\"#212121\",\"red\":\"#b7141f\",\"green\":\"#457b24\",\"yellow\":\"#f6981e\",\"blue\":\"#134eb2\",\"purple\":\"#560088\",\"cyan\":\"#0e717c\",\"white\":\"#efefef\",\"brightBlack\":\"#424242\",\"brightRed\":\"#e83b3f\",\"brightGreen\":\"#7aba3a\",\"brightYellow\":\"#ffea2e\",\"brightBlue\":\"#54a4f3\",\"brightPurple\":\"#aa4dbc\",\"brightCyan\":\"#26bbd1\",\"brightWhite\":\"#d9d9d9\",\"background\":\"#232322\",\"foreground\":\"#e5e5e5\",\"cursorColor\":\"#16afca\",\"selectionBackground\":\"#dfdfdf\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"stoeffel\",\"link\":\"https://github.com/stoeffel/material-iterm\"}]}},{\"name\":\"MaterialDarker\",\"black\":\"#000000\",\"red\":\"#ff5370\",\"green\":\"#c3e88d\",\"yellow\":\"#ffcb6b\",\"blue\":\"#82aaff\",\"purple\":\"#c792ea\",\"cyan\":\"#89ddff\",\"white\":\"#ffffff\",\"brightBlack\":\"#545454\",\"brightRed\":\"#ff5370\",\"brightGreen\":\"#c3e88d\",\"brightYellow\":\"#ffcb6b\",\"brightBlue\":\"#82aaff\",\"brightPurple\":\"#c792ea\",\"brightCyan\":\"#89ddff\",\"brightWhite\":\"#ffffff\",\"background\":\"#212121\",\"foreground\":\"#eeffff\",\"cursorColor\":\"#ffffff\",\"selectionBackground\":\"#eeffff\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"jos3s\",\"link\":\"https://github.com/jos3s\"}]}},{\"name\":\"MaterialOcean\",\"black\":\"#546e7a\",\"red\":\"#ff5370\",\"green\":\"#c3e88d\",\"yellow\":\"#ffcb6b\",\"blue\":\"#82aaff\",\"purple\":\"#c792ea\",\"cyan\":\"#89ddff\",\"white\":\"#ffffff\",\"brightBlack\":\"#546e7a\",\"brightRed\":\"#ff5370\",\"brightGreen\":\"#c3e88d\",\"brightYellow\":\"#ffcb6b\",\"brightBlue\":\"#82aaff\",\"brightPurple\":\"#c792ea\",\"brightCyan\":\"#89ddff\",\"brightWhite\":\"#ffffff\",\"background\":\"#0f111a\",\"foreground\":\"#8f93a2\",\"cursorColor\":\"#ffcc00\",\"selectionBackground\":\"#1f2233\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"kaicataldo\",\"link\":\"https://github.com/kaicataldo/material.vim/blob/master/terminal-colors/iterm2/material-ocean.itermcolors\"},{\"name\":\"fr3fou\",\"link\":\"https://github.com/fr3fou\"}]}},{\"name\":\"Mathias\",\"black\":\"#000000\",\"red\":\"#e52222\",\"green\":\"#a6e32d\",\"yellow\":\"#fc951e\",\"blue\":\"#c48dff\",\"purple\":\"#fa2573\",\"cyan\":\"#67d9f0\",\"white\":\"#f2f2f2\",\"brightBlack\":\"#555555\",\"brightRed\":\"#ff5555\",\"brightGreen\":\"#55ff55\",\"brightYellow\":\"#ffff55\",\"brightBlue\":\"#5555ff\",\"brightPurple\":\"#ff55ff\",\"brightCyan\":\"#55ffff\",\"brightWhite\":\"#ffffff\",\"background\":\"#000000\",\"foreground\":\"#bbbbbb\",\"cursorColor\":\"#bbbbbb\",\"selectionBackground\":\"#555555\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"mathiasbynens\",\"link\":\"https://github.com/mathiasbynens/dotfiles\"}]}},{\"name\":\"Medallion\",\"black\":\"#000000\",\"red\":\"#b64c00\",\"green\":\"#7c8b16\",\"yellow\":\"#d3bd26\",\"blue\":\"#616bb0\",\"purple\":\"#8c5a90\",\"cyan\":\"#916c25\",\"white\":\"#cac29a\",\"brightBlack\":\"#5e5219\",\"brightRed\":\"#ff9149\",\"brightGreen\":\"#b2ca3b\",\"brightYellow\":\"#ffe54a\",\"brightBlue\":\"#acb8ff\",\"brightPurple\":\"#ffa0ff\",\"brightCyan\":\"#ffbc51\",\"brightWhite\":\"#fed698\",\"background\":\"#1d1908\",\"foreground\":\"#cac296\",\"cursorColor\":\"#d3ba30\",\"selectionBackground\":\"#626dac\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"zdj\",\"link\":\"https://github.com/zdj/themes/tree/master/iterm2\"}]}},{\"name\":\"midnight-in-mojave\",\"black\":\"#1e1e1e\",\"red\":\"#ff453a\",\"green\":\"#32d74b\",\"yellow\":\"#ffd60a\",\"blue\":\"#0a84ff\",\"purple\":\"#bf5af2\",\"cyan\":\"#5ac8fa\",\"white\":\"#ffffff\",\"brightBlack\":\"#1e1e1e\",\"brightRed\":\"#ff453a\",\"brightGreen\":\"#32d74b\",\"brightYellow\":\"#ffd60a\",\"brightBlue\":\"#0a84ff\",\"brightPurple\":\"#bf5af2\",\"brightCyan\":\"#5ac8fa\",\"brightWhite\":\"#ffffff\",\"background\":\"#1e1e1e\",\"foreground\":\"#ffffff\",\"cursorColor\":\"#32d74b\",\"selectionBackground\":\"#4a504d\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"OberstKrueger\",\"link\":\"https://github.com/oberstkrueger\"},{\"name\":\"Human Interface Guidelines\",\"link\":\"https://developer.apple.com/design/human-interface-guidelines/macos/overview/themes/\"}]}},{\"name\":\"Mirage\",\"black\":\"#011627\",\"red\":\"#ff9999\",\"green\":\"#85cc95\",\"yellow\":\"#ffd700\",\"blue\":\"#7fb5ff\",\"purple\":\"#ddb3ff\",\"cyan\":\"#21c7a8\",\"white\":\"#ffffff\",\"brightBlack\":\"#575656\",\"brightRed\":\"#ff9999\",\"brightGreen\":\"#85cc95\",\"brightYellow\":\"#ffd700\",\"brightBlue\":\"#7fb5ff\",\"brightPurple\":\"#ddb3ff\",\"brightCyan\":\"#85cc95\",\"brightWhite\":\"#ffffff\",\"background\":\"#1b2738\",\"foreground\":\"#a6b2c0\",\"cursorColor\":\"#ddb3ff\",\"selectionBackground\":\"#273951\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Tristan Remy\",\"link\":\"https://github.com/tristanremy/mirage\"},{\"name\":\"Gomah\",\"link\":\"https://github.com/Gomah/mirage-iterm\"}]}},{\"name\":\"Misterioso\",\"black\":\"#000000\",\"red\":\"#ff4242\",\"green\":\"#74af68\",\"yellow\":\"#ffad29\",\"blue\":\"#338f86\",\"purple\":\"#9414e6\",\"cyan\":\"#23d7d7\",\"white\":\"#e1e1e0\",\"brightBlack\":\"#555555\",\"brightRed\":\"#ff3242\",\"brightGreen\":\"#74cd68\",\"brightYellow\":\"#ffb929\",\"brightBlue\":\"#23d7d7\",\"brightPurple\":\"#ff37ff\",\"brightCyan\":\"#00ede1\",\"brightWhite\":\"#ffffff\",\"background\":\"#2d3743\",\"foreground\":\"#e1e1e0\",\"cursorColor\":\"#000000\",\"selectionBackground\":\"#2d37ff\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"flooose\",\"link\":\"https://github.com/flooose/misterioso-iterm2\"}]}},{\"name\":\"Miu\",\"black\":\"#000000\",\"red\":\"#b87a7a\",\"green\":\"#7ab87a\",\"yellow\":\"#b8b87a\",\"blue\":\"#7a7ab8\",\"purple\":\"#b87ab8\",\"cyan\":\"#7ab8b8\",\"white\":\"#d9d9d9\",\"brightBlack\":\"#262626\",\"brightRed\":\"#dbbdbd\",\"brightGreen\":\"#bddbbd\",\"brightYellow\":\"#dbdbbd\",\"brightBlue\":\"#bdbddb\",\"brightPurple\":\"#dbbddb\",\"brightCyan\":\"#bddbdb\",\"brightWhite\":\"#ffffff\",\"foreground\":\"#d9e6f2\",\"background\":\"#0d1926\",\"cursorColor\":\"#d9e6f2\"},{\"name\":\"Molokai\",\"black\":\"#121212\",\"red\":\"#fa2573\",\"green\":\"#98e123\",\"yellow\":\"#dfd460\",\"blue\":\"#1080d0\",\"purple\":\"#8700ff\",\"cyan\":\"#43a8d0\",\"white\":\"#bbbbbb\",\"brightBlack\":\"#555555\",\"brightRed\":\"#f6669d\",\"brightGreen\":\"#b1e05f\",\"brightYellow\":\"#fff26d\",\"brightBlue\":\"#00afff\",\"brightPurple\":\"#af87ff\",\"brightCyan\":\"#51ceff\",\"brightWhite\":\"#ffffff\",\"background\":\"#121212\",\"foreground\":\"#bbbbbb\",\"cursorColor\":\"#bbbbbb\",\"selectionBackground\":\"#b5d5ff\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"tomasr\",\"link\":\"https://github.com/tomasr/molokai\"}]}},{\"name\":\"MonaLisa\",\"black\":\"#351b0e\",\"red\":\"#9b291c\",\"green\":\"#636232\",\"yellow\":\"#c36e28\",\"blue\":\"#515c5d\",\"purple\":\"#9b1d29\",\"cyan\":\"#588056\",\"white\":\"#f7d75c\",\"brightBlack\":\"#874228\",\"brightRed\":\"#ff4331\",\"brightGreen\":\"#b4b264\",\"brightYellow\":\"#ff9566\",\"brightBlue\":\"#9eb2b4\",\"brightPurple\":\"#ff5b6a\",\"brightCyan\":\"#8acd8f\",\"brightWhite\":\"#ffe598\",\"background\":\"#120b0d\",\"foreground\":\"#f7d66a\",\"cursorColor\":\"#c46c32\",\"selectionBackground\":\"#f7d66a\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"zdj\",\"link\":\"https://github.com/zdj/themes/tree/master/iterm2\"}]}},{\"name\":\"mono-amber\",\"black\":\"#402500\",\"red\":\"#FF9400\",\"green\":\"#FF9400\",\"yellow\":\"#FF9400\",\"blue\":\"#FF9400\",\"purple\":\"#FF9400\",\"cyan\":\"#FF9400\",\"white\":\"#FF9400\",\"brightBlack\":\"#FF9400\",\"brightRed\":\"#FF9400\",\"brightGreen\":\"#FF9400\",\"brightYellow\":\"#FF9400\",\"brightBlue\":\"#FF9400\",\"brightPurple\":\"#FF9400\",\"brightCyan\":\"#FF9400\",\"brightWhite\":\"#FF9400\",\"foreground\":\"#FF9400\",\"background\":\"#2B1900\",\"cursorColor\":\"#FF9400\"},{\"name\":\"mono-cyan\",\"black\":\"#003340\",\"red\":\"#00CCFF\",\"green\":\"#00CCFF\",\"yellow\":\"#00CCFF\",\"blue\":\"#00CCFF\",\"purple\":\"#00CCFF\",\"cyan\":\"#00CCFF\",\"white\":\"#00CCFF\",\"brightBlack\":\"#00CCFF\",\"brightRed\":\"#00CCFF\",\"brightGreen\":\"#00CCFF\",\"brightYellow\":\"#00CCFF\",\"brightBlue\":\"#00CCFF\",\"brightPurple\":\"#00CCFF\",\"brightCyan\":\"#00CCFF\",\"brightWhite\":\"#00CCFF\",\"foreground\":\"#00CCFF\",\"background\":\"#00222B\",\"cursorColor\":\"#00CCFF\"},{\"name\":\"mono-green\",\"black\":\"#034000\",\"red\":\"#0BFF00\",\"green\":\"#0BFF00\",\"yellow\":\"#0BFF00\",\"blue\":\"#0BFF00\",\"purple\":\"#0BFF00\",\"cyan\":\"#0BFF00\",\"white\":\"#0BFF00\",\"brightBlack\":\"#0BFF00\",\"brightRed\":\"#0BFF00\",\"brightGreen\":\"#0BFF00\",\"brightYellow\":\"#0BFF00\",\"brightBlue\":\"#0BFF00\",\"brightPurple\":\"#0BFF00\",\"brightCyan\":\"#0BFF00\",\"brightWhite\":\"#0BFF00\",\"foreground\":\"#0BFF00\",\"background\":\"#022B00\",\"cursorColor\":\"#0BFF00\"},{\"name\":\"Monokai Cmder\",\"cursorColor\":\"#ffffff\",\"selectionBackground\":\"#cccc81\",\"background\":\"#272822\",\"foreground\":\"#cacaca\",\"black\":\"#272822\",\"red\":\"#a70334\",\"green\":\"#74aa04\",\"yellow\":\"#b6b649\",\"blue\":\"#01549e\",\"purple\":\"#89569c\",\"cyan\":\"#1a83a6\",\"white\":\"#cacaca\",\"brightBlack\":\"#7c7c7c\",\"brightRed\":\"#f3044b\",\"brightGreen\":\"#8dd006\",\"brightYellow\":\"#cccc81\",\"brightBlue\":\"#0383f5\",\"brightPurple\":\"#a87db8\",\"brightCyan\":\"#58c2e5\",\"brightWhite\":\"#ffffff\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"vdurante\",\"link\":\"https://github.com/vdurante/windows-terminal-monokai-cmder\"}]}},{\"name\":\"MonokaiDark\",\"black\":\"#75715e\",\"red\":\"#f92672\",\"green\":\"#a6e22e\",\"yellow\":\"#f4bf75\",\"blue\":\"#66d9ef\",\"purple\":\"#ae81ff\",\"cyan\":\"#2AA198\",\"white\":\"#f9f8f5\",\"brightBlack\":\"#272822\",\"brightRed\":\"#f92672\",\"brightGreen\":\"#a6e22e\",\"brightYellow\":\"#f4bf75\",\"brightBlue\":\"#66d9ef\",\"brightPurple\":\"#ae81ff\",\"brightCyan\":\"#2AA198\",\"brightWhite\":\"#f8f8f2\",\"foreground\":\"#f8f8f2\",\"background\":\"#272822\",\"cursorColor\":\"#f8f8f2\"},{\"name\":\"Monokai Octagon\",\"black\":\"#000000\",\"red\":\"#d81e00\",\"green\":\"#5ea702\",\"yellow\":\"#cfae00\",\"blue\":\"#427ab3\",\"purple\":\"#89658e\",\"cyan\":\"#00a7aa\",\"white\":\"#dbded8\",\"brightBlack\":\"#686a66\",\"brightRed\":\"#f54235\",\"brightGreen\":\"#99e343\",\"brightYellow\":\"#fdeb61\",\"brightBlue\":\"#84b0d8\",\"brightPurple\":\"#bc94b7\",\"brightCyan\":\"#37e6e8\",\"brightWhite\":\"#f1f1f0\",\"background\":\"#282a3a\",\"foreground\":\"#eaf2f1\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"MonokaiPro\",\"black\":\"#363537\",\"red\":\"#FF6188\",\"green\":\"#A9DC76\",\"yellow\":\"#FFD866\",\"blue\":\"#FC9867\",\"purple\":\"#AB9DF2\",\"cyan\":\"#78DCE8\",\"white\":\"#FDF9F3\",\"brightBlack\":\"#908E8F\",\"brightRed\":\"#FF6188\",\"brightGreen\":\"#A9DC76\",\"brightYellow\":\"#FFD866\",\"brightBlue\":\"#FC9867\",\"brightPurple\":\"#AB9DF2\",\"brightCyan\":\"#78DCE8\",\"brightWhite\":\"#FDF9F3\",\"foreground\":\"#FDF9F3\",\"background\":\"#363537\",\"cursorColor\":\"#FDF9F3\"},{\"name\":\"MonokaiProRistretto\",\"black\":\"#3E3838\",\"red\":\"#DF7484\",\"green\":\"#BBD87E\",\"yellow\":\"#EDCE73\",\"blue\":\"#DC9373\",\"purple\":\"#A9AAE9\",\"cyan\":\"#A4D7CC\",\"white\":\"#FBF2F3\",\"brightBlack\":\"#70696A\",\"brightRed\":\"#DF7484\",\"brightGreen\":\"#BBD87E\",\"brightYellow\":\"#EDCE73\",\"brightBlue\":\"#DC9373\",\"brightPurple\":\"#A9AAE9\",\"brightCyan\":\"#A4D7CC\",\"brightWhite\":\"#FBF2F3\",\"foreground\":\"#FBF2F3\",\"background\":\"#3E3838\",\"cursorColor\":\"#FBF2F3\"},{\"name\":\"Monokai Remastered\",\"black\":\"#1a1a1a\",\"red\":\"#f4005f\",\"green\":\"#98e024\",\"yellow\":\"#fd971f\",\"blue\":\"#9d65ff\",\"purple\":\"#f4005f\",\"cyan\":\"#58d1eb\",\"white\":\"#c4c5b5\",\"brightBlack\":\"#625e4c\",\"brightRed\":\"#f4005f\",\"brightGreen\":\"#98e024\",\"brightYellow\":\"#e0d561\",\"brightBlue\":\"#9d65ff\",\"brightPurple\":\"#f4005f\",\"brightCyan\":\"#58d1eb\",\"brightWhite\":\"#f6f6ef\",\"background\":\"#0c0c0c\",\"foreground\":\"#d9d9d9\",\"cursorColor\":\"#fc971f\",\"selectionBackground\":\"#343434\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"Monokai Soda\",\"black\":\"#1a1a1a\",\"red\":\"#f4005f\",\"green\":\"#98e024\",\"yellow\":\"#fa8419\",\"blue\":\"#9d65ff\",\"purple\":\"#f4005f\",\"cyan\":\"#58d1eb\",\"white\":\"#c4c5b5\",\"brightBlack\":\"#625e4c\",\"brightRed\":\"#f4005f\",\"brightGreen\":\"#98e024\",\"brightYellow\":\"#e0d561\",\"brightBlue\":\"#9d65ff\",\"brightPurple\":\"#f4005f\",\"brightCyan\":\"#58d1eb\",\"brightWhite\":\"#f6f6ef\",\"background\":\"#1a1a1a\",\"foreground\":\"#c4c5b5\",\"cursorColor\":\"#f6f7ec\",\"selectionBackground\":\"#343434\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"deepsweet\",\"link\":\"https://github.com/deepsweet/Monokai-Soda-iTerm\"}]}},{\"name\":\"Monokai Vivid\",\"black\":\"#121212\",\"red\":\"#fa2934\",\"green\":\"#98e123\",\"yellow\":\"#fff30a\",\"blue\":\"#0443ff\",\"purple\":\"#f800f8\",\"cyan\":\"#01b6ed\",\"white\":\"#ffffff\",\"brightBlack\":\"#838383\",\"brightRed\":\"#f6669d\",\"brightGreen\":\"#b1e05f\",\"brightYellow\":\"#fff26d\",\"brightBlue\":\"#0443ff\",\"brightPurple\":\"#f200f6\",\"brightCyan\":\"#51ceff\",\"brightWhite\":\"#ffffff\",\"background\":\"#121212\",\"foreground\":\"#f9f9f9\",\"cursorColor\":\"#fb0007\",\"selectionBackground\":\"#ffffff\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"vitalymak\",\"link\":\"https://github.com/vitalymak/iTerm2-Color-Schemes\"}]}},{\"name\":\"mono-red\",\"black\":\"#401200\",\"red\":\"#FF3600\",\"green\":\"#FF3600\",\"yellow\":\"#FF3600\",\"blue\":\"#FF3600\",\"purple\":\"#FF3600\",\"cyan\":\"#FF3600\",\"white\":\"#FF3600\",\"brightBlack\":\"#FF3600\",\"brightRed\":\"#FF3600\",\"brightGreen\":\"#FF3600\",\"brightYellow\":\"#FF3600\",\"brightBlue\":\"#FF3600\",\"brightPurple\":\"#FF3600\",\"brightCyan\":\"#FF3600\",\"brightWhite\":\"#FF3600\",\"foreground\":\"#FF3600\",\"background\":\"#2B0C00\",\"cursorColor\":\"#FF3600\"},{\"name\":\"mono-white\",\"black\":\"#3B3B3B\",\"red\":\"#FAFAFA\",\"green\":\"#FAFAFA\",\"yellow\":\"#FAFAFA\",\"blue\":\"#FAFAFA\",\"purple\":\"#FAFAFA\",\"cyan\":\"#FAFAFA\",\"white\":\"#FAFAFA\",\"brightBlack\":\"#FAFAFA\",\"brightRed\":\"#FAFAFA\",\"brightGreen\":\"#FAFAFA\",\"brightYellow\":\"#FAFAFA\",\"brightBlue\":\"#FAFAFA\",\"brightPurple\":\"#FAFAFA\",\"brightCyan\":\"#FAFAFA\",\"brightWhite\":\"#FAFAFA\",\"foreground\":\"#FAFAFA\",\"background\":\"#262626\",\"cursorColor\":\"#FAFAFA\"},{\"name\":\"mono-yellow\",\"black\":\"#403500\",\"red\":\"#FFD300\",\"green\":\"#FFD300\",\"yellow\":\"#FFD300\",\"blue\":\"#FFD300\",\"purple\":\"#FFD300\",\"cyan\":\"#FFD300\",\"white\":\"#FFD300\",\"brightBlack\":\"#FFD300\",\"brightRed\":\"#FFD300\",\"brightGreen\":\"#FFD300\",\"brightYellow\":\"#FFD300\",\"brightBlue\":\"#FFD300\",\"brightPurple\":\"#FFD300\",\"brightCyan\":\"#FFD300\",\"brightWhite\":\"#FFD300\",\"foreground\":\"#FFD300\",\"background\":\"#2B2400\",\"cursorColor\":\"#FFD300\"},{\"name\":\"Moonlight II\",\"black\":\"#191a2a\",\"red\":\"#ff757f\",\"green\":\"#c3e88d\",\"yellow\":\"#ffc777\",\"blue\":\"#82aaff\",\"purple\":\"#c099ff\",\"cyan\":\"#86e1fc\",\"white\":\"#c8d3f5\",\"brightBlack\":\"#828bb8\",\"brightRed\":\"#ff757f\",\"brightGreen\":\"#c3e88d\",\"brightYellow\":\"#ffc777\",\"brightBlue\":\"#82aaff\",\"brightPurple\":\"#c099ff\",\"brightCyan\":\"#86e1fc\",\"brightWhite\":\"#c8d3f5\",\"background\":\"#222436\",\"foreground\":\"#c8d3f5\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"atomiks\",\"link\":\"https://github.com/atomiks\"}]}},{\"name\":\"Morada\",\"black\":\"#040404\",\"red\":\"#0f49c4\",\"green\":\"#48b117\",\"yellow\":\"#e87324\",\"blue\":\"#bc0116\",\"purple\":\"#665b93\",\"cyan\":\"#70a699\",\"white\":\"#f5dcbe\",\"brightBlack\":\"#4f7cbf\",\"brightRed\":\"#1c96c7\",\"brightGreen\":\"#3bff6f\",\"brightYellow\":\"#efc31c\",\"brightBlue\":\"#fb605b\",\"brightPurple\":\"#975b5a\",\"brightCyan\":\"#1eff8e\",\"brightWhite\":\"#f6f5fb\",\"foreground\":\"#ffffff\",\"background\":\"#211f46\",\"cursorColor\":\"#ffffff\"},{\"name\":\"N0tch2k\",\"black\":\"#383838\",\"red\":\"#a95551\",\"green\":\"#666666\",\"yellow\":\"#a98051\",\"blue\":\"#657d3e\",\"purple\":\"#767676\",\"cyan\":\"#c9c9c9\",\"white\":\"#d0b8a3\",\"brightBlack\":\"#474747\",\"brightRed\":\"#a97775\",\"brightGreen\":\"#8c8c8c\",\"brightYellow\":\"#a99175\",\"brightBlue\":\"#98bd5e\",\"brightPurple\":\"#a3a3a3\",\"brightCyan\":\"#dcdcdc\",\"brightWhite\":\"#d8c8bb\",\"background\":\"#222222\",\"foreground\":\"#a0a0a0\",\"cursorColor\":\"#aa9175\",\"selectionBackground\":\"#4d4d4d\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"baskerville\",\"link\":\"https://github.com/baskerville/iTerm-2-Color-Themes\"}]}},{\"name\":\"neon-night\",\"black\":\"#20242d\",\"red\":\"#FF8E8E\",\"green\":\"#7EFDD0\",\"yellow\":\"#FCAD3F\",\"blue\":\"#69B4F9\",\"purple\":\"#DD92F6\",\"cyan\":\"#8CE8ff\",\"white\":\"#C9CCCD\",\"brightBlack\":\"#20242d\",\"brightRed\":\"#FF8E8E\",\"brightGreen\":\"#7EFDD0\",\"brightYellow\":\"#FCAD3F\",\"brightBlue\":\"#69B4F9\",\"brightPurple\":\"#DD92F6\",\"brightCyan\":\"#8CE8ff\",\"brightWhite\":\"#C9CCCD\",\"foreground\":\"#C7C8FF\",\"background\":\"#20242d\",\"cursorColor\":\"#C7C8FF\"},{\"name\":\"Neopolitan\",\"black\":\"#000000\",\"red\":\"#800000\",\"green\":\"#61ce3c\",\"yellow\":\"#fbde2d\",\"blue\":\"#253b76\",\"purple\":\"#ff0080\",\"cyan\":\"#8da6ce\",\"white\":\"#f8f8f8\",\"brightBlack\":\"#000000\",\"brightRed\":\"#800000\",\"brightGreen\":\"#61ce3c\",\"brightYellow\":\"#fbde2d\",\"brightBlue\":\"#253b76\",\"brightPurple\":\"#ff0080\",\"brightCyan\":\"#8da6ce\",\"brightWhite\":\"#f8f8f8\",\"background\":\"#271f19\",\"foreground\":\"#ffffff\",\"cursorColor\":\"#ffffff\",\"selectionBackground\":\"#253b76\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"daytonn\",\"link\":\"https://github.com/daytonn/iTerm2-Color-Schemes\"}]}},{\"name\":\"Nep\",\"black\":\"#000000\",\"red\":\"#dd6f00\",\"green\":\"#00dd6f\",\"yellow\":\"#6fdd00\",\"blue\":\"#6f00dd\",\"purple\":\"#dd006f\",\"cyan\":\"#006fdd\",\"white\":\"#f2f2f2\",\"brightBlack\":\"#7d7d7d\",\"brightRed\":\"#ffb974\",\"brightGreen\":\"#74ffb9\",\"brightYellow\":\"#b9ff74\",\"brightBlue\":\"#b974ff\",\"brightPurple\":\"#ff74b9\",\"brightCyan\":\"#74b9ff\",\"brightWhite\":\"#ffffff\",\"foreground\":\"#23476a\",\"background\":\"#758480\",\"cursorColor\":\"#23476a\"},{\"name\":\"Neutron\",\"black\":\"#23252b\",\"red\":\"#b54036\",\"green\":\"#5ab977\",\"yellow\":\"#deb566\",\"blue\":\"#6a7c93\",\"purple\":\"#a4799d\",\"cyan\":\"#3f94a8\",\"white\":\"#e6e8ef\",\"brightBlack\":\"#23252b\",\"brightRed\":\"#b54036\",\"brightGreen\":\"#5ab977\",\"brightYellow\":\"#deb566\",\"brightBlue\":\"#6a7c93\",\"brightPurple\":\"#a4799d\",\"brightCyan\":\"#3f94a8\",\"brightWhite\":\"#ebedf2\",\"background\":\"#1c1e22\",\"foreground\":\"#e6e8ef\",\"cursorColor\":\"#f6f7ec\",\"selectionBackground\":\"#2f363e\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Ch4s3\",\"link\":\"https://github.com/Ch4s3/iTerm2-Neutron\"}]}},{\"name\":\"NightLion v1\",\"black\":\"#4c4c4c\",\"red\":\"#bb0000\",\"green\":\"#5fde8f\",\"yellow\":\"#f3f167\",\"blue\":\"#276bd8\",\"purple\":\"#bb00bb\",\"cyan\":\"#00dadf\",\"white\":\"#bbbbbb\",\"brightBlack\":\"#555555\",\"brightRed\":\"#ff5555\",\"brightGreen\":\"#55ff55\",\"brightYellow\":\"#ffff55\",\"brightBlue\":\"#5555ff\",\"brightPurple\":\"#ff55ff\",\"brightCyan\":\"#55ffff\",\"brightWhite\":\"#ffffff\",\"background\":\"#000000\",\"foreground\":\"#bbbbbb\",\"cursorColor\":\"#bbbbbb\",\"selectionBackground\":\"#b5d5ff\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Curvve Media\",\"link\":\"http://www.curvve.com/blog/category/themes/\"}]}},{\"name\":\"NightLion v2\",\"black\":\"#4c4c4c\",\"red\":\"#bb0000\",\"green\":\"#04f623\",\"yellow\":\"#f3f167\",\"blue\":\"#64d0f0\",\"purple\":\"#ce6fdb\",\"cyan\":\"#00dadf\",\"white\":\"#bbbbbb\",\"brightBlack\":\"#555555\",\"brightRed\":\"#ff5555\",\"brightGreen\":\"#7df71d\",\"brightYellow\":\"#ffff55\",\"brightBlue\":\"#62cbe8\",\"brightPurple\":\"#ff9bf5\",\"brightCyan\":\"#00ccd8\",\"brightWhite\":\"#ffffff\",\"background\":\"#171717\",\"foreground\":\"#bbbbbb\",\"cursorColor\":\"#bbbbbb\",\"selectionBackground\":\"#b5d5ff\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Curvve Media\",\"link\":\"http://www.curvve.com/blog/category/themes/\"}]}},{\"name\":\"NightOwl\",\"black\":\"#011627\",\"red\":\"#EF5350\",\"green\":\"#22da6e\",\"yellow\":\"#addb67\",\"blue\":\"#82aaff\",\"purple\":\"#c792ea\",\"cyan\":\"#21c7a8\",\"white\":\"#ffffff\",\"brightBlack\":\"#575656\",\"brightRed\":\"#ef5350\",\"brightGreen\":\"#22da6e\",\"brightYellow\":\"#ffeb95\",\"brightBlue\":\"#82aaff\",\"brightPurple\":\"#c792ea\",\"brightCyan\":\"#7fdbca\",\"brightWhite\":\"#ffffff\",\"foreground\":\"#d6deeb\",\"background\":\"#011627\",\"cursorColor\":\"#d6deeb\"},{\"name\":\"Night Owlish Light\",\"black\":\"#011627\",\"red\":\"#d3423e\",\"green\":\"#2aa298\",\"yellow\":\"#daaa01\",\"blue\":\"#4876d6\",\"purple\":\"#403f53\",\"cyan\":\"#08916a\",\"white\":\"#7a8181\",\"brightBlack\":\"#7a8181\",\"brightRed\":\"#f76e6e\",\"brightGreen\":\"#49d0c5\",\"brightYellow\":\"#dac26b\",\"brightBlue\":\"#5ca7e4\",\"brightPurple\":\"#697098\",\"brightCyan\":\"#00c990\",\"brightWhite\":\"#989fb1\",\"background\":\"#ffffff\",\"foreground\":\"#403f53\",\"cursorColor\":\"#403f53\",\"selectionBackground\":\"#f2f2f2\",\"meta\":{\"isDark\":false,\"credits\":[{\"name\":\"praveenpuglia\",\"link\":\"https://github.com/praveenpuglia\"},{\"name\":\"sdras\",\"link\":\"https://github.com/sdras\"}]}},{\"name\":\"nighty\",\"black\":\"#373D48\",\"red\":\"#9B3E46\",\"green\":\"#095B32\",\"yellow\":\"#808020\",\"blue\":\"#1D3E6F\",\"purple\":\"#823065\",\"cyan\":\"#3A7458\",\"white\":\"#828282\",\"brightBlack\":\"#5C6370\",\"brightRed\":\"#D0555F\",\"brightGreen\":\"#119955\",\"brightYellow\":\"#DFE048\",\"brightBlue\":\"#4674B8\",\"brightPurple\":\"#ED86C9\",\"brightCyan\":\"#70D2A4\",\"brightWhite\":\"#DFDFDF\",\"foreground\":\"#DFDFDF\",\"background\":\"#2F2F2F\",\"cursorColor\":\"#DFDFDF\"},{\"name\":\"Nocturnal Winter\",\"black\":\"#4d4d4d\",\"red\":\"#f12d52\",\"green\":\"#09cd7e\",\"yellow\":\"#f5f17a\",\"blue\":\"#3182e0\",\"purple\":\"#ff2b6d\",\"cyan\":\"#09c87a\",\"white\":\"#fcfcfc\",\"brightBlack\":\"#808080\",\"brightRed\":\"#f16d86\",\"brightGreen\":\"#0ae78d\",\"brightYellow\":\"#fffc67\",\"brightBlue\":\"#6096ff\",\"brightPurple\":\"#ff78a2\",\"brightCyan\":\"#0ae78d\",\"brightWhite\":\"#ffffff\",\"background\":\"#0d0d17\",\"foreground\":\"#e6e5e5\",\"cursorColor\":\"#e6e5e5\",\"selectionBackground\":\"#adbdd0\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Shriram Balaji\",\"link\":\"https://github.com/Shriram-Balaji\"}]}},{\"name\":\"nord\",\"black\":\"#3b4252\",\"red\":\"#bf616a\",\"green\":\"#a3be8c\",\"yellow\":\"#ebcb8b\",\"blue\":\"#81a1c1\",\"purple\":\"#b48ead\",\"cyan\":\"#88c0d0\",\"white\":\"#e5e9f0\",\"brightBlack\":\"#4c566a\",\"brightRed\":\"#bf616a\",\"brightGreen\":\"#a3be8c\",\"brightYellow\":\"#ebcb8b\",\"brightBlue\":\"#81a1c1\",\"brightPurple\":\"#b48ead\",\"brightCyan\":\"#8fbcbb\",\"brightWhite\":\"#eceff4\",\"background\":\"#2e3440\",\"foreground\":\"#d8dee9\",\"cursorColor\":\"#eceff4\",\"selectionBackground\":\"#eceff4\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Teraskull\",\"link\":\"https://github.com/Teraskull\"}]}},{\"name\":\"NordLight\",\"black\":\"#003B4E\",\"red\":\"#E64569\",\"green\":\"#069F5F\",\"yellow\":\"#DAB752\",\"blue\":\"#439ECF\",\"purple\":\"#D961DC\",\"cyan\":\"#00B1BE\",\"white\":\"#B3B3B3\",\"brightBlack\":\"#3E89A1\",\"brightRed\":\"#E4859A\",\"brightGreen\":\"#A2CCA1\",\"brightYellow\":\"#E1E387\",\"brightBlue\":\"#6FBBE2\",\"brightPurple\":\"#E586E7\",\"brightCyan\":\"#96DCDA\",\"brightWhite\":\"#DEDEDE\",\"foreground\":\"#004f7c\",\"background\":\"#ebeaf2\",\"cursorColor\":\"#439ECF\"},{\"name\":\"Novel\",\"black\":\"#000000\",\"red\":\"#cc0000\",\"green\":\"#009600\",\"yellow\":\"#d06b00\",\"blue\":\"#0000cc\",\"purple\":\"#cc00cc\",\"cyan\":\"#0087cc\",\"white\":\"#cccccc\",\"brightBlack\":\"#808080\",\"brightRed\":\"#cc0000\",\"brightGreen\":\"#009600\",\"brightYellow\":\"#d06b00\",\"brightBlue\":\"#0000cc\",\"brightPurple\":\"#cc00cc\",\"brightCyan\":\"#0087cc\",\"brightWhite\":\"#ffffff\",\"background\":\"#dfdbc3\",\"foreground\":\"#3b2322\",\"cursorColor\":\"#73635a\",\"selectionBackground\":\"#a4a390\",\"meta\":{\"isDark\":false,\"credits\":null}},{\"name\":\"Obsidian\",\"black\":\"#000000\",\"red\":\"#a60001\",\"green\":\"#00bb00\",\"yellow\":\"#fecd22\",\"blue\":\"#3a9bdb\",\"purple\":\"#bb00bb\",\"cyan\":\"#00bbbb\",\"white\":\"#bbbbbb\",\"brightBlack\":\"#555555\",\"brightRed\":\"#ff0003\",\"brightGreen\":\"#93c863\",\"brightYellow\":\"#fef874\",\"brightBlue\":\"#a1d7ff\",\"brightPurple\":\"#ff55ff\",\"brightCyan\":\"#55ffff\",\"brightWhite\":\"#ffffff\",\"background\":\"#283033\",\"foreground\":\"#cdcdcd\",\"cursorColor\":\"#c0cad0\",\"selectionBackground\":\"#3e4c4f\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"Ocean\",\"black\":\"#000000\",\"red\":\"#990000\",\"green\":\"#00a600\",\"yellow\":\"#999900\",\"blue\":\"#0000b2\",\"purple\":\"#b200b2\",\"cyan\":\"#00a6b2\",\"white\":\"#bfbfbf\",\"brightBlack\":\"#666666\",\"brightRed\":\"#e50000\",\"brightGreen\":\"#00d900\",\"brightYellow\":\"#e5e500\",\"brightBlue\":\"#0000ff\",\"brightPurple\":\"#e500e5\",\"brightCyan\":\"#00e5e5\",\"brightWhite\":\"#e5e5e5\",\"background\":\"#224fbc\",\"foreground\":\"#ffffff\",\"cursorColor\":\"#7f7f7f\",\"selectionBackground\":\"#216dff\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"OceanDark\",\"black\":\"#4F4F4F\",\"red\":\"#AF4B57\",\"green\":\"#AFD383\",\"yellow\":\"#E5C079\",\"blue\":\"#7D90A4\",\"purple\":\"#A4799D\",\"cyan\":\"#85A6A5\",\"white\":\"#EEEDEE\",\"brightBlack\":\"#7B7B7B\",\"brightRed\":\"#AF4B57\",\"brightGreen\":\"#CEFFAB\",\"brightYellow\":\"#FFFECC\",\"brightBlue\":\"#B5DCFE\",\"brightPurple\":\"#FB9BFE\",\"brightCyan\":\"#DFDFFD\",\"brightWhite\":\"#FEFFFE\",\"foreground\":\"#979CAC\",\"background\":\"#1C1F27\",\"cursorColor\":\"#979CAC\"},{\"name\":\"OceanicMaterial\",\"black\":\"#000000\",\"red\":\"#ee2b2a\",\"green\":\"#40a33f\",\"yellow\":\"#ffea2e\",\"blue\":\"#1e80f0\",\"purple\":\"#8800a0\",\"cyan\":\"#16afca\",\"white\":\"#a4a4a4\",\"brightBlack\":\"#777777\",\"brightRed\":\"#dc5c60\",\"brightGreen\":\"#70be71\",\"brightYellow\":\"#fff163\",\"brightBlue\":\"#54a4f3\",\"brightPurple\":\"#aa4dbc\",\"brightCyan\":\"#42c7da\",\"brightWhite\":\"#ffffff\",\"background\":\"#1c262b\",\"foreground\":\"#c2c8d7\",\"cursorColor\":\"#b3b8c3\",\"selectionBackground\":\"#6dc2b8\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"rahulpatel\",\"link\":\"https://github.com/rahulpatel\"}]}},{\"name\":\"OceanicNext\",\"black\":\"#121C21\",\"red\":\"#E44754\",\"green\":\"#89BD82\",\"yellow\":\"#F7BD51\",\"blue\":\"#5486C0\",\"purple\":\"#B77EB8\",\"cyan\":\"#50A5A4\",\"white\":\"#FFFFFF\",\"brightBlack\":\"#52606B\",\"brightRed\":\"#E44754\",\"brightGreen\":\"#89BD82\",\"brightYellow\":\"#F7BD51\",\"brightBlue\":\"#5486C0\",\"brightPurple\":\"#B77EB8\",\"brightCyan\":\"#50A5A4\",\"brightWhite\":\"#FFFFFF\",\"foreground\":\"#b3b8c3\",\"background\":\"#121b21\",\"cursorColor\":\"#b3b8c3\"},{\"name\":\"Ollie\",\"black\":\"#000000\",\"red\":\"#ac2e31\",\"green\":\"#31ac61\",\"yellow\":\"#ac4300\",\"blue\":\"#2d57ac\",\"purple\":\"#b08528\",\"cyan\":\"#1fa6ac\",\"white\":\"#8a8eac\",\"brightBlack\":\"#5b3725\",\"brightRed\":\"#ff3d48\",\"brightGreen\":\"#3bff99\",\"brightYellow\":\"#ff5e1e\",\"brightBlue\":\"#4488ff\",\"brightPurple\":\"#ffc21d\",\"brightCyan\":\"#1ffaff\",\"brightWhite\":\"#5b6ea7\",\"background\":\"#222125\",\"foreground\":\"#8a8dae\",\"cursorColor\":\"#5b6ea7\",\"selectionBackground\":\"#1e3a66\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"zdj\",\"link\":\"https://github.com/zdj/themes/tree/master/iterm2\"}]}},{\"name\":\"Omni\",\"black\":\"#191622\",\"red\":\"#E96379\",\"green\":\"#67e480\",\"yellow\":\"#E89E64\",\"blue\":\"#78D1E1\",\"purple\":\"#988BC7\",\"cyan\":\"#FF79C6\",\"white\":\"#ABB2BF\",\"brightBlack\":\"#000000\",\"brightRed\":\"#E96379\",\"brightGreen\":\"#67e480\",\"brightYellow\":\"#E89E64\",\"brightBlue\":\"#78D1E1\",\"brightPurple\":\"#988BC7\",\"brightCyan\":\"#FF79C6\",\"brightWhite\":\"#ffffff\",\"foreground\":\"#ABB2BF\",\"background\":\"#191622\",\"cursorColor\":\"#ABB2BF\"},{\"name\":\"OneDark\",\"black\":\"#1e2127\",\"red\":\"#e06c75\",\"green\":\"#98c379\",\"yellow\":\"#d19a66\",\"blue\":\"#61afef\",\"purple\":\"#c678dd\",\"cyan\":\"#56b6c2\",\"white\":\"#abb2bf\",\"brightBlack\":\"#5c6370\",\"brightRed\":\"#e06c75\",\"brightGreen\":\"#98c379\",\"brightYellow\":\"#d19a66\",\"brightBlue\":\"#61afef\",\"brightPurple\":\"#c678dd\",\"brightCyan\":\"#56b6c2\",\"brightWhite\":\"#ffffff\",\"background\":\"#1e2127\",\"foreground\":\"#abb2bf\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"azrikahar\",\"link\":\"https://github.com/azrikahar\"}]}},{\"name\":\"OneHalfBlack\",\"black\":\"#282c34\",\"red\":\"#e06c75\",\"green\":\"#98c379\",\"yellow\":\"#e5c07b\",\"blue\":\"#61afef\",\"purple\":\"#c678dd\",\"cyan\":\"#56b6c2\",\"white\":\"#dcdfe4\",\"brightBlack\":\"#282c34\",\"brightRed\":\"#e06c75\",\"brightGreen\":\"#98c379\",\"brightYellow\":\"#e5c07b\",\"brightBlue\":\"#61afef\",\"brightPurple\":\"#c678dd\",\"brightCyan\":\"#56b6c2\",\"brightWhite\":\"#dcdfe4\",\"foreground\":\"#dcdfe4\",\"background\":\"#000000\",\"cursorColor\":\"#dcdfe4\"},{\"name\":\"OneHalfDark\",\"black\":\"#282c34\",\"red\":\"#e06c75\",\"green\":\"#98c379\",\"yellow\":\"#e5c07b\",\"blue\":\"#61afef\",\"purple\":\"#c678dd\",\"cyan\":\"#56b6c2\",\"white\":\"#dcdfe4\",\"brightBlack\":\"#282c34\",\"brightRed\":\"#e06c75\",\"brightGreen\":\"#98c379\",\"brightYellow\":\"#e5c07b\",\"brightBlue\":\"#61afef\",\"brightPurple\":\"#c678dd\",\"brightCyan\":\"#56b6c2\",\"brightWhite\":\"#dcdfe4\",\"background\":\"#282c34\",\"foreground\":\"#dcdfe4\",\"cursorColor\":\"#a3b3cc\",\"selectionBackground\":\"#474e5d\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"sonph\",\"link\":\"https://github.com/sonph\"}]}},{\"name\":\"OneHalfLight\",\"black\":\"#383a42\",\"red\":\"#e45649\",\"green\":\"#50a14f\",\"yellow\":\"#c18401\",\"blue\":\"#0184bc\",\"purple\":\"#a626a4\",\"cyan\":\"#0997b3\",\"white\":\"#fafafa\",\"brightBlack\":\"#4f525e\",\"brightRed\":\"#e06c75\",\"brightGreen\":\"#98c379\",\"brightYellow\":\"#e5c07b\",\"brightBlue\":\"#61afef\",\"brightPurple\":\"#c678dd\",\"brightCyan\":\"#56b6c2\",\"brightWhite\":\"#ffffff\",\"background\":\"#fafafa\",\"foreground\":\"#383a42\",\"cursorColor\":\"#bfceff\",\"selectionBackground\":\"#bfceff\",\"meta\":{\"isDark\":false,\"credits\":[{\"name\":\"sonph\",\"link\":\"https://github.com/sonph\"}]}},{\"name\":\"OneLight\",\"black\":\"#000000\",\"red\":\"#DA3E39\",\"green\":\"#41933E\",\"yellow\":\"#855504\",\"blue\":\"#315EEE\",\"purple\":\"#930092\",\"cyan\":\"#0E6FAD\",\"white\":\"#8E8F96\",\"brightBlack\":\"#2A2B32\",\"brightRed\":\"#DA3E39\",\"brightGreen\":\"#41933E\",\"brightYellow\":\"#855504\",\"brightBlue\":\"#315EEE\",\"brightPurple\":\"#930092\",\"brightCyan\":\"#0E6FAD\",\"brightWhite\":\"#FFFEFE\",\"foreground\":\"#2A2B32\",\"background\":\"#F8F8F8\",\"cursorColor\":\"#2A2B32\"},{\"name\":\"OneStar\",\"black\":\"#000000\",\"red\":\"#d13b3b\",\"green\":\"#0dbc79\",\"yellow\":\"#dfdf44\",\"blue\":\"#2472c8\",\"purple\":\"#c42cc4\",\"cyan\":\"#33a0bb\",\"white\":\"#f1f1f1\",\"brightBlack\":\"#666666\",\"brightRed\":\"#fa4b4b\",\"brightGreen\":\"#23d18b\",\"brightYellow\":\"#fcfc5c\",\"brightBlue\":\"#3b8eea\",\"brightPurple\":\"#d861d8\",\"brightCyan\":\"#29b8db\",\"brightWhite\":\"#fafafa\",\"background\":\"#0e0e0e\",\"foreground\":\"#e4e4e4\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"jos3s\",\"link\":\"https://github.com/jos3s\"}]}},{\"name\":\"Operator Mono Dark\",\"black\":\"#5a5a5a\",\"red\":\"#ca372d\",\"green\":\"#4d7b3a\",\"yellow\":\"#d4d697\",\"blue\":\"#4387cf\",\"purple\":\"#b86cb4\",\"cyan\":\"#72d5c6\",\"white\":\"#ced4cd\",\"brightBlack\":\"#9a9b99\",\"brightRed\":\"#c37d62\",\"brightGreen\":\"#83d0a2\",\"brightYellow\":\"#fdfdc5\",\"brightBlue\":\"#89d3f6\",\"brightPurple\":\"#ff2c7a\",\"brightCyan\":\"#82eada\",\"brightWhite\":\"#fdfdf6\",\"background\":\"#191919\",\"foreground\":\"#c3cac2\",\"cursorColor\":\"#fcdc08\",\"selectionBackground\":\"#19273b\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"vharadkou\",\"link\":\"https://github.com/vharadkou/OperatorMonoDarkTheme\"},{\"name\":\"dreamyguy\",\"link\":\"https://github.com/dreamyguy/iterm-theme-operator-mono-dark\"}]}},{\"name\":\"Overnight Slumber\",\"black\":\"#0a1222\",\"red\":\"#ffa7c4\",\"green\":\"#85cc95\",\"yellow\":\"#ffcb8b\",\"blue\":\"#8dabe1\",\"purple\":\"#c792eb\",\"cyan\":\"#78ccf0\",\"white\":\"#ffffff\",\"brightBlack\":\"#575656\",\"brightRed\":\"#ffa7c4\",\"brightGreen\":\"#85cc95\",\"brightYellow\":\"#ffcb8b\",\"brightBlue\":\"#8dabe1\",\"brightPurple\":\"#c792eb\",\"brightCyan\":\"#ffa7c4\",\"brightWhite\":\"#ffffff\",\"background\":\"#0e1729\",\"foreground\":\"#ced2d6\",\"cursorColor\":\"#ffa7c4\",\"selectionBackground\":\"#1f2b41\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Cristian Velasquez Ramos\",\"link\":\"https://github.com/cevr/overnight\"},{\"name\":\"Gomah\",\"link\":\"https://github.com/Gomah/overnight-slumber-iterm\"}]}},{\"name\":\"palenight\",\"black\":\"#292D3E\",\"red\":\"#F07178\",\"green\":\"#C3E88D\",\"yellow\":\"#FFCB6B\",\"blue\":\"#82AAFF\",\"purple\":\"#C792EA\",\"cyan\":\"#60ADEC\",\"white\":\"#ABB2BF\",\"brightBlack\":\"#959DCB\",\"brightRed\":\"#F07178\",\"brightGreen\":\"#C3E88D\",\"brightYellow\":\"#FF5572\",\"brightBlue\":\"#82AAFF\",\"brightPurple\":\"#FFCB6B\",\"brightCyan\":\"#676E95\",\"brightWhite\":\"#FFFEFE\",\"foreground\":\"#BFC7D5\",\"background\":\"#292D3E\",\"cursorColor\":\"#BFC7D5\"},{\"name\":\"PaleNightHC\",\"black\":\"#000000\",\"red\":\"#f07178\",\"green\":\"#c3e88d\",\"yellow\":\"#ffcb6b\",\"blue\":\"#82aaff\",\"purple\":\"#c792ea\",\"cyan\":\"#89ddff\",\"white\":\"#ffffff\",\"brightBlack\":\"#666666\",\"brightRed\":\"#f6a9ae\",\"brightGreen\":\"#dbf1ba\",\"brightYellow\":\"#ffdfa6\",\"brightBlue\":\"#b4ccff\",\"brightPurple\":\"#ddbdf2\",\"brightCyan\":\"#b8eaff\",\"brightWhite\":\"#999999\",\"background\":\"#3e4251\",\"foreground\":\"#cccccc\",\"cursorColor\":\"#ffcb6b\",\"selectionBackground\":\"#717cb4\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Mattia Astorino\",\"link\":\"https://github.com/equinusocio\"},{\"name\":\"Kasper\",\"link\":\"https://github.com/Kasper-Liu\"}]}},{\"name\":\"Pali\",\"black\":\"#0a0a0a\",\"red\":\"#ab8f74\",\"green\":\"#74ab8f\",\"yellow\":\"#8fab74\",\"blue\":\"#8f74ab\",\"purple\":\"#ab748f\",\"cyan\":\"#748fab\",\"white\":\"#F2F2F2\",\"brightBlack\":\"#5D5D5D\",\"brightRed\":\"#FF1D62\",\"brightGreen\":\"#9cc3af\",\"brightYellow\":\"#FFD00A\",\"brightBlue\":\"#af9cc3\",\"brightPurple\":\"#FF1D62\",\"brightCyan\":\"#4BB8FD\",\"brightWhite\":\"#A020F0\",\"foreground\":\"#d9e6f2\",\"background\":\"#232E37\",\"cursorColor\":\"#d9e6f2\"},{\"name\":\"Panda\",\"black\":\"#1F1F20\",\"red\":\"#FB055A\",\"green\":\"#26FFD4\",\"yellow\":\"#FDAA5A\",\"blue\":\"#5C9FFF\",\"purple\":\"#FC59A6\",\"cyan\":\"#26FFD4\",\"white\":\"#F0F0F0\",\"brightBlack\":\"#5C6370\",\"brightRed\":\"#FB055A\",\"brightGreen\":\"#26FFD4\",\"brightYellow\":\"#FEBE7E\",\"brightBlue\":\"#55ADFF\",\"brightPurple\":\"#FD95D0\",\"brightCyan\":\"#26FFD4\",\"brightWhite\":\"#F0F0F0\",\"foreground\":\"#F0F0F0\",\"background\":\"#1D1E20\",\"cursorColor\":\"#F0F0F0\"},{\"name\":\"Pandora\",\"black\":\"#000000\",\"red\":\"#ff4242\",\"green\":\"#74af68\",\"yellow\":\"#ffad29\",\"blue\":\"#338f86\",\"purple\":\"#9414e6\",\"cyan\":\"#23d7d7\",\"white\":\"#e2e2e2\",\"brightBlack\":\"#3f5648\",\"brightRed\":\"#ff3242\",\"brightGreen\":\"#74cd68\",\"brightYellow\":\"#ffb929\",\"brightBlue\":\"#23d7d7\",\"brightPurple\":\"#ff37ff\",\"brightCyan\":\"#00ede1\",\"brightWhite\":\"#ffffff\",\"background\":\"#141e43\",\"foreground\":\"#e1e1e1\",\"cursorColor\":\"#43d58e\",\"selectionBackground\":\"#2d37ff\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"milosmatic\",\"link\":\"https://github.com/milosmatic/Pandora-iterm\"}]}},{\"name\":\"PaperColorDark\",\"black\":\"#1C1C1C\",\"red\":\"#AF005F\",\"green\":\"#5FAF00\",\"yellow\":\"#D7AF5F\",\"blue\":\"#5FAFD7\",\"purple\":\"#808080\",\"cyan\":\"#D7875F\",\"white\":\"#D0D0D0\",\"brightBlack\":\"#585858\",\"brightRed\":\"#5FAF5F\",\"brightGreen\":\"#AFD700\",\"brightYellow\":\"#AF87D7\",\"brightBlue\":\"#FFAF00\",\"brightPurple\":\"#FF5FAF\",\"brightCyan\":\"#00AFAF\",\"brightWhite\":\"#5F8787\",\"foreground\":\"#D0D0D0\",\"background\":\"#1C1C1C\",\"cursorColor\":\"#D0D0D0\"},{\"name\":\"PaperColorLight\",\"black\":\"#EEEEEE\",\"red\":\"#AF0000\",\"green\":\"#008700\",\"yellow\":\"#5F8700\",\"blue\":\"#0087AF\",\"purple\":\"#878787\",\"cyan\":\"#005F87\",\"white\":\"#444444\",\"brightBlack\":\"#BCBCBC\",\"brightRed\":\"#D70000\",\"brightGreen\":\"#D70087\",\"brightYellow\":\"#8700AF\",\"brightBlue\":\"#D75F00\",\"brightPurple\":\"#D75F00\",\"brightCyan\":\"#005FAF\",\"brightWhite\":\"#005F87\",\"foreground\":\"#444444\",\"background\":\"#EEEEEE\",\"cursorColor\":\"#444444\"},{\"name\":\"Paraiso Dark\",\"black\":\"#2f1e2e\",\"red\":\"#ef6155\",\"green\":\"#48b685\",\"yellow\":\"#fec418\",\"blue\":\"#06b6ef\",\"purple\":\"#815ba4\",\"cyan\":\"#5bc4bf\",\"white\":\"#a39e9b\",\"brightBlack\":\"#776e71\",\"brightRed\":\"#ef6155\",\"brightGreen\":\"#48b685\",\"brightYellow\":\"#fec418\",\"brightBlue\":\"#06b6ef\",\"brightPurple\":\"#815ba4\",\"brightCyan\":\"#5bc4bf\",\"brightWhite\":\"#e7e9db\",\"background\":\"#2f1e2e\",\"foreground\":\"#a39e9b\",\"cursorColor\":\"#a39e9b\",\"selectionBackground\":\"#4f424c\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"idleberg\",\"link\":\"https://github.com/idleberg\"}]}},{\"name\":\"Parasio Dark\",\"black\":\"#2f1e2e\",\"red\":\"#ef6155\",\"green\":\"#48b685\",\"yellow\":\"#fec418\",\"blue\":\"#06b6ef\",\"purple\":\"#815ba4\",\"cyan\":\"#5bc4bf\",\"white\":\"#a39e9b\",\"brightBlack\":\"#776e71\",\"brightRed\":\"#ef6155\",\"brightGreen\":\"#48b685\",\"brightYellow\":\"#fec418\",\"brightBlue\":\"#06b6ef\",\"brightPurple\":\"#815ba4\",\"brightCyan\":\"#5bc4bf\",\"brightWhite\":\"#e7e9db\",\"background\":\"#2f1e2e\",\"foreground\":\"#a39e9b\",\"cursorColor\":\"#a39e9b\",\"selectionBackground\":\"#4f424c\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"PaulMillr\",\"black\":\"#2a2a2a\",\"red\":\"#ff0000\",\"green\":\"#79ff0f\",\"yellow\":\"#e7bf00\",\"blue\":\"#396bd7\",\"purple\":\"#b449be\",\"cyan\":\"#66ccff\",\"white\":\"#bbbbbb\",\"brightBlack\":\"#666666\",\"brightRed\":\"#ff0080\",\"brightGreen\":\"#66ff66\",\"brightYellow\":\"#f3d64e\",\"brightBlue\":\"#709aed\",\"brightPurple\":\"#db67e6\",\"brightCyan\":\"#7adff2\",\"brightWhite\":\"#ffffff\",\"background\":\"#000000\",\"foreground\":\"#f2f2f2\",\"cursorColor\":\"#4d4d4d\",\"selectionBackground\":\"#414141\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"paulmillr\",\"link\":\"https://github.com/paulmillr/dotfiles/tree/master/terminal\"}]}},{\"name\":\"PencilDark\",\"black\":\"#212121\",\"red\":\"#c30771\",\"green\":\"#10a778\",\"yellow\":\"#a89c14\",\"blue\":\"#008ec4\",\"purple\":\"#523c79\",\"cyan\":\"#20a5ba\",\"white\":\"#d9d9d9\",\"brightBlack\":\"#424242\",\"brightRed\":\"#fb007a\",\"brightGreen\":\"#5fd7af\",\"brightYellow\":\"#f3e430\",\"brightBlue\":\"#20bbfc\",\"brightPurple\":\"#6855de\",\"brightCyan\":\"#4fb8cc\",\"brightWhite\":\"#f1f1f1\",\"background\":\"#212121\",\"foreground\":\"#f1f1f1\",\"cursorColor\":\"#20bbfc\",\"selectionBackground\":\"#b6d6fd\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"mattly\",\"link\":\"https://github.com/mattly/iterm-colors-pencil\"}]}},{\"name\":\"PencilLight\",\"black\":\"#212121\",\"red\":\"#c30771\",\"green\":\"#10a778\",\"yellow\":\"#a89c14\",\"blue\":\"#008ec4\",\"purple\":\"#523c79\",\"cyan\":\"#20a5ba\",\"white\":\"#d9d9d9\",\"brightBlack\":\"#424242\",\"brightRed\":\"#fb007a\",\"brightGreen\":\"#5fd7af\",\"brightYellow\":\"#f3e430\",\"brightBlue\":\"#20bbfc\",\"brightPurple\":\"#6855de\",\"brightCyan\":\"#4fb8cc\",\"brightWhite\":\"#f1f1f1\",\"background\":\"#f1f1f1\",\"foreground\":\"#424242\",\"cursorColor\":\"#20bbfc\",\"selectionBackground\":\"#b6d6fd\",\"meta\":{\"isDark\":false,\"credits\":[{\"name\":\"mattly\",\"link\":\"https://github.com/mattly/iterm-colors-pencil\"}]}},{\"name\":\"Peppermint\",\"black\":\"#353535\",\"red\":\"#E64569\",\"green\":\"#89D287\",\"yellow\":\"#DAB752\",\"blue\":\"#439ECF\",\"purple\":\"#D961DC\",\"cyan\":\"#64AAAF\",\"white\":\"#B3B3B3\",\"brightBlack\":\"#535353\",\"brightRed\":\"#E4859A\",\"brightGreen\":\"#A2CCA1\",\"brightYellow\":\"#E1E387\",\"brightBlue\":\"#6FBBE2\",\"brightPurple\":\"#E586E7\",\"brightCyan\":\"#96DCDA\",\"brightWhite\":\"#DEDEDE\",\"foreground\":\"#C7C7C7\",\"background\":\"#000000\",\"cursorColor\":\"#BBBBBB\"},{\"name\":\"Piatto Light\",\"black\":\"#414141\",\"red\":\"#b23771\",\"green\":\"#66781e\",\"yellow\":\"#cd6f34\",\"blue\":\"#3c5ea8\",\"purple\":\"#a454b2\",\"cyan\":\"#66781e\",\"white\":\"#ffffff\",\"brightBlack\":\"#3f3f3f\",\"brightRed\":\"#db3365\",\"brightGreen\":\"#829429\",\"brightYellow\":\"#cd6f34\",\"brightBlue\":\"#3c5ea8\",\"brightPurple\":\"#a454b2\",\"brightCyan\":\"#829429\",\"brightWhite\":\"#f2f2f2\",\"background\":\"#ffffff\",\"foreground\":\"#414141\",\"cursorColor\":\"#5e77c8\",\"selectionBackground\":\"#706b4e\",\"meta\":{\"isDark\":false,\"credits\":[{\"name\":\"kovv\",\"link\":\"https://github.com/kovv\"}]}},{\"name\":\"Pixiefloss\",\"black\":\"#2f2942\",\"red\":\"#ff857f\",\"green\":\"#48b685\",\"yellow\":\"#e6c000\",\"blue\":\"#ae81ff\",\"purple\":\"#ef6155\",\"cyan\":\"#c2ffdf\",\"white\":\"#f8f8f2\",\"brightBlack\":\"#75507b\",\"brightRed\":\"#f1568e\",\"brightGreen\":\"#5adba2\",\"brightYellow\":\"#d5a425\",\"brightBlue\":\"#c5a3ff\",\"brightPurple\":\"#ef6155\",\"brightCyan\":\"#c2ffff\",\"brightWhite\":\"#f8f8f0\",\"foreground\":\"#d1cae8\",\"background\":\"#241f33\",\"cursorColor\":\"#d1cae8\"},{\"name\":\"Pnevma\",\"black\":\"#2f2e2d\",\"red\":\"#a36666\",\"green\":\"#90a57d\",\"yellow\":\"#d7af87\",\"blue\":\"#7fa5bd\",\"purple\":\"#c79ec4\",\"cyan\":\"#8adbb4\",\"white\":\"#d0d0d0\",\"brightBlack\":\"#4a4845\",\"brightRed\":\"#d78787\",\"brightGreen\":\"#afbea2\",\"brightYellow\":\"#e4c9af\",\"brightBlue\":\"#a1bdce\",\"brightPurple\":\"#d7beda\",\"brightCyan\":\"#b1e7dd\",\"brightWhite\":\"#efefef\",\"background\":\"#1c1c1c\",\"foreground\":\"#d0d0d0\",\"cursorColor\":\"#e4c9af\",\"selectionBackground\":\"#4d4d4d\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"baskerville\",\"link\":\"https://github.com/baskerville/iTerm-2-Color-Themes\"}]}},{\"name\":\"Popping and Locking\",\"black\":\"#1d2021\",\"red\":\"#cc241d\",\"green\":\"#98971a\",\"yellow\":\"#d79921\",\"blue\":\"#458588\",\"purple\":\"#b16286\",\"cyan\":\"#689d6a\",\"white\":\"#a89984\",\"brightBlack\":\"#928374\",\"brightRed\":\"#f42c3e\",\"brightGreen\":\"#b8bb26\",\"brightYellow\":\"#fabd2f\",\"brightBlue\":\"#99c6ca\",\"brightPurple\":\"#d3869b\",\"brightCyan\":\"#7ec16e\",\"brightWhite\":\"#ebdbb2\",\"background\":\"#181921\",\"foreground\":\"#ebdbb2\",\"cursorColor\":\"#c7c7c7\",\"selectionBackground\":\"#ebdbb2\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Hedinn Eiriksson\",\"link\":\"https://github.com/hedinne\"},{\"name\":\"didierbroska\",\"link\":\"https://github.com/didierbroska\"}]}},{\"name\":\"PowerShell\",\"black\":\"#000000\",\"red\":\"#7E0008\",\"green\":\"#098003\",\"yellow\":\"#C4A000\",\"blue\":\"#010083\",\"purple\":\"#D33682\",\"cyan\":\"#0E807F\",\"white\":\"#7F7C7F\",\"brightBlack\":\"#808080\",\"brightRed\":\"#EF2929\",\"brightGreen\":\"#1CFE3C\",\"brightYellow\":\"#FEFE45\",\"brightBlue\":\"#268AD2\",\"brightPurple\":\"#FE13FA\",\"brightCyan\":\"#29FFFE\",\"brightWhite\":\"#C2C1C3\",\"foreground\":\"#F6F6F7\",\"background\":\"#052454\",\"cursorColor\":\"#F6F6F7\"},{\"name\":\"primary\",\"black\":\"#000000\",\"red\":\"#db4437\",\"green\":\"#0f9d58\",\"yellow\":\"#f4b400\",\"blue\":\"#4285f4\",\"purple\":\"#db4437\",\"cyan\":\"#4285f4\",\"white\":\"#ffffff\",\"brightBlack\":\"#000000\",\"brightRed\":\"#db4437\",\"brightGreen\":\"#0f9d58\",\"brightYellow\":\"#f4b400\",\"brightBlue\":\"#4285f4\",\"brightPurple\":\"#4285f4\",\"brightCyan\":\"#0f9d58\",\"brightWhite\":\"#ffffff\",\"background\":\"#ffffff\",\"foreground\":\"#000000\",\"cursorColor\":\"#000000\",\"selectionBackground\":\"#656565\",\"meta\":{\"isDark\":false,\"credits\":[{\"name\":\"jayanthkoushik\",\"link\":\"https://github.com/jayanthkoushik\"},{\"name\":\"google\",\"link\":\"https://github.com/google/vim-colorscheme-primary\"}]}},{\"name\":\"Primer\",\"black\":\"#000000\",\"red\":\"#ea4a5a\",\"green\":\"#34d058\",\"yellow\":\"#ffdf5d\",\"blue\":\"#2188ff\",\"purple\":\"#8a63d2\",\"cyan\":\"#15e2e2\",\"white\":\"#ecf0f1\",\"brightBlack\":\"#4f5861\",\"brightRed\":\"#fdaeb7\",\"brightGreen\":\"#bef5cb\",\"brightYellow\":\"#fff5b1\",\"brightBlue\":\"#c8e1ff\",\"brightPurple\":\"#d1bcf9\",\"brightCyan\":\"#a2ecec\",\"brightWhite\":\"#ffffff\",\"background\":\"#1a2b3c\",\"foreground\":\"#ffffff\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"Pro\",\"black\":\"#000000\",\"red\":\"#990000\",\"green\":\"#00a600\",\"yellow\":\"#999900\",\"blue\":\"#2009db\",\"purple\":\"#b200b2\",\"cyan\":\"#00a6b2\",\"white\":\"#bfbfbf\",\"brightBlack\":\"#666666\",\"brightRed\":\"#e50000\",\"brightGreen\":\"#00d900\",\"brightYellow\":\"#e5e500\",\"brightBlue\":\"#0000ff\",\"brightPurple\":\"#e500e5\",\"brightCyan\":\"#00e5e5\",\"brightWhite\":\"#e5e5e5\",\"background\":\"#000000\",\"foreground\":\"#f2f2f2\",\"cursorColor\":\"#4d4d4d\",\"selectionBackground\":\"#414141\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"Pro Light\",\"black\":\"#000000\",\"red\":\"#e5492b\",\"green\":\"#50d148\",\"yellow\":\"#c6c440\",\"blue\":\"#3b75ff\",\"purple\":\"#ed66e8\",\"cyan\":\"#4ed2de\",\"white\":\"#dcdcdc\",\"brightBlack\":\"#9f9f9f\",\"brightRed\":\"#ff6640\",\"brightGreen\":\"#61ef57\",\"brightYellow\":\"#f2f156\",\"brightBlue\":\"#0082ff\",\"brightPurple\":\"#ff7eff\",\"brightCyan\":\"#61f7f8\",\"brightWhite\":\"#f2f2f2\",\"background\":\"#ffffff\",\"foreground\":\"#191919\",\"cursorColor\":\"#4d4d4d\",\"selectionBackground\":\"#c1ddff\",\"meta\":{\"isDark\":false,\"credits\":[{\"name\":\"crowsonkb\",\"link\":\"https://github.com/crowsonkb\"},{\"name\":\"iterm_schemer\",\"link\":\"https://github.com/crowsonkb/iterm_schemer\"}]}},{\"name\":\"PurplePeopleEater\",\"black\":\"#0d1117\",\"red\":\"#e34c26\",\"green\":\"#238636\",\"yellow\":\"#ed9a51\",\"blue\":\"#a5d6ff\",\"purple\":\"#6eb0e8\",\"cyan\":\"#c09aeb\",\"white\":\"#c9d1d9\",\"brightBlack\":\"#0d1117\",\"brightRed\":\"#ff7b72\",\"brightGreen\":\"#3bab4a\",\"brightYellow\":\"#ffa657\",\"brightBlue\":\"#a5d6ff\",\"brightPurple\":\"#79c0ff\",\"brightCyan\":\"#b694df\",\"brightWhite\":\"#c9d1d9\",\"foreground\":\"#c9d1d9\",\"background\":\"#161b22\",\"cursorColor\":\"#c9d1d9\"},{\"name\":\"purplepeter\",\"black\":\"#0a0520\",\"red\":\"#ff796d\",\"green\":\"#99b481\",\"yellow\":\"#efdfac\",\"blue\":\"#66d9ef\",\"purple\":\"#e78fcd\",\"cyan\":\"#ba8cff\",\"white\":\"#ffba81\",\"brightBlack\":\"#100b23\",\"brightRed\":\"#f99f92\",\"brightGreen\":\"#b4be8f\",\"brightYellow\":\"#f2e9bf\",\"brightBlue\":\"#79daed\",\"brightPurple\":\"#ba91d4\",\"brightCyan\":\"#a0a0d6\",\"brightWhite\":\"#b9aed3\",\"background\":\"#2a1a4a\",\"foreground\":\"#ece7fa\",\"cursorColor\":\"#c7c7c7\",\"selectionBackground\":\"#8689c2\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"DeChamp\",\"link\":\"https://github.com/dechamp\"}]}},{\"name\":\"Purple Rain\",\"black\":\"#000000\",\"red\":\"#ff260e\",\"green\":\"#9be205\",\"yellow\":\"#ffc400\",\"blue\":\"#00a2fa\",\"purple\":\"#815bb5\",\"cyan\":\"#00deef\",\"white\":\"#ffffff\",\"brightBlack\":\"#565656\",\"brightRed\":\"#ff4250\",\"brightGreen\":\"#b8e36e\",\"brightYellow\":\"#ffd852\",\"brightBlue\":\"#00a6ff\",\"brightPurple\":\"#ac7bf0\",\"brightCyan\":\"#74fdf3\",\"brightWhite\":\"#ffffff\",\"background\":\"#21084a\",\"foreground\":\"#fffbf6\",\"cursorColor\":\"#ff271d\",\"selectionBackground\":\"#287691\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"msorre2\",\"link\":\"https://github.com/msorre2\"}]}},{\"name\":\"Rapture\",\"black\":\"#000000\",\"red\":\"#fc644d\",\"green\":\"#7afde1\",\"yellow\":\"#fff09b\",\"blue\":\"#6c9bf5\",\"purple\":\"#ff4fa1\",\"cyan\":\"#64e0ff\",\"white\":\"#c0c9e5\",\"brightBlack\":\"#304b66\",\"brightRed\":\"#fc644d\",\"brightGreen\":\"#7afde1\",\"brightYellow\":\"#fff09b\",\"brightBlue\":\"#6c9bf5\",\"brightPurple\":\"#ff4fa1\",\"brightCyan\":\"#64e0ff\",\"brightWhite\":\"#ffffff\",\"background\":\"#111e2a\",\"foreground\":\"#c0c9e5\",\"cursorColor\":\"#ffffff\",\"selectionBackground\":\"#304b66\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Pustur\",\"link\":\"https://github.com/Pustur\"}]}},{\"name\":\"Raycast_Dark\",\"black\":\"#000000\",\"red\":\"#ff5360\",\"green\":\"#59d499\",\"yellow\":\"#ffc531\",\"blue\":\"#56c2ff\",\"purple\":\"#cf2f98\",\"cyan\":\"#52eee5\",\"white\":\"#ffffff\",\"brightBlack\":\"#000000\",\"brightRed\":\"#ff6363\",\"brightGreen\":\"#59d499\",\"brightYellow\":\"#ffc531\",\"brightBlue\":\"#56c2ff\",\"brightPurple\":\"#cf2f98\",\"brightCyan\":\"#52eee5\",\"brightWhite\":\"#ffffff\",\"background\":\"#1a1a1a\",\"foreground\":\"#ffffff\",\"cursorColor\":\"#cccccc\",\"selectionBackground\":\"#333333\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"thomaspaulmann\",\"link\":\"https://github.com/thomaspaulmann\"},{\"name\":\"itsnwa\",\"link\":\"https://github.com/itsnwa\"}]}},{\"name\":\"Raycast_Light\",\"black\":\"#000000\",\"red\":\"#b12424\",\"green\":\"#006b4f\",\"yellow\":\"#f8a300\",\"blue\":\"#138af2\",\"purple\":\"#9a1b6e\",\"cyan\":\"#3eb8bf\",\"white\":\"#ffffff\",\"brightBlack\":\"#000000\",\"brightRed\":\"#b12424\",\"brightGreen\":\"#006b4f\",\"brightYellow\":\"#f8a300\",\"brightBlue\":\"#138af2\",\"brightPurple\":\"#9a1b6e\",\"brightCyan\":\"#3eb8bf\",\"brightWhite\":\"#ffffff\",\"background\":\"#ffffff\",\"foreground\":\"#000000\",\"cursorColor\":\"#000000\",\"selectionBackground\":\"#e5e5e5\",\"meta\":{\"isDark\":false,\"credits\":[{\"name\":\"thomaspaulmann\",\"link\":\"https://github.com/thomaspaulmann\"},{\"name\":\"itsnwa\",\"link\":\"https://github.com/itsnwa\"}]}},{\"name\":\"rebecca\",\"black\":\"#12131e\",\"red\":\"#dd7755\",\"green\":\"#04dbb5\",\"yellow\":\"#f2e7b7\",\"blue\":\"#7aa5ff\",\"purple\":\"#bf9cf9\",\"cyan\":\"#56d3c2\",\"white\":\"#e4e3e9\",\"brightBlack\":\"#666699\",\"brightRed\":\"#ff92cd\",\"brightGreen\":\"#01eac0\",\"brightYellow\":\"#fffca8\",\"brightBlue\":\"#69c0fa\",\"brightPurple\":\"#c17ff8\",\"brightCyan\":\"#8bfde1\",\"brightWhite\":\"#f4f2f9\",\"background\":\"#292a44\",\"foreground\":\"#e8e6ed\",\"cursorColor\":\"#b89bf9\",\"selectionBackground\":\"#663399\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"vic\",\"link\":\"https://github.com/vic\"}]}},{\"name\":\"Red Alert\",\"black\":\"#000000\",\"red\":\"#d62e4e\",\"green\":\"#71be6b\",\"yellow\":\"#beb86b\",\"blue\":\"#489bee\",\"purple\":\"#e979d7\",\"cyan\":\"#6bbeb8\",\"white\":\"#d6d6d6\",\"brightBlack\":\"#262626\",\"brightRed\":\"#e02553\",\"brightGreen\":\"#aff08c\",\"brightYellow\":\"#dfddb7\",\"brightBlue\":\"#65aaf1\",\"brightPurple\":\"#ddb7df\",\"brightCyan\":\"#b7dfdd\",\"brightWhite\":\"#ffffff\",\"background\":\"#762423\",\"foreground\":\"#ffffff\",\"cursorColor\":\"#ffffff\",\"selectionBackground\":\"#073642\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"Red Planet\",\"black\":\"#202020\",\"red\":\"#8c3432\",\"green\":\"#728271\",\"yellow\":\"#e8bf6a\",\"blue\":\"#69819e\",\"purple\":\"#896492\",\"cyan\":\"#5b8390\",\"white\":\"#b9aa99\",\"brightBlack\":\"#676767\",\"brightRed\":\"#b55242\",\"brightGreen\":\"#869985\",\"brightYellow\":\"#ebeb91\",\"brightBlue\":\"#60827e\",\"brightPurple\":\"#de4974\",\"brightCyan\":\"#38add8\",\"brightWhite\":\"#d6bfb8\",\"background\":\"#222222\",\"foreground\":\"#c2b790\",\"cursorColor\":\"#c2b790\",\"selectionBackground\":\"#1b324a\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"ibrokemypie\",\"link\":\"https://github.com/ibrokemypie\"},{\"name\":\"eliquious\",\"link\":\"https://github.com/eliquious\"}]}},{\"name\":\"Red Sands\",\"black\":\"#000000\",\"red\":\"#ff3f00\",\"green\":\"#00bb00\",\"yellow\":\"#e7b000\",\"blue\":\"#0072ff\",\"purple\":\"#bb00bb\",\"cyan\":\"#00bbbb\",\"white\":\"#bbbbbb\",\"brightBlack\":\"#555555\",\"brightRed\":\"#bb0000\",\"brightGreen\":\"#00bb00\",\"brightYellow\":\"#e7b000\",\"brightBlue\":\"#0072ae\",\"brightPurple\":\"#ff55ff\",\"brightCyan\":\"#55ffff\",\"brightWhite\":\"#ffffff\",\"background\":\"#7a251e\",\"foreground\":\"#d7c9a7\",\"cursorColor\":\"#ffffff\",\"selectionBackground\":\"#a4a390\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"Relaxed\",\"black\":\"#151515\",\"red\":\"#bc5653\",\"green\":\"#909d63\",\"yellow\":\"#ebc17a\",\"blue\":\"#6a8799\",\"purple\":\"#b06698\",\"cyan\":\"#c9dfff\",\"white\":\"#d9d9d9\",\"brightBlack\":\"#636363\",\"brightRed\":\"#bc5653\",\"brightGreen\":\"#a0ac77\",\"brightYellow\":\"#ebc17a\",\"brightBlue\":\"#7eaac7\",\"brightPurple\":\"#b06698\",\"brightCyan\":\"#acbbd0\",\"brightWhite\":\"#f7f7f7\",\"background\":\"#353a44\",\"foreground\":\"#d9d9d9\",\"cursorColor\":\"#d9d9d9\",\"selectionBackground\":\"#6a7985\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"Rippedcasts\",\"black\":\"#000000\",\"red\":\"#cdaf95\",\"green\":\"#a8ff60\",\"yellow\":\"#bfbb1f\",\"blue\":\"#75a5b0\",\"purple\":\"#ff73fd\",\"cyan\":\"#5a647e\",\"white\":\"#bfbfbf\",\"brightBlack\":\"#666666\",\"brightRed\":\"#eecbad\",\"brightGreen\":\"#bcee68\",\"brightYellow\":\"#e5e500\",\"brightBlue\":\"#86bdc9\",\"brightPurple\":\"#e500e5\",\"brightCyan\":\"#8c9bc4\",\"brightWhite\":\"#e5e5e5\",\"background\":\"#2b2b2b\",\"foreground\":\"#ffffff\",\"cursorColor\":\"#7f7f7f\",\"selectionBackground\":\"#5a647e\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"mdw123\",\"link\":\"https://github.com/mdw123/rippedcasts\"}]}},{\"name\":\"Rose Pine\",\"black\":\"#706e86\",\"red\":\"#eb6f92\",\"green\":\"#9ccfd8\",\"yellow\":\"#f6c177\",\"blue\":\"#31748f\",\"purple\":\"#c4a7e7\",\"cyan\":\"#ebbcba\",\"white\":\"#e0def4\",\"brightBlack\":\"#706e86\",\"brightRed\":\"#eb6f92\",\"brightGreen\":\"#9ccfd8\",\"brightYellow\":\"#f6c177\",\"brightBlue\":\"#31748f\",\"brightPurple\":\"#c4a7e7\",\"brightCyan\":\"#ebbcba\",\"brightWhite\":\"#e0def4\",\"background\":\"#191724\",\"foreground\":\"#e0def4\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"Rouge 2\",\"black\":\"#5d5d6b\",\"red\":\"#c6797e\",\"green\":\"#969e92\",\"yellow\":\"#dbcdab\",\"blue\":\"#6e94b9\",\"purple\":\"#4c4e78\",\"cyan\":\"#8ab6c1\",\"white\":\"#e8e8ea\",\"brightBlack\":\"#616274\",\"brightRed\":\"#c6797e\",\"brightGreen\":\"#e6dcc4\",\"brightYellow\":\"#e6dcc4\",\"brightBlue\":\"#98b3cd\",\"brightPurple\":\"#8283a1\",\"brightCyan\":\"#abcbd3\",\"brightWhite\":\"#e8e8ea\",\"background\":\"#17182b\",\"foreground\":\"#a2a3aa\",\"cursorColor\":\"#969e92\",\"selectionBackground\":\"#5d5d6b\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Josef Aidt\",\"link\":\"https://github.com/josefaidt/rouge-theme\"},{\"name\":\"Sam Rose\",\"link\":\"https://github.com/samrose3\"}]}},{\"name\":\"Royal\",\"black\":\"#241f2b\",\"red\":\"#91284c\",\"green\":\"#23801c\",\"yellow\":\"#b49d27\",\"blue\":\"#6580b0\",\"purple\":\"#674d96\",\"cyan\":\"#8aaabe\",\"white\":\"#524966\",\"brightBlack\":\"#312d3d\",\"brightRed\":\"#d5356c\",\"brightGreen\":\"#2cd946\",\"brightYellow\":\"#fde83b\",\"brightBlue\":\"#90baf9\",\"brightPurple\":\"#a479e3\",\"brightCyan\":\"#acd4eb\",\"brightWhite\":\"#9e8cbd\",\"background\":\"#100815\",\"foreground\":\"#514968\",\"cursorColor\":\"#524966\",\"selectionBackground\":\"#1f1d2b\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"zdj\",\"link\":\"https://github.com/zdj/themes/tree/master/iterm2\"}]}},{\"name\":\"Ryuuko\",\"black\":\"#2c3941\",\"red\":\"#865f5b\",\"green\":\"#66907d\",\"yellow\":\"#b1a990\",\"blue\":\"#6a8e95\",\"purple\":\"#b18a73\",\"cyan\":\"#88b2ac\",\"white\":\"#ececec\",\"brightBlack\":\"#5d7079\",\"brightRed\":\"#865f5b\",\"brightGreen\":\"#66907d\",\"brightYellow\":\"#b1a990\",\"brightBlue\":\"#6a8e95\",\"brightPurple\":\"#b18a73\",\"brightCyan\":\"#88b2ac\",\"brightWhite\":\"#ececec\",\"background\":\"#2c3941\",\"foreground\":\"#ececec\",\"cursorColor\":\"#ececec\",\"selectionBackground\":\"#002831\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"dylanaraps\",\"link\":\"https://github.com/dylanaraps\"},{\"name\":\"iandrewt\",\"link\":\"https://github.com/iandrewt\"}]}},{\"name\":\"Sakura\",\"black\":\"#000000\",\"red\":\"#d52370\",\"green\":\"#41af1a\",\"yellow\":\"#bc7053\",\"blue\":\"#6964ab\",\"purple\":\"#c71fbf\",\"cyan\":\"#939393\",\"white\":\"#998eac\",\"brightBlack\":\"#786d69\",\"brightRed\":\"#f41d99\",\"brightGreen\":\"#22e529\",\"brightYellow\":\"#f59574\",\"brightBlue\":\"#9892f1\",\"brightPurple\":\"#e90cdd\",\"brightCyan\":\"#eeeeee\",\"brightWhite\":\"#cbb6ff\",\"background\":\"#18131e\",\"foreground\":\"#dd7bdc\",\"cursorColor\":\"#ff65fd\",\"selectionBackground\":\"#c05cbf\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"0xN0ri\",\"link\":\"https://github.com/0xN0ri\"},{\"name\":\"zdj\",\"link\":\"https://github.com/zdj\"}]}},{\"name\":\"Sat\",\"black\":\"#000000\",\"red\":\"#dd0007\",\"green\":\"#07dd00\",\"yellow\":\"#ddd600\",\"blue\":\"#0007dd\",\"purple\":\"#d600dd\",\"cyan\":\"#00ddd6\",\"white\":\"#f2f2f2\",\"brightBlack\":\"#7d7d7d\",\"brightRed\":\"#ff7478\",\"brightGreen\":\"#78ff74\",\"brightYellow\":\"#fffa74\",\"brightBlue\":\"#7478ff\",\"brightPurple\":\"#fa74ff\",\"brightCyan\":\"#74fffa\",\"brightWhite\":\"#ffffff\",\"foreground\":\"#23476a\",\"background\":\"#758480\",\"cursorColor\":\"#23476a\"},{\"name\":\"Scarlet Protocol\",\"black\":\"#101116\",\"red\":\"#ff0051\",\"green\":\"#00dc84\",\"yellow\":\"#faf945\",\"blue\":\"#0271b6\",\"purple\":\"#ca30c7\",\"cyan\":\"#00c5c7\",\"white\":\"#c7c7c7\",\"brightBlack\":\"#686868\",\"brightRed\":\"#ff6e67\",\"brightGreen\":\"#5ffa68\",\"brightYellow\":\"#fffc67\",\"brightBlue\":\"#6871ff\",\"brightPurple\":\"#bd35ec\",\"brightCyan\":\"#60fdff\",\"brightWhite\":\"#ffffff\",\"background\":\"#1c153d\",\"foreground\":\"#e41951\",\"cursorColor\":\"#76ff9f\",\"selectionBackground\":\"#c1deff\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"ReagentX\",\"link\":\"https://github.com/ReagentX\"}]}},{\"name\":\"Seafoam Pastel\",\"black\":\"#757575\",\"red\":\"#825d4d\",\"green\":\"#728c62\",\"yellow\":\"#ada16d\",\"blue\":\"#4d7b82\",\"purple\":\"#8a7267\",\"cyan\":\"#729494\",\"white\":\"#e0e0e0\",\"brightBlack\":\"#8a8a8a\",\"brightRed\":\"#cf937a\",\"brightGreen\":\"#98d9aa\",\"brightYellow\":\"#fae79d\",\"brightBlue\":\"#7ac3cf\",\"brightPurple\":\"#d6b2a1\",\"brightCyan\":\"#ade0e0\",\"brightWhite\":\"#e0e0e0\",\"background\":\"#243435\",\"foreground\":\"#d4e7d4\",\"cursorColor\":\"#57647a\",\"selectionBackground\":\"#ffffff\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"SeaShells\",\"black\":\"#17384c\",\"red\":\"#d15123\",\"green\":\"#027c9b\",\"yellow\":\"#fca02f\",\"blue\":\"#1e4950\",\"purple\":\"#68d4f1\",\"cyan\":\"#50a3b5\",\"white\":\"#deb88d\",\"brightBlack\":\"#434b53\",\"brightRed\":\"#d48678\",\"brightGreen\":\"#628d98\",\"brightYellow\":\"#fdd39f\",\"brightBlue\":\"#1bbcdd\",\"brightPurple\":\"#bbe3ee\",\"brightCyan\":\"#87acb4\",\"brightWhite\":\"#fee4ce\",\"background\":\"#09141b\",\"foreground\":\"#deb88d\",\"cursorColor\":\"#fca02f\",\"selectionBackground\":\"#1e4962\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"zdj\",\"link\":\"https://github.com/zdj/themes/tree/master/iterm2\"}]}},{\"name\":\"Seti\",\"black\":\"#323232\",\"red\":\"#c22832\",\"green\":\"#8ec43d\",\"yellow\":\"#e0c64f\",\"blue\":\"#43a5d5\",\"purple\":\"#8b57b5\",\"cyan\":\"#8ec43d\",\"white\":\"#eeeeee\",\"brightBlack\":\"#323232\",\"brightRed\":\"#c22832\",\"brightGreen\":\"#8ec43d\",\"brightYellow\":\"#e0c64f\",\"brightBlue\":\"#43a5d5\",\"brightPurple\":\"#8b57b5\",\"brightCyan\":\"#8ec43d\",\"brightWhite\":\"#ffffff\",\"background\":\"#111213\",\"foreground\":\"#cacecd\",\"cursorColor\":\"#e3bf21\",\"selectionBackground\":\"#303233\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"jesseweed\",\"link\":\"https://github.com/jesseweed/seti-syntax/\"},{\"name\":\"philduffy\",\"link\":\"https://github.com/willmanduffy/seti-iterm\"}]}},{\"name\":\"shades-of-purple\",\"black\":\"#000000\",\"red\":\"#d90429\",\"green\":\"#3ad900\",\"yellow\":\"#ffe700\",\"blue\":\"#6943ff\",\"purple\":\"#ff2c70\",\"cyan\":\"#00c5c7\",\"white\":\"#c7c7c7\",\"brightBlack\":\"#686868\",\"brightRed\":\"#f92a1c\",\"brightGreen\":\"#43d426\",\"brightYellow\":\"#f1d000\",\"brightBlue\":\"#6871ff\",\"brightPurple\":\"#ff77ff\",\"brightCyan\":\"#79e8fb\",\"brightWhite\":\"#ffffff\",\"background\":\"#1e1d40\",\"foreground\":\"#ffffff\",\"cursorColor\":\"#fad000\",\"selectionBackground\":\"#b362ff\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"ahmadawais\",\"link\":\"https://github.com/ahmadawais/shades-of-purple-iterm2\"},{\"name\":\"fr3fou\",\"link\":\"https://github.com/fr3fou\"}]}},{\"name\":\"Shaman\",\"black\":\"#012026\",\"red\":\"#b2302d\",\"green\":\"#00a941\",\"yellow\":\"#5e8baa\",\"blue\":\"#449a86\",\"purple\":\"#00599d\",\"cyan\":\"#5d7e19\",\"white\":\"#405555\",\"brightBlack\":\"#384451\",\"brightRed\":\"#ff4242\",\"brightGreen\":\"#2aea5e\",\"brightYellow\":\"#8ed4fd\",\"brightBlue\":\"#61d5ba\",\"brightPurple\":\"#1298ff\",\"brightCyan\":\"#98d028\",\"brightWhite\":\"#58fbd6\",\"background\":\"#001015\",\"foreground\":\"#405555\",\"cursorColor\":\"#4afcd6\",\"selectionBackground\":\"#415555\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"zdj\",\"link\":\"https://github.com/zdj/themes/tree/master/iterm2\"}]}},{\"name\":\"Shel\",\"black\":\"#2c2423\",\"red\":\"#ab2463\",\"green\":\"#6ca323\",\"yellow\":\"#ab6423\",\"blue\":\"#2c64a2\",\"purple\":\"#6c24a2\",\"cyan\":\"#2ca363\",\"white\":\"#918988\",\"brightBlack\":\"#918988\",\"brightRed\":\"#f588b9\",\"brightGreen\":\"#c2ee86\",\"brightYellow\":\"#f5ba86\",\"brightBlue\":\"#8fbaec\",\"brightPurple\":\"#c288ec\",\"brightCyan\":\"#8feeb9\",\"brightWhite\":\"#f5eeec\",\"foreground\":\"#4882cd\",\"background\":\"#2a201f\",\"cursorColor\":\"#4882cd\"},{\"name\":\"Slate\",\"black\":\"#222222\",\"red\":\"#e2a8bf\",\"green\":\"#81d778\",\"yellow\":\"#c4c9c0\",\"blue\":\"#264b49\",\"purple\":\"#a481d3\",\"cyan\":\"#15ab9c\",\"white\":\"#02c5e0\",\"brightBlack\":\"#ffffff\",\"brightRed\":\"#ffcdd9\",\"brightGreen\":\"#beffa8\",\"brightYellow\":\"#d0ccca\",\"brightBlue\":\"#7ab0d2\",\"brightPurple\":\"#c5a7d9\",\"brightCyan\":\"#8cdfe0\",\"brightWhite\":\"#e0e0e0\",\"background\":\"#222222\",\"foreground\":\"#35b1d2\",\"cursorColor\":\"#87d3c4\",\"selectionBackground\":\"#0f3754\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"deneshshan\",\"link\":\"https://github.com/deneshshan\"}]}},{\"name\":\"SleepyHollow\",\"black\":\"#572100\",\"red\":\"#ba3934\",\"green\":\"#91773f\",\"yellow\":\"#b55600\",\"blue\":\"#5f63b4\",\"purple\":\"#a17c7b\",\"cyan\":\"#8faea9\",\"white\":\"#af9a91\",\"brightBlack\":\"#4e4b61\",\"brightRed\":\"#d9443f\",\"brightGreen\":\"#d6b04e\",\"brightYellow\":\"#f66813\",\"brightBlue\":\"#8086ef\",\"brightPurple\":\"#e2c2bb\",\"brightCyan\":\"#a4dce7\",\"brightWhite\":\"#d2c7a9\",\"background\":\"#121214\",\"foreground\":\"#af9a91\",\"cursorColor\":\"#af9a91\",\"selectionBackground\":\"#575256\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"zdj\",\"link\":\"https://github.com/zdj/themes/tree/master/iterm2\"}]}},{\"name\":\"Smyck\",\"black\":\"#000000\",\"red\":\"#b84131\",\"green\":\"#7da900\",\"yellow\":\"#c4a500\",\"blue\":\"#62a3c4\",\"purple\":\"#ba8acc\",\"cyan\":\"#207383\",\"white\":\"#a1a1a1\",\"brightBlack\":\"#7a7a7a\",\"brightRed\":\"#d6837c\",\"brightGreen\":\"#c4f137\",\"brightYellow\":\"#fee14d\",\"brightBlue\":\"#8dcff0\",\"brightPurple\":\"#f79aff\",\"brightCyan\":\"#6ad9cf\",\"brightWhite\":\"#f7f7f7\",\"background\":\"#1b1b1b\",\"foreground\":\"#f7f7f7\",\"cursorColor\":\"#bbbbbb\",\"selectionBackground\":\"#207483\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"hukl\",\"link\":\"https://github.com/hukl/Smyck-Color-Scheme\"}]}},{\"name\":\"Snazzy\",\"black\":\"#000000\",\"red\":\"#fc4346\",\"green\":\"#50fb7c\",\"yellow\":\"#f0fb8c\",\"blue\":\"#49baff\",\"purple\":\"#fc4cb4\",\"cyan\":\"#8be9fe\",\"white\":\"#ededec\",\"brightBlack\":\"#555555\",\"brightRed\":\"#fc4346\",\"brightGreen\":\"#50fb7c\",\"brightYellow\":\"#f0fb8c\",\"brightBlue\":\"#49baff\",\"brightPurple\":\"#fc4cb4\",\"brightCyan\":\"#8be9fe\",\"brightWhite\":\"#ededec\",\"background\":\"#1e1f29\",\"foreground\":\"#ebece6\",\"cursorColor\":\"#e4e4e4\",\"selectionBackground\":\"#81aec6\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"SoftServer\",\"black\":\"#000000\",\"red\":\"#a2686a\",\"green\":\"#9aa56a\",\"yellow\":\"#a3906a\",\"blue\":\"#6b8fa3\",\"purple\":\"#6a71a3\",\"cyan\":\"#6ba58f\",\"white\":\"#99a3a2\",\"brightBlack\":\"#666c6c\",\"brightRed\":\"#dd5c60\",\"brightGreen\":\"#bfdf55\",\"brightYellow\":\"#deb360\",\"brightBlue\":\"#62b1df\",\"brightPurple\":\"#606edf\",\"brightCyan\":\"#64e39c\",\"brightWhite\":\"#d2e0de\",\"background\":\"#242626\",\"foreground\":\"#99a3a2\",\"cursorColor\":\"#d2e0de\",\"selectionBackground\":\"#7f8786\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"zdj\",\"link\":\"https://github.com/zdj/themes/tree/master/iterm2\"}]}},{\"name\":\"Solarized Darcula\",\"black\":\"#25292a\",\"red\":\"#f24840\",\"green\":\"#629655\",\"yellow\":\"#b68800\",\"blue\":\"#2075c7\",\"purple\":\"#797fd4\",\"cyan\":\"#15968d\",\"white\":\"#d2d8d9\",\"brightBlack\":\"#25292a\",\"brightRed\":\"#f24840\",\"brightGreen\":\"#629655\",\"brightYellow\":\"#b68800\",\"brightBlue\":\"#2075c7\",\"brightPurple\":\"#797fd4\",\"brightCyan\":\"#15968d\",\"brightWhite\":\"#d2d8d9\",\"background\":\"#3d3f41\",\"foreground\":\"#d2d8d9\",\"cursorColor\":\"#708284\",\"selectionBackground\":\"#214283\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"@rickhanlonii\",\"link\":\"https://github.com/rickhanlonii\"}]}},{\"name\":\"SolarizedDark\",\"black\":\"#073642\",\"red\":\"#DC322F\",\"green\":\"#859900\",\"yellow\":\"#CF9A6B\",\"blue\":\"#268BD2\",\"purple\":\"#D33682\",\"cyan\":\"#2AA198\",\"white\":\"#EEE8D5\",\"brightBlack\":\"#657B83\",\"brightRed\":\"#D87979\",\"brightGreen\":\"#88CF76\",\"brightYellow\":\"#657B83\",\"brightBlue\":\"#2699FF\",\"brightPurple\":\"#D33682\",\"brightCyan\":\"#43B8C3\",\"brightWhite\":\"#FDF6E3\",\"foreground\":\"#839496\",\"background\":\"#002B36\",\"cursorColor\":\"#839496\"},{\"name\":\"Solarized Dark Higher Contrast\",\"black\":\"#002831\",\"red\":\"#d11c24\",\"green\":\"#6cbe6c\",\"yellow\":\"#a57706\",\"blue\":\"#2176c7\",\"purple\":\"#c61c6f\",\"cyan\":\"#259286\",\"white\":\"#eae3cb\",\"brightBlack\":\"#006488\",\"brightRed\":\"#f5163b\",\"brightGreen\":\"#51ef84\",\"brightYellow\":\"#b27e28\",\"brightBlue\":\"#178ec8\",\"brightPurple\":\"#e24d8e\",\"brightCyan\":\"#00b39e\",\"brightWhite\":\"#fcf4dc\",\"background\":\"#001e27\",\"foreground\":\"#9cc2c3\",\"cursorColor\":\"#f34b00\",\"selectionBackground\":\"#003748\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"heisters\",\"link\":\"https://gist.github.com/heisters/1015503\"}]}},{\"name\":\"Solarized Dark - Patched\",\"black\":\"#002831\",\"red\":\"#d11c24\",\"green\":\"#738a05\",\"yellow\":\"#a57706\",\"blue\":\"#2176c7\",\"purple\":\"#c61c6f\",\"cyan\":\"#259286\",\"white\":\"#eae3cb\",\"brightBlack\":\"#475b62\",\"brightRed\":\"#bd3613\",\"brightGreen\":\"#475b62\",\"brightYellow\":\"#536870\",\"brightBlue\":\"#708284\",\"brightPurple\":\"#5956ba\",\"brightCyan\":\"#819090\",\"brightWhite\":\"#fcf4dc\",\"background\":\"#001e27\",\"foreground\":\"#708284\",\"cursorColor\":\"#708284\",\"selectionBackground\":\"#002831\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"SolarizedLight\",\"black\":\"#073642\",\"red\":\"#DC322F\",\"green\":\"#859900\",\"yellow\":\"#B58900\",\"blue\":\"#268BD2\",\"purple\":\"#D33682\",\"cyan\":\"#2AA198\",\"white\":\"#EEE8D5\",\"brightBlack\":\"#002B36\",\"brightRed\":\"#CB4B16\",\"brightGreen\":\"#586E75\",\"brightYellow\":\"#657B83\",\"brightBlue\":\"#839496\",\"brightPurple\":\"#6C71C4\",\"brightCyan\":\"#93A1A1\",\"brightWhite\":\"#FDF6E3\",\"foreground\":\"#657B83\",\"background\":\"#FDF6E3\",\"cursorColor\":\"#657B83\"},{\"name\":\"Sonoran Gothic\",\"foreground\":\"#EAF4DE\",\"background\":\"#241F17\",\"cursorColor\":\"#EAF4DE\",\"black\":\"#867F6E\",\"red\":\"#EB6f6f\",\"green\":\"#669C50\",\"yellow\":\"#F2D696\",\"blue\":\"#227B4d\",\"purple\":\"#A5ABDA\",\"cyan\":\"#E18F62\",\"white\":\"#EAF4DE\",\"brightBlack\":\"#867F6E\",\"brightRed\":\"#EB6f6f\",\"brightGreen\":\"#669C50\",\"brightYellow\":\"#F2D696\",\"brightBlue\":\"#227B4D\",\"brightPurple\":\"#A5ABDA\",\"brightCyan\":\"#E18F62\",\"brightWhite\":\"#EAF4DE\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"d-mckee\",\"link\":\"https://github.com/d-mckee\"}]}},{\"name\":\"Sonoran Sunrise\",\"foreground\":\"#61543E\",\"background\":\"#F9FAE3\",\"cursorColor\":\"#61543E\",\"selectionBackground\":\"#a4f017\",\"black\":\"#F9FAE3\",\"red\":\"#EB6f6f\",\"green\":\"#669C50\",\"yellow\":\"#F2C55C\",\"blue\":\"#227B4D\",\"purple\":\"#7189D9\",\"cyan\":\"#E07941\",\"white\":\"#665E4B\",\"brightBlack\":\"#F9FAE3\",\"brightRed\":\"#EB6f6f\",\"brightGreen\":\"#669C50\",\"brightYellow\":\"#F2C55C\",\"brightBlue\":\"#227B4D\",\"brightPurple\":\"#7189D9\",\"brightCyan\":\"#E07941\",\"brightWhite\":\"#665E4B\",\"meta\":{\"isDark\":false,\"credits\":[{\"name\":\"d-mckee\",\"link\":\"https://github.com/d-mckee\"}]}},{\"name\":\"Spacedust\",\"black\":\"#6e5346\",\"red\":\"#e35b00\",\"green\":\"#5cab96\",\"yellow\":\"#e3cd7b\",\"blue\":\"#0f548b\",\"purple\":\"#e35b00\",\"cyan\":\"#06afc7\",\"white\":\"#f0f1ce\",\"brightBlack\":\"#684c31\",\"brightRed\":\"#ff8a3a\",\"brightGreen\":\"#aecab8\",\"brightYellow\":\"#ffc878\",\"brightBlue\":\"#67a0ce\",\"brightPurple\":\"#ff8a3a\",\"brightCyan\":\"#83a7b4\",\"brightWhite\":\"#fefff1\",\"background\":\"#0a1e24\",\"foreground\":\"#ecf0c1\",\"cursorColor\":\"#708284\",\"selectionBackground\":\"#0a385c\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"mhallendal\",\"link\":\"https://github.com/mhallendal/spacedust-theme\"},{\"name\":\"Couto\",\"link\":\"https://github.com/Couto\"}]}},{\"name\":\"SpaceGray\",\"black\":\"#000000\",\"red\":\"#b04b57\",\"green\":\"#87b379\",\"yellow\":\"#e5c179\",\"blue\":\"#7d8fa4\",\"purple\":\"#a47996\",\"cyan\":\"#85a7a5\",\"white\":\"#b3b8c3\",\"brightBlack\":\"#000000\",\"brightRed\":\"#b04b57\",\"brightGreen\":\"#87b379\",\"brightYellow\":\"#e5c179\",\"brightBlue\":\"#7d8fa4\",\"brightPurple\":\"#a47996\",\"brightCyan\":\"#85a7a5\",\"brightWhite\":\"#ffffff\",\"background\":\"#20242d\",\"foreground\":\"#b3b8c3\",\"cursorColor\":\"#b3b8c3\",\"selectionBackground\":\"#16181e\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"ryentzer\",\"link\":\"https://github.com/ryentzer/SpaceGray-iTerm\"}]}},{\"name\":\"SpaceGray Eighties\",\"black\":\"#15171c\",\"red\":\"#ec5f67\",\"green\":\"#81a764\",\"yellow\":\"#fec254\",\"blue\":\"#5486c0\",\"purple\":\"#bf83c1\",\"cyan\":\"#57c2c1\",\"white\":\"#efece7\",\"brightBlack\":\"#555555\",\"brightRed\":\"#ff6973\",\"brightGreen\":\"#93d493\",\"brightYellow\":\"#ffd256\",\"brightBlue\":\"#4d84d1\",\"brightPurple\":\"#ff55ff\",\"brightCyan\":\"#83e9e4\",\"brightWhite\":\"#ffffff\",\"background\":\"#222222\",\"foreground\":\"#bdbaae\",\"cursorColor\":\"#bbbbbb\",\"selectionBackground\":\"#272e35\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"mhkeller\",\"link\":\"https://github.com/mhkeller/spacegray-eighties-iterm\"}]}},{\"name\":\"SpaceGray Eighties Dull\",\"black\":\"#15171c\",\"red\":\"#b24a56\",\"green\":\"#92b477\",\"yellow\":\"#c6735a\",\"blue\":\"#7c8fa5\",\"purple\":\"#a5789e\",\"cyan\":\"#80cdcb\",\"white\":\"#b3b8c3\",\"brightBlack\":\"#555555\",\"brightRed\":\"#ec5f67\",\"brightGreen\":\"#89e986\",\"brightYellow\":\"#fec254\",\"brightBlue\":\"#5486c0\",\"brightPurple\":\"#bf83c1\",\"brightCyan\":\"#58c2c1\",\"brightWhite\":\"#ffffff\",\"background\":\"#222222\",\"foreground\":\"#c9c6bc\",\"cursorColor\":\"#bbbbbb\",\"selectionBackground\":\"#272e36\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"mhkeller\",\"link\":\"https://github.com/mhkeller/spacegray-eighties-iterm\"}]}},{\"name\":\"Spiderman\",\"black\":\"#1b1d1e\",\"red\":\"#e60813\",\"green\":\"#e22928\",\"yellow\":\"#e24756\",\"blue\":\"#2c3fff\",\"purple\":\"#2435db\",\"cyan\":\"#3256ff\",\"white\":\"#fffef6\",\"brightBlack\":\"#505354\",\"brightRed\":\"#ff0325\",\"brightGreen\":\"#ff3338\",\"brightYellow\":\"#fe3a35\",\"brightBlue\":\"#1d50ff\",\"brightPurple\":\"#747cff\",\"brightCyan\":\"#6184ff\",\"brightWhite\":\"#fffff9\",\"background\":\"#1b1d1e\",\"foreground\":\"#e3e3e3\",\"cursorColor\":\"#2c3fff\",\"selectionBackground\":\"#070e50\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"pyrophos\",\"link\":\"https://github.com/pyrophos\"}]}},{\"name\":\"Spring\",\"black\":\"#000000\",\"red\":\"#ff4d83\",\"green\":\"#1f8c3b\",\"yellow\":\"#1fc95b\",\"blue\":\"#1dd3ee\",\"purple\":\"#8959a8\",\"cyan\":\"#3e999f\",\"white\":\"#ffffff\",\"brightBlack\":\"#000000\",\"brightRed\":\"#ff0021\",\"brightGreen\":\"#1fc231\",\"brightYellow\":\"#d5b807\",\"brightBlue\":\"#15a9fd\",\"brightPurple\":\"#8959a8\",\"brightCyan\":\"#3e999f\",\"brightWhite\":\"#ffffff\",\"background\":\"#ffffff\",\"foreground\":\"#4d4d4c\",\"cursorColor\":\"#4d4d4c\",\"selectionBackground\":\"#d6d6d6\",\"meta\":{\"isDark\":false,\"credits\":[{\"name\":\"t3chnoboy\",\"link\":\"https://github.com/t3chnoboy/spring-iTerm\"}]}},{\"name\":\"Square\",\"black\":\"#050505\",\"red\":\"#e9897c\",\"green\":\"#b6377d\",\"yellow\":\"#ecebbe\",\"blue\":\"#a9cdeb\",\"purple\":\"#75507b\",\"cyan\":\"#c9caec\",\"white\":\"#f2f2f2\",\"brightBlack\":\"#141414\",\"brightRed\":\"#f99286\",\"brightGreen\":\"#c3f786\",\"brightYellow\":\"#fcfbcc\",\"brightBlue\":\"#b6defb\",\"brightPurple\":\"#ad7fa8\",\"brightCyan\":\"#d7d9fc\",\"brightWhite\":\"#e2e2e2\",\"background\":\"#1a1a1a\",\"foreground\":\"#acacab\",\"cursorColor\":\"#fcfbcc\",\"selectionBackground\":\"#4d4d4d\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"baskerville\",\"link\":\"https://github.com/baskerville/iTerm-2-Color-Themes\"}]}},{\"name\":\"Srcery\",\"black\":\"#1C1B19\",\"red\":\"#FF3128\",\"green\":\"#519F50\",\"yellow\":\"#FBB829\",\"blue\":\"#5573A3\",\"purple\":\"#E02C6D\",\"cyan\":\"#0AAEB3\",\"white\":\"#918175\",\"brightBlack\":\"#2D2B28\",\"brightRed\":\"#F75341\",\"brightGreen\":\"#98BC37\",\"brightYellow\":\"#FED06E\",\"brightBlue\":\"#8EB2F7\",\"brightPurple\":\"#E35682\",\"brightCyan\":\"#53FDE9\",\"brightWhite\":\"#FCE8C3\",\"foreground\":\"#ebdbb2\",\"background\":\"#282828\",\"cursorColor\":\"#ebdbb2\"},{\"name\":\"Sublette\",\"black\":\"#253045\",\"red\":\"#ee5577\",\"green\":\"#55ee77\",\"yellow\":\"#ffdd88\",\"blue\":\"#5588ff\",\"purple\":\"#ff77cc\",\"cyan\":\"#44eeee\",\"white\":\"#f5f5da\",\"brightBlack\":\"#405570\",\"brightRed\":\"#ee6655\",\"brightGreen\":\"#99ee77\",\"brightYellow\":\"#ffff77\",\"brightBlue\":\"#77bbff\",\"brightPurple\":\"#aa88ff\",\"brightCyan\":\"#55ffbb\",\"brightWhite\":\"#ffffee\",\"background\":\"#202535\",\"foreground\":\"#ccced0\",\"cursorColor\":\"#ccced0\",\"selectionBackground\":\"#ccced0\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"sublee\",\"link\":\"https://github.com/sublee\"}]}},{\"name\":\"Subliminal\",\"black\":\"#7f7f7f\",\"red\":\"#e15a60\",\"green\":\"#a9cfa4\",\"yellow\":\"#ffe2a9\",\"blue\":\"#6699cc\",\"purple\":\"#f1a5ab\",\"cyan\":\"#5fb3b3\",\"white\":\"#d4d4d4\",\"brightBlack\":\"#7f7f7f\",\"brightRed\":\"#e15a60\",\"brightGreen\":\"#a9cfa4\",\"brightYellow\":\"#ffe2a9\",\"brightBlue\":\"#6699cc\",\"brightPurple\":\"#f1a5ab\",\"brightCyan\":\"#5fb3b3\",\"brightWhite\":\"#d4d4d4\",\"background\":\"#282c35\",\"foreground\":\"#d4d4d4\",\"cursorColor\":\"#c7c7c7\",\"selectionBackground\":\"#484e5b\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"gdsrosa\",\"link\":\"https://github.com/gdsrosa/subliminal-itermcolors\"}]}},{\"name\":\"summer-pop\",\"black\":\"#666666\",\"red\":\"#FF1E8E\",\"green\":\"#8EFF1E\",\"yellow\":\"#FFFB00\",\"blue\":\"#1E8EFF\",\"purple\":\"#E500E5\",\"cyan\":\"#00E5E5\",\"white\":\"#E5E5E5\",\"brightBlack\":\"#666666\",\"brightRed\":\"#FF1E8E\",\"brightGreen\":\"#8EFF1E\",\"brightYellow\":\"#FFFB00\",\"brightBlue\":\"#1E8EFF\",\"brightPurple\":\"#E500E5\",\"brightCyan\":\"#00E5E5\",\"brightWhite\":\"#E5E5E5\",\"foreground\":\"#FFFFFF\",\"background\":\"#272822\",\"cursorColor\":\"#FFFFFF\"},{\"name\":\"Sundried\",\"black\":\"#302b2a\",\"red\":\"#a7463d\",\"green\":\"#587744\",\"yellow\":\"#9d602a\",\"blue\":\"#485b98\",\"purple\":\"#864651\",\"cyan\":\"#9c814f\",\"white\":\"#c9c9c9\",\"brightBlack\":\"#4d4e48\",\"brightRed\":\"#aa000c\",\"brightGreen\":\"#128c21\",\"brightYellow\":\"#fc6a21\",\"brightBlue\":\"#7999f7\",\"brightPurple\":\"#fd8aa1\",\"brightCyan\":\"#fad484\",\"brightWhite\":\"#ffffff\",\"background\":\"#1a1818\",\"foreground\":\"#c9c9c9\",\"cursorColor\":\"#ffffff\",\"selectionBackground\":\"#302b2a\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"zdj\",\"link\":\"https://github.com/zdj/themes/tree/master/iterm2\"}]}},{\"name\":\"sweet-eliverlara\",\"black\":\"#282C34\",\"red\":\"#ED254E\",\"green\":\"#71F79F\",\"yellow\":\"#F9DC5C\",\"blue\":\"#7CB7FF\",\"purple\":\"#C74DED\",\"cyan\":\"#00C1E4\",\"white\":\"#DCDFE4\",\"brightBlack\":\"#282C34\",\"brightRed\":\"#ED254E\",\"brightGreen\":\"#71F79F\",\"brightYellow\":\"#F9DC5C\",\"brightBlue\":\"#7CB7FF\",\"brightPurple\":\"#C74DED\",\"brightCyan\":\"#00C1E4\",\"brightWhite\":\"#DCDFE4\",\"foreground\":\"#C3C7D1\",\"background\":\"#282C34\",\"cursorColor\":\"#C3C7D1\"},{\"name\":\"SweetTerminal\",\"black\":\"#3F3F54\",\"red\":\"#f60055\",\"green\":\"#06c993\",\"yellow\":\"#9700be\",\"blue\":\"#f69154\",\"purple\":\"#ec89cb\",\"cyan\":\"#60ADEC\",\"white\":\"#ABB2BF\",\"brightBlack\":\"#959DCB\",\"brightRed\":\"#f60055\",\"brightGreen\":\"#06c993\",\"brightYellow\":\"#9700be\",\"brightBlue\":\"#f69154\",\"brightPurple\":\"#ec89cb\",\"brightCyan\":\"#00dded\",\"brightWhite\":\"#ffffff\",\"foreground\":\"#ffffff\",\"background\":\"#222235\",\"cursorColor\":\"#ffffff\"},{\"name\":\"Symfonic\",\"black\":\"#000000\",\"red\":\"#dc322f\",\"green\":\"#56db3a\",\"yellow\":\"#ff8400\",\"blue\":\"#0084d4\",\"purple\":\"#b729d9\",\"cyan\":\"#ccccff\",\"white\":\"#ffffff\",\"brightBlack\":\"#1b1d21\",\"brightRed\":\"#dc322f\",\"brightGreen\":\"#56db3a\",\"brightYellow\":\"#ff8400\",\"brightBlue\":\"#0084d4\",\"brightPurple\":\"#b729d9\",\"brightCyan\":\"#ccccff\",\"brightWhite\":\"#ffffff\",\"background\":\"#000000\",\"foreground\":\"#ffffff\",\"cursorColor\":\"#dc322f\",\"selectionBackground\":\"#073642\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Symfony\",\"link\":\"http://symfony.com/doc/current/book/index.html\"}]}},{\"name\":\"Symphonic\",\"black\":\"#000000\",\"red\":\"#dc322f\",\"green\":\"#56db3a\",\"yellow\":\"#ff8400\",\"blue\":\"#0084d4\",\"purple\":\"#b729d9\",\"cyan\":\"#ccccff\",\"white\":\"#ffffff\",\"brightBlack\":\"#1b1d21\",\"brightRed\":\"#dc322f\",\"brightGreen\":\"#56db3a\",\"brightYellow\":\"#ff8400\",\"brightBlue\":\"#0084d4\",\"brightPurple\":\"#b729d9\",\"brightCyan\":\"#ccccff\",\"brightWhite\":\"#ffffff\",\"foreground\":\"#ffffff\",\"background\":\"#000000\",\"cursorColor\":\"#ffffff\"},{\"name\":\"synthwave\",\"black\":\"#000000\",\"red\":\"#f6188f\",\"green\":\"#1ebb2b\",\"yellow\":\"#fdf834\",\"blue\":\"#2186ec\",\"purple\":\"#f85a21\",\"cyan\":\"#12c3e2\",\"white\":\"#ffffff\",\"brightBlack\":\"#000000\",\"brightRed\":\"#f841a0\",\"brightGreen\":\"#25c141\",\"brightYellow\":\"#fdf454\",\"brightBlue\":\"#2f9ded\",\"brightPurple\":\"#f97137\",\"brightCyan\":\"#19cde6\",\"brightWhite\":\"#ffffff\",\"background\":\"#000000\",\"foreground\":\"#dad9c7\",\"cursorColor\":\"#19cde6\",\"selectionBackground\":\"#19cde6\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"brettstil\",\"link\":\"https://github.com/brettstil/\"}]}},{\"name\":\"synthwave-everything\",\"black\":\"#fefefe\",\"red\":\"#f97e72\",\"green\":\"#72f1b8\",\"yellow\":\"#fede5d\",\"blue\":\"#6d77b3\",\"purple\":\"#c792ea\",\"cyan\":\"#f772e0\",\"white\":\"#fefefe\",\"brightBlack\":\"#fefefe\",\"brightRed\":\"#f88414\",\"brightGreen\":\"#72f1b8\",\"brightYellow\":\"#fff951\",\"brightBlue\":\"#36f9f6\",\"brightPurple\":\"#e1acff\",\"brightCyan\":\"#f92aad\",\"brightWhite\":\"#fefefe\",\"background\":\"#2a2139\",\"foreground\":\"#f0eff1\",\"cursorColor\":\"#72f1b8\",\"selectionBackground\":\"#181521\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"smithbm2316\",\"link\":\"https://github.com/smithbm2316\"},{\"name\":\"robb0wen\",\"link\":\"https://github.com/robb0wen\"}]}},{\"name\":\"Tango Adapted\",\"black\":\"#000000\",\"red\":\"#ff0000\",\"green\":\"#59d600\",\"yellow\":\"#f0cb00\",\"blue\":\"#00a2ff\",\"purple\":\"#c17ecc\",\"cyan\":\"#00d0d6\",\"white\":\"#e6ebe1\",\"brightBlack\":\"#8f928b\",\"brightRed\":\"#ff0013\",\"brightGreen\":\"#93ff00\",\"brightYellow\":\"#fff121\",\"brightBlue\":\"#88c9ff\",\"brightPurple\":\"#e9a7e1\",\"brightCyan\":\"#00feff\",\"brightWhite\":\"#f6f6f4\",\"background\":\"#ffffff\",\"foreground\":\"#000000\",\"cursorColor\":\"#000000\",\"selectionBackground\":\"#c1deff\",\"meta\":{\"isDark\":false,\"credits\":[{\"name\":\"crowsonkb\",\"link\":\"https://github.com/crowsonkb\"},{\"name\":\"iterm_schemer\",\"link\":\"https://github.com/crowsonkb/iterm_schemer\"}]}},{\"name\":\"Tango Half Adapted\",\"black\":\"#000000\",\"red\":\"#ff0000\",\"green\":\"#4cc300\",\"yellow\":\"#e2c000\",\"blue\":\"#008ef6\",\"purple\":\"#a96cb3\",\"cyan\":\"#00bdc3\",\"white\":\"#e0e5db\",\"brightBlack\":\"#797d76\",\"brightRed\":\"#ff0013\",\"brightGreen\":\"#8af600\",\"brightYellow\":\"#ffec00\",\"brightBlue\":\"#76bfff\",\"brightPurple\":\"#d898d1\",\"brightCyan\":\"#00f6fa\",\"brightWhite\":\"#f4f4f2\",\"background\":\"#ffffff\",\"foreground\":\"#000000\",\"cursorColor\":\"#000000\",\"selectionBackground\":\"#c1deff\",\"meta\":{\"isDark\":false,\"credits\":[{\"name\":\"crowsonkb\",\"link\":\"https://github.com/crowsonkb\"},{\"name\":\"iterm_schemer\",\"link\":\"https://github.com/crowsonkb/iterm_schemer\"}]}},{\"name\":\"Teerb\",\"black\":\"#1c1c1c\",\"red\":\"#d68686\",\"green\":\"#aed686\",\"yellow\":\"#d7af87\",\"blue\":\"#86aed6\",\"purple\":\"#d6aed6\",\"cyan\":\"#8adbb4\",\"white\":\"#d0d0d0\",\"brightBlack\":\"#1c1c1c\",\"brightRed\":\"#d68686\",\"brightGreen\":\"#aed686\",\"brightYellow\":\"#e4c9af\",\"brightBlue\":\"#86aed6\",\"brightPurple\":\"#d6aed6\",\"brightCyan\":\"#b1e7dd\",\"brightWhite\":\"#efefef\",\"background\":\"#262626\",\"foreground\":\"#d0d0d0\",\"cursorColor\":\"#e4c9af\",\"selectionBackground\":\"#4d4d4d\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Teerb\",\"link\":\"https://gist.github.com/teerb/1360453\"}]}},{\"name\":\"Tender\",\"black\":\"#1d1d1d\",\"red\":\"#c5152f\",\"green\":\"#c9d05c\",\"yellow\":\"#ffc24b\",\"blue\":\"#b3deef\",\"purple\":\"#d3b987\",\"cyan\":\"#73cef4\",\"white\":\"#eeeeee\",\"brightBlack\":\"#323232\",\"brightRed\":\"#f43753\",\"brightGreen\":\"#d9e066\",\"brightYellow\":\"#facc72\",\"brightBlue\":\"#c0eafb\",\"brightPurple\":\"#efd093\",\"brightCyan\":\"#a1d6ec\",\"brightWhite\":\"#ffffff\",\"foreground\":\"#EEEEEE\",\"background\":\"#282828\",\"cursorColor\":\"#EEEEEE\"},{\"name\":\"Terminal Basic\",\"black\":\"#000000\",\"red\":\"#990000\",\"green\":\"#00a600\",\"yellow\":\"#999900\",\"blue\":\"#0000b2\",\"purple\":\"#b200b2\",\"cyan\":\"#00a6b2\",\"white\":\"#bfbfbf\",\"brightBlack\":\"#666666\",\"brightRed\":\"#e50000\",\"brightGreen\":\"#00d900\",\"brightYellow\":\"#e5e500\",\"brightBlue\":\"#0000ff\",\"brightPurple\":\"#e500e5\",\"brightCyan\":\"#00e5e5\",\"brightWhite\":\"#e5e5e5\",\"background\":\"#ffffff\",\"foreground\":\"#000000\",\"cursorColor\":\"#7f7f7f\",\"selectionBackground\":\"#a4c9ff\",\"meta\":{\"isDark\":false,\"credits\":null}},{\"name\":\"TerminixDark\",\"black\":\"#282a2e\",\"red\":\"#a54242\",\"green\":\"#a1b56c\",\"yellow\":\"#de935f\",\"blue\":\"#225555\",\"purple\":\"#85678f\",\"cyan\":\"#5e8d87\",\"white\":\"#777777\",\"brightBlack\":\"#373b41\",\"brightRed\":\"#c63535\",\"brightGreen\":\"#608360\",\"brightYellow\":\"#fa805a\",\"brightBlue\":\"#449da1\",\"brightPurple\":\"#ba8baf\",\"brightCyan\":\"#86c1b9\",\"brightWhite\":\"#c5c8c6\",\"foreground\":\"#868A8C\",\"background\":\"#091116\",\"cursorColor\":\"#868A8C\"},{\"name\":\"Thayer Bright\",\"black\":\"#1b1d1e\",\"red\":\"#f92672\",\"green\":\"#4df840\",\"yellow\":\"#f4fd22\",\"blue\":\"#2757d6\",\"purple\":\"#8c54fe\",\"cyan\":\"#38c8b5\",\"white\":\"#ccccc6\",\"brightBlack\":\"#505354\",\"brightRed\":\"#ff5995\",\"brightGreen\":\"#b6e354\",\"brightYellow\":\"#feed6c\",\"brightBlue\":\"#3f78ff\",\"brightPurple\":\"#9e6ffe\",\"brightCyan\":\"#23cfd5\",\"brightWhite\":\"#f8f8f2\",\"background\":\"#1b1d1e\",\"foreground\":\"#f8f8f8\",\"cursorColor\":\"#fc971f\",\"selectionBackground\":\"#4d4d4d\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"t3chnoboy\",\"link\":\"https://github.com/t3chnoboy/thayer-bright-iTerm\"}]}},{\"name\":\"The Hulk\",\"black\":\"#1b1d1e\",\"red\":\"#269d1b\",\"green\":\"#13ce30\",\"yellow\":\"#63e457\",\"blue\":\"#2525f5\",\"purple\":\"#641f74\",\"cyan\":\"#378ca9\",\"white\":\"#d9d8d1\",\"brightBlack\":\"#505354\",\"brightRed\":\"#8dff2a\",\"brightGreen\":\"#48ff77\",\"brightYellow\":\"#3afe16\",\"brightBlue\":\"#506b95\",\"brightPurple\":\"#72589d\",\"brightCyan\":\"#4085a6\",\"brightWhite\":\"#e5e6e1\",\"background\":\"#1b1d1e\",\"foreground\":\"#b5b5b5\",\"cursorColor\":\"#16b61b\",\"selectionBackground\":\"#4d504c\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"pyrophos\",\"link\":\"https://github.com/pyrophos\"}]}},{\"name\":\"Tin\",\"black\":\"#000000\",\"red\":\"#8d534e\",\"green\":\"#4e8d53\",\"yellow\":\"#888d4e\",\"blue\":\"#534e8d\",\"purple\":\"#8d4e88\",\"cyan\":\"#4e888d\",\"white\":\"#ffffff\",\"brightBlack\":\"#000000\",\"brightRed\":\"#b57d78\",\"brightGreen\":\"#78b57d\",\"brightYellow\":\"#b0b578\",\"brightBlue\":\"#7d78b5\",\"brightPurple\":\"#b578b0\",\"brightCyan\":\"#78b0b5\",\"brightWhite\":\"#ffffff\",\"foreground\":\"#ffffff\",\"background\":\"#2e2e35\",\"cursorColor\":\"#ffffff\"},{\"name\":\"Tinacious Design (Dark)\",\"black\":\"#1d1d26\",\"red\":\"#ff3399\",\"green\":\"#00d364\",\"yellow\":\"#ffcc66\",\"blue\":\"#00cbff\",\"purple\":\"#cc66ff\",\"cyan\":\"#00ceca\",\"white\":\"#cbcbf0\",\"brightBlack\":\"#636667\",\"brightRed\":\"#ff2f92\",\"brightGreen\":\"#00d364\",\"brightYellow\":\"#ffd479\",\"brightBlue\":\"#00cbff\",\"brightPurple\":\"#d783ff\",\"brightCyan\":\"#00d5d4\",\"brightWhite\":\"#d5d6f3\",\"background\":\"#1d1d26\",\"foreground\":\"#cbcbf0\",\"cursorColor\":\"#cbcbf0\",\"selectionBackground\":\"#ff3399\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Tina Holly\",\"link\":\"https://tinaciousdesign.com\"}]}},{\"name\":\"Tinacious Design (Light)\",\"black\":\"#1d1d26\",\"red\":\"#ff3399\",\"green\":\"#00d364\",\"yellow\":\"#ffcc66\",\"blue\":\"#00cbff\",\"purple\":\"#cc66ff\",\"cyan\":\"#00ceca\",\"white\":\"#cbcbf0\",\"brightBlack\":\"#636667\",\"brightRed\":\"#ff2f92\",\"brightGreen\":\"#00d364\",\"brightYellow\":\"#ffd479\",\"brightBlue\":\"#00cbff\",\"brightPurple\":\"#d783ff\",\"brightCyan\":\"#00d5d4\",\"brightWhite\":\"#d5d6f3\",\"background\":\"#f8f8ff\",\"foreground\":\"#1d1d26\",\"cursorColor\":\"#cbcbf0\",\"selectionBackground\":\"#ff3399\",\"meta\":{\"isDark\":false,\"credits\":[{\"name\":\"Tina Holly\",\"link\":\"https://tinaciousdesign.com\"}]}},{\"name\":\"TokyoNight\",\"black\":\"#363b54\",\"red\":\"#f7768e\",\"green\":\"#41a6b5\",\"yellow\":\"#e0af68\",\"blue\":\"#7aa2f7\",\"purple\":\"#bb9af7\",\"cyan\":\"#7dcfff\",\"white\":\"#787c99\",\"brightBlack\":\"#363b54\",\"brightRed\":\"#f7768e\",\"brightGreen\":\"#41a6b5\",\"brightYellow\":\"#e0af68\",\"brightBlue\":\"#7aa2f7\",\"brightPurple\":\"#bb9af7\",\"brightCyan\":\"#7dcfff\",\"brightWhite\":\"#acb0d0\",\"background\":\"#16161e\",\"foreground\":\"#787c99\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"TokyoNightLight\",\"black\":\"#0f0f14\",\"red\":\"#8c4351\",\"green\":\"#33635c\",\"yellow\":\"#8f5e15\",\"blue\":\"#34548a\",\"purple\":\"#5a4a78\",\"cyan\":\"#0f4b6e\",\"white\":\"#828594\",\"brightBlack\":\"#0f0f14\",\"brightRed\":\"#8c4351\",\"brightGreen\":\"#33635c\",\"brightYellow\":\"#8f5e15\",\"brightBlue\":\"#34548a\",\"brightPurple\":\"#5a4a78\",\"brightCyan\":\"#0f4b6e\",\"brightWhite\":\"#828594\",\"background\":\"#cbccd1\",\"foreground\":\"#4c505e\",\"meta\":{\"isDark\":false,\"credits\":null}},{\"name\":\"TokyoNightStorm\",\"black\":\"#3b4261\",\"red\":\"#f7768e\",\"green\":\"#73daca\",\"yellow\":\"#e0af68\",\"blue\":\"#7aa2f7\",\"purple\":\"#bb9af7\",\"cyan\":\"#7dcfff\",\"white\":\"#7982a9\",\"brightBlack\":\"#3b4261\",\"brightRed\":\"#f7768e\",\"brightGreen\":\"#73daca\",\"brightYellow\":\"#e0af68\",\"brightBlue\":\"#7aa2f7\",\"brightPurple\":\"#bb9af7\",\"brightCyan\":\"#7dcfff\",\"brightWhite\":\"#a9b1d6\",\"background\":\"#1f2335\",\"foreground\":\"#7982a9\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"Tomorrow\",\"black\":\"#000000\",\"red\":\"#c82829\",\"green\":\"#718c00\",\"yellow\":\"#eab700\",\"blue\":\"#4271ae\",\"purple\":\"#8959a8\",\"cyan\":\"#3e999f\",\"white\":\"#ffffff\",\"brightBlack\":\"#000000\",\"brightRed\":\"#c82829\",\"brightGreen\":\"#718c00\",\"brightYellow\":\"#eab700\",\"brightBlue\":\"#4271ae\",\"brightPurple\":\"#8959a8\",\"brightCyan\":\"#3e999f\",\"brightWhite\":\"#ffffff\",\"background\":\"#ffffff\",\"foreground\":\"#4d4d4c\",\"cursorColor\":\"#4d4d4c\",\"selectionBackground\":\"#d6d6d6\",\"meta\":{\"isDark\":false,\"credits\":[{\"name\":\"chriskempson\",\"link\":\"https://github.com/chriskempson/tomorrow-theme/tree/master/iTerm2\"}]}},{\"name\":\"Tomorrow Night\",\"black\":\"#000000\",\"red\":\"#cc6666\",\"green\":\"#b5bd68\",\"yellow\":\"#f0c674\",\"blue\":\"#81a2be\",\"purple\":\"#b294bb\",\"cyan\":\"#8abeb7\",\"white\":\"#ffffff\",\"brightBlack\":\"#000000\",\"brightRed\":\"#cc6666\",\"brightGreen\":\"#b5bd68\",\"brightYellow\":\"#f0c674\",\"brightBlue\":\"#81a2be\",\"brightPurple\":\"#b294bb\",\"brightCyan\":\"#8abeb7\",\"brightWhite\":\"#ffffff\",\"background\":\"#1d1f21\",\"foreground\":\"#c5c8c6\",\"cursorColor\":\"#c5c8c6\",\"selectionBackground\":\"#373b41\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"ashwinv11\",\"link\":\"https://github.com/ashwinv11/\"}]}},{\"name\":\"Tomorrow Night Blue\",\"black\":\"#000000\",\"red\":\"#ff9da4\",\"green\":\"#d1f1a9\",\"yellow\":\"#ffeead\",\"blue\":\"#bbdaff\",\"purple\":\"#ebbbff\",\"cyan\":\"#99ffff\",\"white\":\"#ffffff\",\"brightBlack\":\"#000000\",\"brightRed\":\"#ff9da4\",\"brightGreen\":\"#d1f1a9\",\"brightYellow\":\"#ffeead\",\"brightBlue\":\"#bbdaff\",\"brightPurple\":\"#ebbbff\",\"brightCyan\":\"#99ffff\",\"brightWhite\":\"#ffffff\",\"background\":\"#002451\",\"foreground\":\"#ffffff\",\"cursorColor\":\"#ffffff\",\"selectionBackground\":\"#003f8e\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"Tomorrow Night Bright\",\"black\":\"#000000\",\"red\":\"#d54e53\",\"green\":\"#b9ca4a\",\"yellow\":\"#e7c547\",\"blue\":\"#7aa6da\",\"purple\":\"#c397d8\",\"cyan\":\"#70c0b1\",\"white\":\"#ffffff\",\"brightBlack\":\"#000000\",\"brightRed\":\"#d54e53\",\"brightGreen\":\"#b9ca4a\",\"brightYellow\":\"#e7c547\",\"brightBlue\":\"#7aa6da\",\"brightPurple\":\"#c397d8\",\"brightCyan\":\"#70c0b1\",\"brightWhite\":\"#ffffff\",\"background\":\"#000000\",\"foreground\":\"#eaeaea\",\"cursorColor\":\"#eaeaea\",\"selectionBackground\":\"#424242\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"Tomorrow Night Burns\",\"black\":\"#252525\",\"red\":\"#832e31\",\"green\":\"#a63c40\",\"yellow\":\"#d3494e\",\"blue\":\"#fc595f\",\"purple\":\"#df9395\",\"cyan\":\"#ba8586\",\"white\":\"#f5f5f5\",\"brightBlack\":\"#5d6f71\",\"brightRed\":\"#832e31\",\"brightGreen\":\"#a63c40\",\"brightYellow\":\"#d2494e\",\"brightBlue\":\"#fc595f\",\"brightPurple\":\"#df9395\",\"brightCyan\":\"#ba8586\",\"brightWhite\":\"#f5f5f5\",\"background\":\"#151515\",\"foreground\":\"#a1b0b8\",\"cursorColor\":\"#ff443e\",\"selectionBackground\":\"#b0bec5\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"ashwinv11\",\"link\":\"https://github.com/ashwinv11/\"}]}},{\"name\":\"Tomorrow Night Eighties\",\"black\":\"#000000\",\"red\":\"#f2777a\",\"green\":\"#99cc99\",\"yellow\":\"#ffcc66\",\"blue\":\"#6699cc\",\"purple\":\"#cc99cc\",\"cyan\":\"#66cccc\",\"white\":\"#ffffff\",\"brightBlack\":\"#000000\",\"brightRed\":\"#f2777a\",\"brightGreen\":\"#99cc99\",\"brightYellow\":\"#ffcc66\",\"brightBlue\":\"#6699cc\",\"brightPurple\":\"#cc99cc\",\"brightCyan\":\"#66cccc\",\"brightWhite\":\"#ffffff\",\"background\":\"#2d2d2d\",\"foreground\":\"#cccccc\",\"cursorColor\":\"#cccccc\",\"selectionBackground\":\"#515151\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"ToyChest\",\"black\":\"#2c3f58\",\"red\":\"#be2d26\",\"green\":\"#1a9172\",\"yellow\":\"#db8e27\",\"blue\":\"#325d96\",\"purple\":\"#8a5edc\",\"cyan\":\"#35a08f\",\"white\":\"#23d183\",\"brightBlack\":\"#336889\",\"brightRed\":\"#dd5944\",\"brightGreen\":\"#31d07b\",\"brightYellow\":\"#e7d84b\",\"brightBlue\":\"#34a6da\",\"brightPurple\":\"#ae6bdc\",\"brightCyan\":\"#42c3ae\",\"brightWhite\":\"#d5d5d5\",\"background\":\"#24364b\",\"foreground\":\"#31d07b\",\"cursorColor\":\"#d5d5d5\",\"selectionBackground\":\"#5f217a\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"zdj\",\"link\":\"https://github.com/zdj/themes/tree/master/iterm2\"}]}},{\"name\":\"Treehouse\",\"black\":\"#321300\",\"red\":\"#b2270e\",\"green\":\"#44a900\",\"yellow\":\"#aa820c\",\"blue\":\"#58859a\",\"purple\":\"#97363d\",\"cyan\":\"#b25a1e\",\"white\":\"#786b53\",\"brightBlack\":\"#433626\",\"brightRed\":\"#ed5d20\",\"brightGreen\":\"#55f238\",\"brightYellow\":\"#f2b732\",\"brightBlue\":\"#85cfed\",\"brightPurple\":\"#e14c5a\",\"brightCyan\":\"#f07d14\",\"brightWhite\":\"#ffc800\",\"background\":\"#191919\",\"foreground\":\"#786b53\",\"cursorColor\":\"#fac814\",\"selectionBackground\":\"#786b53\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"zdj\",\"link\":\"https://github.com/zdj/themes/tree/master/iterm2\"}]}},{\"name\":\"Twilight\",\"black\":\"#141414\",\"red\":\"#c06d44\",\"green\":\"#afb97a\",\"yellow\":\"#c2a86c\",\"blue\":\"#44474a\",\"purple\":\"#b4be7c\",\"cyan\":\"#778385\",\"white\":\"#ffffd4\",\"brightBlack\":\"#262626\",\"brightRed\":\"#de7c4c\",\"brightGreen\":\"#ccd88c\",\"brightYellow\":\"#e2c47e\",\"brightBlue\":\"#5a5e62\",\"brightPurple\":\"#d0dc8e\",\"brightCyan\":\"#8a989b\",\"brightWhite\":\"#ffffd4\",\"background\":\"#141414\",\"foreground\":\"#ffffd4\",\"cursorColor\":\"#ffffff\",\"selectionBackground\":\"#313131\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"stefri\",\"link\":\"https://gist.github.com/stefri/1183140\"}]}},{\"name\":\"Ubuntu\",\"black\":\"#2e3436\",\"red\":\"#cc0000\",\"green\":\"#4e9a06\",\"yellow\":\"#c4a000\",\"blue\":\"#3465a4\",\"purple\":\"#75507b\",\"cyan\":\"#06989a\",\"white\":\"#d3d7cf\",\"brightBlack\":\"#555753\",\"brightRed\":\"#ef2929\",\"brightGreen\":\"#8ae234\",\"brightYellow\":\"#fce94f\",\"brightBlue\":\"#729fcf\",\"brightPurple\":\"#ad7fa8\",\"brightCyan\":\"#34e2e2\",\"brightWhite\":\"#eeeeec\",\"background\":\"#300a24\",\"foreground\":\"#eeeeec\",\"cursorColor\":\"#bbbbbb\",\"selectionBackground\":\"#b5d5ff\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Maximus\",\"link\":\"http://superuser.com/questions/497240/ubuntu-purple-terminal-colors-in-conemu\"},{\"name\":\"stepin\",\"link\":\"https://github.com/stepin\"}]}},{\"name\":\"UltraViolent\",\"black\":\"#242728\",\"red\":\"#ff0090\",\"green\":\"#b6ff00\",\"yellow\":\"#fff727\",\"blue\":\"#47e0fb\",\"purple\":\"#d731ff\",\"cyan\":\"#0effbb\",\"white\":\"#e1e1e1\",\"brightBlack\":\"#636667\",\"brightRed\":\"#fb58b4\",\"brightGreen\":\"#deff8c\",\"brightYellow\":\"#ebe087\",\"brightBlue\":\"#7fecff\",\"brightPurple\":\"#e681ff\",\"brightCyan\":\"#69fcd3\",\"brightWhite\":\"#f9f9f5\",\"background\":\"#242728\",\"foreground\":\"#c1c1c1\",\"cursorColor\":\"#c1c1c1\",\"selectionBackground\":\"#574c49\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"UnderTheSea\",\"black\":\"#022026\",\"red\":\"#b2302d\",\"green\":\"#00a941\",\"yellow\":\"#59819c\",\"blue\":\"#459a86\",\"purple\":\"#00599d\",\"cyan\":\"#5d7e19\",\"white\":\"#405555\",\"brightBlack\":\"#384451\",\"brightRed\":\"#ff4242\",\"brightGreen\":\"#2aea5e\",\"brightYellow\":\"#8ed4fd\",\"brightBlue\":\"#61d5ba\",\"brightPurple\":\"#1298ff\",\"brightCyan\":\"#98d028\",\"brightWhite\":\"#58fbd6\",\"background\":\"#011116\",\"foreground\":\"#ffffff\",\"cursorColor\":\"#4afcd6\",\"selectionBackground\":\"#415555\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"peterpme\",\"link\":\"https://github.com/peterpme\"}]}},{\"name\":\"Unikitty\",\"black\":\"#0c0c0c\",\"red\":\"#a80f20\",\"green\":\"#bafc8b\",\"yellow\":\"#eedf4b\",\"blue\":\"#145fcd\",\"purple\":\"#ff36a2\",\"cyan\":\"#6bd1bc\",\"white\":\"#e2d7e1\",\"brightBlack\":\"#434343\",\"brightRed\":\"#d91329\",\"brightGreen\":\"#d3ffaf\",\"brightYellow\":\"#ffef50\",\"brightBlue\":\"#0075ea\",\"brightPurple\":\"#fdd5e5\",\"brightCyan\":\"#79ecd5\",\"brightWhite\":\"#fff3fe\",\"background\":\"#ff8cd9\",\"foreground\":\"#0b0b0b\",\"cursorColor\":\"#bafc8b\",\"selectionBackground\":\"#3ea9fe\",\"meta\":{\"isDark\":false,\"credits\":[{\"name\":\"jakebathman\",\"link\":\"https://github.com/jakebathman\"}]}},{\"name\":\"Ura\",\"black\":\"#000000\",\"red\":\"#c21b6f\",\"green\":\"#6fc21b\",\"yellow\":\"#c26f1b\",\"blue\":\"#1b6fc2\",\"purple\":\"#6f1bc2\",\"cyan\":\"#1bc26f\",\"white\":\"#808080\",\"brightBlack\":\"#808080\",\"brightRed\":\"#ee84b9\",\"brightGreen\":\"#b9ee84\",\"brightYellow\":\"#eeb984\",\"brightBlue\":\"#84b9ee\",\"brightPurple\":\"#b984ee\",\"brightCyan\":\"#84eeb9\",\"brightWhite\":\"#e5e5e5\",\"foreground\":\"#23476a\",\"background\":\"#feffee\",\"cursorColor\":\"#23476a\"},{\"name\":\"Urple\",\"black\":\"#000000\",\"red\":\"#b0425b\",\"green\":\"#37a415\",\"yellow\":\"#ad5c42\",\"blue\":\"#564d9b\",\"purple\":\"#6c3ca1\",\"cyan\":\"#808080\",\"white\":\"#87799c\",\"brightBlack\":\"#5d3225\",\"brightRed\":\"#ff6388\",\"brightGreen\":\"#29e620\",\"brightYellow\":\"#f08161\",\"brightBlue\":\"#867aed\",\"brightPurple\":\"#a05eee\",\"brightCyan\":\"#eaeaea\",\"brightWhite\":\"#bfa3ff\",\"background\":\"#1b1b23\",\"foreground\":\"#877a9b\",\"cursorColor\":\"#a063eb\",\"selectionBackground\":\"#a063eb\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"zdj\",\"link\":\"https://github.com/zdj/themes/tree/master/iterm2\"}]}},{\"name\":\"Vag\",\"black\":\"#303030\",\"red\":\"#a87139\",\"green\":\"#39a871\",\"yellow\":\"#71a839\",\"blue\":\"#7139a8\",\"purple\":\"#a83971\",\"cyan\":\"#3971a8\",\"white\":\"#8a8a8a\",\"brightBlack\":\"#494949\",\"brightRed\":\"#b0763b\",\"brightGreen\":\"#3bb076\",\"brightYellow\":\"#76b03b\",\"brightBlue\":\"#763bb0\",\"brightPurple\":\"#b03b76\",\"brightCyan\":\"#3b76b0\",\"brightWhite\":\"#cfcfcf\",\"foreground\":\"#d9e6f2\",\"background\":\"#191f1d\",\"cursorColor\":\"#d9e6f2\"},{\"name\":\"Vaughn\",\"black\":\"#25234f\",\"red\":\"#705050\",\"green\":\"#60b48a\",\"yellow\":\"#dfaf8f\",\"blue\":\"#5555ff\",\"purple\":\"#f08cc3\",\"cyan\":\"#8cd0d3\",\"white\":\"#709080\",\"brightBlack\":\"#709080\",\"brightRed\":\"#dca3a3\",\"brightGreen\":\"#60b48a\",\"brightYellow\":\"#f0dfaf\",\"brightBlue\":\"#5555ff\",\"brightPurple\":\"#ec93d3\",\"brightCyan\":\"#93e0e3\",\"brightWhite\":\"#ffffff\",\"background\":\"#25234f\",\"foreground\":\"#dcdccc\",\"cursorColor\":\"#ff5555\",\"selectionBackground\":\"#b5d5ff\",\"meta\":{\"isDark\":true,\"credits\":null}},{\"name\":\"VibrantInk\",\"black\":\"#878787\",\"red\":\"#ff6600\",\"green\":\"#ccff04\",\"yellow\":\"#ffcc00\",\"blue\":\"#44b4cc\",\"purple\":\"#9933cc\",\"cyan\":\"#44b4cc\",\"white\":\"#f5f5f5\",\"brightBlack\":\"#555555\",\"brightRed\":\"#ff0000\",\"brightGreen\":\"#00ff00\",\"brightYellow\":\"#ffff00\",\"brightBlue\":\"#0000ff\",\"brightPurple\":\"#ff00ff\",\"brightCyan\":\"#00ffff\",\"brightWhite\":\"#e5e5e5\",\"background\":\"#000000\",\"foreground\":\"#ffffff\",\"cursorColor\":\"#ffffff\",\"selectionBackground\":\"#b5d5ff\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"asanghi\",\"link\":\"https://github.com/asanghi/vibrantinklion\"}]}},{\"name\":\"Violet Dark\",\"black\":\"#56595c\",\"red\":\"#c94c22\",\"green\":\"#85981c\",\"yellow\":\"#b4881d\",\"blue\":\"#2e8bce\",\"purple\":\"#d13a82\",\"cyan\":\"#32a198\",\"white\":\"#c9c6bd\",\"brightBlack\":\"#45484b\",\"brightRed\":\"#bd3613\",\"brightGreen\":\"#738a04\",\"brightYellow\":\"#a57705\",\"brightBlue\":\"#2176c7\",\"brightPurple\":\"#c61c6f\",\"brightCyan\":\"#259286\",\"brightWhite\":\"#c9c6bd\",\"background\":\"#1c1d1f\",\"foreground\":\"#708284\",\"cursorColor\":\"#708284\",\"selectionBackground\":\"#595ab7\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"ashfinal\",\"link\":\"https://github.com/ashfinal/vim-colors-violet\"}]}},{\"name\":\"Violet Light\",\"black\":\"#56595c\",\"red\":\"#c94c22\",\"green\":\"#85981c\",\"yellow\":\"#b4881d\",\"blue\":\"#2e8bce\",\"purple\":\"#d13a82\",\"cyan\":\"#32a198\",\"white\":\"#d3d0c9\",\"brightBlack\":\"#45484b\",\"brightRed\":\"#bd3613\",\"brightGreen\":\"#738a04\",\"brightYellow\":\"#a57705\",\"brightBlue\":\"#2176c7\",\"brightPurple\":\"#c61c6f\",\"brightCyan\":\"#259286\",\"brightWhite\":\"#c9c6bd\",\"background\":\"#fcf4dc\",\"foreground\":\"#536870\",\"cursorColor\":\"#536870\",\"selectionBackground\":\"#595ab7\",\"meta\":{\"isDark\":false,\"credits\":[{\"name\":\"ashfinal\",\"link\":\"https://github.com/ashfinal/vim-colors-violet\"}]}},{\"name\":\"VSCodeDark+\",\"black\":\"#6A787A\",\"red\":\"#E9653B\",\"green\":\"#39E9A8\",\"yellow\":\"#E5B684\",\"blue\":\"#44AAE6\",\"purple\":\"#E17599\",\"cyan\":\"#3DD5E7\",\"white\":\"#C3DDE1\",\"brightBlack\":\"#598489\",\"brightRed\":\"#E65029\",\"brightGreen\":\"#00FF9A\",\"brightYellow\":\"#E89440\",\"brightBlue\":\"#009AFB\",\"brightPurple\":\"#FF578F\",\"brightCyan\":\"#5FFFFF\",\"brightWhite\":\"#D9FBFF\",\"foreground\":\"#CCCCCC\",\"background\":\"#1E1E1E\",\"cursorColor\":\"#CCCCCC\"},{\"name\":\"VSCodeLight+\",\"black\":\"#020202\",\"red\":\"#CD3232\",\"green\":\"#00BC00\",\"yellow\":\"#A5A900\",\"blue\":\"#0752A8\",\"purple\":\"#BC05BC\",\"cyan\":\"#0598BC\",\"white\":\"#343434\",\"brightBlack\":\"#5E5E5E\",\"brightRed\":\"#cd3333\",\"brightGreen\":\"#1BCE1A\",\"brightYellow\":\"#ADBB5B\",\"brightBlue\":\"#0752A8\",\"brightPurple\":\"#C451CE\",\"brightCyan\":\"#52A8C7\",\"brightWhite\":\"#A6A3A6\",\"foreground\":\"#020202\",\"background\":\"#f9f9f9\",\"cursorColor\":\"#020202\"},{\"name\":\"WarmNeon\",\"black\":\"#000000\",\"red\":\"#e24346\",\"green\":\"#39b13a\",\"yellow\":\"#dae145\",\"blue\":\"#4261c5\",\"purple\":\"#f920fb\",\"cyan\":\"#2abbd4\",\"white\":\"#d0b8a3\",\"brightBlack\":\"#fefcfc\",\"brightRed\":\"#e97071\",\"brightGreen\":\"#9cc090\",\"brightYellow\":\"#ddda7a\",\"brightBlue\":\"#7b91d6\",\"brightPurple\":\"#f674ba\",\"brightCyan\":\"#5ed1e5\",\"brightWhite\":\"#d8c8bb\",\"background\":\"#404040\",\"foreground\":\"#afdab6\",\"cursorColor\":\"#30ff24\",\"selectionBackground\":\"#b0ad21\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"PyCharm\",\"link\":\"http://www.jetbrains.com/pycharm/\"},{\"name\":\"firewut\",\"link\":\"https://github.com/firewut\"}]}},{\"name\":\"Wez\",\"black\":\"#000000\",\"red\":\"#cc5555\",\"green\":\"#55cc55\",\"yellow\":\"#cdcd55\",\"blue\":\"#5555cc\",\"purple\":\"#cc55cc\",\"cyan\":\"#7acaca\",\"white\":\"#cccccc\",\"brightBlack\":\"#555555\",\"brightRed\":\"#ff5555\",\"brightGreen\":\"#55ff55\",\"brightYellow\":\"#ffff55\",\"brightBlue\":\"#5555ff\",\"brightPurple\":\"#ff55ff\",\"brightCyan\":\"#55ffff\",\"brightWhite\":\"#ffffff\",\"background\":\"#000000\",\"foreground\":\"#b3b3b3\",\"cursorColor\":\"#53ae71\",\"selectionBackground\":\"#4d52f8\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"wez\",\"link\":\"https://gist.github.com/wez/850268/\"}]}},{\"name\":\"Whimsy\",\"black\":\"#535178\",\"red\":\"#ef6487\",\"green\":\"#5eca89\",\"yellow\":\"#fdd877\",\"blue\":\"#65aef7\",\"purple\":\"#aa7ff0\",\"cyan\":\"#43c1be\",\"white\":\"#ffffff\",\"brightBlack\":\"#535178\",\"brightRed\":\"#ef6487\",\"brightGreen\":\"#5eca89\",\"brightYellow\":\"#fdd877\",\"brightBlue\":\"#65aef7\",\"brightPurple\":\"#aa7ff0\",\"brightCyan\":\"#43c1be\",\"brightWhite\":\"#ffffff\",\"background\":\"#29283b\",\"foreground\":\"#b3b0d6\",\"cursorColor\":\"#b3b0d6\",\"selectionBackground\":\"#3d3c58\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Rod\",\"link\":\"https://github.com/rod\"}]}},{\"name\":\"WildCherry\",\"black\":\"#000507\",\"red\":\"#d94085\",\"green\":\"#2ab250\",\"yellow\":\"#ffd16f\",\"blue\":\"#883cdc\",\"purple\":\"#ececec\",\"cyan\":\"#c1b8b7\",\"white\":\"#fff8de\",\"brightBlack\":\"#009cc9\",\"brightRed\":\"#da6bac\",\"brightGreen\":\"#f4dca5\",\"brightYellow\":\"#eac066\",\"brightBlue\":\"#308cba\",\"brightPurple\":\"#ae636b\",\"brightCyan\":\"#ff919d\",\"brightWhite\":\"#e4838d\",\"background\":\"#1f1726\",\"foreground\":\"#dafaff\",\"cursorColor\":\"#dd00ff\",\"selectionBackground\":\"#002831\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"mashaal\",\"link\":\"https://github.com/mashaal/wild-cherry\"}]}},{\"name\":\"Wombat\",\"black\":\"#000000\",\"red\":\"#ff615a\",\"green\":\"#b1e969\",\"yellow\":\"#ebd99c\",\"blue\":\"#5da9f6\",\"purple\":\"#e86aff\",\"cyan\":\"#82fff7\",\"white\":\"#dedacf\",\"brightBlack\":\"#313131\",\"brightRed\":\"#f58c80\",\"brightGreen\":\"#ddf88f\",\"brightYellow\":\"#eee5b2\",\"brightBlue\":\"#a5c7ff\",\"brightPurple\":\"#ddaaff\",\"brightCyan\":\"#b7fff9\",\"brightWhite\":\"#ffffff\",\"background\":\"#171717\",\"foreground\":\"#dedacf\",\"cursorColor\":\"#bbbbbb\",\"selectionBackground\":\"#453b39\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"djoyner\",\"link\":\"https://github.com/djoyner/iTerm2-wombat\"}]}},{\"name\":\"Wryan\",\"black\":\"#333333\",\"red\":\"#8c4665\",\"green\":\"#287373\",\"yellow\":\"#7c7c99\",\"blue\":\"#395573\",\"purple\":\"#5e468c\",\"cyan\":\"#31658c\",\"white\":\"#899ca1\",\"brightBlack\":\"#3d3d3d\",\"brightRed\":\"#bf4d80\",\"brightGreen\":\"#53a6a6\",\"brightYellow\":\"#9e9ecb\",\"brightBlue\":\"#477ab3\",\"brightPurple\":\"#7e62b3\",\"brightCyan\":\"#6096bf\",\"brightWhite\":\"#c0c0c0\",\"background\":\"#101010\",\"foreground\":\"#999993\",\"cursorColor\":\"#9e9ecb\",\"selectionBackground\":\"#4d4d4d\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"baskerville\",\"link\":\"https://github.com/baskerville/iTerm-2-Color-Themes\"}]}},{\"name\":\"Wzoreck\",\"black\":\"#2E3436\",\"red\":\"#FC6386\",\"green\":\"#424043\",\"yellow\":\"#FCE94F\",\"blue\":\"#FB976B\",\"purple\":\"#75507B\",\"cyan\":\"#34E2E2\",\"white\":\"#FFFFFF\",\"brightBlack\":\"#989595\",\"brightRed\":\"#FC6386\",\"brightGreen\":\"#A9DC76\",\"brightYellow\":\"#FCE94F\",\"brightBlue\":\"#FB976B\",\"brightPurple\":\"#AB9DF2\",\"brightCyan\":\"#34E2E2\",\"brightWhite\":\"#D1D1C0\",\"foreground\":\"#FCFCFA\",\"background\":\"#424043\",\"cursorColor\":\"#FCFCFA\"},{\"name\":\"Zenburn\",\"black\":\"#4d4d4d\",\"red\":\"#705050\",\"green\":\"#60b48a\",\"yellow\":\"#f0dfaf\",\"blue\":\"#506070\",\"purple\":\"#dc8cc3\",\"cyan\":\"#8cd0d3\",\"white\":\"#dcdccc\",\"brightBlack\":\"#709080\",\"brightRed\":\"#dca3a3\",\"brightGreen\":\"#c3bf9f\",\"brightYellow\":\"#e0cf9f\",\"brightBlue\":\"#94bff3\",\"brightPurple\":\"#ec93d3\",\"brightCyan\":\"#93e0e3\",\"brightWhite\":\"#ffffff\",\"background\":\"#3f3f3f\",\"foreground\":\"#dcdccc\",\"cursorColor\":\"#73635a\",\"selectionBackground\":\"#21322f\",\"meta\":{\"isDark\":true,\"credits\":[{\"name\":\"Zenburn\",\"link\":\"http://sunaku.github.io/zenburn-terminal-color-scheme.html\"}]}}]");
let MouseButton = /* @__PURE__ */ function(MouseButton$2) {
	MouseButton$2[MouseButton$2["Left"] = 0] = "Left";
	MouseButton$2[MouseButton$2["Middle"] = 1] = "Middle";
	MouseButton$2[MouseButton$2["Right"] = 2] = "Right";
	MouseButton$2[MouseButton$2["Back"] = 3] = "Back";
	MouseButton$2[MouseButton$2["Forward"] = 4] = "Forward";
	return MouseButton$2;
}({});
const createHeader = (rootCtx, programCtx, opts = {}) => {
	const t$12 = opts.transport ?? transport;
	const setTargetSeconds = opts.setTargetSeconds ?? ((seconds) => {
		if (!rootCtx) return;
		rootCtx.targetSeconds.value = seconds;
	});
	return {
		height: 48,
		onMouseDown: (e$59, x$4, y$5, w$5, h$5) => {
			if (!rootCtx || !programCtx?.result.value) return;
			x$4 -= 160;
			w$5 -= 160;
			let ratio = x$4 / w$5;
			if (e$59.altKey) {
				const barLengthSeconds = 240 / (programCtx.result.value.compile.bpm ?? 120);
				const sampleRate = programCtx.latency.value.state.sampleRate || 44100;
				const secToSamples = (sec) => Math.round(sec * sampleRate);
				if (y$5 < h$5 / 2) {
					const barIndex = ratio * 128;
					const phraseBar = Math.floor(barIndex / 4) * 4;
					const begin = secToSamples(phraseBar * barLengthSeconds);
					const end = secToSamples((phraseBar + 4) * barLengthSeconds);
					if (begin === t$12.getLoopBeginSamples() && end === t$12.getLoopEndSamples()) {
						t$12.setLoopBeginSamples(0);
						t$12.setLoopEndSamples(0);
					} else {
						t$12.setLoopBeginSamples(begin);
						t$12.setLoopEndSamples(end);
					}
				} else {
					const windowStartTime = programCtx.timeSeconds.value - 1 * barLengthSeconds;
					const timeWindowSeconds = TIME_WINDOW_BARS * barLengthSeconds;
					const clickedSeconds = windowStartTime + ratio * timeWindowSeconds;
					const barStartSeconds = Math.floor(clickedSeconds / barLengthSeconds) * barLengthSeconds;
					const begin = secToSamples(barStartSeconds);
					const end = secToSamples(barStartSeconds + barLengthSeconds);
					if (begin === t$12.getLoopBeginSamples() && end === t$12.getLoopEndSamples()) {
						t$12.setLoopBeginSamples(0);
						t$12.setLoopEndSamples(0);
					} else {
						t$12.setLoopBeginSamples(begin);
						t$12.setLoopEndSamples(end);
					}
				}
				return;
			}
			if (ratio < 0 || e$59.button === MouseButton.Right) {
				t$12.restart();
				return;
			}
			const half = h$5 / 2;
			const dx = e$59.clientX - x$4;
			if (y$5 < half) {
				t$12.beginSeek();
				const seek = () => {
					const seconds = ratio * 128 * 4 * 60 / programCtx.result.value.compile.bpm;
					const beatLengthSeconds = 60 / programCtx.result.value.compile.bpm / 4;
					const snappedSeconds = Math.max(0, Math.round(seconds / beatLengthSeconds) * beatLengthSeconds);
					t$12.seek(snappedSeconds);
					setTargetSeconds(seconds);
				};
				seek();
				const handleMove = (e$60) => {
					ratio = clamp01((e$60.clientX - dx) / w$5);
					seek();
				};
				window.addEventListener("mousemove", handleMove);
				window.addEventListener("mouseup", () => {
					t$12.endSeek();
					window.removeEventListener("mousemove", handleMove);
				}, { once: true });
			} else {
				t$12.beginSeek();
				let currentSeconds = programCtx.latency.value.state.timeSeconds ?? 0;
				const seek = (delta) => {
					const seconds = Math.max(0, currentSeconds + delta * .015);
					t$12.seek(seconds);
					currentSeconds = seconds;
					setTargetSeconds(seconds);
				};
				const handleMove = (e$60) => {
					const cx = e$60.clientX - dx;
					seek(x$4 - cx);
					x$4 = cx;
				};
				window.addEventListener("mousemove", handleMove);
				window.addEventListener("mouseup", () => {
					t$12.endSeek();
					window.removeEventListener("mousemove", handleMove);
				}, { once: true });
			}
		},
		draw: (c$7, x$4, y$5, w$5, h$5) => {
			c$7.save();
			c$7.translate(x$4, y$5);
			c$7.fillStyle = theme.value.black + "dd";
			c$7.fillRect(x$4, y$5, w$5, h$5);
			c$7.restore();
			if (!programCtx?.result?.value) return;
			x$4 += 160;
			w$5 -= 160;
			const timeSeconds = programCtx.timeSeconds;
			const bpm$1 = programCtx.result.value.compile.bpm ?? 120;
			const barLengthSeconds = 240 / bpm$1;
			const windowStartTime = timeSeconds.value - 1 * barLengthSeconds;
			const windowEndTime = timeSeconds.value + 4 * barLengthSeconds;
			const timeWindowSeconds = TIME_WINDOW_BARS * barLengthSeconds;
			const pxPerSecond = w$5 / timeWindowSeconds;
			const playheadX = 1 * barLengthSeconds * pxPerSecond;
			const barCount = Math.max(1, Math.floor(128));
			const totalSeconds = barLengthSeconds * barCount;
			c$7.save();
			c$7.translate(x$4, y$5);
			c$7.beginPath();
			c$7.rect(0, 0, w$5, h$5);
			c$7.clip();
			h$5 /= 2;
			const timelineHistories = programCtx.histories.value.filter((hist) => hist.genName === "Timeline");
			const labels = [...programCtx.result.value?.compile?.labels ?? []].sort((a$36, b$4) => a$36.bar - b$4.bar);
			const sampleRate = programCtx.latency.value.state.sampleRate || 44100;
			const minimapH = Math.max(4, h$5 - 4);
			const drawTint = (startX, endX, color) => {
				const start = Math.max(0, Math.min(w$5, startX));
				const end = Math.max(0, Math.min(w$5, endX));
				const ww = Math.max(0, end - start);
				if (ww <= 0) return;
				c$7.save();
				c$7.globalAlpha = .175;
				c$7.fillStyle = color;
				c$7.fillRect(start, 0, ww, h$5);
				c$7.restore();
			};
			let lastLabelColor;
			if (labels.length > 0) {
				const labelPositions = [];
				let leftColor;
				let leftX = 0;
				for (const label of labels) {
					const color = getTimelineColor(label.colorIndex);
					const labelSeconds = label.bar * barLengthSeconds;
					if (labelSeconds <= timeSeconds.value) lastLabelColor = color;
					if (labelSeconds <= 0) {
						leftColor = color;
						leftX = labelSeconds / totalSeconds * w$5;
						continue;
					}
					if (labelSeconds > totalSeconds) break;
					labelPositions.push({
						x: labelSeconds / totalSeconds * w$5,
						color
					});
				}
				if (leftColor) labelPositions.unshift({
					x: leftX,
					color: leftColor
				});
				for (let i$6 = 0; i$6 < labelPositions.length - 1; i$6++) drawTint(labelPositions[i$6].x, labelPositions[i$6 + 1].x, labelPositions[i$6].color);
				if (labelPositions.length >= 1) drawTint(labelPositions[labelPositions.length - 1].x, w$5, labelPositions[labelPositions.length - 1].color);
			}
			const loopBegin = t$12.getLoopBeginSamples();
			const loopEnd = t$12.getLoopEndSamples();
			if (loopBegin != null && loopEnd != null && loopEnd > loopBegin) {
				const loopBeginSec = loopBegin / sampleRate;
				const loopEndSec = loopEnd / sampleRate;
				const loopStartX = loopBeginSec / totalSeconds * w$5;
				const loopEndX = loopEndSec / totalSeconds * w$5;
				c$7.save();
				c$7.globalAlpha = .3;
				c$7.fillStyle = primaryColor.value;
				c$7.fillRect(Math.max(0, loopStartX), 0, Math.min(w$5, loopEndX) - Math.max(0, loopStartX), h$5);
				c$7.restore();
			}
			for (const timeline of timelineHistories) {
				const segs = readTimelineSegsFromCompiledTimeline(compileTimelineNotation(timeline.sequence).bytecode, sampleRate, bpm$1, 0, totalSeconds);
				c$7.strokeStyle = getTimelineColor(timeline.colorIndex);
				c$7.lineWidth = 1.35;
				c$7.lineCap = "square";
				c$7.lineJoin = "miter";
				c$7.beginPath();
				for (let px = 0; px <= w$5; px += .5) {
					const vy = (1 - getTimelineValueAtSample(segs, px / w$5 * totalSeconds * sampleRate)) * minimapH / 2 + minimapH / 2 + 2;
					if (px === 0) c$7.moveTo(px, vy);
					else c$7.lineTo(px, vy);
				}
				c$7.stroke();
			}
			let prevLabelX = -Infinity;
			for (let barIndex = 0; barIndex <= barCount; barIndex += 4) {
				const x$5 = barIndex / barCount * (w$5 - 1);
				const isMajor = barIndex % 16 === 0;
				c$7.fillStyle = isMajor ? "#fff" : "rgba(255, 255, 255, 0.35)";
				c$7.font = isMajor ? "bold 6pt Outfit" : "6pt Outfit";
				c$7.textAlign = "left";
				c$7.textBaseline = "middle";
				const phraseNumber = String(barIndex + 1);
				if (x$5 - prevLabelX > 20) {
					c$7.fillText(phraseNumber, x$5 + 5, 6);
					prevLabelX = x$5;
					c$7.strokeStyle = isMajor ? "rgba(255, 255, 255, 0.25)" : "rgba(255, 255, 255, 0.15)";
					c$7.lineWidth = 1;
					c$7.beginPath();
					c$7.moveTo(x$5, 0);
					c$7.lineTo(x$5, h$5);
					c$7.stroke();
				}
			}
			{
				const minimapPlayheadX = timeSeconds.value / totalSeconds * w$5 + 1;
				const minimapPlayheadColor = lastLabelColor ?? secondaryColor.value;
				c$7.strokeStyle = minimapPlayheadColor;
				c$7.lineWidth = 2;
				c$7.beginPath();
				c$7.moveTo(minimapPlayheadX, 0);
				c$7.lineTo(minimapPlayheadX, h$5);
				c$7.stroke();
				c$7.fillStyle = minimapPlayheadColor + "44";
				c$7.fillRect(Math.max(0, minimapPlayheadX - 1.5), 0, 3, h$5);
			}
			y$5 += h$5;
			c$7.fillStyle = primaryColor.value;
			c$7.fillRect(0, y$5 - .5, w$5, 2);
			y$5 += 1.5;
			if (labels.length > 0) {
				const scrubDrawTint = (startX, endX, color) => {
					const start = Math.max(0, Math.min(w$5, startX));
					const end = Math.max(0, Math.min(w$5, endX));
					const ww = Math.max(0, end - start);
					if (ww <= 0) return;
					c$7.save();
					c$7.globalAlpha = .175;
					c$7.fillStyle = color;
					c$7.fillRect(start, y$5, ww, h$5);
					c$7.restore();
				};
				const scrubLabelPositions = [];
				let leftColor;
				let leftX = 0;
				for (const label of labels) {
					const color = getTimelineColor(label.colorIndex);
					const labelSeconds = label.bar * barLengthSeconds;
					const labelX = (labelSeconds - windowStartTime) * pxPerSecond;
					if (labelSeconds <= windowStartTime) {
						leftColor = color;
						leftX = labelX;
						continue;
					}
					if (labelSeconds > windowEndTime) break;
					scrubLabelPositions.push({
						x: labelX,
						color
					});
				}
				if (leftColor) scrubLabelPositions.unshift({
					x: leftX,
					color: leftColor
				});
				for (let i$6 = 0; i$6 < scrubLabelPositions.length - 1; i$6++) scrubDrawTint(scrubLabelPositions[i$6].x, scrubLabelPositions[i$6 + 1].x, scrubLabelPositions[i$6].color);
				if (scrubLabelPositions.length >= 1) scrubDrawTint(scrubLabelPositions[scrubLabelPositions.length - 1].x, w$5, scrubLabelPositions[scrubLabelPositions.length - 1].color);
			}
			if (loopBegin != null && loopEnd != null && loopEnd > loopBegin) {
				const loopBeginSec = loopBegin / sampleRate;
				const loopEndSec = loopEnd / sampleRate;
				const loopStartX = (loopBeginSec - windowStartTime) * pxPerSecond;
				const loopEndX = (loopEndSec - windowStartTime) * pxPerSecond;
				const start = Math.max(0, Math.min(w$5, loopStartX));
				const end = Math.max(0, Math.min(w$5, loopEndX));
				const ww = Math.max(0, end - start);
				if (ww > 0) {
					c$7.save();
					c$7.globalAlpha = .3;
					c$7.fillStyle = primaryColor.value;
					c$7.fillRect(start, y$5, ww, h$5);
					c$7.restore();
				}
			}
			const barSizes = /* @__PURE__ */ new Map();
			const firstBarStart = Math.floor(windowStartTime / barLengthSeconds) * barLengthSeconds;
			for (let barStart = firstBarStart; barStart < windowEndTime + barLengthSeconds; barStart += barLengthSeconds) {
				if (barStart < 0) continue;
				const barIndex = Math.round(barStart / barLengthSeconds);
				const barNumber = barIndex + 1;
				const isPhraseStart = (barNumber - 1 & 3) === 0;
				const barX = (barStart - windowStartTime) * pxPerSecond;
				c$7.strokeStyle = isPhraseStart ? "rgba(255, 255, 255, 0.55)" : "rgba(255, 255, 255, 0.25)";
				c$7.lineWidth = isPhraseStart ? 1.5 : 1;
				c$7.beginPath();
				c$7.moveTo(barX, y$5);
				c$7.lineTo(barX, y$5 + h$5);
				c$7.stroke();
				const rowY = y$5 + 11.5;
				c$7.textBaseline = "middle";
				c$7.textAlign = "left";
				c$7.fillStyle = isPhraseStart ? "rgba(255, 255, 255, 0.95)" : "rgba(255, 255, 255, 0.75)";
				c$7.font = isPhraseStart ? "bold 9pt Outfit" : "normal 8pt Outfit";
				c$7.fillText(String(barNumber), barX + 7, rowY);
				const barNumWidth = c$7.measureText(String(barNumber)).width;
				const t$13 = Math.max(0, barStart);
				const mins = Math.round(t$13 / 60);
				const secs = Math.round(t$13 % 60);
				const timeLabel = mins + ":" + String(secs).padStart(2, "0");
				c$7.font = "6.5pt Outfit";
				c$7.fillStyle = "rgba(200,200,200,0.6)";
				c$7.fillText(timeLabel, barX + 7 + barNumWidth + 5, rowY);
				const timeWidth = c$7.measureText(timeLabel).width;
				barSizes.set(barIndex, {
					barNum: barNumWidth,
					time: timeWidth
				});
			}
			if (labels.length > 0) {
				c$7.textAlign = "left";
				c$7.textBaseline = "middle";
				c$7.font = "800 7.5pt Outfit";
				const rowY = y$5 + 11.5;
				for (let i$6 = 0; i$6 < labels.length; i$6++) {
					const label = labels[i$6];
					const labelSeconds = label.bar * barLengthSeconds;
					if (labelSeconds > windowEndTime) continue;
					let labelX = (labelSeconds - windowStartTime) * pxPerSecond;
					const origLabelX = labelX;
					const sizes = barSizes.get(label.bar);
					let barNumWidth = sizes?.barNum ?? c$7.measureText(String(label.bar + 1)).width;
					let timeWidth = sizes?.time;
					if (timeWidth === void 0) {
						const t$13 = Math.max(0, label.bar * barLengthSeconds);
						const mins = Math.round(t$13 / 60);
						const secs = Math.round(t$13 % 60);
						c$7.font = "6.5pt Outfit";
						timeWidth = c$7.measureText(mins + ":" + String(secs).padStart(2, "0")).width;
						c$7.font = "800 7pt Outfit";
					}
					if (playheadX > origLabelX + 7 + barNumWidth + 5 + timeWidth) labelX = playheadX;
					const color = getTimelineColor(label.colorIndex);
					const nextLabel = labels[i$6 + 1];
					if (nextLabel) {
						const nextLabelX = (nextLabel.bar * barLengthSeconds - windowStartTime) * pxPerSecond;
						const textWidth = [...label.text].reduce((acc, char) => acc + c$7.measureText(char).width + .5, 0) - 1;
						if (labelX + 5 + textWidth > nextLabelX - 10) labelX = Math.min(playheadX, nextLabelX - 15 - textWidth);
					}
					if (origLabelX === labelX && playheadX < origLabelX) {
						c$7.strokeStyle = color;
						c$7.lineWidth = 1.5;
						c$7.beginPath();
						c$7.moveTo(labelX, y$5);
						c$7.lineTo(labelX, y$5 + h$5);
						c$7.stroke();
					}
					const textX = labelX + (origLabelX !== labelX ? 5 : 7 + barNumWidth + 5 + timeWidth + 5);
					c$7.fillStyle = color;
					let px = textX;
					for (const char of label.text) {
						c$7.fillText(char, px, rowY);
						px += c$7.measureText(char).width + 1.5;
					}
				}
			}
			c$7.strokeStyle = lastLabelColor ?? secondaryColor.value;
			c$7.lineWidth = 2;
			c$7.beginPath();
			c$7.moveTo(playheadX, y$5);
			c$7.lineTo(playheadX, y$5 + h$5);
			c$7.stroke();
			c$7.restore();
		}
	};
};
const session = c$3(null);
const busy = c$3(false);
var busyTimeout = null;
var _busyLock = false;
function busyBounce() {
	if (_busyLock) return;
	busy.value = true;
	if (busyTimeout) clearTimeout(busyTimeout);
	busyTimeout = setTimeout(() => {
		if (_busyLock) return;
		busy.value = false;
	}, 100);
}
function busyLock() {
	if (busyTimeout) clearTimeout(busyTimeout);
	_busyLock = true;
	busy.value = true;
}
function busyUnlock() {
	_busyLock = false;
	busyBounce();
}
busyBounce();
persist("session", () => session.value, () => ({ session: session.value }), (data) => {
	session.value = data.session ?? null;
});
const editor = c$3(null);
const themeName = c$3(localStorage.getItem("themeName") || "Dracula+");
const themeVariation = c$3(localStorage.getItem("themeVariation") || "B");
const theme = c$3(safeJsonParse(localStorage.getItem("theme")) || {
	gray: "#444444",
	black: "#000000",
	red: "#FFFFFF",
	green: "#ea580c",
	yellow: "#aaaaaa",
	blue: "#bbbbbb",
	purple: "#FFFF00",
	cyan: "#cccccc",
	white: "#dddddd",
	brightBlack: "#666666",
	brightRed: "#eeeeee",
	brightGreen: "#fafafa",
	brightYellow: "#bbbbcc",
	brightBlue: "#ccccdd",
	brightPurple: "#ddddaa",
	brightCyan: "#eeeecc",
	brightWhite: "#ffffff"
});
var actualTheme = c$3({ ...theme.value });
m(() => {
	localStorage.setItem("themeName", themeName.value);
});
m(() => {
	localStorage.setItem("themeVariation", themeVariation.value);
});
m(() => {
	localStorage.setItem("theme", JSON.stringify(theme.value));
});
m(() => {
	if (themeVariation.value === "A") o$24(() => {
		theme.value = { ...actualTheme.value };
	});
	else if (themeVariation.value === "B") {
		const red = actualTheme.value.red;
		const green = actualTheme.value.green;
		o$24(() => {
			theme.value = {
				...actualTheme.value,
				red: green,
				green: red
			};
		});
	} else if (themeVariation.value === "C") {
		const blue = actualTheme.value.blue;
		const green = actualTheme.value.green;
		o$24(() => {
			theme.value = {
				...actualTheme.value,
				blue: green,
				green: blue
			};
		});
	}
});
m(() => {
	const json = _all_default.find((theme$1) => theme$1.name === themeName.value);
	if (!json) {
		themeName.value = "Pixiefloss";
		return;
	}
	theme.value = json;
	actualTheme.value = json;
});
const primaryColor = b(() => theme.value.green);
const primaryMediumColor = b(() => blendHex(theme.value.green, theme.value.black, .42));
const primaryDarkColor = b(() => blendHex(theme.value.green, theme.value.black, FILL_ALPHA));
const secondaryColor = b(() => theme.value.purple);
const grayColor = b(() => luminate(theme.value.white, -.5));
const backgroundColor = b(() => theme.value.black);
b(() => luminate(theme.value.black, .2));
const textColor = b(() => theme.value.white);
const primaryGradientA = b(() => luminate(primaryColor.value, .125));
const primaryGradientB = b(() => saturate(luminate(primaryColor.value, -.2), .5));
const primaryGradientStyle = b(() => ({ backgroundImage: `linear-gradient(to bottom right, ${primaryGradientA.value}, ${primaryGradientB.value})` }));
var timelineColorKeys = [
	"red",
	"green",
	"yellow",
	"blue",
	"purple",
	"cyan"
];
const timelineColorByIndex = b(() => {
	const t$12 = theme.value;
	return timelineColorKeys.map((k$4) => t$12[k$4]);
});
function getTimelineColor(index) {
	if (index == null || index < 0 || index > 5) return primaryColor.value;
	return timelineColorByIndex.value[index] ?? primaryColor.value;
}
const consoleDebug = c$3("[no output yet...]");
const mainPage = c$3(null);
const sidebarTab = c$3(null);
const sidebarOpen = b(() => sidebarTab.value !== null);
const isPlaying = c$3(false);
const isPaused = c$3(false);
const isStopped = c$3(false);
const isActuallyPlaying = c$3(false);
const isActuallyPaused = c$3(false);
const isActuallyStopped = c$3(false);
const ctx = c$3(null);
createDspContext().then((c$7) => ctx.value = c$7);
const wasmMemoryUsage = c$3(null);
const memoryDebugInfo = c$3(null);
const tickCount = c$3(0);
const deferDraw = c$3(false);
const skipAnimations = c$3(0);
const currentProjectId = c$3(null);
const playingProjectId = c$3(null);
const projects = c$3([]);
function getNextUntitledName() {
	const nums = projects.value.map((p$6) => {
		if (p$6.name === "Untitled") return 1;
		const m$5 = p$6.name.match(/^Untitled (\d+)$/);
		return m$5 ? parseInt(m$5[1], 10) : 0;
	}).filter((n$4) => n$4 > 0);
	const next = (nums.length ? Math.max(...nums) : 0) + 1;
	return next === 1 ? "Untitled" : `Untitled ${next}`;
}
function createProject(data = {}) {
	const id = data.id ?? `lm3-project-${createId()}`;
	return signalify({
		serverId: data.serverId ?? null,
		userId: data.userId ?? session.value?.userId ?? null,
		id,
		name: data.name ?? getNextUntitledName(),
		doc: createPersistedDoc(id, tokenize, data.doc),
		scratch: createPersistedDoc(`${id}-scratch`, tokenize, data.scratch),
		sampleCount: data.sampleCount ?? 0,
		remixOfId: data.remixOfId ?? null,
		get isDirty() {
			return this.doc.code !== this.scratch.code;
		},
		isPublic: data.isPublic ?? false,
		isSaved: data.isSaved ?? false
	});
}
const currentProject = b(() => currentProjectId.value ? projects.value.find((project) => project.id === currentProjectId.value) : null);
const playingProject = b(() => playingProjectId.value ? projects.value.find((project) => project.id === playingProjectId.value) : null);
persistKeyed(() => `projects-${session.value?.userId ?? null}`, () => {
	currentProjectId.value;
	projects.value.forEach((project) => {
		Object.assign({}, project);
	});
}, () => ({
	currentProjectId: currentProjectId.value,
	projects: projects.value.map((project) => ({
		serverId: project.serverId,
		userId: project.userId,
		id: project.id,
		name: project.name,
		sampleCount: project.sampleCount,
		remixOfId: project.remixOfId,
		isPublic: project.isPublic,
		isSaved: project.isSaved
	}))
}), (data) => {
	const projectsWithNoOwner = projects.value.filter((project) => project.userId === null && project.scratch.code !== "");
	if (data.projects?.length) {
		projects.value = [...data.projects.map(createProject), ...projectsWithNoOwner];
		currentProjectId.value = data.currentProjectId ?? projects.value[0].id;
	} else {
		projects.value = projectsWithNoOwner.length ? projectsWithNoOwner : [createProject()];
		currentProjectId.value = projects.value[0].id;
	}
});
m(() => {
	if (!session.value) {
		projects.value = o$24(() => projects.value.filter((project) => !project.userId));
		queueMicrotask(() => {
			n(() => {
				if (!projects.value.length) {
					projects.value = [createProject()];
					currentProjectId.value = projects.value[0].id;
				}
			});
		});
	}
});
m(() => {
	if (!currentProject.value && playingProject.value) currentProjectId.value = playingProjectId.value;
});
const isPlayingCurrent = b(() => playingProjectId.value === currentProjectId.value);
m(() => {
	if (!playingProjectId.value) playingProjectId.value = currentProjectId.value;
});
m(() => {
	if (playingProjectId.value && !playingProject.value) playingProjectId.value = currentProjectId.value;
});
m(() => {
	const dsp = ctx.value?.dsp;
	if (!dsp) return;
	tickCount.value;
	isPlaying.value = dsp.isPlaying;
	isPaused.value = dsp.isPaused;
	isStopped.value = dsp.isStopped;
	isActuallyPlaying.value = dsp.isActuallyPlaying;
	isActuallyPaused.value = dsp.isActuallyPaused;
	isActuallyStopped.value = dsp.isActuallyStopped;
});
var vmId = 0;
const programContexts = c$3(/* @__PURE__ */ new Map());
const playingContext = c$3(null);
const playingInlineContext = c$3(null);
const playingDjContexts = c$3([]);
async function createProgramContext(ctx$1, opts) {
	const ref = c$3(null);
	const isPlayingThis = b(() => ref.value !== null && (playingContext.value === ref.value || playingInlineContext.value === ref.value || playingDjContexts.value.includes(ref.value)));
	const programCtx = await ctx$1.createDspProgramContext({
		vmId: vmId++,
		isPlayingThis,
		...opts
	});
	ref.value = programCtx;
	return programCtx;
}
async function getProgramContext(ctx$1, id, opts = {}) {
	let programContext = programContexts.value.get(id);
	if (!programContext) {
		const deferred = Deferred();
		programContext = deferred.promise;
		programContexts.value.set(id, deferred.promise);
		programContexts.value = new Map(programContexts.value);
		deferred.resolve(await createProgramContext(ctx$1, {
			...opts,
			projectId: opts.projectId ?? id
		}));
	}
	return programContext;
}
const currentProgramContext = c$3(null);
const playingProgramContext = c$3(null);
m(() => {
	if (!ctx.value) return;
	const currentId = currentProjectId.value;
	if (!currentId) return;
	const project = currentProject.value;
	if (!project) return;
	getProgramContext(ctx.value, currentId, { doc: project.scratch }).then((programContext) => {
		n(() => {
			currentProgramContext.value = programContext;
		});
	});
});
m(() => {
	if (!ctx.value) return;
	const playingId = playingProjectId.value;
	if (!playingId) return;
	const project = playingProject.value;
	if (!project) return;
	getProgramContext(ctx.value, playingId, { doc: project.scratch }).then((programContext) => {
		n(() => {
			playingProgramContext.value = programContext;
		});
	});
});
async function ensureProgramContexts() {
	if (!ctx.value) return;
	const c$7 = ctx.value;
	if (!currentProjectId.value || !currentProject.value) return;
	if (!playingProjectId.value || !playingProject.value) return;
	const currentId = currentProjectId.value;
	const playingId = playingProjectId.value;
	const currentCtx = await getProgramContext(c$7, currentId, { doc: currentProject.value.scratch });
	const playingCtx = await getProgramContext(c$7, playingId, { doc: playingProject.value.scratch });
	n(() => {
		currentCtx.fullResync.value = true;
		playingCtx.fullResync.value = true;
	});
	return {
		currentProgramContext: currentCtx,
		playingProgramContext: playingCtx
	};
}
m(() => {
	const playing = playingProgramContext.value;
	const project = playingProject.value;
	if (playing && project && isPlaying.value) {
		playing.program.latency.update();
		playing.latency.value = playing.program.latency;
		project.sampleCount = playing.program.latency.state.sampleCount;
	}
});
m(() => {
	const programCtx = currentProgramContext.value;
	const workletError = ctx.value?.dsp.state.workletError;
	if (!programCtx?.doc) return;
	const result = programCtx.result.value;
	programCtx.doc.errors = computeDocErrors(result, workletError ?? null);
});
m(() => {
	const result = currentProgramContext.value?.result.value;
	if (result && editor.value) editor.value.settings.caretPhaseCoeff = 120 / result.compile.bpm;
});
m(() => {
	const programCtx = currentProgramContext.value;
	if (!programCtx || !ctx.value) return;
	tickCount.value;
	if (!isActuallyPlaying.value) programCtx.program.latency.update();
	const seconds = isScrubbing.value ? ctx.value.targetSeconds.value : programCtx.latency.value.state.timeSeconds ?? 0;
	if ((isScrubbing.value || !isActuallyPlaying.value) && skipAnimations.value === 0) {
		const prev = programCtx.timeSeconds.peek();
		programCtx.timeSeconds.value = prev + (seconds - prev) * .35;
	} else programCtx.timeSeconds.value = seconds;
});
const transport = {
	start: async () => {
		if (!ctx.value) return;
		const dsp = ctx.value.dsp;
		await dsp.state.audioContext.resume();
		const contexts = await ensureProgramContexts();
		if (!contexts) return;
		const { currentProgramContext: currentProgramContext$1, playingProgramContext: playingProgramContext$1 } = contexts;
		if (playingInlineContext.value) await inlineTransport.stop();
		if (isPlaying.value) {
			if (!isPlayingCurrent.value) {
				playingProjectId.value = currentProjectId.value;
				playingContext.value = currentProgramContext$1;
				dsp.swapPrograms(playingProgramContext$1.program, currentProgramContext$1.program);
				await dsp.refreshUntilHistories(currentProgramContext$1.program, { maxTries: 60 });
				deferDraw.value = true;
			}
		} else {
			playingProjectId.value = currentProjectId.value;
			playingContext.value = currentProgramContext$1;
			await dsp.start([currentProgramContext$1.program]);
			await dsp.refreshUntilHistories(currentProgramContext$1.program, { maxTries: 60 });
		}
	},
	pause: async () => {
		if (!ctx.value) return;
		const dsp = ctx.value.dsp;
		const contexts = await ensureProgramContexts();
		if (!contexts) return;
		dsp.togglePause([contexts.playingProgramContext.program]);
	},
	stop: async () => {
		if (!ctx.value) return;
		const dsp = ctx.value.dsp;
		const contexts = await ensureProgramContexts();
		if (!contexts) return;
		const { currentProgramContext: currentProgramContext$1, playingProgramContext: playingProgramContext$1 } = contexts;
		if (!isActuallyPlaying.value) {
			dsp.seek(0, [currentProgramContext$1.program], false);
			return;
		}
		playingContext.value = null;
		await dsp.stop([playingProgramContext$1.program]);
	},
	restart: async () => {
		if (!ctx.value) return;
		const dsp = ctx.value.dsp;
		await dsp.state.audioContext.resume();
		const contexts = await ensureProgramContexts();
		if (!contexts) return;
		const { currentProgramContext: currentProgramContext$1, playingProgramContext: playingProgramContext$1 } = contexts;
		skipAnimations.value += 1;
		dsp.seek(0, [currentProgramContext$1.program], false);
		if (isPlaying.value) {
			if (!isPlayingCurrent.value) {
				playingProjectId.value = currentProjectId.value;
				playingContext.value = currentProgramContext$1;
				dsp.swapPrograms(playingProgramContext$1.program, currentProgramContext$1.program);
				await dsp.refreshUntilHistories(currentProgramContext$1.program, { maxTries: 60 });
				deferDraw.value = true;
			}
		} else {
			playingProjectId.value = currentProjectId.value;
			playingContext.value = currentProgramContext$1;
			await dsp.start([currentProgramContext$1.program]);
			await dsp.refreshUntilHistories(currentProgramContext$1.program, { maxTries: 60 });
		}
	},
	beginSeek: async () => {
		if (!ctx.value) return;
		const dsp = ctx.value.dsp;
		const contexts = await ensureProgramContexts();
		if (!contexts) return;
		isScrubbing.value = true;
		scrubbingProgramState.value = contexts.currentProgramContext.program.state;
		dsp.pause([contexts.currentProgramContext.program]);
	},
	endSeek: async () => {
		if (!ctx.value) return;
		const dsp = ctx.value.dsp;
		const contexts = await ensureProgramContexts();
		if (!contexts) return;
		if (scrubbingProgramState.value === DspProgramState.Start) dsp.start([contexts.currentProgramContext.program]);
		else dsp.pause([contexts.currentProgramContext.program]);
		isScrubbing.value = false;
	},
	seek: async (seconds) => {
		if (!ctx.value) return;
		const dsp = ctx.value.dsp;
		const contexts = await ensureProgramContexts();
		if (!contexts) return;
		const sampleRate = contexts.currentProgramContext.latency.value.state.sampleRate;
		const sampleCount = Math.round(seconds * sampleRate);
		await dsp.seek(sampleCount, [contexts.currentProgramContext.program], scrubbingProgramState.value === DspProgramState.Start && isPlayingCurrent.value);
	},
	getLoopBeginSamples: () => {
		if (!ctx.value) return;
		return ctx.value.dsp.loopBeginSamples;
	},
	getLoopEndSamples: () => {
		if (!ctx.value) return;
		return ctx.value.dsp.loopEndSamples;
	},
	setLoopBeginSamples: (samples) => {
		if (!ctx.value) return;
		const dsp = ctx.value.dsp;
		dsp.loopBeginSamples = samples;
	},
	setLoopEndSamples: (samples) => {
		if (!ctx.value) return;
		const dsp = ctx.value.dsp;
		dsp.loopEndSamples = samples;
	},
	setProjectEndSamples: (samples) => {
		if (!ctx.value) return;
		const dsp = ctx.value.dsp;
		dsp.projectEndSamples = samples;
	}
};
const inlineTransport = {
	start: async (inline) => {
		if (!ctx.value) return;
		const dsp = ctx.value.dsp;
		await dsp.state.audioContext.resume();
		if (playingContext.value) await transport.stop();
		if (playingInlineContext.value) {
			await inlineTransport.stop();
			await new Promise((resolve) => setTimeout(resolve, 100));
		}
		playingInlineContext.value = inline;
		await dsp.start([inline.program]);
		await dsp.refreshUntilHistories(inline.program, { maxTries: 60 });
		deferDraw.value = true;
	},
	stop: async () => {
		if (!playingInlineContext.value) return;
		if (!ctx.value) return;
		const dsp = ctx.value.dsp;
		const { program } = playingInlineContext.value;
		playingInlineContext.value = null;
		await dsp.stop([program]);
	},
	restart: async () => {
		if (!playingInlineContext.value) return;
		if (!ctx.value) return;
		const dsp = ctx.value.dsp;
		await dsp.state.audioContext.resume();
		await dsp.seek(0, [playingInlineContext.value.program], false);
		await dsp.start([playingInlineContext.value.program]);
	}
};
const isScrubbing = c$3(false);
const scrubbingProgramState = c$3(DspProgramState.Stop);
function createNewProject() {
	const project = createProject();
	n(() => {
		projects.value = [...projects.value, project];
		currentProjectId.value = project.id;
	});
}
async function deleteProject(project) {
	const wasCurrent = currentProjectId.value === project.id;
	const wasPlaying = playingProjectId.value === project.id;
	const programCtx = await programContexts.value.get(project.id);
	if (wasPlaying && programCtx && ctx.value) ctx.value.dsp.stop([programCtx.program]);
	programCtx?.dispose();
	programContexts.value.delete(project.id);
	programContexts.value = new Map(programContexts.value);
	const remove = () => {
		localStorage.removeItem(project.id);
		localStorage.removeItem(`${project.id}-scratch`);
		n(() => {
			projects.value = projects.value.filter((p$6) => p$6.id !== project.id);
			if (wasCurrent || wasPlaying) {
				if (!projects.value.length) projects.value = [createProject()];
				const next = projects.value[0];
				requestAnimationFrame(() => {
					n(() => {
						currentProjectId.value = next.id;
						playingProjectId.value = next.id;
					});
				});
			}
		});
	};
	if (project.serverId) api.deleteProject(project.serverId).then(remove).catch((error$1) => {
		console.error(error$1);
	});
	else remove();
	api.deleteProject(project.id).then(remove).catch((error$1) => {
		console.error(error$1);
	});
}
function discardChanges(project) {
	project.scratch.code = project.doc.code;
}
async function saveProject(project, values = {}) {
	try {
		const result = await api.saveProject({
			...project,
			...values
		});
		n(() => {
			project.serverId = result.id;
			if (values.name != null) project.name = values.name;
			if (values.isPublic != null) project.isPublic = values.isPublic;
			project.doc.code = project.scratch.code;
			project.isSaved = true;
		});
	} catch (error$1) {
		alert("Failed to save project: " + error$1.message);
		console.error(error$1);
	}
}
persist("workspace", () => {
	mainPage.value;
	sidebarTab.value;
	currentProjectId.value;
	Object.assign({}, settings);
}, () => ({
	mainPage: mainPage.value,
	sidebarTab: sidebarTab.value,
	sidebarOpen: sidebarOpen.value,
	currentProjectId: currentProjectId.value,
	settings
}), (data) => {
	skipAnimations.value += 1;
	mainPage.value = data.mainPage ?? "browse";
	sidebarTab.value = data.sidebarTab ?? null;
	currentProjectId.value = data.currentProjectId ?? null;
	Object.assign(settings, data.settings ?? {});
});
m(() => {
	if (currentProject.value && ctx.value) {
		ensureProgramContexts();
		o$24(() => {
			skipAnimations.value += 10;
		});
		deferDraw.value = true;
	}
});
m(() => {
	currentProjectId.value;
	requestAnimationFrame(() => {
		editor.value?.focus();
	});
});
m(() => {
	ensureProgramContexts();
});
m(() => {
	const handleKeyDown = (e$59) => {
		if (autocompleteState.visible) {
			const { matches, selectedIndex, replaceStart, replaceEnd, doc } = autocompleteState;
			if (e$59.key === "Tab") {
				autocompleteState.selectedIndex = selectedIndex < 0 ? e$59.shiftKey ? matches.length - 1 : 0 : e$59.shiftKey ? (selectedIndex - 1 + matches.length) % matches.length : (selectedIndex + 1) % matches.length;
				e$59.preventDefault();
				return true;
			}
			if (e$59.key === "Enter") {
				if (selectedIndex < 0) return false;
				const ed = activeEditor.value;
				const d$5 = doc;
				if (ed && d$5 && matches.length > 0) {
					const word = matches[(selectedIndex % matches.length + matches.length) % matches.length];
					const caretBefore = {
						line: ed.caret.line.value,
						column: ed.caret.column.value
					};
					const caretAfter = {
						line: replaceStart.line,
						column: replaceStart.column + word.length
					};
					d$5.buffer.replaceSelection(replaceStart, replaceEnd, word, void 0, caretBefore, void 0, caretAfter);
					ed.caret.line.value = caretAfter.line;
					ed.caret.column.value = caretAfter.column;
				}
				autocompleteState.visible = false;
				e$59.preventDefault();
				return true;
			}
			if (e$59.key === "Escape") {
				autocompleteState.visible = false;
				return false;
			}
		}
		if (e$59.altKey) {
			if (e$59.key === "k") {
				settings.showKnobs = !settings.showKnobs;
				return true;
			} else if (e$59.key === "i") {
				settings.showVisuals = !settings.showVisuals;
				return true;
			} else if (e$59.key === "o") {
				settings.showDocs = !settings.showDocs;
				return true;
			} else if (e$59.key === "p") {
				settings.wordWrap = !settings.wordWrap;
				return true;
			} else if (e$59.key === "l") {
				toggleAnalyserType();
				return true;
			}
		}
		if ((e$59.ctrlKey || e$59.metaKey) && e$59.key === " ") {
			if (e$59.altKey) transport.restart();
			else if (e$59.shiftKey) transport.pause();
			else if (isPlaying.value) transport.stop();
			else transport.start();
			return true;
		}
		return false;
	};
	onKeyOverride(handleKeyDown);
	window.addEventListener("keydown", handleKeyDown);
	return () => window.removeEventListener("keydown", handleKeyDown);
});
const bytecode = b(() => {
	const bytecode$1 = currentProgramContext.value?.result.value?.compile.bytecode;
	if (!bytecode$1) return ["[nothing yet...]"];
	return disassembleBytecode(bytecode$1);
});
const waveFFT = c$3(null);
var fftSize = 8192;
var fft = new WaveFFT(fftSize);
fft.init().then(() => {
	waveFFT.value = {
		fft,
		window: WaveFFT.blackman(fftSize),
		windowed: new Float32Array(fftSize)
	};
});
function toggleAnalyserType() {
	settings.analyserType = settings.analyserType === "waveform" ? "spectrum" : settings.analyserType === "spectrum" ? "amplitude" : "waveform";
}
const showIntro = c$3(true);
const bpm = b(() => currentProgramContext.value?.result.value?.compile.bpm ?? 120);
const audioContext = b(() => ctx.value?.dsp.state.audioContext ?? null);
const userProjectsCount = c$3(0);
const cacheBust = c$3(safeJsonParse(localStorage.getItem("cacheBust")) || 0);
m(() => {
	localStorage.setItem("cacheBust", JSON.stringify(cacheBust.value));
});
const browseProjects = c$3(null);
const widgetOptions = signalify({
	showVisuals: true,
	showKnobs: true,
	noHeader: false
});
const docsSearch = c$3("");
const admin = signalify({ editDocs: false });
persist("admin", () => {
	Object.assign({}, admin);
}, () => ({ admin: Object.assign({}, admin) }), (data) => {
	Object.assign(admin, data.admin ?? {});
});
const favIconSvgText = c$3("");
const shouldSkipSyncPreview = c$3(false);
var restoreSyncPreview = debounce(100, () => {
	shouldSkipSyncPreview.value = false;
});
function skipSyncPreview() {
	shouldSkipSyncPreview.value = true;
	restoreSyncPreview();
}
const aiTemperature = c$3(.3);
const aiTopP = c$3(1);
const aiModel = c$3("gpt-5.2-chat-latest");
const aiPromptNew = c$3("");
const aiPromptModify = c$3("");
persist("ai", () => {
	aiTemperature.value;
	aiTopP.value;
	aiModel.value;
	aiPromptNew.value;
	aiPromptModify.value;
}, () => ({
	aiTemperature: aiTemperature.value,
	aiTopP: aiTopP.value,
	aiModel: aiModel.value,
	aiPromptNew: aiPromptNew.value,
	aiPromptModify: aiPromptModify.value
}), (data) => {
	aiTemperature.value = data.aiTemperature ?? .3;
	aiTopP.value = data.aiTopP ?? 1;
	aiModel.value = data.aiModel ?? "gpt-5.2-chat-latest";
	aiPromptNew.value = data.aiPromptNew ?? "";
	aiPromptModify.value = data.aiPromptModify ?? "";
});
m(() => {
	const end = [...playingProgramContext.value?.result.value?.compile?.labels ?? []].find((l$10) => l$10.text.toLowerCase() === "end");
	if (!end) {
		transport.setProjectEndSamples(0);
		return;
	}
	transport.setProjectEndSamples(Math.round(end.bar * 4 * 60 / bpm.value * (playingProgramContext.value?.latency.value.state.sampleRate || 44100)));
});
const djDocA = c$3(createPersistedDoc("dj-doc-a", tokenize));
const djDocB = c$3(createPersistedDoc("dj-doc-b", tokenize));
const djProgramA = c$3(null);
const djProgramB = c$3(null);
const djHeaderA = c$3(null);
const djHeaderB = c$3(null);
const djTitleA = c$3("");
const djTitleB = c$3("");
const djCrossfade = c$3(.5);
const djBpm = c$3(120);
const djTargetSecondsA = c$3(0);
const djTargetSecondsB = c$3(0);
const djIsScrubbingA = c$3(false);
const djIsScrubbingB = c$3(false);
const djScrubbingProgramStateA = c$3(DspProgramState.Stop);
const djScrubbingProgramStateB = c$3(DspProgramState.Stop);
function djGridSamples(sampleRate, bpm$1) {
	const stepSeconds = 60 / (bpm$1 || 120) / 4;
	return Math.max(1, Math.round(stepSeconds * (sampleRate || 44100)));
}
function djAlignToPhase(sampleCount, grid, phase) {
	const g$5 = Math.max(1, Math.round(grid) || 1);
	const p$6 = (Math.round(phase) % g$5 + g$5) % g$5;
	const s$4 = Math.max(0, Math.round(sampleCount));
	let delta = p$6 - (s$4 % g$5 + g$5) % g$5;
	const half = g$5 / 2;
	if (delta > half) delta -= g$5;
	else if (delta < -half) delta += g$5;
	return Math.max(0, s$4 + delta);
}
async function ensureDjProgramContexts() {
	if (!ctx.value) return;
	const c$7 = ctx.value;
	const a$36 = await getProgramContext(c$7, "dj-doc-a", { doc: djDocA.value });
	const b$4 = await getProgramContext(c$7, "dj-doc-b", { doc: djDocB.value });
	n(() => {
		a$36.fullResync.value = true;
		b$4.fullResync.value = true;
	});
	return {
		a: a$36,
		b: b$4
	};
}
const djTransport = {
	start: async () => {
		if (!ctx.value) return;
		const dsp = ctx.value.dsp;
		await dsp.state.audioContext.resume();
		const inline = playingInlineContext.value;
		if (inline) {
			playingInlineContext.value = null;
			await dsp.stop([inline.program]);
		}
		const normal = playingContext.value;
		if (normal) {
			playingContext.value = null;
			await dsp.stop([normal.program]);
		}
		const contexts = await ensureDjProgramContexts();
		if (!contexts) return;
		const { a: a$36, b: b$4 } = contexts;
		playingDjContexts.value = [a$36, b$4];
		await dsp.start([a$36.program, b$4.program]);
		await Promise.all([dsp.refreshUntilHistories(a$36.program, { maxTries: 60 }), dsp.refreshUntilHistories(b$4.program, { maxTries: 60 })]);
		deferDraw.value = true;
	},
	pause: async () => {
		const contexts = await ensureDjProgramContexts();
		if (!contexts || !ctx.value) return;
		ctx.value.dsp.togglePause([contexts.a.program, contexts.b.program]);
	},
	stop: async () => {
		const contexts = await ensureDjProgramContexts();
		if (!contexts || !ctx.value) return;
		playingDjContexts.value = [];
		await ctx.value.dsp.stop([contexts.a.program, contexts.b.program]);
	},
	restart: async () => {
		const contexts = await ensureDjProgramContexts();
		if (!contexts || !ctx.value) return;
		await ctx.value.dsp.state.audioContext.resume();
		skipAnimations.value += 1;
		await ctx.value.dsp.seek(0, [contexts.a.program, contexts.b.program], false);
	},
	beginSeek: async (deck) => {
		const contexts = await ensureDjProgramContexts();
		if (!contexts || !ctx.value) return;
		const p$6 = deck === "a" ? contexts.a : contexts.b;
		if (deck === "a") {
			djIsScrubbingA.value = true;
			djScrubbingProgramStateA.value = p$6.program.state;
		} else {
			djIsScrubbingB.value = true;
			djScrubbingProgramStateB.value = p$6.program.state;
		}
		ctx.value.dsp.pause([p$6.program]);
	},
	endSeek: async (deck) => {
		const contexts = await ensureDjProgramContexts();
		if (!contexts || !ctx.value) return;
		const dsp = ctx.value.dsp;
		const p$6 = deck === "a" ? contexts.a : contexts.b;
		if ((deck === "a" ? djScrubbingProgramStateA.value : djScrubbingProgramStateB.value) === DspProgramState.Start) dsp.start([p$6.program]);
		else dsp.pause([p$6.program]);
		if (deck === "a") djIsScrubbingA.value = false;
		else djIsScrubbingB.value = false;
	},
	seek: async (deck, seconds) => {
		const contexts = await ensureDjProgramContexts();
		if (!contexts || !ctx.value) return;
		const dsp = ctx.value.dsp;
		const p$6 = deck === "a" ? contexts.a : contexts.b;
		const other = deck === "a" ? contexts.b : contexts.a;
		const sampleRate = p$6.latency.value.state.sampleRate || 44100;
		const bpm$1 = p$6.result.value?.compile.bpm ?? other.result.value?.compile.bpm ?? 120;
		const desired = Math.round(seconds * sampleRate);
		const grid = djGridSamples(sampleRate, bpm$1);
		other.program.latency.update();
		const aligned = djAlignToPhase(desired, grid, ((other.program.latency.state.sampleCount ?? 0) % grid + grid) % grid);
		if (deck === "a") djTargetSecondsA.value = seconds;
		else djTargetSecondsB.value = seconds;
		const preview = (deck === "a" ? djScrubbingProgramStateA.value : djScrubbingProgramStateB.value) === DspProgramState.Start && isActuallyPlaying.value;
		await dsp.seekPrograms(aligned, [p$6.program], preview);
	},
	deck: (deck) => ({
		restart: () => djTransport.restart(),
		beginSeek: () => djTransport.beginSeek(deck),
		endSeek: () => djTransport.endSeek(deck),
		seek: (seconds) => djTransport.seek(deck, seconds),
		getLoopBeginSamples: () => transport.getLoopBeginSamples(),
		getLoopEndSamples: () => transport.getLoopEndSamples(),
		setLoopBeginSamples: (samples) => transport.setLoopBeginSamples(samples),
		setLoopEndSamples: (samples) => transport.setLoopEndSamples(samples)
	})
};
m(() => {
	const c$7 = ctx.value;
	const a$36 = djProgramA.value;
	const b$4 = djProgramB.value;
	const x$4 = djCrossfade.value;
	if (!c$7 || !a$36 || !b$4) return;
	let gainA, gainB;
	if (x$4 < .5) {
		gainA = 1;
		gainB = x$4 * 2;
	} else {
		gainA = 1 - (x$4 - .5) * 2;
		gainB = 1;
	}
	gainA = Math.max(0, Math.min(1, gainA));
	gainB = Math.max(0, Math.min(1, gainB));
	c$7.dsp.setProgramGain(a$36.program, gainA);
	c$7.dsp.setProgramGain(b$4.program, gainB);
});
m(() => {
	const c$7 = ctx.value;
	if (!c$7) return;
	const page = mainPage.value;
	const bpmValue = djBpm.value;
	if (page === "dj") c$7.dsp.bpmOverride(bpmValue);
	else c$7.dsp.bpmOverride(0);
});
m(() => {
	if (mainPage.value !== "dj") return;
	const a$36 = djProgramA.value;
	const b$4 = djProgramB.value;
	if (!a$36 || !b$4) return;
	const bpmValue = djBpm.value || a$36.result.value?.compile?.bpm || b$4.result.value?.compile?.bpm || 120;
	const sampleRate = a$36.latency.value.state.sampleRate ?? b$4.latency.value.state.sampleRate ?? 44100;
	const endA = [...a$36.result.value?.compile?.labels ?? []].find((l$10) => l$10.text.toLowerCase() === "end");
	const endB = [...b$4.result.value?.compile?.labels ?? []].find((l$10) => l$10.text.toLowerCase() === "end");
	const aSamples = endA ? Math.round(endA.bar * 4 * 60 / bpmValue * sampleRate) : 0;
	const bSamples = endB ? Math.round(endB.bar * 4 * 60 / bpmValue * sampleRate) : 0;
	transport.setProjectEndSamples(Math.max(aSamples, bSamples));
});
m(() => {
	const programCtx = djProgramA.value;
	if (!programCtx || !ctx.value) return;
	tickCount.value;
	if (!isActuallyPlaying.value) programCtx.program.latency.update();
	const seconds = djIsScrubbingA.value ? djTargetSecondsA.value : programCtx.latency.value.state.timeSeconds ?? 0;
	if ((djIsScrubbingA.value || !isActuallyPlaying.value) && skipAnimations.value === 0) {
		const prev = programCtx.timeSeconds.peek();
		programCtx.timeSeconds.value = prev + (seconds - prev) * .35;
	} else programCtx.timeSeconds.value = seconds;
});
m(() => {
	const programCtx = djProgramB.value;
	if (!programCtx || !ctx.value) return;
	tickCount.value;
	if (!isActuallyPlaying.value) programCtx.program.latency.update();
	const seconds = djIsScrubbingB.value ? djTargetSecondsB.value : programCtx.latency.value.state.timeSeconds ?? 0;
	if ((djIsScrubbingB.value || !isActuallyPlaying.value) && skipAnimations.value === 0) {
		const prev = programCtx.timeSeconds.peek();
		programCtx.timeSeconds.value = prev + (seconds - prev) * .35;
	} else programCtx.timeSeconds.value = seconds;
});
m(() => {
	if (!ctx.value) return;
	getProgramContext(ctx.value, "dj-doc-a", { doc: djDocA.value }).then((programContext) => {
		djProgramA.value = programContext;
		djHeaderA.value = createHeader(ctx.value, programContext, {
			transport: djTransport.deck("a"),
			setTargetSeconds: (seconds) => djTargetSecondsA.value = seconds
		});
	});
	getProgramContext(ctx.value, "dj-doc-b", { doc: djDocB.value }).then((programContext) => {
		djProgramB.value = programContext;
		djHeaderB.value = createHeader(ctx.value, programContext, {
			transport: djTransport.deck("b"),
			setTargetSeconds: (seconds) => djTargetSecondsB.value = seconds
		});
	});
});
persist("dj", () => {
	djTitleA.value;
	djTitleB.value;
}, () => ({
	djTitleA: djTitleA.value,
	djTitleB: djTitleB.value,
	djBpm: djBpm.value
}), (data) => {
	djTitleA.value = data.djTitleA ?? "";
	djTitleB.value = data.djTitleB ?? "";
	djBpm.value = data.djBpm ?? 120;
});
function g(n$4, t$12) {
	for (var e$59 in t$12) n$4[e$59] = t$12[e$59];
	return n$4;
}
function E(n$4, t$12) {
	for (var e$59 in n$4) if ("__source" !== e$59 && !(e$59 in t$12)) return !0;
	for (var r$11 in t$12) if ("__source" !== r$11 && n$4[r$11] !== t$12[r$11]) return !0;
	return !1;
}
function N(n$4, t$12) {
	this.props = n$4, this.context = t$12;
}
(N.prototype = new x()).isPureReactComponent = !0, N.prototype.shouldComponentUpdate = function(n$4, t$12) {
	return E(this.props, n$4) || E(this.state, t$12);
};
var T$1 = l.__b;
l.__b = function(n$4) {
	n$4.type && n$4.type.__f && n$4.ref && (n$4.props.ref = n$4.ref, n$4.ref = null), T$1 && T$1(n$4);
};
var A$1 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
function D(n$4) {
	function t$12(t$13) {
		var e$59 = g({}, t$13);
		return delete e$59.ref, n$4(e$59, t$13.ref || null);
	}
	return t$12.$$typeof = A$1, t$12.render = n$4, t$12.prototype.isReactComponent = t$12.__f = !0, t$12.displayName = "ForwardRef(" + (n$4.displayName || n$4.name) + ")", t$12;
}
var U = l.__e;
l.__e = function(n$4, t$12, e$59, r$11) {
	if (n$4.then) {
		for (var u$5, o$34 = t$12; o$34 = o$34.__;) if ((u$5 = o$34.__c) && u$5.__c) return t$12.__e ?? (t$12.__e = e$59.__e, t$12.__k = e$59.__k), u$5.__c(n$4, t$12);
	}
	U(n$4, t$12, e$59, r$11);
};
var F = l.unmount;
function V(n$4, t$12, e$59) {
	return n$4 && (n$4.__c && n$4.__c.__H && (n$4.__c.__H.__.forEach(function(n$5) {
		"function" == typeof n$5.__c && n$5.__c();
	}), n$4.__c.__H = null), null != (n$4 = g({}, n$4)).__c && (n$4.__c.__P === e$59 && (n$4.__c.__P = t$12), n$4.__c.__e = !0, n$4.__c = null), n$4.__k = n$4.__k && n$4.__k.map(function(n$5) {
		return V(n$5, t$12, e$59);
	})), n$4;
}
function W(n$4, t$12, e$59) {
	return n$4 && e$59 && (n$4.__v = null, n$4.__k = n$4.__k && n$4.__k.map(function(n$5) {
		return W(n$5, t$12, e$59);
	}), n$4.__c && n$4.__c.__P === t$12 && (n$4.__e && e$59.appendChild(n$4.__e), n$4.__c.__e = !0, n$4.__c.__P = e$59)), n$4;
}
function P() {
	this.__u = 0, this.o = null, this.__b = null;
}
function j(n$4) {
	if (!n$4.__) return null;
	var t$12 = n$4.__.__c;
	return t$12 && t$12.__a && t$12.__a(n$4);
}
function B() {
	this.i = null, this.l = null;
}
l.unmount = function(n$4) {
	var t$12 = n$4.__c;
	t$12 && (t$12.__z = !0), t$12 && t$12.__R && t$12.__R(), t$12 && 32 & n$4.__u && (n$4.type = null), F && F(n$4);
}, (P.prototype = new x()).__c = function(n$4, t$12) {
	var e$59 = t$12.__c, r$11 = this;
	r$11.o ??= [], r$11.o.push(e$59);
	var u$5 = j(r$11.__v), o$34 = !1, i$6 = function() {
		o$34 || r$11.__z || (o$34 = !0, e$59.__R = null, u$5 ? u$5(c$7) : c$7());
	};
	e$59.__R = i$6;
	var l$10 = e$59.__P;
	e$59.__P = null;
	var c$7 = function() {
		if (!--r$11.__u) {
			if (r$11.state.__a) {
				var n$5 = r$11.state.__a;
				r$11.__v.__k[0] = W(n$5, n$5.__c.__P, n$5.__c.__O);
			}
			var t$13;
			for (r$11.setState({ __a: r$11.__b = null }); t$13 = r$11.o.pop();) t$13.__P = l$10, t$13.forceUpdate();
		}
	};
	r$11.__u++ || 32 & t$12.__u || r$11.setState({ __a: r$11.__b = r$11.__v.__k[0] }), n$4.then(i$6, i$6);
}, P.prototype.componentWillUnmount = function() {
	this.o = [];
}, P.prototype.render = function(n$4, e$59) {
	if (this.__b) {
		if (this.__v.__k) {
			var r$11 = document.createElement("div"), o$34 = this.__v.__k[0].__c;
			this.__v.__k[0] = V(this.__b, r$11, o$34.__O = o$34.__P);
		}
		this.__b = null;
	}
	var i$6 = e$59.__a && _(k, null, n$4.fallback);
	return i$6 && (i$6.__u &= -33), [_(k, null, e$59.__a ? null : n$4.children), i$6];
};
var H = function(n$4, t$12, e$59) {
	if (++e$59[1] === e$59[0] && n$4.l.delete(t$12), n$4.props.revealOrder && ("t" !== n$4.props.revealOrder[0] || !n$4.l.size)) for (e$59 = n$4.i; e$59;) {
		for (; e$59.length > 3;) e$59.pop()();
		if (e$59[1] < e$59[0]) break;
		n$4.i = e$59 = e$59[2];
	}
};
(B.prototype = new x()).__a = function(n$4) {
	var t$12 = this, e$59 = j(t$12.__v), r$11 = t$12.l.get(n$4);
	return r$11[0]++, function(u$5) {
		var o$34 = function() {
			t$12.props.revealOrder ? (r$11.push(u$5), H(t$12, n$4, r$11)) : u$5();
		};
		e$59 ? e$59(o$34) : o$34();
	};
}, B.prototype.render = function(n$4) {
	this.i = null, this.l = /* @__PURE__ */ new Map();
	var t$12 = L(n$4.children);
	n$4.revealOrder && "b" === n$4.revealOrder[0] && t$12.reverse();
	for (var e$59 = t$12.length; e$59--;) this.l.set(t$12[e$59], this.i = [
		1,
		0,
		this.i
	]);
	return n$4.children;
}, B.prototype.componentDidUpdate = B.prototype.componentDidMount = function() {
	var n$4 = this;
	this.l.forEach(function(t$12, e$59) {
		H(n$4, e$59, t$12);
	});
};
var q$1 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103, G = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/, J$1 = /^on(Ani|Tra|Tou|BeforeInp|Compo)/, K$1 = /[A-Z0-9]/g, Q$1 = "undefined" != typeof document, X = function(n$4) {
	return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/ : /fil|che|ra/).test(n$4);
};
x.prototype.isReactComponent = {}, [
	"componentWillMount",
	"componentWillReceiveProps",
	"componentWillUpdate"
].forEach(function(t$12) {
	Object.defineProperty(x.prototype, t$12, {
		configurable: !0,
		get: function() {
			return this["UNSAFE_" + t$12];
		},
		set: function(n$4) {
			Object.defineProperty(this, t$12, {
				configurable: !0,
				writable: !0,
				value: n$4
			});
		}
	});
});
var en = l.event;
function rn() {}
function un() {
	return this.cancelBubble;
}
function on() {
	return this.defaultPrevented;
}
l.event = function(n$4) {
	return en && (n$4 = en(n$4)), n$4.persist = rn, n$4.isPropagationStopped = un, n$4.isDefaultPrevented = on, n$4.nativeEvent = n$4;
};
var cn$1 = {
	enumerable: !1,
	configurable: !0,
	get: function() {
		return this.class;
	}
}, fn = l.vnode;
l.vnode = function(n$4) {
	"string" == typeof n$4.type && function(n$5) {
		var t$12 = n$5.props, e$59 = n$5.type, u$5 = {}, o$34 = -1 === e$59.indexOf("-");
		for (var i$6 in t$12) {
			var l$10 = t$12[i$6];
			if (!("value" === i$6 && "defaultValue" in t$12 && null == l$10 || Q$1 && "children" === i$6 && "noscript" === e$59 || "class" === i$6 || "className" === i$6)) {
				var c$7 = i$6.toLowerCase();
				"defaultValue" === i$6 && "value" in t$12 && null == t$12.value ? i$6 = "value" : "download" === i$6 && !0 === l$10 ? l$10 = "" : "translate" === c$7 && "no" === l$10 ? l$10 = !1 : "o" === c$7[0] && "n" === c$7[1] ? "ondoubleclick" === c$7 ? i$6 = "ondblclick" : "onchange" !== c$7 || "input" !== e$59 && "textarea" !== e$59 || X(t$12.type) ? "onfocus" === c$7 ? i$6 = "onfocusin" : "onblur" === c$7 ? i$6 = "onfocusout" : J$1.test(i$6) && (i$6 = c$7) : c$7 = i$6 = "oninput" : o$34 && G.test(i$6) ? i$6 = i$6.replace(K$1, "-$&").toLowerCase() : null === l$10 && (l$10 = void 0), "oninput" === c$7 && u$5[i$6 = c$7] && (i$6 = "oninputCapture"), u$5[i$6] = l$10;
			}
		}
		"select" == e$59 && u$5.multiple && Array.isArray(u$5.value) && (u$5.value = L(t$12.children).forEach(function(n$6) {
			n$6.props.selected = -1 != u$5.value.indexOf(n$6.props.value);
		})), "select" == e$59 && null != u$5.defaultValue && (u$5.value = L(t$12.children).forEach(function(n$6) {
			n$6.props.selected = u$5.multiple ? -1 != u$5.defaultValue.indexOf(n$6.props.value) : u$5.defaultValue == n$6.props.value;
		})), t$12.class && !t$12.className ? (u$5.class = t$12.class, Object.defineProperty(u$5, "className", cn$1)) : t$12.className && (u$5.class = u$5.className = t$12.className), n$5.props = u$5;
	}(n$4), n$4.$$typeof = q$1, fn && fn(n$4);
};
var an = l.__r;
l.__r = function(n$4) {
	an && an(n$4), n$4.__c;
};
var sn = l.diffed;
l.diffed = function(n$4) {
	sn && sn(n$4);
	var t$12 = n$4.props, e$59 = n$4.__e;
	null != e$59 && "textarea" === n$4.type && "value" in t$12 && t$12.value !== e$59.value && (e$59.value = null == t$12.value ? "" : t$12.value);
};
var a$31 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M244,56v48a12,12,0,0,1-12,12H184a12,12,0,1,1,0-24H201.1l-19-17.38c-.13-.12-.26-.24-.38-.37A76,76,0,1,0,127,204h1a75.53,75.53,0,0,0,52.15-20.72,12,12,0,0,1,16.49,17.45A99.45,99.45,0,0,1,128,228h-1.37A100,100,0,1,1,198.51,57.06L220,76.72V56a12,12,0,0,1,24,0Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M216,128a88,88,0,1,1-88-88A88,88,0,0,1,216,128Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M240,56v48a8,8,0,0,1-8,8H184a8,8,0,0,1,0-16H211.4L184.81,71.64l-.25-.24a80,80,0,1,0-1.67,114.78,8,8,0,0,1,11,11.63A95.44,95.44,0,0,1,128,224h-1.32A96,96,0,1,1,195.75,60L224,85.8V56a8,8,0,1,1,16,0Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M240,56v48a8,8,0,0,1-8,8H184a8,8,0,0,1-5.66-13.66l17-17-10.55-9.65-.25-.24a80,80,0,1,0-1.67,114.78,8,8,0,1,1,11,11.63A95.44,95.44,0,0,1,128,224h-1.32A96,96,0,1,1,195.75,60l10.93,10L226.34,50.3A8,8,0,0,1,240,56Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M238,56v48a6,6,0,0,1-6,6H184a6,6,0,0,1,0-12h32.55l-30.38-27.8c-.06-.06-.12-.13-.19-.19a82,82,0,1,0-1.7,117.65,6,6,0,0,1,8.24,8.73A93.46,93.46,0,0,1,128,222h-1.28A94,94,0,1,1,194.37,61.4L226,90.35V56a6,6,0,1,1,12,0Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M240,56v48a8,8,0,0,1-8,8H184a8,8,0,0,1,0-16H211.4L184.81,71.64l-.25-.24a80,80,0,1,0-1.67,114.78,8,8,0,0,1,11,11.63A95.44,95.44,0,0,1,128,224h-1.32A96,96,0,1,1,195.75,60L224,85.8V56a8,8,0,1,1,16,0Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M236,56v48a4,4,0,0,1-4,4H184a4,4,0,0,1,0-8h37.7L187.53,68.69l-.13-.12a84,84,0,1,0-1.75,120.51,4,4,0,0,1,5.5,5.82A91.43,91.43,0,0,1,128,220h-1.26A92,92,0,1,1,193,62.84l35,32.05V56a4,4,0,1,1,8,0Z" }))]
]);
var e$54 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M228,48V96a12,12,0,0,1-12,12H168a12,12,0,0,1,0-24h19l-7.8-7.8a75.55,75.55,0,0,0-53.32-22.26h-.43A75.49,75.49,0,0,0,72.39,75.57,12,12,0,1,1,55.61,58.41a99.38,99.38,0,0,1,69.87-28.47H126A99.42,99.42,0,0,1,196.2,59.23L204,67V48a12,12,0,0,1,24,0ZM183.61,180.43a75.49,75.49,0,0,1-53.09,21.63h-.43A75.55,75.55,0,0,1,76.77,179.8L69,172H88a12,12,0,0,0,0-24H40a12,12,0,0,0-12,12v48a12,12,0,0,0,24,0V189l7.8,7.8A99.42,99.42,0,0,0,130,226.06h.56a99.38,99.38,0,0,0,69.87-28.47,12,12,0,0,0-16.78-17.16Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M216,128a88,88,0,1,1-88-88A88,88,0,0,1,216,128Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M224,48V96a8,8,0,0,1-8,8H168a8,8,0,0,1,0-16h28.69L182.06,73.37a79.56,79.56,0,0,0-56.13-23.43h-.45A79.52,79.52,0,0,0,69.59,72.71,8,8,0,0,1,58.41,61.27a96,96,0,0,1,135,.79L208,76.69V48a8,8,0,0,1,16,0ZM186.41,183.29a80,80,0,0,1-112.47-.66L59.31,168H88a8,8,0,0,0,0-16H40a8,8,0,0,0-8,8v48a8,8,0,0,0,16,0V179.31l14.63,14.63A95.43,95.43,0,0,0,130,222.06h.53a95.36,95.36,0,0,0,67.07-27.33,8,8,0,0,0-11.18-11.44Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M224,48V96a8,8,0,0,1-8,8H168a8,8,0,0,1-5.66-13.66L180.65,72a79.48,79.48,0,0,0-54.72-22.09h-.45A79.52,79.52,0,0,0,69.59,72.71,8,8,0,0,1,58.41,61.27,96,96,0,0,1,192,60.7l18.36-18.36A8,8,0,0,1,224,48ZM186.41,183.29A80,80,0,0,1,75.35,184l18.31-18.31A8,8,0,0,0,88,152H40a8,8,0,0,0-8,8v48a8,8,0,0,0,13.66,5.66L64,195.3a95.42,95.42,0,0,0,66,26.76h.53a95.36,95.36,0,0,0,67.07-27.33,8,8,0,0,0-11.18-11.44Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M222,48V96a6,6,0,0,1-6,6H168a6,6,0,0,1,0-12h33.52L183.47,72a81.51,81.51,0,0,0-57.53-24h-.46A81.5,81.5,0,0,0,68.19,71.28a6,6,0,1,1-8.38-8.58,93.38,93.38,0,0,1,65.67-26.76H126a93.45,93.45,0,0,1,66,27.53l18,18V48a6,6,0,0,1,12,0ZM187.81,184.72a81.5,81.5,0,0,1-57.29,23.34h-.46a81.51,81.51,0,0,1-57.53-24L54.48,166H88a6,6,0,0,0,0-12H40a6,6,0,0,0-6,6v48a6,6,0,0,0,12,0V174.48l18,18.05a93.45,93.45,0,0,0,66,27.53h.52a93.38,93.38,0,0,0,65.67-26.76,6,6,0,1,0-8.38-8.58Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M224,48V96a8,8,0,0,1-8,8H168a8,8,0,0,1,0-16h28.69L182.06,73.37a79.56,79.56,0,0,0-56.13-23.43h-.45A79.52,79.52,0,0,0,69.59,72.71,8,8,0,0,1,58.41,61.27a96,96,0,0,1,135,.79L208,76.69V48a8,8,0,0,1,16,0ZM186.41,183.29a80,80,0,0,1-112.47-.66L59.31,168H88a8,8,0,0,0,0-16H40a8,8,0,0,0-8,8v48a8,8,0,0,0,16,0V179.31l14.63,14.63A95.43,95.43,0,0,0,130,222.06h.53a95.36,95.36,0,0,0,67.07-27.33,8,8,0,0,0-11.18-11.44Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M220,48V96a4,4,0,0,1-4,4H168a4,4,0,0,1,0-8h38.34L184.89,70.54A84,84,0,0,0,66.8,69.85a4,4,0,1,1-5.6-5.72,92,92,0,0,1,129.34.76L212,86.34V48a4,4,0,0,1,8,0ZM189.2,186.15a83.44,83.44,0,0,1-58.68,23.91h-.47a83.52,83.52,0,0,1-58.94-24.6L49.66,164H88a4,4,0,0,0,0-8H40a4,4,0,0,0-4,4v48a4,4,0,0,0,8,0V169.66l21.46,21.45A91.43,91.43,0,0,0,130,218.06h.51a91.45,91.45,0,0,0,64.28-26.19,4,4,0,1,0-5.6-5.72Z" }))]
]);
var e$53 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M216,36H40A20,20,0,0,0,20,56V200a20,20,0,0,0,20,20H216a20,20,0,0,0,20-20V56A20,20,0,0,0,216,36Zm-4,160H44V60H212ZM68,92A12,12,0,0,1,80,80h96a12,12,0,0,1,0,24H80A12,12,0,0,1,68,92Zm0,36a12,12,0,0,1,12-12h96a12,12,0,0,1,0,24H80A12,12,0,0,1,68,128Zm0,36a12,12,0,0,1,12-12h96a12,12,0,0,1,0,24H80A12,12,0,0,1,68,164Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M224,56V200a8,8,0,0,1-8,8H40a8,8,0,0,1-8-8V56a8,8,0,0,1,8-8H216A8,8,0,0,1,224,56Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M216,40H40A16,16,0,0,0,24,56V200a16,16,0,0,0,16,16H216a16,16,0,0,0,16-16V56A16,16,0,0,0,216,40Zm0,160H40V56H216V200ZM184,96a8,8,0,0,1-8,8H80a8,8,0,0,1,0-16h96A8,8,0,0,1,184,96Zm0,32a8,8,0,0,1-8,8H80a8,8,0,0,1,0-16h96A8,8,0,0,1,184,128Zm0,32a8,8,0,0,1-8,8H80a8,8,0,0,1,0-16h96A8,8,0,0,1,184,160Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M216,40H40A16,16,0,0,0,24,56V200a16,16,0,0,0,16,16H216a16,16,0,0,0,16-16V56A16,16,0,0,0,216,40ZM176,168H80a8,8,0,0,1,0-16h96a8,8,0,0,1,0,16Zm0-32H80a8,8,0,0,1,0-16h96a8,8,0,0,1,0,16Zm0-32H80a8,8,0,0,1,0-16h96a8,8,0,0,1,0,16Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M216,42H40A14,14,0,0,0,26,56V200a14,14,0,0,0,14,14H216a14,14,0,0,0,14-14V56A14,14,0,0,0,216,42Zm2,158a2,2,0,0,1-2,2H40a2,2,0,0,1-2-2V56a2,2,0,0,1,2-2H216a2,2,0,0,1,2,2ZM182,96a6,6,0,0,1-6,6H80a6,6,0,0,1,0-12h96A6,6,0,0,1,182,96Zm0,32a6,6,0,0,1-6,6H80a6,6,0,0,1,0-12h96A6,6,0,0,1,182,128Zm0,32a6,6,0,0,1-6,6H80a6,6,0,0,1,0-12h96A6,6,0,0,1,182,160Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M216,40H40A16,16,0,0,0,24,56V200a16,16,0,0,0,16,16H216a16,16,0,0,0,16-16V56A16,16,0,0,0,216,40Zm0,160H40V56H216V200ZM184,96a8,8,0,0,1-8,8H80a8,8,0,0,1,0-16h96A8,8,0,0,1,184,96Zm0,32a8,8,0,0,1-8,8H80a8,8,0,0,1,0-16h96A8,8,0,0,1,184,128Zm0,32a8,8,0,0,1-8,8H80a8,8,0,0,1,0-16h96A8,8,0,0,1,184,160Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M216,44H40A12,12,0,0,0,28,56V200a12,12,0,0,0,12,12H216a12,12,0,0,0,12-12V56A12,12,0,0,0,216,44Zm4,156a4,4,0,0,1-4,4H40a4,4,0,0,1-4-4V56a4,4,0,0,1,4-4H216a4,4,0,0,1,4,4ZM180,96a4,4,0,0,1-4,4H80a4,4,0,0,1,0-8h96A4,4,0,0,1,180,96Zm0,32a4,4,0,0,1-4,4H80a4,4,0,0,1,0-8h96A4,4,0,0,1,180,128Zm0,32a4,4,0,0,1-4,4H80a4,4,0,0,1,0-8h96A4,4,0,0,1,180,160Z" }))]
]);
var e$52 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M232,44H160a43.86,43.86,0,0,0-32,13.85A43.86,43.86,0,0,0,96,44H24A12,12,0,0,0,12,56V200a12,12,0,0,0,12,12H96a20,20,0,0,1,20,20,12,12,0,0,0,24,0,20,20,0,0,1,20-20h72a12,12,0,0,0,12-12V56A12,12,0,0,0,232,44ZM96,188H36V68H96a20,20,0,0,1,20,20V192.81A43.79,43.79,0,0,0,96,188Zm124,0H160a43.71,43.71,0,0,0-20,4.83V88a20,20,0,0,1,20-20h60Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M232,56V200H160a32,32,0,0,0-32,32,32,32,0,0,0-32-32H24V56H96a32,32,0,0,1,32,32,32,32,0,0,1,32-32Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M232,48H160a40,40,0,0,0-32,16A40,40,0,0,0,96,48H24a8,8,0,0,0-8,8V200a8,8,0,0,0,8,8H96a24,24,0,0,1,24,24,8,8,0,0,0,16,0,24,24,0,0,1,24-24h72a8,8,0,0,0,8-8V56A8,8,0,0,0,232,48ZM96,192H32V64H96a24,24,0,0,1,24,24V200A39.81,39.81,0,0,0,96,192Zm128,0H160a39.81,39.81,0,0,0-24,8V88a24,24,0,0,1,24-24h64Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M240,56V200a8,8,0,0,1-8,8H160a24,24,0,0,0-24,23.94,7.9,7.9,0,0,1-5.12,7.55A8,8,0,0,1,120,232a24,24,0,0,0-24-24H24a8,8,0,0,1-8-8V56a8,8,0,0,1,8-8H88a32,32,0,0,1,32,32v87.73a8.17,8.17,0,0,0,7.47,8.25,8,8,0,0,0,8.53-8V80a32,32,0,0,1,32-32h64A8,8,0,0,1,240,56Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M232,50H160a38,38,0,0,0-32,17.55A38,38,0,0,0,96,50H24a6,6,0,0,0-6,6V200a6,6,0,0,0,6,6H96a26,26,0,0,1,26,26,6,6,0,0,0,12,0,26,26,0,0,1,26-26h72a6,6,0,0,0,6-6V56A6,6,0,0,0,232,50ZM96,194H30V62H96a26,26,0,0,1,26,26V204.31A37.86,37.86,0,0,0,96,194Zm130,0H160a37.87,37.87,0,0,0-26,10.32V88a26,26,0,0,1,26-26h66Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M232,48H160a40,40,0,0,0-32,16A40,40,0,0,0,96,48H24a8,8,0,0,0-8,8V200a8,8,0,0,0,8,8H96a24,24,0,0,1,24,24,8,8,0,0,0,16,0,24,24,0,0,1,24-24h72a8,8,0,0,0,8-8V56A8,8,0,0,0,232,48ZM96,192H32V64H96a24,24,0,0,1,24,24V200A39.81,39.81,0,0,0,96,192Zm128,0H160a39.81,39.81,0,0,0-24,8V88a24,24,0,0,1,24-24h64Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M232,52H160a36,36,0,0,0-32,19.54A36,36,0,0,0,96,52H24a4,4,0,0,0-4,4V200a4,4,0,0,0,4,4H96a28,28,0,0,1,28,28,4,4,0,0,0,8,0,28,28,0,0,1,28-28h72a4,4,0,0,0,4-4V56A4,4,0,0,0,232,52ZM96,196H28V60H96a28,28,0,0,1,28,28V209.4A35.93,35.93,0,0,0,96,196Zm132,0H160a35.94,35.94,0,0,0-28,13.41V88a28,28,0,0,1,28-28h68Z" }))]
]);
var t$7 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M216.49,104.49l-80,80a12,12,0,0,1-17,0l-80-80a12,12,0,0,1,17-17L128,159l71.51-71.52a12,12,0,0,1,17,17Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M208,96l-80,80L48,96Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M215.39,92.94A8,8,0,0,0,208,88H48a8,8,0,0,0-5.66,13.66l80,80a8,8,0,0,0,11.32,0l80-80A8,8,0,0,0,215.39,92.94ZM128,164.69,67.31,104H188.69Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M213.66,101.66l-80,80a8,8,0,0,1-11.32,0l-80-80A8,8,0,0,1,48,88H208a8,8,0,0,1,5.66,13.66Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M212.24,100.24l-80,80a6,6,0,0,1-8.48,0l-80-80a6,6,0,0,1,8.48-8.48L128,167.51l75.76-75.75a6,6,0,0,1,8.48,8.48Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M213.66,101.66l-80,80a8,8,0,0,1-11.32,0l-80-80A8,8,0,0,1,53.66,90.34L128,164.69l74.34-74.35a8,8,0,0,1,11.32,11.32Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M210.83,98.83l-80,80a4,4,0,0,1-5.66,0l-80-80a4,4,0,0,1,5.66-5.66L128,170.34l77.17-77.17a4,4,0,1,1,5.66,5.66Z" }))]
]);
var a$30 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M168.49,199.51a12,12,0,0,1-17,17l-80-80a12,12,0,0,1,0-17l80-80a12,12,0,0,1,17,17L97,128Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M160,48V208L80,128Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M163.06,40.61a8,8,0,0,0-8.72,1.73l-80,80a8,8,0,0,0,0,11.32l80,80A8,8,0,0,0,168,208V48A8,8,0,0,0,163.06,40.61ZM152,188.69,91.31,128,152,67.31Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M168,48V208a8,8,0,0,1-13.66,5.66l-80-80a8,8,0,0,1,0-11.32l80-80A8,8,0,0,1,168,48Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M164.24,203.76a6,6,0,1,1-8.48,8.48l-80-80a6,6,0,0,1,0-8.48l80-80a6,6,0,0,1,8.48,8.48L88.49,128Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M165.66,202.34a8,8,0,0,1-11.32,11.32l-80-80a8,8,0,0,1,0-11.32l80-80a8,8,0,0,1,11.32,11.32L91.31,128Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M162.83,205.17a4,4,0,0,1-5.66,5.66l-80-80a4,4,0,0,1,0-5.66l80-80a4,4,0,1,1,5.66,5.66L85.66,128Z" }))]
]);
var t$6 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M184.49,136.49l-80,80a12,12,0,0,1-17-17L159,128,87.51,56.49a12,12,0,1,1,17-17l80,80A12,12,0,0,1,184.49,136.49Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M176,128,96,208V48Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M181.66,122.34l-80-80A8,8,0,0,0,88,48V208a8,8,0,0,0,13.66,5.66l80-80A8,8,0,0,0,181.66,122.34ZM104,188.69V67.31L164.69,128Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M181.66,133.66l-80,80A8,8,0,0,1,88,208V48a8,8,0,0,1,13.66-5.66l80,80A8,8,0,0,1,181.66,133.66Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M180.24,132.24l-80,80a6,6,0,0,1-8.48-8.48L167.51,128,91.76,52.24a6,6,0,0,1,8.48-8.48l80,80A6,6,0,0,1,180.24,132.24Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M181.66,133.66l-80,80a8,8,0,0,1-11.32-11.32L164.69,128,90.34,53.66a8,8,0,0,1,11.32-11.32l80,80A8,8,0,0,1,181.66,133.66Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M178.83,130.83l-80,80a4,4,0,0,1-5.66-5.66L170.34,128,93.17,50.83a4,4,0,0,1,5.66-5.66l80,80A4,4,0,0,1,178.83,130.83Z" }))]
]);
var a$29 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M216.49,168.49a12,12,0,0,1-17,0L128,97,56.49,168.49a12,12,0,0,1-17-17l80-80a12,12,0,0,1,17,0l80,80A12,12,0,0,1,216.49,168.49Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M208,160H48l80-80Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M213.66,154.34l-80-80a8,8,0,0,0-11.32,0l-80,80A8,8,0,0,0,48,168H208a8,8,0,0,0,5.66-13.66ZM67.31,152,128,91.31,188.69,152Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M215.39,163.06A8,8,0,0,1,208,168H48a8,8,0,0,1-5.66-13.66l80-80a8,8,0,0,1,11.32,0l80,80A8,8,0,0,1,215.39,163.06Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M212.24,164.24a6,6,0,0,1-8.48,0L128,88.49,52.24,164.24a6,6,0,0,1-8.48-8.48l80-80a6,6,0,0,1,8.48,0l80,80A6,6,0,0,1,212.24,164.24Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M213.66,165.66a8,8,0,0,1-11.32,0L128,91.31,53.66,165.66a8,8,0,0,1-11.32-11.32l80-80a8,8,0,0,1,11.32,0l80,80A8,8,0,0,1,213.66,165.66Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M210.83,162.83a4,4,0,0,1-5.66,0L128,85.66,50.83,162.83a4,4,0,0,1-5.66-5.66l80-80a4,4,0,0,1,5.66,0l80,80A4,4,0,0,1,210.83,162.83Z" }))]
]);
var e$51 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M56,84A12,12,0,0,1,68,72H188a12,12,0,0,1,12,12v88a12,12,0,0,1-24,0V96H68A12,12,0,0,1,56,84ZM236,56V200a20,20,0,0,1-20,20H149.26a12,12,0,0,1-11.4-8.26,36,36,0,0,0-67.74,0A12,12,0,0,1,58.74,220H40a20,20,0,0,1-20-20V56A20,20,0,0,1,40,36H216A20,20,0,0,1,236,56ZM104,164a16,16,0,1,0-16-16A16,16,0,0,0,104,164ZM212,60H44V196h6.92a60.18,60.18,0,0,1,21.76-23.16,40,40,0,1,1,62.64,0A60.18,60.18,0,0,1,157.08,196H212Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M192,80v96H104a32,32,0,1,0-32-32H64V80Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M216,40H40A16,16,0,0,0,24,56V200a16,16,0,0,0,16,16H53.39a8,8,0,0,0,7.23-4.57,48,48,0,0,1,86.76,0,8,8,0,0,0,7.23,4.57H216a16,16,0,0,0,16-16V56A16,16,0,0,0,216,40ZM80,144a24,24,0,1,1,24,24A24,24,0,0,1,80,144Zm136,56H159.43a64.39,64.39,0,0,0-28.83-26.16,40,40,0,1,0-53.2,0A64.39,64.39,0,0,0,48.57,200H40V56H216ZM56,96V80a8,8,0,0,1,8-8H192a8,8,0,0,1,8,8v96a8,8,0,0,1-8,8H176a8,8,0,0,1,0-16h8V88H72v8a8,8,0,0,1-16,0Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M216,40H40A16,16,0,0,0,24,56V200a16,16,0,0,0,16,16H53.39a8,8,0,0,0,7.23-4.57,48,48,0,0,1,86.76,0,8,8,0,0,0,7.23,4.57H216a16,16,0,0,0,16-16V56A16,16,0,0,0,216,40ZM104,168a32,32,0,1,1,32-32A32,32,0,0,1,104,168Zm112,32H159.43a63.93,63.93,0,0,0-13.16-16H192a8,8,0,0,0,8-8V80a8,8,0,0,0-8-8H64a8,8,0,0,0-8,8v96a8,8,0,0,0,6,7.75A63.72,63.72,0,0,0,48.57,200H40V56H216Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M216,42H40A14,14,0,0,0,26,56V200a14,14,0,0,0,14,14H53.39a6,6,0,0,0,5.42-3.43,50,50,0,0,1,90.38,0,6,6,0,0,0,5.42,3.43H216a14,14,0,0,0,14-14V56A14,14,0,0,0,216,42ZM78,144a26,26,0,1,1,26,26A26,26,0,0,1,78,144Zm140,56a2,2,0,0,1-2,2H158.27a62.34,62.34,0,0,0-31.48-27.61,38,38,0,1,0-45.58,0A62.34,62.34,0,0,0,49.73,202H40a2,2,0,0,1-2-2V56a2,2,0,0,1,2-2H216a2,2,0,0,1,2,2ZM198,80v96a6,6,0,0,1-6,6H176a6,6,0,0,1,0-12h10V86H70V96a6,6,0,0,1-12,0V80a6,6,0,0,1,6-6H192A6,6,0,0,1,198,80Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M216,40H40A16,16,0,0,0,24,56V200a16,16,0,0,0,16,16H53.39a8,8,0,0,0,7.23-4.57,48,48,0,0,1,86.76,0,8,8,0,0,0,7.23,4.57H216a16,16,0,0,0,16-16V56A16,16,0,0,0,216,40ZM80,144a24,24,0,1,1,24,24A24,24,0,0,1,80,144Zm136,56H159.43a64.39,64.39,0,0,0-28.83-26.16,40,40,0,1,0-53.2,0A64.39,64.39,0,0,0,48.57,200H40V56H216ZM56,96V80a8,8,0,0,1,8-8H192a8,8,0,0,1,8,8v96a8,8,0,0,1-8,8H176a8,8,0,0,1,0-16h8V88H72v8a8,8,0,0,1-16,0Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M216,44H40A12,12,0,0,0,28,56V200a12,12,0,0,0,12,12H53.39A4,4,0,0,0,57,209.71a52,52,0,0,1,94,0,4,4,0,0,0,3.61,2.29H216a12,12,0,0,0,12-12V56A12,12,0,0,0,216,44Zm4,156a4,4,0,0,1-4,4H157.08a60.38,60.38,0,0,0-34.68-29.07,36,36,0,1,0-36.8,0A60.38,60.38,0,0,0,50.92,204H40a4,4,0,0,1-4-4V56a4,4,0,0,1,4-4H216a4,4,0,0,1,4,4ZM104,172a28,28,0,1,1,28-28A28,28,0,0,1,104,172Zm92-92v96a4,4,0,0,1-4,4H176a4,4,0,0,1,0-8h12V84H68V96a4,4,0,0,1-8,0V80a4,4,0,0,1,4-4H192A4,4,0,0,1,196,80Z" }))]
]);
var a$28 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M232.49,80.49l-128,128a12,12,0,0,1-17,0l-56-56a12,12,0,1,1,17-17L96,183,215.51,63.51a12,12,0,0,1,17,17Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M232,56V200a16,16,0,0,1-16,16H40a16,16,0,0,1-16-16V56A16,16,0,0,1,40,40H216A16,16,0,0,1,232,56Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M205.66,85.66l-96,96a8,8,0,0,1-11.32,0l-40-40a8,8,0,0,1,11.32-11.32L104,164.69l90.34-90.35a8,8,0,0,1,11.32,11.32Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M216,40H40A16,16,0,0,0,24,56V200a16,16,0,0,0,16,16H216a16,16,0,0,0,16-16V56A16,16,0,0,0,216,40ZM205.66,85.66l-96,96a8,8,0,0,1-11.32,0l-40-40a8,8,0,0,1,11.32-11.32L104,164.69l90.34-90.35a8,8,0,0,1,11.32,11.32Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M228.24,76.24l-128,128a6,6,0,0,1-8.48,0l-56-56a6,6,0,0,1,8.48-8.48L96,191.51,219.76,67.76a6,6,0,0,1,8.48,8.48Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M229.66,77.66l-128,128a8,8,0,0,1-11.32,0l-56-56a8,8,0,0,1,11.32-11.32L96,188.69,218.34,66.34a8,8,0,0,1,11.32,11.32Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M226.83,74.83l-128,128a4,4,0,0,1-5.66,0l-56-56a4,4,0,0,1,5.66-5.66L96,194.34,221.17,69.17a4,4,0,1,1,5.66,5.66Z" }))]
]);
var a$27 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M236,128a108,108,0,0,1-216,0c0-42.52,24.73-81.34,63-98.9A12,12,0,1,1,93,50.91C63.24,64.57,44,94.83,44,128a84,84,0,0,0,168,0c0-33.17-19.24-63.43-49-77.09A12,12,0,1,1,173,29.1C211.27,46.66,236,85.48,236,128Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M224,128a96,96,0,1,1-96-96A96,96,0,0,1,224,128Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M232,128a104,104,0,0,1-208,0c0-41,23.81-78.36,60.66-95.27a8,8,0,0,1,6.68,14.54C60.15,61.59,40,93.27,40,128a88,88,0,0,0,176,0c0-34.73-20.15-66.41-51.34-80.73a8,8,0,0,1,6.68-14.54C208.19,49.64,232,87,232,128Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M128,24A104,104,0,1,0,232,128,104.11,104.11,0,0,0,128,24Zm0,176A72,72,0,0,1,92,65.64a8,8,0,0,1,8,13.85,56,56,0,1,0,56,0,8,8,0,0,1,8-13.85A72,72,0,0,1,128,200Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M230,128a102,102,0,0,1-204,0c0-40.18,23.35-76.86,59.5-93.45a6,6,0,0,1,5,10.9C58.61,60.09,38,92.49,38,128a90,90,0,0,0,180,0c0-35.51-20.61-67.91-52.5-82.55a6,6,0,0,1,5-10.9C206.65,51.14,230,87.82,230,128Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M232,128a104,104,0,0,1-208,0c0-41,23.81-78.36,60.66-95.27a8,8,0,0,1,6.68,14.54C60.15,61.59,40,93.27,40,128a88,88,0,0,0,176,0c0-34.73-20.15-66.41-51.34-80.73a8,8,0,0,1,6.68-14.54C208.19,49.64,232,87,232,128Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M228,128a100,100,0,0,1-200,0c0-39.4,22.9-75.37,58.33-91.63a4,4,0,1,1,3.34,7.27C57.07,58.6,36,91.71,36,128a92,92,0,0,0,184,0c0-36.29-21.07-69.4-53.67-84.36a4,4,0,1,1,3.34-7.27C205.1,52.63,228,88.6,228,128Z" }))]
]);
var a$26 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M128,20A108,108,0,1,0,236,128,108.12,108.12,0,0,0,128,20Zm0,192a84,84,0,1,1,84-84A84.09,84.09,0,0,1,128,212Zm68-84a12,12,0,0,1-12,12H128a12,12,0,0,1-12-12V72a12,12,0,0,1,24,0v44h44A12,12,0,0,1,196,128Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M224,128a96,96,0,1,1-96-96A96,96,0,0,1,224,128Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M128,24A104,104,0,1,0,232,128,104.11,104.11,0,0,0,128,24Zm0,192a88,88,0,1,1,88-88A88.1,88.1,0,0,1,128,216Zm64-88a8,8,0,0,1-8,8H128a8,8,0,0,1-8-8V72a8,8,0,0,1,16,0v48h48A8,8,0,0,1,192,128Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M128,24A104,104,0,1,0,232,128,104.11,104.11,0,0,0,128,24Zm56,112H128a8,8,0,0,1-8-8V72a8,8,0,0,1,16,0v48h48a8,8,0,0,1,0,16Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M128,26A102,102,0,1,0,230,128,102.12,102.12,0,0,0,128,26Zm0,192a90,90,0,1,1,90-90A90.1,90.1,0,0,1,128,218Zm62-90a6,6,0,0,1-6,6H128a6,6,0,0,1-6-6V72a6,6,0,0,1,12,0v50h50A6,6,0,0,1,190,128Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M128,24A104,104,0,1,0,232,128,104.11,104.11,0,0,0,128,24Zm0,192a88,88,0,1,1,88-88A88.1,88.1,0,0,1,128,216Zm64-88a8,8,0,0,1-8,8H128a8,8,0,0,1-8-8V72a8,8,0,0,1,16,0v48h48A8,8,0,0,1,192,128Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M128,28A100,100,0,1,0,228,128,100.11,100.11,0,0,0,128,28Zm0,192a92,92,0,1,1,92-92A92.1,92.1,0,0,1,128,220Zm60-92a4,4,0,0,1-4,4H128a4,4,0,0,1-4-4V72a4,4,0,0,1,8,0v52h52A4,4,0,0,1,188,128Z" }))]
]);
var l$5 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M71.68,97.22,34.74,128l36.94,30.78a12,12,0,1,1-15.36,18.44l-48-40a12,12,0,0,1,0-18.44l48-40A12,12,0,0,1,71.68,97.22Zm176,21.56-48-40a12,12,0,1,0-15.36,18.44L221.26,128l-36.94,30.78a12,12,0,1,0,15.36,18.44l48-40a12,12,0,0,0,0-18.44ZM164.1,28.72a12,12,0,0,0-15.38,7.18l-64,176a12,12,0,0,0,7.18,15.37A11.79,11.79,0,0,0,96,228a12,12,0,0,0,11.28-7.9l64-176A12,12,0,0,0,164.1,28.72Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M240,128l-48,40H64L16,128,64,88H192Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M69.12,94.15,28.5,128l40.62,33.85a8,8,0,1,1-10.24,12.29l-48-40a8,8,0,0,1,0-12.29l48-40a8,8,0,0,1,10.24,12.3Zm176,27.7-48-40a8,8,0,1,0-10.24,12.3L227.5,128l-40.62,33.85a8,8,0,1,0,10.24,12.29l48-40a8,8,0,0,0,0-12.29ZM162.73,32.48a8,8,0,0,0-10.25,4.79l-64,176a8,8,0,0,0,4.79,10.26A8.14,8.14,0,0,0,96,224a8,8,0,0,0,7.52-5.27l64-176A8,8,0,0,0,162.73,32.48Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M216,40H40A16,16,0,0,0,24,56V200a16,16,0,0,0,16,16H216a16,16,0,0,0,16-16V56A16,16,0,0,0,216,40ZM92.8,145.6a8,8,0,1,1-9.6,12.8l-32-24a8,8,0,0,1,0-12.8l32-24a8,8,0,0,1,9.6,12.8L69.33,128Zm58.89-71.4-32,112a8,8,0,1,1-15.38-4.4l32-112a8,8,0,0,1,15.38,4.4Zm53.11,60.2-32,24a8,8,0,0,1-9.6-12.8L186.67,128,163.2,110.4a8,8,0,1,1,9.6-12.8l32,24a8,8,0,0,1,0,12.8Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M67.84,92.61,25.37,128l42.47,35.39a6,6,0,1,1-7.68,9.22l-48-40a6,6,0,0,1,0-9.22l48-40a6,6,0,0,1,7.68,9.22Zm176,30.78-48-40a6,6,0,1,0-7.68,9.22L230.63,128l-42.47,35.39a6,6,0,1,0,7.68,9.22l48-40a6,6,0,0,0,0-9.22Zm-81.79-89A6,6,0,0,0,154.36,38l-64,176A6,6,0,0,0,94,221.64a6.15,6.15,0,0,0,2,.36,6,6,0,0,0,5.64-3.95l64-176A6,6,0,0,0,162.05,34.36Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M69.12,94.15,28.5,128l40.62,33.85a8,8,0,1,1-10.24,12.29l-48-40a8,8,0,0,1,0-12.29l48-40a8,8,0,0,1,10.24,12.3Zm176,27.7-48-40a8,8,0,1,0-10.24,12.3L227.5,128l-40.62,33.85a8,8,0,1,0,10.24,12.29l48-40a8,8,0,0,0,0-12.29ZM162.73,32.48a8,8,0,0,0-10.25,4.79l-64,176a8,8,0,0,0,4.79,10.26A8.14,8.14,0,0,0,96,224a8,8,0,0,0,7.52-5.27l64-176A8,8,0,0,0,162.73,32.48Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M66.56,91.07,22.25,128l44.31,36.93A4,4,0,0,1,64,172a3.94,3.94,0,0,1-2.56-.93l-48-40a4,4,0,0,1,0-6.14l48-40a4,4,0,0,1,5.12,6.14Zm176,33.86-48-40a4,4,0,1,0-5.12,6.14L233.75,128l-44.31,36.93a4,4,0,1,0,5.12,6.14l48-40a4,4,0,0,0,0-6.14ZM161.37,36.24a4,4,0,0,0-5.13,2.39l-64,176a4,4,0,0,0,2.39,5.13A4.12,4.12,0,0,0,96,220a4,4,0,0,0,3.76-2.63l64-176A4,4,0,0,0,161.37,36.24Z" }))]
]);
var l$4 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M108,136a16,16,0,1,1-16-16A16,16,0,0,1,108,136Zm56-16a16,16,0,1,0,16,16A16,16,0,0,0,164,120Zm76.07,76.56-67,29.71A20.15,20.15,0,0,1,146,214.9l-8.54-23.13c-3.13.14-6.27.24-9.45.24s-6.32-.1-9.45-.24L110,214.9a20.19,20.19,0,0,1-27.08,11.37l-67-29.71A19.93,19.93,0,0,1,4.62,173.41L34.15,57A20,20,0,0,1,50.37,42.19l36.06-5.93A20.26,20.26,0,0,1,109.22,51.1l4.41,17.41c4.74-.33,9.52-.51,14.37-.51s9.63.18,14.37.51l4.41-17.41a20.25,20.25,0,0,1,22.79-14.84l36.06,5.93A20,20,0,0,1,221.85,57l29.53,116.38A19.93,19.93,0,0,1,240.07,196.56ZM227.28,176,199.23,65.46l-30.07-4.94-2.84,11.17c2.9.58,5.78,1.2,8.61,1.92a12,12,0,1,1-5.86,23.27A168.43,168.43,0,0,0,128,92a168.43,168.43,0,0,0-41.07,4.88,12,12,0,0,1-5.86-23.27c2.83-.72,5.71-1.34,8.61-1.92L86.85,60.52,56.77,65.46,28.72,176l60.22,26.7,5-13.57c-4.37-.76-8.67-1.65-12.88-2.71a12,12,0,0,1,5.86-23.28A168.43,168.43,0,0,0,128,168a168.43,168.43,0,0,0,41.07-4.88,12,12,0,0,1,5.86,23.28c-4.21,1.06-8.51,1.95-12.88,2.71l5,13.57Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M235.21,185.59l-67,29.7a8.15,8.15,0,0,1-11-4.56L147,183.06a190.5,190.5,0,0,1-19,.94,190.5,190.5,0,0,1-19-.94L98.75,210.73a8.15,8.15,0,0,1-11,4.56l-67-29.7a8,8,0,0,1-4.55-9.24L45.77,60A8.08,8.08,0,0,1,52.31,54l36.06-5.92a8.1,8.1,0,0,1,9.21,6l5,19.63a192.32,192.32,0,0,1,50.88,0l5-19.63a8.1,8.1,0,0,1,9.21-6L203.69,54A8.08,8.08,0,0,1,210.23,60l29.53,116.37A8,8,0,0,1,235.21,185.59Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M104,140a12,12,0,1,1-12-12A12,12,0,0,1,104,140Zm60-12a12,12,0,1,0,12,12A12,12,0,0,0,164,128Zm74.45,64.9-67,29.71a16.17,16.17,0,0,1-21.71-9.1l-8.11-22q-6.72.45-13.63.46t-13.63-.46l-8.11,22a16.18,16.18,0,0,1-21.71,9.1l-67-29.71a15.94,15.94,0,0,1-9.06-18.51L38,58A16.08,16.08,0,0,1,51,46.13l36.06-5.92a16.21,16.21,0,0,1,18.26,11.88l3.26,12.83Q118.11,64,128,64t19.4.92l3.26-12.83a16.22,16.22,0,0,1,18.26-11.88L205,46.13A16.08,16.08,0,0,1,218,58l29.53,116.38A15.94,15.94,0,0,1,238.45,192.9ZM232,178.28,202.47,62s0,0-.08,0L166.33,56a.17.17,0,0,0-.17,0l-2.83,11.14c5,.94,10,2.06,14.83,3.42A8,8,0,0,1,176,86.31a8.09,8.09,0,0,1-2.16-.3A172.25,172.25,0,0,0,128,80a172.25,172.25,0,0,0-45.84,6,8,8,0,1,1-4.32-15.4c4.82-1.36,9.78-2.48,14.82-3.42L89.83,56a.21.21,0,0,0-.12,0h0L53.61,61.92a.24.24,0,0,0-.09,0L24,178.33,91,208a.21.21,0,0,0,.22,0L98,189.72a173.2,173.2,0,0,1-20.14-4.32A8,8,0,0,1,82.16,170,171.85,171.85,0,0,0,128,176a171.85,171.85,0,0,0,45.84-6,8,8,0,0,1,4.32,15.41A173.2,173.2,0,0,1,158,189.72L164.75,208a.22.22,0,0,0,.21,0Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M247.51,174.39,218,58a16.08,16.08,0,0,0-13-11.88l-36.06-5.92a16.22,16.22,0,0,0-18.26,11.88l-.21.85a4,4,0,0,0,3.27,4.93,155.62,155.62,0,0,1,24.41,5.62,8.2,8.2,0,0,1,5.62,9.7,8,8,0,0,1-10.19,5.64,155.4,155.4,0,0,0-90.8-.1,8.22,8.22,0,0,1-10.28-4.81,8,8,0,0,1,5.08-10.33,156.85,156.85,0,0,1,24.72-5.72,4,4,0,0,0,3.27-4.93l-.21-.85A16.21,16.21,0,0,0,87.08,40.21L51,46.13A16.08,16.08,0,0,0,38,58L8.49,174.39a15.94,15.94,0,0,0,9.06,18.51l67,29.71a16.17,16.17,0,0,0,21.71-9.1l3.49-9.45a4,4,0,0,0-3.27-5.35,158.13,158.13,0,0,1-28.63-6.2,8.2,8.2,0,0,1-5.61-9.67,8,8,0,0,1,10.2-5.66,155.59,155.59,0,0,0,91.12,0,8,8,0,0,1,10.19,5.65,8.19,8.19,0,0,1-5.61,9.68,157.84,157.84,0,0,1-28.62,6.2,4,4,0,0,0-3.27,5.35l3.49,9.45a16.18,16.18,0,0,0,21.71,9.1l67-29.71A15.94,15.94,0,0,0,247.51,174.39ZM92,152a12,12,0,1,1,12-12A12,12,0,0,1,92,152Zm72,0a12,12,0,1,1,12-12A12,12,0,0,1,164,152Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M102,140a10,10,0,1,1-10-10A10,10,0,0,1,102,140Zm62-10a10,10,0,1,0,10,10A10,10,0,0,0,164,130Zm73.64,61.08-67,29.71a14.43,14.43,0,0,1-5.77,1.21,14.13,14.13,0,0,1-13.25-9.18L143,189.43c-4.93.37-9.92.58-15,.58s-10.06-.21-15-.58l-8.63,23.39A14.13,14.13,0,0,1,91.13,222a14.43,14.43,0,0,1-5.77-1.21l-67-29.71a14,14,0,0,1-7.93-16.2L40,58.5A14.07,14.07,0,0,1,51.34,48.11L87.4,42.19a14.19,14.19,0,0,1,16,10.39l3.69,14.53a197.5,197.5,0,0,1,41.82,0l3.69-14.53a14.19,14.19,0,0,1,16-10.39l36.06,5.92A14.07,14.07,0,0,1,216,58.5l29.53,116.38A14,14,0,0,1,237.64,191.08Zm-3.7-13.25L204.41,61.45a2.08,2.08,0,0,0-1.7-1.5L166.65,54a2.13,2.13,0,0,0-2.42,1.5l-3.36,13.24a169.28,169.28,0,0,1,16.75,3.76A6,6,0,0,1,176,84.31a5.71,5.71,0,0,1-1.62-.23A174.26,174.26,0,0,0,128,78a174.26,174.26,0,0,0-46.38,6.08,6,6,0,1,1-3.24-11.55,169.28,169.28,0,0,1,16.75-3.76L91.77,55.53A2.12,2.12,0,0,0,89.35,54L53.29,60a2.08,2.08,0,0,0-1.7,1.5L22.06,177.83a2,2,0,0,0,1.16,2.28l67,29.7a2.19,2.19,0,0,0,1.76,0,2.07,2.07,0,0,0,1.14-1.17l7.58-20.55a171.46,171.46,0,0,1-22.33-4.64,6,6,0,1,1,3.24-11.55A174.26,174.26,0,0,0,128,178a174.26,174.26,0,0,0,46.38-6.08,6,6,0,1,1,3.24,11.55,171.46,171.46,0,0,1-22.33,4.64l7.58,20.55a2.07,2.07,0,0,0,1.14,1.17,2.19,2.19,0,0,0,1.76,0l67-29.7A2,2,0,0,0,233.94,177.83Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M104,140a12,12,0,1,1-12-12A12,12,0,0,1,104,140Zm60-12a12,12,0,1,0,12,12A12,12,0,0,0,164,128Zm74.45,64.9-67,29.71a16.17,16.17,0,0,1-21.71-9.1l-8.11-22q-6.72.45-13.63.46t-13.63-.46l-8.11,22a16.18,16.18,0,0,1-21.71,9.1l-67-29.71a15.93,15.93,0,0,1-9.06-18.51L38,58A16.07,16.07,0,0,1,51,46.14l36.06-5.93a16.22,16.22,0,0,1,18.26,11.88l3.26,12.84Q118.11,64,128,64t19.4.93l3.26-12.84a16.21,16.21,0,0,1,18.26-11.88L205,46.14A16.07,16.07,0,0,1,218,58l29.53,116.38A15.93,15.93,0,0,1,238.45,192.9ZM232,178.28,202.47,62s0,0-.08,0L166.33,56a.17.17,0,0,0-.17,0l-2.83,11.14c5,.94,10,2.06,14.83,3.42A8,8,0,0,1,176,86.31a8.09,8.09,0,0,1-2.16-.3A172.25,172.25,0,0,0,128,80a172.25,172.25,0,0,0-45.84,6,8,8,0,1,1-4.32-15.4c4.82-1.36,9.78-2.48,14.82-3.42L89.83,56s0,0-.12,0h0L53.61,61.93a.17.17,0,0,0-.09,0L24,178.33,91,208a.23.23,0,0,0,.22,0L98,189.72a173.2,173.2,0,0,1-20.14-4.32A8,8,0,0,1,82.16,170,171.85,171.85,0,0,0,128,176a171.85,171.85,0,0,0,45.84-6,8,8,0,0,1,4.32,15.41A173.2,173.2,0,0,1,158,189.72L164.75,208a.22.22,0,0,0,.21,0Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M100,140a8,8,0,1,1-8-8A8,8,0,0,1,100,140Zm64-8a8,8,0,1,0,8,8A8,8,0,0,0,164,132Zm72.83,57.25-67,29.71a12.36,12.36,0,0,1-5,1,12.13,12.13,0,0,1-11.38-7.88l-9.15-24.81c-5.36.45-10.81.69-16.34.69s-11-.24-16.34-.69l-9.15,24.81A12.13,12.13,0,0,1,91.13,220a12.36,12.36,0,0,1-5-1l-67-29.71a12,12,0,0,1-6.8-13.88L41.9,59a12.06,12.06,0,0,1,9.77-8.91l36.06-5.92a12.18,12.18,0,0,1,13.73,8.91l4.12,16.22a195.47,195.47,0,0,1,44.84,0l4.12-16.22a12.18,12.18,0,0,1,13.73-8.91l36.06,5.92A12.06,12.06,0,0,1,214.1,59l29.53,116.38A12,12,0,0,1,236.83,189.25Zm-1-11.91L206.35,61A4.07,4.07,0,0,0,203,58L167,52.05a4.15,4.15,0,0,0-4.69,3L158.4,70.38a166.74,166.74,0,0,1,18.68,4.08,4,4,0,1,1-2.16,7.7A176.21,176.21,0,0,0,128,76a176.21,176.21,0,0,0-46.92,6.16,4,4,0,1,1-2.16-7.7A166.74,166.74,0,0,1,97.6,70.38L93.71,55a4.15,4.15,0,0,0-4.69-3L53,58a4.07,4.07,0,0,0-3.31,3L20.12,177.34a4,4,0,0,0,2.29,4.59l67,29.71a4.16,4.16,0,0,0,3.35,0A4,4,0,0,0,95,209.35l8.45-22.88a171.49,171.49,0,0,1-24.53-4.92,4,4,0,0,1,2.16-7.71A176.21,176.21,0,0,0,128,180a176.21,176.21,0,0,0,46.92-6.16,4,4,0,0,1,2.16,7.71,171.49,171.49,0,0,1-24.53,4.92L161,209.35a4,4,0,0,0,2.23,2.32,4.16,4.16,0,0,0,3.35,0l67-29.71A4,4,0,0,0,235.88,177.34Z" }))]
]);
var e$50 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M71.51,88.49a12,12,0,0,1,17-17L116,99V24a12,12,0,0,1,24,0V99l27.51-27.52a12,12,0,0,1,17,17l-48,48a12,12,0,0,1-17,0ZM224,116H188a12,12,0,0,0,0,24h32v56H36V140H68a12,12,0,0,0,0-24H32a20,20,0,0,0-20,20v64a20,20,0,0,0,20,20H224a20,20,0,0,0,20-20V136A20,20,0,0,0,224,116Zm-20,52a16,16,0,1,0-16,16A16,16,0,0,0,204,168Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M232,136v64a8,8,0,0,1-8,8H32a8,8,0,0,1-8-8V136a8,8,0,0,1,8-8H224A8,8,0,0,1,232,136Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M240,136v64a16,16,0,0,1-16,16H32a16,16,0,0,1-16-16V136a16,16,0,0,1,16-16H72a8,8,0,0,1,0,16H32v64H224V136H184a8,8,0,0,1,0-16h40A16,16,0,0,1,240,136Zm-117.66-2.34a8,8,0,0,0,11.32,0l48-48a8,8,0,0,0-11.32-11.32L136,108.69V24a8,8,0,0,0-16,0v84.69L85.66,74.34A8,8,0,0,0,74.34,85.66ZM200,168a12,12,0,1,0-12,12A12,12,0,0,0,200,168Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M74.34,85.66A8,8,0,0,1,85.66,74.34L120,108.69V24a8,8,0,0,1,16,0v84.69l34.34-34.35a8,8,0,0,1,11.32,11.32l-48,48a8,8,0,0,1-11.32,0ZM240,136v64a16,16,0,0,1-16,16H32a16,16,0,0,1-16-16V136a16,16,0,0,1,16-16H84.4a4,4,0,0,1,2.83,1.17L111,145A24,24,0,0,0,145,145l23.8-23.8A4,4,0,0,1,171.6,120H224A16,16,0,0,1,240,136Zm-40,32a12,12,0,1,0-12,12A12,12,0,0,0,200,168Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M238,136v64a14,14,0,0,1-14,14H32a14,14,0,0,1-14-14V136a14,14,0,0,1,14-14H72a6,6,0,0,1,0,12H32a2,2,0,0,0-2,2v64a2,2,0,0,0,2,2H224a2,2,0,0,0,2-2V136a2,2,0,0,0-2-2H184a6,6,0,0,1,0-12h40A14,14,0,0,1,238,136Zm-114.24-3.76a6,6,0,0,0,8.48,0l48-48a6,6,0,0,0-8.48-8.48L134,113.51V24a6,6,0,0,0-12,0v89.51L84.24,75.76a6,6,0,0,0-8.48,8.48ZM198,168a10,10,0,1,0-10,10A10,10,0,0,0,198,168Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M240,136v64a16,16,0,0,1-16,16H32a16,16,0,0,1-16-16V136a16,16,0,0,1,16-16H72a8,8,0,0,1,0,16H32v64H224V136H184a8,8,0,0,1,0-16h40A16,16,0,0,1,240,136Zm-117.66-2.34a8,8,0,0,0,11.32,0l48-48a8,8,0,0,0-11.32-11.32L136,108.69V24a8,8,0,0,0-16,0v84.69L85.66,74.34A8,8,0,0,0,74.34,85.66ZM200,168a12,12,0,1,0-12,12A12,12,0,0,0,200,168Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M236,136v64a12,12,0,0,1-12,12H32a12,12,0,0,1-12-12V136a12,12,0,0,1,12-12H72a4,4,0,0,1,0,8H32a4,4,0,0,0-4,4v64a4,4,0,0,0,4,4H224a4,4,0,0,0,4-4V136a4,4,0,0,0-4-4H184a4,4,0,0,1,0-8h40A12,12,0,0,1,236,136Zm-110.83-5.17a4,4,0,0,0,5.66,0l48-48a4,4,0,1,0-5.66-5.66L132,118.34V24a4,4,0,0,0-8,0v94.34L82.83,77.17a4,4,0,0,0-5.66,5.66ZM196,168a8,8,0,1,0-8,8A8,8,0,0,0,196,168Z" }))]
]);
var e$49 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M228,144v64a12,12,0,0,1-12,12H40a12,12,0,0,1-12-12V144a12,12,0,0,1,24,0v52H204V144a12,12,0,0,1,24,0Zm-108.49,8.49a12,12,0,0,0,17,0l40-40a12,12,0,0,0-17-17L140,115V32a12,12,0,0,0-24,0v83L96.49,95.51a12,12,0,0,0-17,17Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M216,48V208H40V48A16,16,0,0,1,56,32H200A16,16,0,0,1,216,48Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M224,144v64a8,8,0,0,1-8,8H40a8,8,0,0,1-8-8V144a8,8,0,0,1,16,0v56H208V144a8,8,0,0,1,16,0Zm-101.66,5.66a8,8,0,0,0,11.32,0l40-40a8,8,0,0,0-11.32-11.32L136,124.69V32a8,8,0,0,0-16,0v92.69L93.66,98.34a8,8,0,0,0-11.32,11.32Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M224,144v64a8,8,0,0,1-8,8H40a8,8,0,0,1-8-8V144a8,8,0,0,1,16,0v56H208V144a8,8,0,0,1,16,0Zm-101.66,5.66a8,8,0,0,0,11.32,0l40-40A8,8,0,0,0,168,96H136V32a8,8,0,0,0-16,0V96H88a8,8,0,0,0-5.66,13.66Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M222,144v64a6,6,0,0,1-6,6H40a6,6,0,0,1-6-6V144a6,6,0,0,1,12,0v58H210V144a6,6,0,0,1,12,0Zm-98.24,4.24a6,6,0,0,0,8.48,0l40-40a6,6,0,0,0-8.48-8.48L134,129.51V32a6,6,0,0,0-12,0v97.51L92.24,99.76a6,6,0,0,0-8.48,8.48Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M224,144v64a8,8,0,0,1-8,8H40a8,8,0,0,1-8-8V144a8,8,0,0,1,16,0v56H208V144a8,8,0,0,1,16,0Zm-101.66,5.66a8,8,0,0,0,11.32,0l40-40a8,8,0,0,0-11.32-11.32L136,124.69V32a8,8,0,0,0-16,0v92.69L93.66,98.34a8,8,0,0,0-11.32,11.32Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M220,144v64a4,4,0,0,1-4,4H40a4,4,0,0,1-4-4V144a4,4,0,0,1,8,0v60H212V144a4,4,0,0,1,8,0Zm-94.83,2.83a4,4,0,0,0,5.66,0l40-40a4,4,0,1,0-5.66-5.66L132,134.34V32a4,4,0,0,0-8,0V134.34L90.83,101.17a4,4,0,0,0-5.66,5.66Z" }))]
]);
var a$25 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M224,44H32A12,12,0,0,0,20,56V192a20,20,0,0,0,20,20H216a20,20,0,0,0,20-20V56A12,12,0,0,0,224,44ZM193.15,68,128,127.72,62.85,68ZM44,188V83.28l75.89,69.57a12,12,0,0,0,16.22,0L212,83.28V188Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M224,56l-96,88L32,56Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M224,48H32a8,8,0,0,0-8,8V192a16,16,0,0,0,16,16H216a16,16,0,0,0,16-16V56A8,8,0,0,0,224,48ZM203.43,64,128,133.15,52.57,64ZM216,192H40V74.19l82.59,75.71a8,8,0,0,0,10.82,0L216,74.19V192Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M224,48H32a8,8,0,0,0-8,8V192a16,16,0,0,0,16,16H216a16,16,0,0,0,16-16V56A8,8,0,0,0,224,48Zm-8,144H40V74.19l82.59,75.71a8,8,0,0,0,10.82,0L216,74.19V192Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M224,50H32a6,6,0,0,0-6,6V192a14,14,0,0,0,14,14H216a14,14,0,0,0,14-14V56A6,6,0,0,0,224,50ZM208.58,62,128,135.86,47.42,62ZM216,194H40a2,2,0,0,1-2-2V69.64l86,78.78a6,6,0,0,0,8.1,0L218,69.64V192A2,2,0,0,1,216,194Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M224,48H32a8,8,0,0,0-8,8V192a16,16,0,0,0,16,16H216a16,16,0,0,0,16-16V56A8,8,0,0,0,224,48ZM203.43,64,128,133.15,52.57,64ZM216,192H40V74.19l82.59,75.71a8,8,0,0,0,10.82,0L216,74.19V192Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M224,52H32a4,4,0,0,0-4,4V192a12,12,0,0,0,12,12H216a12,12,0,0,0,12-12V56A4,4,0,0,0,224,52Zm-10.28,8L128,138.57,42.28,60ZM216,196H40a4,4,0,0,1-4-4V65.09L125.3,147a4,4,0,0,0,5.4,0L220,65.09V192A4,4,0,0,1,216,196Z" }))]
]);
var a$24 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M148,200a20,20,0,1,1-20-20A20,20,0,0,1,148,200Zm-20-40a12,12,0,0,0,12-12V48a12,12,0,0,0-24,0V148A12,12,0,0,0,128,160Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M216,40V216a16,16,0,0,1-16,16H56a16,16,0,0,1-16-16V40A16,16,0,0,1,56,24H200A16,16,0,0,1,216,40Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M144,200a16,16,0,1,1-16-16A16,16,0,0,1,144,200Zm-16-40a8,8,0,0,0,8-8V48a8,8,0,0,0-16,0V152A8,8,0,0,0,128,160Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M200,24H56A16,16,0,0,0,40,40V216a16,16,0,0,0,16,16H200a16,16,0,0,0,16-16V40A16,16,0,0,0,200,24ZM128,160a12,12,0,1,1-12,12A12,12,0,0,1,128,160Zm-8-24V80a8,8,0,0,1,16,0v56a8,8,0,0,1-16,0Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M142,200a14,14,0,1,1-14-14A14,14,0,0,1,142,200Zm-14-42a6,6,0,0,0,6-6V48a6,6,0,0,0-12,0V152A6,6,0,0,0,128,158Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M144,200a16,16,0,1,1-16-16A16,16,0,0,1,144,200Zm-16-40a8,8,0,0,0,8-8V48a8,8,0,0,0-16,0V152A8,8,0,0,0,128,160Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M140,200a12,12,0,1,1-12-12A12,12,0,0,1,140,200Zm-12-44a4,4,0,0,0,4-4V48a4,4,0,0,0-8,0V152A4,4,0,0,0,128,156Z" }))]
]);
var a$23 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M251,123.13c-.37-.81-9.13-20.26-28.48-39.61C196.63,57.67,164,44,128,44S59.37,57.67,33.51,83.52C14.16,102.87,5.4,122.32,5,123.13a12.08,12.08,0,0,0,0,9.75c.37.82,9.13,20.26,28.49,39.61C59.37,198.34,92,212,128,212s68.63-13.66,94.48-39.51c19.36-19.35,28.12-38.79,28.49-39.61A12.08,12.08,0,0,0,251,123.13Zm-46.06,33C183.47,177.27,157.59,188,128,188s-55.47-10.73-76.91-31.88A130.36,130.36,0,0,1,29.52,128,130.45,130.45,0,0,1,51.09,99.89C72.54,78.73,98.41,68,128,68s55.46,10.73,76.91,31.89A130.36,130.36,0,0,1,226.48,128,130.45,130.45,0,0,1,204.91,156.12ZM128,84a44,44,0,1,0,44,44A44.05,44.05,0,0,0,128,84Zm0,64a20,20,0,1,1,20-20A20,20,0,0,1,128,148Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M128,56C48,56,16,128,16,128s32,72,112,72,112-72,112-72S208,56,128,56Zm0,112a40,40,0,1,1,40-40A40,40,0,0,1,128,168Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M247.31,124.76c-.35-.79-8.82-19.58-27.65-38.41C194.57,61.26,162.88,48,128,48S61.43,61.26,36.34,86.35C17.51,105.18,9,124,8.69,124.76a8,8,0,0,0,0,6.5c.35.79,8.82,19.57,27.65,38.4C61.43,194.74,93.12,208,128,208s66.57-13.26,91.66-38.34c18.83-18.83,27.3-37.61,27.65-38.4A8,8,0,0,0,247.31,124.76ZM128,192c-30.78,0-57.67-11.19-79.93-33.25A133.47,133.47,0,0,1,25,128,133.33,133.33,0,0,1,48.07,97.25C70.33,75.19,97.22,64,128,64s57.67,11.19,79.93,33.25A133.46,133.46,0,0,1,231.05,128C223.84,141.46,192.43,192,128,192Zm0-112a48,48,0,1,0,48,48A48.05,48.05,0,0,0,128,80Zm0,80a32,32,0,1,1,32-32A32,32,0,0,1,128,160Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M247.31,124.76c-.35-.79-8.82-19.58-27.65-38.41C194.57,61.26,162.88,48,128,48S61.43,61.26,36.34,86.35C17.51,105.18,9,124,8.69,124.76a8,8,0,0,0,0,6.5c.35.79,8.82,19.57,27.65,38.4C61.43,194.74,93.12,208,128,208s66.57-13.26,91.66-38.34c18.83-18.83,27.3-37.61,27.65-38.4A8,8,0,0,0,247.31,124.76ZM128,168a40,40,0,1,1,40-40A40,40,0,0,1,128,168Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M245.48,125.57c-.34-.78-8.66-19.23-27.24-37.81C201,70.54,171.38,50,128,50S55,70.54,37.76,87.76c-18.58,18.58-26.9,37-27.24,37.81a6,6,0,0,0,0,4.88c.34.77,8.66,19.22,27.24,37.8C55,185.47,84.62,206,128,206s73-20.53,90.24-37.75c18.58-18.58,26.9-37,27.24-37.8A6,6,0,0,0,245.48,125.57ZM128,194c-31.38,0-58.78-11.42-81.45-33.93A134.77,134.77,0,0,1,22.69,128,134.56,134.56,0,0,1,46.55,95.94C69.22,73.42,96.62,62,128,62s58.78,11.42,81.45,33.94A134.56,134.56,0,0,1,233.31,128C226.94,140.21,195,194,128,194Zm0-112a46,46,0,1,0,46,46A46.06,46.06,0,0,0,128,82Zm0,80a34,34,0,1,1,34-34A34,34,0,0,1,128,162Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M247.31,124.76c-.35-.79-8.82-19.58-27.65-38.41C194.57,61.26,162.88,48,128,48S61.43,61.26,36.34,86.35C17.51,105.18,9,124,8.69,124.76a8,8,0,0,0,0,6.5c.35.79,8.82,19.57,27.65,38.4C61.43,194.74,93.12,208,128,208s66.57-13.26,91.66-38.34c18.83-18.83,27.3-37.61,27.65-38.4A8,8,0,0,0,247.31,124.76ZM128,192c-30.78,0-57.67-11.19-79.93-33.25A133.47,133.47,0,0,1,25,128,133.33,133.33,0,0,1,48.07,97.25C70.33,75.19,97.22,64,128,64s57.67,11.19,79.93,33.25A133.46,133.46,0,0,1,231.05,128C223.84,141.46,192.43,192,128,192Zm0-112a48,48,0,1,0,48,48A48.05,48.05,0,0,0,128,80Zm0,80a32,32,0,1,1,32-32A32,32,0,0,1,128,160Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M243.66,126.38c-.34-.76-8.52-18.89-26.83-37.2C199.87,72.22,170.7,52,128,52S56.13,72.22,39.17,89.18c-18.31,18.31-26.49,36.44-26.83,37.2a4.08,4.08,0,0,0,0,3.25c.34.77,8.52,18.89,26.83,37.2,17,17,46.14,37.17,88.83,37.17s71.87-20.21,88.83-37.17c18.31-18.31,26.49-36.43,26.83-37.2A4.08,4.08,0,0,0,243.66,126.38Zm-32.7,35c-23.07,23-51,34.62-83,34.62s-59.89-11.65-83-34.62A135.71,135.71,0,0,1,20.44,128,135.69,135.69,0,0,1,45,94.62C68.11,71.65,96,60,128,60s59.89,11.65,83,34.62A135.79,135.79,0,0,1,235.56,128,135.71,135.71,0,0,1,211,161.38ZM128,84a44,44,0,1,0,44,44A44.05,44.05,0,0,0,128,84Zm0,80a36,36,0,1,1,36-36A36,36,0,0,1,128,164Z" }))]
]);
var e$48 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M56.88,31.93A12,12,0,1,0,39.12,48.07l16,17.65C20.67,88.66,5.72,121.58,5,123.13a12.08,12.08,0,0,0,0,9.75c.37.82,9.13,20.26,28.49,39.61C59.37,198.34,92,212,128,212a131.34,131.34,0,0,0,51-10l20.09,22.1a12,12,0,0,0,17.76-16.14ZM128,188c-29.59,0-55.47-10.73-76.91-31.88A130.69,130.69,0,0,1,29.52,128c5.27-9.31,18.79-29.9,42-44.29l90.09,99.11A109.33,109.33,0,0,1,128,188Zm123-55.12c-.36.81-9,20-28,39.16a12,12,0,1,1-17-16.9A130.48,130.48,0,0,0,226.48,128a130.36,130.36,0,0,0-21.57-28.12C183.46,78.73,157.59,68,128,68c-3.35,0-6.7.14-10,.42a12,12,0,1,1-2-23.91c3.93-.34,8-.51,12-.51,36,0,68.63,13.67,94.49,39.52,19.35,19.35,28.11,38.8,28.48,39.61A12.08,12.08,0,0,1,251,132.88Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M128,56C48,56,16,128,16,128s32,72,112,72,112-72,112-72S208,56,128,56Zm0,112a40,40,0,1,1,40-40A40,40,0,0,1,128,168Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M53.92,34.62A8,8,0,1,0,42.08,45.38L61.32,66.55C25,88.84,9.38,123.2,8.69,124.76a8,8,0,0,0,0,6.5c.35.79,8.82,19.57,27.65,38.4C61.43,194.74,93.12,208,128,208a127.11,127.11,0,0,0,52.07-10.83l22,24.21a8,8,0,1,0,11.84-10.76Zm47.33,75.84,41.67,45.85a32,32,0,0,1-41.67-45.85ZM128,192c-30.78,0-57.67-11.19-79.93-33.25A133.16,133.16,0,0,1,25,128c4.69-8.79,19.66-33.39,47.35-49.38l18,19.75a48,48,0,0,0,63.66,70l14.73,16.2A112,112,0,0,1,128,192Zm6-95.43a8,8,0,0,1,3-15.72,48.16,48.16,0,0,1,38.77,42.64,8,8,0,0,1-7.22,8.71,6.39,6.39,0,0,1-.75,0,8,8,0,0,1-8-7.26A32.09,32.09,0,0,0,134,96.57Zm113.28,34.69c-.42.94-10.55,23.37-33.36,43.8a8,8,0,1,1-10.67-11.92A132.77,132.77,0,0,0,231.05,128a133.15,133.15,0,0,0-23.12-30.77C185.67,75.19,158.78,64,128,64a118.37,118.37,0,0,0-19.36,1.57A8,8,0,1,1,106,49.79,134,134,0,0,1,128,48c34.88,0,66.57,13.26,91.66,38.35,18.83,18.83,27.3,37.62,27.65,38.41A8,8,0,0,1,247.31,131.26Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M96.68,57.87a4,4,0,0,1,2.08-6.6A130.13,130.13,0,0,1,128,48c34.88,0,66.57,13.26,91.66,38.35,18.83,18.83,27.3,37.62,27.65,38.41a8,8,0,0,1,0,6.5c-.35.79-8.82,19.57-27.65,38.4q-4.28,4.26-8.79,8.07a4,4,0,0,1-5.55-.36ZM213.92,210.62a8,8,0,1,1-11.84,10.76L180,197.13A127.21,127.21,0,0,1,128,208c-34.88,0-66.57-13.26-91.66-38.34C17.51,150.83,9,132.05,8.69,131.26a8,8,0,0,1,0-6.5C9,124,17.51,105.18,36.34,86.35a135,135,0,0,1,25-19.78L42.08,45.38A8,8,0,1,1,53.92,34.62Zm-65.49-48.25-52.69-58a40,40,0,0,0,52.69,58Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M52.44,36A6,6,0,0,0,43.56,44L64.44,67c-37.28,21.9-53.23,57-53.92,58.57a6,6,0,0,0,0,4.88c.34.77,8.66,19.22,27.24,37.8C55,185.47,84.62,206,128,206a124.91,124.91,0,0,0,52.57-11.25l23,25.29a6,6,0,0,0,8.88-8.08Zm48.62,71.32,45,49.52a34,34,0,0,1-45-49.52ZM128,194c-31.38,0-58.78-11.42-81.45-33.93A134.57,134.57,0,0,1,22.69,128c4.29-8.2,20.1-35.18,50-51.91L92.89,98.3a46,46,0,0,0,61.35,67.48l17.81,19.6A113.47,113.47,0,0,1,128,194Zm6.4-99.4a6,6,0,0,1,2.25-11.79,46.17,46.17,0,0,1,37.15,40.87,6,6,0,0,1-5.42,6.53l-.56,0a6,6,0,0,1-6-5.45A34.1,34.1,0,0,0,134.4,94.6Zm111.08,35.85c-.41.92-10.37,23-32.86,43.12a6,6,0,1,1-8-8.94A134.07,134.07,0,0,0,233.31,128a134.67,134.67,0,0,0-23.86-32.07C186.78,73.42,159.38,62,128,62a120.19,120.19,0,0,0-19.69,1.6,6,6,0,1,1-2-11.83A131.12,131.12,0,0,1,128,50c43.38,0,73,20.54,90.24,37.76,18.58,18.58,26.9,37,27.24,37.81A6,6,0,0,1,245.48,130.45Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M53.92,34.62A8,8,0,1,0,42.08,45.38L61.32,66.55C25,88.84,9.38,123.2,8.69,124.76a8,8,0,0,0,0,6.5c.35.79,8.82,19.57,27.65,38.4C61.43,194.74,93.12,208,128,208a127.11,127.11,0,0,0,52.07-10.83l22,24.21a8,8,0,1,0,11.84-10.76Zm47.33,75.84,41.67,45.85a32,32,0,0,1-41.67-45.85ZM128,192c-30.78,0-57.67-11.19-79.93-33.25A133.16,133.16,0,0,1,25,128c4.69-8.79,19.66-33.39,47.35-49.38l18,19.75a48,48,0,0,0,63.66,70l14.73,16.2A112,112,0,0,1,128,192Zm6-95.43a8,8,0,0,1,3-15.72,48.16,48.16,0,0,1,38.77,42.64,8,8,0,0,1-7.22,8.71,6.39,6.39,0,0,1-.75,0,8,8,0,0,1-8-7.26A32.09,32.09,0,0,0,134,96.57Zm113.28,34.69c-.42.94-10.55,23.37-33.36,43.8a8,8,0,1,1-10.67-11.92A132.77,132.77,0,0,0,231.05,128a133.15,133.15,0,0,0-23.12-30.77C185.67,75.19,158.78,64,128,64a118.37,118.37,0,0,0-19.36,1.57A8,8,0,1,1,106,49.79,134,134,0,0,1,128,48c34.88,0,66.57,13.26,91.66,38.35,18.83,18.83,27.3,37.62,27.65,38.41A8,8,0,0,1,247.31,131.26Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M51,37.31A4,4,0,0,0,45,42.69L67.59,67.5C29.34,89,13,124.81,12.34,126.38a4.08,4.08,0,0,0,0,3.25c.34.77,8.52,18.89,26.83,37.2,17,17,46.14,37.17,88.83,37.17a122.59,122.59,0,0,0,53.06-11.69l24,26.38a4,4,0,1,0,5.92-5.38ZM149.1,157.16A36,36,0,0,1,101,104.22ZM128,196c-32,0-59.89-11.65-83-34.62A135.81,135.81,0,0,1,20.44,128c3.65-7.23,20.09-36.81,52.68-54.43l22.45,24.7a44,44,0,0,0,59,64.83l20.89,23A114.94,114.94,0,0,1,128,196Zm6.78-103.36a4,4,0,0,1,1.49-7.86,44.15,44.15,0,0,1,35.54,39.09,4,4,0,0,1-3.61,4.35l-.38,0a4,4,0,0,1-4-3.63A36.1,36.1,0,0,0,134.78,92.64Zm108.88,37c-.41.91-10.2,22.58-32.38,42.45a4,4,0,0,1-2.67,1,4,4,0,0,1-2.67-7A136.71,136.71,0,0,0,235.56,128,136.07,136.07,0,0,0,211,94.62C187.89,71.65,160,60,128,60a122,122,0,0,0-20,1.63,4,4,0,0,1-1.32-7.89A129.3,129.3,0,0,1,128,52c42.7,0,71.87,20.22,88.83,37.18,18.31,18.31,26.49,36.44,26.83,37.2A4.08,4.08,0,0,1,243.66,129.63Z" }))]
]);
var e$47 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M140,124v92a12,12,0,0,1-24,0V124a12,12,0,0,1,24,0Zm60,68a12,12,0,0,0-12,12v12a12,12,0,0,0,24,0V204A12,12,0,0,0,200,192Zm24-40H212V40a12,12,0,0,0-24,0V152H176a12,12,0,0,0,0,24h48a12,12,0,0,0,0-24ZM56,160a12,12,0,0,0-12,12v44a12,12,0,0,0,24,0V172A12,12,0,0,0,56,160Zm24-40H68V40a12,12,0,0,0-24,0v80H32a12,12,0,0,0,0,24H80a12,12,0,0,0,0-24Zm72-48H140V40a12,12,0,0,0-24,0V72H104a12,12,0,0,0,0,24h48a12,12,0,0,0,0-24Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M200,40V216H56V40Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M136,120v96a8,8,0,0,1-16,0V120a8,8,0,0,1,16,0Zm64,72a8,8,0,0,0-8,8v16a8,8,0,0,0,16,0V200A8,8,0,0,0,200,192Zm24-32H208V40a8,8,0,0,0-16,0V160H176a8,8,0,0,0,0,16h48a8,8,0,0,0,0-16ZM56,160a8,8,0,0,0-8,8v48a8,8,0,0,0,16,0V168A8,8,0,0,0,56,160Zm24-32H64V40a8,8,0,0,0-16,0v88H32a8,8,0,0,0,0,16H80a8,8,0,0,0,0-16Zm72-48H136V40a8,8,0,0,0-16,0V80H104a8,8,0,0,0,0,16h48a8,8,0,0,0,0-16Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M136,120v96a8,8,0,0,1-16,0V120a8,8,0,0,1,16,0Zm64,72a8,8,0,0,0-8,8v16a8,8,0,0,0,16,0V200A8,8,0,0,0,200,192Zm24-48H208V40a8,8,0,0,0-16,0V144H176a8,8,0,0,0-8,8v16a8,8,0,0,0,8,8h48a8,8,0,0,0,8-8V152A8,8,0,0,0,224,144ZM56,160a8,8,0,0,0-8,8v48a8,8,0,0,0,16,0V168A8,8,0,0,0,56,160Zm24-48H64V40a8,8,0,0,0-16,0v72H32a8,8,0,0,0-8,8v16a8,8,0,0,0,8,8H80a8,8,0,0,0,8-8V120A8,8,0,0,0,80,112Zm72-48H136V40a8,8,0,0,0-16,0V64H104a8,8,0,0,0-8,8V88a8,8,0,0,0,8,8h48a8,8,0,0,0,8-8V72A8,8,0,0,0,152,64Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M134,120v96a6,6,0,0,1-12,0V120a6,6,0,0,1,12,0Zm66,74a6,6,0,0,0-6,6v16a6,6,0,0,0,12,0V200A6,6,0,0,0,200,194Zm24-32H206V40a6,6,0,0,0-12,0V162H176a6,6,0,0,0,0,12h48a6,6,0,0,0,0-12ZM56,162a6,6,0,0,0-6,6v48a6,6,0,0,0,12,0V168A6,6,0,0,0,56,162Zm24-32H62V40a6,6,0,0,0-12,0v90H32a6,6,0,0,0,0,12H80a6,6,0,0,0,0-12Zm72-48H134V40a6,6,0,0,0-12,0V82H104a6,6,0,0,0,0,12h48a6,6,0,0,0,0-12Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M136,120v96a8,8,0,0,1-16,0V120a8,8,0,0,1,16,0Zm64,72a8,8,0,0,0-8,8v16a8,8,0,0,0,16,0V200A8,8,0,0,0,200,192Zm24-32H208V40a8,8,0,0,0-16,0V160H176a8,8,0,0,0,0,16h48a8,8,0,0,0,0-16ZM56,160a8,8,0,0,0-8,8v48a8,8,0,0,0,16,0V168A8,8,0,0,0,56,160Zm24-32H64V40a8,8,0,0,0-16,0v88H32a8,8,0,0,0,0,16H80a8,8,0,0,0,0-16Zm72-48H136V40a8,8,0,0,0-16,0V80H104a8,8,0,0,0,0,16h48a8,8,0,0,0,0-16Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M132,120v96a4,4,0,0,1-8,0V120a4,4,0,0,1,8,0Zm68,76a4,4,0,0,0-4,4v16a4,4,0,0,0,8,0V200A4,4,0,0,0,200,196Zm24-32H204V40a4,4,0,0,0-8,0V164H176a4,4,0,0,0,0,8h48a4,4,0,0,0,0-8ZM56,164a4,4,0,0,0-4,4v48a4,4,0,0,0,8,0V168A4,4,0,0,0,56,164Zm24-32H60V40a4,4,0,0,0-8,0v92H32a4,4,0,0,0,0,8H80a4,4,0,0,0,0-8Zm72-48H132V40a4,4,0,0,0-8,0V84H104a4,4,0,0,0,0,8h48a4,4,0,0,0,0-8Z" }))]
]);
var a$22 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M145.93,14.77A12,12,0,0,0,127,19.89L107.07,74.5,87.38,55.39a12,12,0,0,0-17.9,1.33C47.27,85.82,36,115.19,36,144a92,92,0,0,0,184,0C220,82.85,168.2,33.25,145.93,14.77ZM128,212a68.07,68.07,0,0,1-68-68c0-19.94,7-40.62,20.71-61.64l22.93,22.25a12,12,0,0,0,19.63-4.5l20.21-55.4C165.39,65.61,196,102.29,196,144A68.07,68.07,0,0,1,128,212Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M208,144a80,80,0,0,1-160,0c0-30.57,14.42-58.26,31-80l33,32,26.27-72C159.86,41.92,208,88.15,208,144Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M143.38,17.85a8,8,0,0,0-12.63,3.41l-22,60.41L84.59,58.26a8,8,0,0,0-11.93.89C51,87.53,40,116.08,40,144a88,88,0,0,0,176,0C216,84.55,165.21,36,143.38,17.85ZM128,216a72.08,72.08,0,0,1-72-72c0-22,8.09-44.79,24.06-67.84l26.37,25.58a8,8,0,0,0,13.09-3l22.27-61.07C164.21,58.08,200,97.91,200,144A72.08,72.08,0,0,1,128,216Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M143.38,17.85a8,8,0,0,0-12.63,3.41l-22,60.41L84.59,58.26a8,8,0,0,0-11.93.89C51,87.53,40,116.08,40,144a88,88,0,0,0,176,0C216,84.55,165.21,36,143.38,17.85Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M142.1,19.38a6,6,0,0,0-9.47,2.56L109.54,85.25,83.2,59.69a6,6,0,0,0-9,.67C52.85,88.39,42,116.53,42,144a86,86,0,0,0,172,0C214,85.4,163.72,37.33,142.1,19.38ZM128,218a74.09,74.09,0,0,1-74-74c0-23,8.67-46.87,25.77-70.91l28.05,27.22a6,6,0,0,0,9.82-2.25L140.93,34.2C163.35,54.16,202,95.6,202,144A74.09,74.09,0,0,1,128,218Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M143.38,17.85a8,8,0,0,0-12.63,3.41l-22,60.41L84.59,58.26a8,8,0,0,0-11.93.89C51,87.53,40,116.08,40,144a88,88,0,0,0,176,0C216,84.55,165.21,36,143.38,17.85ZM128,216a72.08,72.08,0,0,1-72-72c0-22,8.09-44.79,24.06-67.84l26.37,25.58a8,8,0,0,0,13.09-3l22.27-61.07C164.21,58.08,200,97.91,200,144A72.08,72.08,0,0,1,128,216Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M140.82,20.92a4,4,0,0,0-6.31,1.71l-24.15,66.2L81.81,61.13a4,4,0,0,0-6,.44C54.71,89.25,44,117,44,144a84,84,0,0,0,168,0C212,86.24,162.22,38.69,140.82,20.92ZM128,220a76.08,76.08,0,0,1-76-76c0-24.07,9.25-48.93,27.5-74l29.71,28.83a4,4,0,0,0,6.55-1.5l24.3-66.6C162.27,50.09,204,93.18,204,144A76.08,76.08,0,0,1,128,220Z" }))]
]);
var e$46 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M208,28H83.31a19.86,19.86,0,0,0-14.14,5.86L33.86,69.17A19.86,19.86,0,0,0,28,83.31V208a20,20,0,0,0,20,20H208a20,20,0,0,0,20-20V48A20,20,0,0,0,208,28ZM92,52h72V72H92ZM204,204H52V85L68,69v7A20,20,0,0,0,88,96h80a20,20,0,0,0,20-20V52h16Zm-76-96a42,42,0,1,0,42,42A42,42,0,0,0,128,108Zm0,60a18,18,0,1,1,18-18A18,18,0,0,1,128,168Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M208,40H176V80a8,8,0,0,1-8,8H88a8,8,0,0,1-8-8V40.73a8,8,0,0,0-2.34,1.61L42.34,77.66A8,8,0,0,0,40,83.31V208a8,8,0,0,0,8,8H208a8,8,0,0,0,8-8V48A8,8,0,0,0,208,40ZM128,184a32,32,0,1,1,32-32A32,32,0,0,1,128,184Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M208,32H83.31A15.86,15.86,0,0,0,72,36.69L36.69,72A15.86,15.86,0,0,0,32,83.31V208a16,16,0,0,0,16,16H208a16,16,0,0,0,16-16V48A16,16,0,0,0,208,32ZM88,48h80V80H88ZM208,208H48V83.31l24-24V80A16,16,0,0,0,88,96h80a16,16,0,0,0,16-16V48h24Zm-80-96a40,40,0,1,0,40,40A40,40,0,0,0,128,112Zm0,64a24,24,0,1,1,24-24A24,24,0,0,1,128,176Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M208,32H83.31A15.86,15.86,0,0,0,72,36.69L36.69,72A15.86,15.86,0,0,0,32,83.31V208a16,16,0,0,0,16,16H208a16,16,0,0,0,16-16V48A16,16,0,0,0,208,32ZM128,184a32,32,0,1,1,32-32A32,32,0,0,1,128,184ZM172,80a4,4,0,0,1-4,4H88a4,4,0,0,1-4-4V48h88Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M208,34H83.31a13.94,13.94,0,0,0-9.9,4.1L38.1,73.41a13.94,13.94,0,0,0-4.1,9.9V208a14,14,0,0,0,14,14H208a14,14,0,0,0,14-14V48A14,14,0,0,0,208,34ZM86,46h84V80a2,2,0,0,1-2,2H88a2,2,0,0,1-2-2ZM210,208a2,2,0,0,1-2,2H48a2,2,0,0,1-2-2V83.31a2,2,0,0,1,.59-1.41L74,54.48V80A14,14,0,0,0,88,94h80a14,14,0,0,0,14-14V46h26a2,2,0,0,1,2,2Zm-82-94a38,38,0,1,0,38,38A38,38,0,0,0,128,114Zm0,64a26,26,0,1,1,26-26A26,26,0,0,1,128,178Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M208,32H83.31A15.86,15.86,0,0,0,72,36.69L36.69,72A15.86,15.86,0,0,0,32,83.31V208a16,16,0,0,0,16,16H208a16,16,0,0,0,16-16V48A16,16,0,0,0,208,32ZM88,48h80V80H88ZM208,208H48V83.31l24-24V80A16,16,0,0,0,88,96h80a16,16,0,0,0,16-16V48h24Zm-80-96a40,40,0,1,0,40,40A40,40,0,0,0,128,112Zm0,64a24,24,0,1,1,24-24A24,24,0,0,1,128,176Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M208,36H83.31a12,12,0,0,0-8.48,3.51L39.52,74.83A11.9,11.9,0,0,0,36,83.31V208a12,12,0,0,0,12,12H208a12,12,0,0,0,12-12V48A12,12,0,0,0,208,36ZM84,44h88V80a4,4,0,0,1-4,4H88a4,4,0,0,1-4-4ZM212,208a4,4,0,0,1-4,4H48a4,4,0,0,1-4-4V83.31a4,4,0,0,1,1.17-2.82L76,49.66V80A12,12,0,0,0,88,92h80a12,12,0,0,0,12-12V44h28a4,4,0,0,1,4,4Zm-84-92a36,36,0,1,0,36,36A36,36,0,0,0,128,116Zm0,64a28,28,0,1,1,28-28A28,28,0,0,1,128,180Z" }))]
]);
var l$3 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M128,76a52,52,0,1,0,52,52A52.06,52.06,0,0,0,128,76Zm0,80a28,28,0,1,1,28-28A28,28,0,0,1,128,156Zm113.86-49.57A12,12,0,0,0,236,98.34L208.21,82.49l-.11-31.31a12,12,0,0,0-4.25-9.12,116,116,0,0,0-38-21.41,12,12,0,0,0-9.68.89L128,37.27,99.83,21.53a12,12,0,0,0-9.7-.9,116.06,116.06,0,0,0-38,21.47,12,12,0,0,0-4.24,9.1l-.14,31.34L20,98.35a12,12,0,0,0-5.85,8.11,110.7,110.7,0,0,0,0,43.11A12,12,0,0,0,20,157.66l27.82,15.85.11,31.31a12,12,0,0,0,4.25,9.12,116,116,0,0,0,38,21.41,12,12,0,0,0,9.68-.89L128,218.73l28.14,15.74a12,12,0,0,0,9.7.9,116.06,116.06,0,0,0,38-21.47,12,12,0,0,0,4.24-9.1l.14-31.34,27.81-15.81a12,12,0,0,0,5.85-8.11A110.7,110.7,0,0,0,241.86,106.43Zm-22.63,33.18-26.88,15.28a11.94,11.94,0,0,0-4.55,4.59c-.54,1-1.11,1.93-1.7,2.88a12,12,0,0,0-1.83,6.31L184.13,199a91.83,91.83,0,0,1-21.07,11.87l-27.15-15.19a12,12,0,0,0-5.86-1.53h-.29c-1.14,0-2.3,0-3.44,0a12.08,12.08,0,0,0-6.14,1.51L93,210.82A92.27,92.27,0,0,1,71.88,199l-.11-30.24a12,12,0,0,0-1.83-6.32c-.58-.94-1.16-1.91-1.7-2.88A11.92,11.92,0,0,0,63.7,155L36.8,139.63a86.53,86.53,0,0,1,0-23.24l26.88-15.28a12,12,0,0,0,4.55-4.58c.54-1,1.11-1.94,1.7-2.89a12,12,0,0,0,1.83-6.31L71.87,57A91.83,91.83,0,0,1,92.94,45.17l27.15,15.19a11.92,11.92,0,0,0,6.15,1.52c1.14,0,2.3,0,3.44,0a12.08,12.08,0,0,0,6.14-1.51L163,45.18A92.27,92.27,0,0,1,184.12,57l.11,30.24a12,12,0,0,0,1.83,6.32c.58.94,1.16,1.91,1.7,2.88A11.92,11.92,0,0,0,192.3,101l26.9,15.33A86.53,86.53,0,0,1,219.23,139.61Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M230.1,108.76,198.25,90.62c-.64-1.16-1.31-2.29-2-3.41l-.12-36A104.61,104.61,0,0,0,162,32L130,49.89c-1.34,0-2.69,0-4,0L94,32A104.58,104.58,0,0,0,59.89,51.25l-.16,36c-.7,1.12-1.37,2.26-2,3.41l-31.84,18.1a99.15,99.15,0,0,0,0,38.46l31.85,18.14c.64,1.16,1.31,2.29,2,3.41l.12,36A104.61,104.61,0,0,0,94,224l32-17.87c1.34,0,2.69,0,4,0L162,224a104.58,104.58,0,0,0,34.08-19.25l.16-36c.7-1.12,1.37-2.26,2-3.41l31.84-18.1A99.15,99.15,0,0,0,230.1,108.76ZM128,168a40,40,0,1,1,40-40A40,40,0,0,1,128,168Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M128,80a48,48,0,1,0,48,48A48.05,48.05,0,0,0,128,80Zm0,80a32,32,0,1,1,32-32A32,32,0,0,1,128,160Zm109.94-52.79a8,8,0,0,0-3.89-5.4l-29.83-17-.12-33.62a8,8,0,0,0-2.83-6.08,111.91,111.91,0,0,0-36.72-20.67,8,8,0,0,0-6.46.59L128,41.85,97.88,25a8,8,0,0,0-6.47-.6A111.92,111.92,0,0,0,54.73,45.15a8,8,0,0,0-2.83,6.07l-.15,33.65-29.83,17a8,8,0,0,0-3.89,5.4,106.47,106.47,0,0,0,0,41.56,8,8,0,0,0,3.89,5.4l29.83,17,.12,33.63a8,8,0,0,0,2.83,6.08,111.91,111.91,0,0,0,36.72,20.67,8,8,0,0,0,6.46-.59L128,214.15,158.12,231a7.91,7.91,0,0,0,3.9,1,8.09,8.09,0,0,0,2.57-.42,112.1,112.1,0,0,0,36.68-20.73,8,8,0,0,0,2.83-6.07l.15-33.65,29.83-17a8,8,0,0,0,3.89-5.4A106.47,106.47,0,0,0,237.94,107.21Zm-15,34.91-28.57,16.25a8,8,0,0,0-3,3c-.58,1-1.19,2.06-1.81,3.06a7.94,7.94,0,0,0-1.22,4.21l-.15,32.25a95.89,95.89,0,0,1-25.37,14.3L134,199.13a8,8,0,0,0-3.91-1h-.19c-1.21,0-2.43,0-3.64,0a8.1,8.1,0,0,0-4.1,1l-28.84,16.1A96,96,0,0,1,67.88,201l-.11-32.2a8,8,0,0,0-1.22-4.22c-.62-1-1.23-2-1.8-3.06a8.09,8.09,0,0,0-3-3.06l-28.6-16.29a90.49,90.49,0,0,1,0-28.26L61.67,97.63a8,8,0,0,0,3-3c.58-1,1.19-2.06,1.81-3.06a7.94,7.94,0,0,0,1.22-4.21l.15-32.25a95.89,95.89,0,0,1,25.37-14.3L122,56.87a8,8,0,0,0,4.1,1c1.21,0,2.43,0,3.64,0a8,8,0,0,0,4.1-1l28.84-16.1A96,96,0,0,1,188.12,55l.11,32.2a8,8,0,0,0,1.22,4.22c.62,1,1.23,2,1.8,3.06a8.09,8.09,0,0,0,3,3.06l28.6,16.29A90.49,90.49,0,0,1,222.9,142.12Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M237.94,107.21a8,8,0,0,0-3.89-5.4l-29.83-17-.12-33.62a8,8,0,0,0-2.83-6.08,111.91,111.91,0,0,0-36.72-20.67,8,8,0,0,0-6.46.59L128,41.85,97.88,25a8,8,0,0,0-6.47-.6A111.92,111.92,0,0,0,54.73,45.15a8,8,0,0,0-2.83,6.07l-.15,33.65-29.83,17a8,8,0,0,0-3.89,5.4,106.47,106.47,0,0,0,0,41.56,8,8,0,0,0,3.89,5.4l29.83,17,.12,33.63a8,8,0,0,0,2.83,6.08,111.91,111.91,0,0,0,36.72,20.67,8,8,0,0,0,6.46-.59L128,214.15,158.12,231a7.91,7.91,0,0,0,3.9,1,8.09,8.09,0,0,0,2.57-.42,112.1,112.1,0,0,0,36.68-20.73,8,8,0,0,0,2.83-6.07l.15-33.65,29.83-17a8,8,0,0,0,3.89-5.4A106.47,106.47,0,0,0,237.94,107.21ZM128,168a40,40,0,1,1,40-40A40,40,0,0,1,128,168Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M128,82a46,46,0,1,0,46,46A46.06,46.06,0,0,0,128,82Zm0,80a34,34,0,1,1,34-34A34,34,0,0,1,128,162Zm108-54.4a6,6,0,0,0-2.92-4L202.64,86.22l-.42-.71L202.1,51.2A6,6,0,0,0,200,46.64a110.12,110.12,0,0,0-36.07-20.31,6,6,0,0,0-4.84.45L128.46,43.86h-1L96.91,26.76a6,6,0,0,0-4.86-.44A109.92,109.92,0,0,0,56,46.68a6,6,0,0,0-2.12,4.55l-.16,34.34c-.14.23-.28.47-.41.71L22.91,103.57A6,6,0,0,0,20,107.62a104.81,104.81,0,0,0,0,40.78,6,6,0,0,0,2.92,4l30.42,17.33.42.71.12,34.31A6,6,0,0,0,56,209.36a110.12,110.12,0,0,0,36.07,20.31,6,6,0,0,0,4.84-.45l30.61-17.08h1l30.56,17.1A6.09,6.09,0,0,0,162,230a5.83,5.83,0,0,0,1.93-.32,109.92,109.92,0,0,0,36-20.36,6,6,0,0,0,2.12-4.55l.16-34.34c.14-.23.28-.47.41-.71l30.42-17.29a6,6,0,0,0,2.92-4.05A104.81,104.81,0,0,0,236,107.6Zm-11.25,35.79L195.32,160.1a6.07,6.07,0,0,0-2.28,2.3c-.59,1-1.21,2.11-1.86,3.14a6,6,0,0,0-.91,3.16l-.16,33.21a98.15,98.15,0,0,1-27.52,15.53L133,200.88a6,6,0,0,0-2.93-.77h-.14c-1.24,0-2.5,0-3.74,0a6,6,0,0,0-3.07.76L93.45,217.43a98,98,0,0,1-27.56-15.49l-.12-33.17a6,6,0,0,0-.91-3.16c-.64-1-1.27-2.08-1.86-3.14a6,6,0,0,0-2.27-2.3L31.3,143.4a93,93,0,0,1,0-30.79L60.68,95.9A6.07,6.07,0,0,0,63,93.6c.59-1,1.21-2.11,1.86-3.14a6,6,0,0,0,.91-3.16l.16-33.21A98.15,98.15,0,0,1,93.41,38.56L123,55.12a5.81,5.81,0,0,0,3.07.76c1.24,0,2.5,0,3.74,0a6,6,0,0,0,3.07-.76l29.65-16.56a98,98,0,0,1,27.56,15.49l.12,33.17a6,6,0,0,0,.91,3.16c.64,1,1.27,2.08,1.86,3.14a6,6,0,0,0,2.27,2.3L224.7,112.6A93,93,0,0,1,224.73,143.39Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M128,80a48,48,0,1,0,48,48A48.05,48.05,0,0,0,128,80Zm0,80a32,32,0,1,1,32-32A32,32,0,0,1,128,160Zm109.94-52.79a8,8,0,0,0-3.89-5.4l-29.83-17-.12-33.62a8,8,0,0,0-2.83-6.08,111.91,111.91,0,0,0-36.72-20.67,8,8,0,0,0-6.46.59L128,41.85,97.88,25a8,8,0,0,0-6.47-.6A112.1,112.1,0,0,0,54.73,45.15a8,8,0,0,0-2.83,6.07l-.15,33.65-29.83,17a8,8,0,0,0-3.89,5.4,106.47,106.47,0,0,0,0,41.56,8,8,0,0,0,3.89,5.4l29.83,17,.12,33.62a8,8,0,0,0,2.83,6.08,111.91,111.91,0,0,0,36.72,20.67,8,8,0,0,0,6.46-.59L128,214.15,158.12,231a7.91,7.91,0,0,0,3.9,1,8.09,8.09,0,0,0,2.57-.42,112.1,112.1,0,0,0,36.68-20.73,8,8,0,0,0,2.83-6.07l.15-33.65,29.83-17a8,8,0,0,0,3.89-5.4A106.47,106.47,0,0,0,237.94,107.21Zm-15,34.91-28.57,16.25a8,8,0,0,0-3,3c-.58,1-1.19,2.06-1.81,3.06a7.94,7.94,0,0,0-1.22,4.21l-.15,32.25a95.89,95.89,0,0,1-25.37,14.3L134,199.13a8,8,0,0,0-3.91-1h-.19c-1.21,0-2.43,0-3.64,0a8.08,8.08,0,0,0-4.1,1l-28.84,16.1A96,96,0,0,1,67.88,201l-.11-32.2a8,8,0,0,0-1.22-4.22c-.62-1-1.23-2-1.8-3.06a8.09,8.09,0,0,0-3-3.06l-28.6-16.29a90.49,90.49,0,0,1,0-28.26L61.67,97.63a8,8,0,0,0,3-3c.58-1,1.19-2.06,1.81-3.06a7.94,7.94,0,0,0,1.22-4.21l.15-32.25a95.89,95.89,0,0,1,25.37-14.3L122,56.87a8,8,0,0,0,4.1,1c1.21,0,2.43,0,3.64,0a8.08,8.08,0,0,0,4.1-1l28.84-16.1A96,96,0,0,1,188.12,55l.11,32.2a8,8,0,0,0,1.22,4.22c.62,1,1.23,2,1.8,3.06a8.09,8.09,0,0,0,3,3.06l28.6,16.29A90.49,90.49,0,0,1,222.9,142.12Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M128,84a44,44,0,1,0,44,44A44.05,44.05,0,0,0,128,84Zm0,80a36,36,0,1,1,36-36A36,36,0,0,1,128,164Zm106-56a4,4,0,0,0-2-2.7l-30.89-17.6q-.47-.82-1-1.62L200.1,51.2a3.94,3.94,0,0,0-1.42-3,107.8,107.8,0,0,0-35.41-19.94,4,4,0,0,0-3.23.29L129,45.87h-2l-31-17.36a4,4,0,0,0-3.23-.3,108.05,108.05,0,0,0-35.39,20,4,4,0,0,0-1.41,3l-.16,34.9-1,1.62L23.9,105.3A4,4,0,0,0,22,108a102.76,102.76,0,0,0,0,40,4,4,0,0,0,1.95,2.7l30.89,17.6q.47.83,1,1.62l.12,34.87a3.94,3.94,0,0,0,1.42,3,107.8,107.8,0,0,0,35.41,19.94,4,4,0,0,0,3.23-.29L127,210.13h2l31,17.36a4,4,0,0,0,3.23.3,108.05,108.05,0,0,0,35.39-20,4,4,0,0,0,1.41-3l.16-34.9,1-1.62L232.1,150.7a4,4,0,0,0,2-2.71A102.76,102.76,0,0,0,234,108Zm-7.48,36.67L196.3,161.84a4,4,0,0,0-1.51,1.53c-.61,1.09-1.25,2.17-1.91,3.24a3.92,3.92,0,0,0-.61,2.1l-.16,34.15a99.8,99.8,0,0,1-29.7,16.77l-30.4-17a4.06,4.06,0,0,0-2-.51H130c-1.28,0-2.57,0-3.84,0a4.1,4.1,0,0,0-2.05.51l-30.45,17A100.23,100.23,0,0,1,63.89,202.9l-.12-34.12a3.93,3.93,0,0,0-.61-2.11c-.66-1-1.3-2.14-1.91-3.23a4,4,0,0,0-1.51-1.53L29.49,144.68a94.78,94.78,0,0,1,0-33.34L59.7,94.16a4,4,0,0,0,1.51-1.53c.61-1.09,1.25-2.17,1.91-3.23a4,4,0,0,0,.61-2.11l.16-34.15a99.8,99.8,0,0,1,29.7-16.77l30.4,17a4.1,4.1,0,0,0,2.05.51c1.28,0,2.57,0,3.84,0a4,4,0,0,0,2.05-.51l30.45-17A100.23,100.23,0,0,1,192.11,53.1l.12,34.12a3.93,3.93,0,0,0,.61,2.11c.66,1,1.3,2.14,1.91,3.23a4,4,0,0,0,1.51,1.53l30.25,17.23A94.78,94.78,0,0,1,226.54,144.66Z" }))]
]);
var e$45 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M212.62,75.17A63.7,63.7,0,0,0,206.39,26,12,12,0,0,0,196,20a63.71,63.71,0,0,0-50,24H126A63.71,63.71,0,0,0,76,20a12,12,0,0,0-10.39,6,63.7,63.7,0,0,0-6.23,49.17A61.5,61.5,0,0,0,52,104v8a60.1,60.1,0,0,0,45.76,58.28A43.66,43.66,0,0,0,92,192v4H76a20,20,0,0,1-20-20,44.05,44.05,0,0,0-44-44,12,12,0,0,0,0,24,20,20,0,0,1,20,20,44.05,44.05,0,0,0,44,44H92v12a12,12,0,0,0,24,0V192a20,20,0,0,1,40,0v40a12,12,0,0,0,24,0V192a43.66,43.66,0,0,0-5.76-21.72A60.1,60.1,0,0,0,220,112v-8A61.5,61.5,0,0,0,212.62,75.17ZM196,112a36,36,0,0,1-36,36H112a36,36,0,0,1-36-36v-8a37.87,37.87,0,0,1,6.13-20.12,11.65,11.65,0,0,0,1.58-11.49,39.9,39.9,0,0,1-.4-27.72,39.87,39.87,0,0,1,26.41,17.8A12,12,0,0,0,119.82,68h32.35a12,12,0,0,0,10.11-5.53,39.84,39.84,0,0,1,26.41-17.8,39.9,39.9,0,0,1-.4,27.72,12,12,0,0,0,1.61,11.53A37.85,37.85,0,0,1,196,104Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M208,104v8a48,48,0,0,1-48,48H136a32,32,0,0,1,32,32v40H104V192a32,32,0,0,1,32-32H112a48,48,0,0,1-48-48v-8a49.28,49.28,0,0,1,8.51-27.3A51.92,51.92,0,0,1,76,32a52,52,0,0,1,43.83,24h32.34A52,52,0,0,1,196,32a51.92,51.92,0,0,1,3.49,44.7A49.28,49.28,0,0,1,208,104Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M208.3,75.68A59.74,59.74,0,0,0,202.93,28,8,8,0,0,0,196,24a59.75,59.75,0,0,0-48,24H124A59.75,59.75,0,0,0,76,24a8,8,0,0,0-6.93,4,59.78,59.78,0,0,0-5.38,47.68A58.14,58.14,0,0,0,56,104v8a56.06,56.06,0,0,0,48.44,55.47A39.8,39.8,0,0,0,96,192v8H72a24,24,0,0,1-24-24A40,40,0,0,0,8,136a8,8,0,0,0,0,16,24,24,0,0,1,24,24,40,40,0,0,0,40,40H96v16a8,8,0,0,0,16,0V192a24,24,0,0,1,48,0v40a8,8,0,0,0,16,0V192a39.8,39.8,0,0,0-8.44-24.53A56.06,56.06,0,0,0,216,112v-8A58,58,0,0,0,208.3,75.68ZM200,112a40,40,0,0,1-40,40H112a40,40,0,0,1-40-40v-8a41.74,41.74,0,0,1,6.9-22.48A8,8,0,0,0,80,73.83a43.81,43.81,0,0,1,.79-33.58,43.88,43.88,0,0,1,32.32,20.06A8,8,0,0,0,119.82,64h32.35a8,8,0,0,0,6.74-3.69,43.87,43.87,0,0,1,32.32-20.06A43.81,43.81,0,0,1,192,73.83a8.09,8.09,0,0,0,1,7.65A41.76,41.76,0,0,1,200,104Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M216,104v8a56.06,56.06,0,0,1-48.44,55.47A39.8,39.8,0,0,1,176,192v40a8,8,0,0,1-8,8H104a8,8,0,0,1-8-8V216H72a40,40,0,0,1-40-40A24,24,0,0,0,8,152a8,8,0,0,1,0-16,40,40,0,0,1,40,40,24,24,0,0,0,24,24H96v-8a39.8,39.8,0,0,1,8.44-24.53A56.06,56.06,0,0,1,56,112v-8a58.14,58.14,0,0,1,7.69-28.32A59.78,59.78,0,0,1,69.07,28,8,8,0,0,1,76,24a59.75,59.75,0,0,1,48,24h24a59.75,59.75,0,0,1,48-24,8,8,0,0,1,6.93,4,59.74,59.74,0,0,1,5.37,47.68A58,58,0,0,1,216,104Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M206.13,75.92A57.79,57.79,0,0,0,201.2,29a6,6,0,0,0-5.2-3,57.77,57.77,0,0,0-47,24H123A57.77,57.77,0,0,0,76,26a6,6,0,0,0-5.2,3,57.79,57.79,0,0,0-4.93,46.92A55.88,55.88,0,0,0,58,104v8a54.06,54.06,0,0,0,50.45,53.87A37.85,37.85,0,0,0,98,192v10H72a26,26,0,0,1-26-26A38,38,0,0,0,8,138a6,6,0,0,0,0,12,26,26,0,0,1,26,26,38,38,0,0,0,38,38H98v18a6,6,0,0,0,12,0V192a26,26,0,0,1,52,0v40a6,6,0,0,0,12,0V192a37.85,37.85,0,0,0-10.45-26.13A54.06,54.06,0,0,0,214,112v-8A55.88,55.88,0,0,0,206.13,75.92ZM202,112a42,42,0,0,1-42,42H112a42,42,0,0,1-42-42v-8a43.86,43.86,0,0,1,7.3-23.69,6,6,0,0,0,.81-5.76,45.85,45.85,0,0,1,1.43-36.42,45.85,45.85,0,0,1,35.23,21.1A6,6,0,0,0,119.83,62h32.34a6,6,0,0,0,5.06-2.76,45.83,45.83,0,0,1,35.23-21.11,45.85,45.85,0,0,1,1.43,36.42,6,6,0,0,0,.79,5.74A43.78,43.78,0,0,1,202,104Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M208.31,75.68A59.78,59.78,0,0,0,202.93,28,8,8,0,0,0,196,24a59.75,59.75,0,0,0-48,24H124A59.75,59.75,0,0,0,76,24a8,8,0,0,0-6.93,4,59.78,59.78,0,0,0-5.38,47.68A58.14,58.14,0,0,0,56,104v8a56.06,56.06,0,0,0,48.44,55.47A39.8,39.8,0,0,0,96,192v8H72a24,24,0,0,1-24-24A40,40,0,0,0,8,136a8,8,0,0,0,0,16,24,24,0,0,1,24,24,40,40,0,0,0,40,40H96v16a8,8,0,0,0,16,0V192a24,24,0,0,1,48,0v40a8,8,0,0,0,16,0V192a39.8,39.8,0,0,0-8.44-24.53A56.06,56.06,0,0,0,216,112v-8A58.14,58.14,0,0,0,208.31,75.68ZM200,112a40,40,0,0,1-40,40H112a40,40,0,0,1-40-40v-8a41.74,41.74,0,0,1,6.9-22.48A8,8,0,0,0,80,73.83a43.81,43.81,0,0,1,.79-33.58,43.88,43.88,0,0,1,32.32,20.06A8,8,0,0,0,119.82,64h32.35a8,8,0,0,0,6.74-3.69,43.87,43.87,0,0,1,32.32-20.06A43.81,43.81,0,0,1,192,73.83a8.09,8.09,0,0,0,1,7.65A41.72,41.72,0,0,1,200,104Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M203.94,76.16A55.73,55.73,0,0,0,199.46,30,4,4,0,0,0,196,28a55.78,55.78,0,0,0-46,24H122A55.78,55.78,0,0,0,76,28a4,4,0,0,0-3.46,2,55.73,55.73,0,0,0-4.48,46.16A53.78,53.78,0,0,0,60,104v8a52.06,52.06,0,0,0,52,52h1.41A36,36,0,0,0,100,192v12H72a28,28,0,0,1-28-28A36,36,0,0,0,8,140a4,4,0,0,0,0,8,28,28,0,0,1,28,28,36,36,0,0,0,36,36h28v20a4,4,0,0,0,8,0V192a28,28,0,0,1,56,0v40a4,4,0,0,0,8,0V192a36,36,0,0,0-13.41-28H160a52.06,52.06,0,0,0,52-52v-8A53.78,53.78,0,0,0,203.94,76.16ZM204,112a44.05,44.05,0,0,1-44,44H112a44.05,44.05,0,0,1-44-44v-8a45.76,45.76,0,0,1,7.71-24.89,4,4,0,0,0,.53-3.84,47.82,47.82,0,0,1,2.1-39.21,47.8,47.8,0,0,1,38.12,22.1A4,4,0,0,0,119.83,60h32.34a4,4,0,0,0,3.37-1.84,47.8,47.8,0,0,1,38.12-22.1,47.82,47.82,0,0,1,2.1,39.21,4,4,0,0,0,.53,3.83A45.85,45.85,0,0,1,204,104Z" }))]
]);
var e$44 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M128,20A108,108,0,1,0,236,128,108.12,108.12,0,0,0,128,20Zm0,187a113.4,113.4,0,0,1-20.39-35h40.82a116.94,116.94,0,0,1-10,20.77A108.61,108.61,0,0,1,128,207Zm-26.49-59a135.42,135.42,0,0,1,0-40h53a135.42,135.42,0,0,1,0,40ZM44,128a83.49,83.49,0,0,1,2.43-20H77.25a160.63,160.63,0,0,0,0,40H46.43A83.49,83.49,0,0,1,44,128Zm84-79a113.4,113.4,0,0,1,20.39,35H107.59a116.94,116.94,0,0,1,10-20.77A108.61,108.61,0,0,1,128,49Zm50.73,59h30.82a83.52,83.52,0,0,1,0,40H178.75a160.63,160.63,0,0,0,0-40Zm20.77-24H173.71a140.82,140.82,0,0,0-15.5-34.36A84.51,84.51,0,0,1,199.52,84ZM97.79,49.64A140.82,140.82,0,0,0,82.29,84H56.48A84.51,84.51,0,0,1,97.79,49.64ZM56.48,172H82.29a140.82,140.82,0,0,0,15.5,34.36A84.51,84.51,0,0,1,56.48,172Zm101.73,34.36A140.82,140.82,0,0,0,173.71,172h25.81A84.51,84.51,0,0,1,158.21,206.36Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M224,128a96,96,0,1,1-96-96A96,96,0,0,1,224,128Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M128,24h0A104,104,0,1,0,232,128,104.12,104.12,0,0,0,128,24Zm88,104a87.61,87.61,0,0,1-3.33,24H174.16a157.44,157.44,0,0,0,0-48h38.51A87.61,87.61,0,0,1,216,128ZM102,168H154a115.11,115.11,0,0,1-26,45A115.27,115.27,0,0,1,102,168Zm-3.9-16a140.84,140.84,0,0,1,0-48h59.88a140.84,140.84,0,0,1,0,48ZM40,128a87.61,87.61,0,0,1,3.33-24H81.84a157.44,157.44,0,0,0,0,48H43.33A87.61,87.61,0,0,1,40,128ZM154,88H102a115.11,115.11,0,0,1,26-45A115.27,115.27,0,0,1,154,88Zm52.33,0H170.71a135.28,135.28,0,0,0-22.3-45.6A88.29,88.29,0,0,1,206.37,88ZM107.59,42.4A135.28,135.28,0,0,0,85.29,88H49.63A88.29,88.29,0,0,1,107.59,42.4ZM49.63,168H85.29a135.28,135.28,0,0,0,22.3,45.6A88.29,88.29,0,0,1,49.63,168Zm98.78,45.6a135.28,135.28,0,0,0,22.3-45.6h35.66A88.29,88.29,0,0,1,148.41,213.6Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M128,24h0A104,104,0,1,0,232,128,104.12,104.12,0,0,0,128,24Zm78.36,64H170.71a135.28,135.28,0,0,0-22.3-45.6A88.29,88.29,0,0,1,206.37,88ZM216,128a87.61,87.61,0,0,1-3.33,24H174.16a157.44,157.44,0,0,0,0-48h38.51A87.61,87.61,0,0,1,216,128ZM128,43a115.27,115.27,0,0,1,26,45H102A115.11,115.11,0,0,1,128,43ZM102,168H154a115.11,115.11,0,0,1-26,45A115.27,115.27,0,0,1,102,168Zm-3.9-16a140.84,140.84,0,0,1,0-48h59.88a140.84,140.84,0,0,1,0,48Zm50.35,61.6a135.28,135.28,0,0,0,22.3-45.6h35.66A88.29,88.29,0,0,1,148.41,213.6Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M128,26A102,102,0,1,0,230,128,102.12,102.12,0,0,0,128,26Zm81.57,64H169.19a132.58,132.58,0,0,0-25.73-50.67A90.29,90.29,0,0,1,209.57,90ZM218,128a89.7,89.7,0,0,1-3.83,26H171.81a155.43,155.43,0,0,0,0-52h42.36A89.7,89.7,0,0,1,218,128Zm-90,87.83a110,110,0,0,1-15.19-19.45A124.24,124.24,0,0,1,99.35,166h57.3a124.24,124.24,0,0,1-13.46,30.38A110,110,0,0,1,128,215.83ZM96.45,154a139.18,139.18,0,0,1,0-52h63.1a139.18,139.18,0,0,1,0,52ZM38,128a89.7,89.7,0,0,1,3.83-26H84.19a155.43,155.43,0,0,0,0,52H41.83A89.7,89.7,0,0,1,38,128Zm90-87.83a110,110,0,0,1,15.19,19.45A124.24,124.24,0,0,1,156.65,90H99.35a124.24,124.24,0,0,1,13.46-30.38A110,110,0,0,1,128,40.17Zm-15.46-.84A132.58,132.58,0,0,0,86.81,90H46.43A90.29,90.29,0,0,1,112.54,39.33ZM46.43,166H86.81a132.58,132.58,0,0,0,25.73,50.67A90.29,90.29,0,0,1,46.43,166Zm97,50.67A132.58,132.58,0,0,0,169.19,166h40.38A90.29,90.29,0,0,1,143.46,216.67Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M128,24h0A104,104,0,1,0,232,128,104.12,104.12,0,0,0,128,24Zm88,104a87.61,87.61,0,0,1-3.33,24H174.16a157.44,157.44,0,0,0,0-48h38.51A87.61,87.61,0,0,1,216,128ZM102,168H154a115.11,115.11,0,0,1-26,45A115.27,115.27,0,0,1,102,168Zm-3.9-16a140.84,140.84,0,0,1,0-48h59.88a140.84,140.84,0,0,1,0,48ZM40,128a87.61,87.61,0,0,1,3.33-24H81.84a157.44,157.44,0,0,0,0,48H43.33A87.61,87.61,0,0,1,40,128ZM154,88H102a115.11,115.11,0,0,1,26-45A115.27,115.27,0,0,1,154,88Zm52.33,0H170.71a135.28,135.28,0,0,0-22.3-45.6A88.29,88.29,0,0,1,206.37,88ZM107.59,42.4A135.28,135.28,0,0,0,85.29,88H49.63A88.29,88.29,0,0,1,107.59,42.4ZM49.63,168H85.29a135.28,135.28,0,0,0,22.3,45.6A88.29,88.29,0,0,1,49.63,168Zm98.78,45.6a135.28,135.28,0,0,0,22.3-45.6h35.66A88.29,88.29,0,0,1,148.41,213.6Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M128,28h0A100,100,0,1,0,228,128,100.11,100.11,0,0,0,128,28Zm0,190.61c-6.33-6.09-23-24.41-31.27-54.61h62.54C151,194.2,134.33,212.52,128,218.61ZM94.82,156a140.42,140.42,0,0,1,0-56h66.36a140.42,140.42,0,0,1,0,56ZM128,37.39c6.33,6.09,23,24.41,31.27,54.61H96.73C105,61.8,121.67,43.48,128,37.39ZM169.41,100h46.23a92.09,92.09,0,0,1,0,56H169.41a152.65,152.65,0,0,0,0-56Zm43.25-8h-45a129.39,129.39,0,0,0-29.19-55.4A92.25,92.25,0,0,1,212.66,92ZM117.54,36.6A129.39,129.39,0,0,0,88.35,92h-45A92.25,92.25,0,0,1,117.54,36.6ZM40.36,100H86.59a152.65,152.65,0,0,0,0,56H40.36a92.09,92.09,0,0,1,0-56Zm3,64h45a129.39,129.39,0,0,0,29.19,55.4A92.25,92.25,0,0,1,43.34,164Zm95.12,55.4A129.39,129.39,0,0,0,167.65,164h45A92.25,92.25,0,0,1,138.46,219.4Z" }))]
]);
var e$43 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M204.73,51.85A108.07,108.07,0,0,0,20,128v56a28,28,0,0,0,28,28H64a28,28,0,0,0,28-28V144a28,28,0,0,0-28-28H44.84A84.05,84.05,0,0,1,128,44h.64a83.7,83.7,0,0,1,82.52,72H192a28,28,0,0,0-28,28v40a28,28,0,0,0,28,28h16a28,28,0,0,0,28-28V128A107.34,107.34,0,0,0,204.73,51.85ZM64,140a4,4,0,0,1,4,4v40a4,4,0,0,1-4,4H48a4,4,0,0,1-4-4V140Zm148,44a4,4,0,0,1-4,4H192a4,4,0,0,1-4-4V144a4,4,0,0,1,4-4h20Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M80,144v40a16,16,0,0,1-16,16H48a16,16,0,0,1-16-16V128H64A16,16,0,0,1,80,144Zm112-16a16,16,0,0,0-16,16v40a16,16,0,0,0,16,16h16a16,16,0,0,0,16-16V128Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M201.89,54.66A104.08,104.08,0,0,0,24,128v56a24,24,0,0,0,24,24H64a24,24,0,0,0,24-24V144a24,24,0,0,0-24-24H40.36A88,88,0,0,1,128,40h.67a87.71,87.71,0,0,1,87,80H192a24,24,0,0,0-24,24v40a24,24,0,0,0,24,24h16a24,24,0,0,0,24-24V128A103.41,103.41,0,0,0,201.89,54.66ZM64,136a8,8,0,0,1,8,8v40a8,8,0,0,1-8,8H48a8,8,0,0,1-8-8V136Zm152,48a8,8,0,0,1-8,8H192a8,8,0,0,1-8-8V144a8,8,0,0,1,8-8h24Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M232,128v56a24,24,0,0,1-24,24H192a24,24,0,0,1-24-24V144a24,24,0,0,1,24-24h23.65a87.71,87.71,0,0,0-87-80H128a88,88,0,0,0-87.64,80H64a24,24,0,0,1,24,24v40a24,24,0,0,1-24,24H48a24,24,0,0,1-24-24V128A104.11,104.11,0,0,1,201.89,54.66,103.41,103.41,0,0,1,232,128Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M200.47,56.07A101.37,101.37,0,0,0,128.77,26H128A102,102,0,0,0,26,128v56a22,22,0,0,0,22,22H64a22,22,0,0,0,22-22V144a22,22,0,0,0-22-22H38.2A90.12,90.12,0,0,1,192,64.52,89.41,89.41,0,0,1,217.81,122H192a22,22,0,0,0-22,22v40a22,22,0,0,0,22,22h16a22,22,0,0,0,22-22V128A101.44,101.44,0,0,0,200.47,56.07ZM64,134a10,10,0,0,1,10,10v40a10,10,0,0,1-10,10H48a10,10,0,0,1-10-10V134Zm154,50a10,10,0,0,1-10,10H192a10,10,0,0,1-10-10V144a10,10,0,0,1,10-10h26Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M201.89,54.66A103.43,103.43,0,0,0,128.79,24H128A104,104,0,0,0,24,128v56a24,24,0,0,0,24,24H64a24,24,0,0,0,24-24V144a24,24,0,0,0-24-24H40.36A88,88,0,0,1,128,40h.67a87.71,87.71,0,0,1,87,80H192a24,24,0,0,0-24,24v40a24,24,0,0,0,24,24h16a24,24,0,0,0,24-24V128A103.41,103.41,0,0,0,201.89,54.66ZM64,136a8,8,0,0,1,8,8v40a8,8,0,0,1-8,8H48a8,8,0,0,1-8-8V136Zm152,48a8,8,0,0,1-8,8H192a8,8,0,0,1-8-8V144a8,8,0,0,1,8-8h24Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M199.05,57.48A100.07,100.07,0,0,0,28,128v56a20,20,0,0,0,20,20H64a20,20,0,0,0,20-20V144a20,20,0,0,0-20-20H36.08A92,92,0,0,1,128,36h.7a91.75,91.75,0,0,1,91.22,88H192a20,20,0,0,0-20,20v40a20,20,0,0,0,20,20h16a20,20,0,0,0,20-20V128A99.43,99.43,0,0,0,199.05,57.48ZM64,132a12,12,0,0,1,12,12v40a12,12,0,0,1-12,12H48a12,12,0,0,1-12-12V132Zm156,52a12,12,0,0,1-12,12H192a12,12,0,0,1-12-12V144a12,12,0,0,1,12-12h28Z" }))]
]);
var a$21 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M178,36c-20.09,0-37.92,7.93-50,21.56C115.92,43.93,98.09,36,78,36a66.08,66.08,0,0,0-66,66c0,72.34,105.81,130.14,110.31,132.57a12,12,0,0,0,11.38,0C138.19,232.14,244,174.34,244,102A66.08,66.08,0,0,0,178,36Zm-5.49,142.36A328.69,328.69,0,0,1,128,210.16a328.69,328.69,0,0,1-44.51-31.8C61.82,159.77,36,131.42,36,102A42,42,0,0,1,78,60c17.8,0,32.7,9.4,38.89,24.54a12,12,0,0,0,22.22,0C145.3,69.4,160.2,60,178,60a42,42,0,0,1,42,42C220,131.42,194.18,159.77,172.51,178.36Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M232,102c0,66-104,122-104,122S24,168,24,102A54,54,0,0,1,78,48c22.59,0,41.94,12.31,50,32,8.06-19.69,27.41-32,50-32A54,54,0,0,1,232,102Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M178,40c-20.65,0-38.73,8.88-50,23.89C116.73,48.88,98.65,40,78,40a62.07,62.07,0,0,0-62,62c0,70,103.79,126.66,108.21,129a8,8,0,0,0,7.58,0C136.21,228.66,240,172,240,102A62.07,62.07,0,0,0,178,40ZM128,214.8C109.74,204.16,32,155.69,32,102A46.06,46.06,0,0,1,78,56c19.45,0,35.78,10.36,42.6,27a8,8,0,0,0,14.8,0c6.82-16.67,23.15-27,42.6-27a46.06,46.06,0,0,1,46,46C224,155.61,146.24,204.15,128,214.8Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M240,102c0,70-103.79,126.66-108.21,129a8,8,0,0,1-7.58,0C119.79,228.66,16,172,16,102A62.07,62.07,0,0,1,78,40c20.65,0,38.73,8.88,50,23.89C139.27,48.88,157.35,40,178,40A62.07,62.07,0,0,1,240,102Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M178,42c-21,0-39.26,9.47-50,25.34C117.26,51.47,99,42,78,42a60.07,60.07,0,0,0-60,60c0,29.2,18.2,59.59,54.1,90.31a334.68,334.68,0,0,0,53.06,37,6,6,0,0,0,5.68,0,334.68,334.68,0,0,0,53.06-37C219.8,161.59,238,131.2,238,102A60.07,60.07,0,0,0,178,42ZM128,217.11C111.59,207.64,30,157.72,30,102A48.05,48.05,0,0,1,78,54c20.28,0,37.31,10.83,44.45,28.27a6,6,0,0,0,11.1,0C140.69,64.83,157.72,54,178,54a48.05,48.05,0,0,1,48,48C226,157.72,144.41,207.64,128,217.11Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M178,40c-20.65,0-38.73,8.88-50,23.89C116.73,48.88,98.65,40,78,40a62.07,62.07,0,0,0-62,62c0,70,103.79,126.66,108.21,129a8,8,0,0,0,7.58,0C136.21,228.66,240,172,240,102A62.07,62.07,0,0,0,178,40ZM128,214.8C109.74,204.16,32,155.69,32,102A46.06,46.06,0,0,1,78,56c19.45,0,35.78,10.36,42.6,27a8,8,0,0,0,14.8,0c6.82-16.67,23.15-27,42.6-27a46.06,46.06,0,0,1,46,46C224,155.61,146.24,204.15,128,214.8Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M178,44c-21.44,0-39.92,10.19-50,27.07C117.92,54.19,99.44,44,78,44a58.07,58.07,0,0,0-58,58c0,28.59,18,58.47,53.4,88.79a333.81,333.81,0,0,0,52.7,36.73,4,4,0,0,0,3.8,0,333.81,333.81,0,0,0,52.7-36.73C218,160.47,236,130.59,236,102A58.07,58.07,0,0,0,178,44ZM128,219.42c-14-8-100-59.35-100-117.42A50.06,50.06,0,0,1,78,52c21.11,0,38.85,11.31,46.3,29.51a4,4,0,0,0,7.4,0C139.15,63.31,156.89,52,178,52a50.06,50.06,0,0,1,50,50C228,160,142,211.46,128,219.42Z" }))]
]);
var e$42 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M222.14,105.85l-80-80a20,20,0,0,0-28.28,0l-80,80A19.86,19.86,0,0,0,28,120v96a12,12,0,0,0,12,12h64a12,12,0,0,0,12-12V164h24v52a12,12,0,0,0,12,12h64a12,12,0,0,0,12-12V120A19.86,19.86,0,0,0,222.14,105.85ZM204,204H164V152a12,12,0,0,0-12-12H104a12,12,0,0,0-12,12v52H52V121.65l76-76,76,76Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M216,120v96H152V152H104v64H40V120a8,8,0,0,1,2.34-5.66l80-80a8,8,0,0,1,11.32,0l80,80A8,8,0,0,1,216,120Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M219.31,108.68l-80-80a16,16,0,0,0-22.62,0l-80,80A15.87,15.87,0,0,0,32,120v96a8,8,0,0,0,8,8h64a8,8,0,0,0,8-8V160h32v56a8,8,0,0,0,8,8h64a8,8,0,0,0,8-8V120A15.87,15.87,0,0,0,219.31,108.68ZM208,208H160V152a8,8,0,0,0-8-8H104a8,8,0,0,0-8,8v56H48V120l80-80,80,80Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M224,120v96a8,8,0,0,1-8,8H160a8,8,0,0,1-8-8V164a4,4,0,0,0-4-4H108a4,4,0,0,0-4,4v52a8,8,0,0,1-8,8H40a8,8,0,0,1-8-8V120a16,16,0,0,1,4.69-11.31l80-80a16,16,0,0,1,22.62,0l80,80A16,16,0,0,1,224,120Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M217.9,110.1l-80-80a14,14,0,0,0-19.8,0l-80,80A13.92,13.92,0,0,0,34,120v96a6,6,0,0,0,6,6h64a6,6,0,0,0,6-6V158h36v58a6,6,0,0,0,6,6h64a6,6,0,0,0,6-6V120A13.92,13.92,0,0,0,217.9,110.1ZM210,210H158V152a6,6,0,0,0-6-6H104a6,6,0,0,0-6,6v58H46V120a2,2,0,0,1,.58-1.42l80-80a2,2,0,0,1,2.84,0l80,80A2,2,0,0,1,210,120Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M219.31,108.68l-80-80a16,16,0,0,0-22.62,0l-80,80A15.87,15.87,0,0,0,32,120v96a8,8,0,0,0,8,8h64a8,8,0,0,0,8-8V160h32v56a8,8,0,0,0,8,8h64a8,8,0,0,0,8-8V120A15.87,15.87,0,0,0,219.31,108.68ZM208,208H160V152a8,8,0,0,0-8-8H104a8,8,0,0,0-8,8v56H48V120l80-80,80,80Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M216.49,111.51l-80-80a12,12,0,0,0-17,0l-80,80A12,12,0,0,0,36,120v96a4,4,0,0,0,4,4h64a4,4,0,0,0,4-4V156h40v60a4,4,0,0,0,4,4h64a4,4,0,0,0,4-4V120A12,12,0,0,0,216.49,111.51ZM212,212H156V152a4,4,0,0,0-4-4H104a4,4,0,0,0-4,4v60H44V120a4,4,0,0,1,1.17-2.83l80-80a4,4,0,0,1,5.66,0l80,80A4,4,0,0,1,212,120Z" }))]
]);
var e$41 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M252,128a60,60,0,0,1-102.43,42.43l-.49-.53L89.22,102.31a36,36,0,1,0,0,51.38l3.08-3.48a12,12,0,1,1,18,15.91l-3.35,3.78-.49.53a60,60,0,1,1,0-84.86l.49.53,59.86,67.59a36,36,0,1,0,0-51.38l-3.08,3.48a12,12,0,1,1-18-15.91l3.35-3.78.49-.53A60,60,0,0,1,252,128Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M225.94,161.94a48,48,0,0,1-67.88,0L128,128l30.06-33.94a48,48,0,0,1,67.88,67.88ZM30.06,94.06a48,48,0,0,0,67.88,67.88L128,128,97.94,94.06A48,48,0,0,0,30.06,94.06Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M248,128a56,56,0,0,1-95.6,39.6l-.33-.35L92.12,99.55a40,40,0,1,0,0,56.9l8.52-9.62a8,8,0,1,1,12,10.61l-8.69,9.81-.33.35a56,56,0,1,1,0-79.2l.33.35,59.95,67.7a40,40,0,1,0,0-56.9l-8.52,9.62a8,8,0,1,1-12-10.61l8.69-9.81.33-.35A56,56,0,0,1,248,128Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M216,40H40A16,16,0,0,0,24,56V200a16,16,0,0,0,16,16H216a16,16,0,0,0,16-16V56A16,16,0,0,0,216,40ZM204.28,156.28a40,40,0,0,1-56.4.17L97.29,111.34,97,111A24,24,0,1,0,97,145c.36-.36.71-.73,1-1.1a8,8,0,1,1,12,10.6c-.55.62-1.13,1.23-1.71,1.81a40,40,0,1,1-.17-56.73l50.58,45.11.33.31A24,24,0,1,0,159,111c-.36.36-.7.72-1,1.1a8,8,0,0,1-12-10.59c.54-.62,1.12-1.24,1.71-1.82a40,40,0,0,1,56.57,56.56Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M246,128a54,54,0,0,1-92.18,38.18,3.07,3.07,0,0,1-.25-.26l-60-67.74a42,42,0,1,0,0,59.64l8.57-9.67a6,6,0,1,1,9,8l-8.69,9.81a3.07,3.07,0,0,1-.25.26,54,54,0,1,1,0-76.36,3.07,3.07,0,0,1,.25.26l60,67.74a42,42,0,1,0,0-59.64l-8.57,9.67a6,6,0,1,1-9-8l8.69-9.81a3.07,3.07,0,0,1,.25-.26A54,54,0,0,1,246,128Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M248,128a56,56,0,0,1-95.6,39.6l-.33-.35L92.12,99.55a40,40,0,1,0,0,56.9l8.52-9.62a8,8,0,1,1,12,10.61l-8.69,9.81-.33.35a56,56,0,1,1,0-79.2l.33.35,59.95,67.7a40,40,0,1,0,0-56.9l-8.52,9.62a8,8,0,1,1-12-10.61l8.69-9.81.33-.35A56,56,0,0,1,248,128Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M244,128a52,52,0,0,1-88.77,36.77l-.17-.18L95,96.8a44,44,0,1,0,0,62.4l8.6-9.72a4,4,0,0,1,6,5.3l-8.68,9.81-.17.18a52,52,0,1,1,0-73.54l.17.18,60,67.79a44,44,0,1,0,0-62.4l-8.6,9.72a4,4,0,0,1-6-5.3l8.68-9.81.17-.18A52,52,0,0,1,244,128Z" }))]
]);
var a$20 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M108,84a16,16,0,1,1,16,16A16,16,0,0,1,108,84Zm128,44A108,108,0,1,1,128,20,108.12,108.12,0,0,1,236,128Zm-24,0a84,84,0,1,0-84,84A84.09,84.09,0,0,0,212,128Zm-72,36.68V132a20,20,0,0,0-20-20,12,12,0,0,0-4,23.32V168a20,20,0,0,0,20,20,12,12,0,0,0,4-23.32Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M224,128a96,96,0,1,1-96-96A96,96,0,0,1,224,128Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M144,176a8,8,0,0,1-8,8,16,16,0,0,1-16-16V128a8,8,0,0,1,0-16,16,16,0,0,1,16,16v40A8,8,0,0,1,144,176Zm88-48A104,104,0,1,1,128,24,104.11,104.11,0,0,1,232,128Zm-16,0a88,88,0,1,0-88,88A88.1,88.1,0,0,0,216,128ZM124,96a12,12,0,1,0-12-12A12,12,0,0,0,124,96Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M128,24A104,104,0,1,0,232,128,104.11,104.11,0,0,0,128,24Zm-4,48a12,12,0,1,1-12,12A12,12,0,0,1,124,72Zm12,112a16,16,0,0,1-16-16V128a8,8,0,0,1,0-16,16,16,0,0,1,16,16v40a8,8,0,0,1,0,16Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M142,176a6,6,0,0,1-6,6,14,14,0,0,1-14-14V128a2,2,0,0,0-2-2,6,6,0,0,1,0-12,14,14,0,0,1,14,14v40a2,2,0,0,0,2,2A6,6,0,0,1,142,176ZM124,94a10,10,0,1,0-10-10A10,10,0,0,0,124,94Zm106,34A102,102,0,1,1,128,26,102.12,102.12,0,0,1,230,128Zm-12,0a90,90,0,1,0-90,90A90.1,90.1,0,0,0,218,128Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M128,24A104,104,0,1,0,232,128,104.11,104.11,0,0,0,128,24Zm0,192a88,88,0,1,1,88-88A88.1,88.1,0,0,1,128,216Zm16-40a8,8,0,0,1-8,8,16,16,0,0,1-16-16V128a8,8,0,0,1,0-16,16,16,0,0,1,16,16v40A8,8,0,0,1,144,176ZM112,84a12,12,0,1,1,12,12A12,12,0,0,1,112,84Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M140,176a4,4,0,0,1-4,4,12,12,0,0,1-12-12V128a4,4,0,0,0-4-4,4,4,0,0,1,0-8,12,12,0,0,1,12,12v40a4,4,0,0,0,4,4A4,4,0,0,1,140,176ZM124,92a8,8,0,1,0-8-8A8,8,0,0,0,124,92Zm104,36A100,100,0,1,1,128,28,100.11,100.11,0,0,1,228,128Zm-8,0a92,92,0,1,0-92,92A92.1,92.1,0,0,0,220,128Z" }))]
]);
var e$40 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M180,232a12,12,0,0,1-12,12H88a12,12,0,0,1,0-24h80A12,12,0,0,1,180,232Zm40-128a92.47,92.47,0,0,1-37,73.73,7.81,7.81,0,0,0-3,6.27,20,20,0,0,1-20,20H96a20,20,0,0,1-20-20v-.23a7.76,7.76,0,0,0-3.25-6.2,91.36,91.36,0,0,1-36.75-73C35.73,54.69,76,13.2,125.79,12A92,92,0,0,1,220,104Zm-24,0a68,68,0,0,0-69.65-68C89.56,36.89,59.8,67.56,60,104.39a67.52,67.52,0,0,0,27.18,54h0A32.14,32.14,0,0,1,99.77,180H116V149L87.51,120.49a12,12,0,0,1,17-17L128,127l23.51-23.51a12,12,0,0,1,17,17L140,149v31h16.25a31.89,31.89,0,0,1,12.41-21.49A67.45,67.45,0,0,0,196,104Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M208,104a79.86,79.86,0,0,1-30.59,62.92A24.29,24.29,0,0,0,168,186v6a8,8,0,0,1-8,8H96a8,8,0,0,1-8-8v-6a24.11,24.11,0,0,0-9.3-19A79.87,79.87,0,0,1,48,104.45C47.76,61.09,82.72,25,126.07,24A80,80,0,0,1,208,104Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M176,232a8,8,0,0,1-8,8H88a8,8,0,0,1,0-16h80A8,8,0,0,1,176,232Zm40-128a87.55,87.55,0,0,1-33.64,69.21A16.24,16.24,0,0,0,176,186v6a16,16,0,0,1-16,16H96a16,16,0,0,1-16-16v-6a16,16,0,0,0-6.23-12.66A87.59,87.59,0,0,1,40,104.5C39.74,56.83,78.26,17.15,125.88,16A88,88,0,0,1,216,104Zm-16,0a72,72,0,0,0-73.74-72c-39,.92-70.47,33.39-70.26,72.39a71.64,71.64,0,0,0,27.64,56.3h0A32,32,0,0,1,96,186v6h24V147.31L90.34,117.66a8,8,0,0,1,11.32-11.32L128,132.69l26.34-26.35a8,8,0,0,1,11.32,11.32L136,147.31V192h24v-6a32.12,32.12,0,0,1,12.47-25.35A71.65,71.65,0,0,0,200,104Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M176,232a8,8,0,0,1-8,8H88a8,8,0,0,1,0-16h80A8,8,0,0,1,176,232Zm40-128a87.55,87.55,0,0,1-33.64,69.21A16.24,16.24,0,0,0,176,186v6a16,16,0,0,1-16,16H96a16,16,0,0,1-16-16v-6a16,16,0,0,0-6.23-12.66A87.59,87.59,0,0,1,40,104.49C39.74,56.83,78.26,17.14,125.88,16A88,88,0,0,1,216,104Zm-50.34,2.34a8,8,0,0,0-11.32,0L128,132.69l-26.34-26.35a8,8,0,0,0-11.32,11.32L120,147.31V184a8,8,0,0,0,16,0V147.31l29.66-29.65A8,8,0,0,0,165.66,106.34Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M174,232a6,6,0,0,1-6,6H88a6,6,0,0,1,0-12h80A6,6,0,0,1,174,232Zm40-128a85.56,85.56,0,0,1-32.88,67.64A18.23,18.23,0,0,0,174,186v6a14,14,0,0,1-14,14H96a14,14,0,0,1-14-14v-6a18,18,0,0,0-7-14.23h0a85.59,85.59,0,0,1-33-67.25C41.74,57.91,79.39,19.12,125.93,18A86,86,0,0,1,214,104Zm-12,0a74,74,0,0,0-75.79-74C86.17,31,53.78,64.34,54,104.42a73.67,73.67,0,0,0,28.4,57.87A29.92,29.92,0,0,1,94,186v6a2,2,0,0,0,2,2h26V146.49L91.76,116.24a6,6,0,0,1,8.48-8.48L128,135.52l27.76-27.76a6,6,0,0,1,8.48,8.48L134,146.49V194h26a2,2,0,0,0,2-2v-6a30.18,30.18,0,0,1,11.7-23.78A73.59,73.59,0,0,0,202,104Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M176,232a8,8,0,0,1-8,8H88a8,8,0,0,1,0-16h80A8,8,0,0,1,176,232Zm40-128a87.55,87.55,0,0,1-33.64,69.21A16.24,16.24,0,0,0,176,186v6a16,16,0,0,1-16,16H96a16,16,0,0,1-16-16v-6a16,16,0,0,0-6.23-12.66A87.59,87.59,0,0,1,40,104.5C39.74,56.83,78.26,17.15,125.88,16A88,88,0,0,1,216,104Zm-16,0a72,72,0,0,0-73.74-72c-39,.92-70.47,33.39-70.26,72.39a71.64,71.64,0,0,0,27.64,56.3h0A32,32,0,0,1,96,186v6h24V147.31L90.34,117.66a8,8,0,0,1,11.32-11.32L128,132.69l26.34-26.35a8,8,0,0,1,11.32,11.32L136,147.31V192h24v-6a32.12,32.12,0,0,1,12.47-25.35A71.65,71.65,0,0,0,200,104Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M172,232a4,4,0,0,1-4,4H88a4,4,0,0,1,0-8h80A4,4,0,0,1,172,232Zm40-128a83.59,83.59,0,0,1-32.11,66.06A20.2,20.2,0,0,0,172,186v6a12,12,0,0,1-12,12H96a12,12,0,0,1-12-12v-6a20,20,0,0,0-7.76-15.81A83.58,83.58,0,0,1,44,104.47C43.75,59,80.52,21.09,126,20a84,84,0,0,1,86,84Zm-8,0a76,76,0,0,0-77.84-76C85,29,51.77,63.27,52,104.43a75.62,75.62,0,0,0,29.17,59.43A28,28,0,0,1,92,186v6a4,4,0,0,0,4,4h28V145.66L93.17,114.83a4,4,0,0,1,5.66-5.66L128,138.34l29.17-29.17a4,4,0,1,1,5.66,5.66L132,145.66V196h28a4,4,0,0,0,4-4v-6a28.14,28.14,0,0,1,10.94-22.2A75.62,75.62,0,0,0,204,104Z" }))]
]);
var a$19 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M219.71,117.38a12,12,0,0,0-7.25-8.52L161.28,88.39l10.59-70.61a12,12,0,0,0-20.64-10l-112,120a12,12,0,0,0,4.31,19.33l51.18,20.47L84.13,238.22a12,12,0,0,0,20.64,10l112-120A12,12,0,0,0,219.71,117.38ZM113.6,203.55l6.27-41.77a12,12,0,0,0-7.41-12.92L68.74,131.37,142.4,52.45l-6.27,41.77a12,12,0,0,0,7.41,12.92l43.72,17.49Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M96,240l16-80L48,136,160,16,144,96l64,24Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M215.79,118.17a8,8,0,0,0-5-5.66L153.18,90.9l14.66-73.33a8,8,0,0,0-13.69-7l-112,120a8,8,0,0,0,3,13l57.63,21.61L88.16,238.43a8,8,0,0,0,13.69,7l112-120A8,8,0,0,0,215.79,118.17ZM109.37,214l10.47-52.38a8,8,0,0,0-5-9.06L62,132.71l84.62-90.66L136.16,94.43a8,8,0,0,0,5,9.06l52.8,19.8Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M213.85,125.46l-112,120a8,8,0,0,1-13.69-7l14.66-73.33L45.19,143.49a8,8,0,0,1-3-13l112-120a8,8,0,0,1,13.69,7L153.18,90.9l57.63,21.61a8,8,0,0,1,3,12.95Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M213.84,118.63a6,6,0,0,0-3.73-4.25L150.88,92.17l15-75a6,6,0,0,0-10.27-5.27l-112,120a6,6,0,0,0,2.28,9.71l59.23,22.21-15,75a6,6,0,0,0,3.14,6.52A6.07,6.07,0,0,0,96,246a6,6,0,0,0,4.39-1.91l112-120A6,6,0,0,0,213.84,118.63ZM106,220.46l11.85-59.28a6,6,0,0,0-3.77-6.8l-55.6-20.85,91.46-98L138.12,94.82a6,6,0,0,0,3.77,6.8l55.6,20.85Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M215.79,118.17a8,8,0,0,0-5-5.66L153.18,90.9l14.66-73.33a8,8,0,0,0-13.69-7l-112,120a8,8,0,0,0,3,13l57.63,21.61L88.16,238.43a8,8,0,0,0,13.69,7l112-120A8,8,0,0,0,215.79,118.17ZM109.37,214l10.47-52.38a8,8,0,0,0-5-9.06L62,132.71l84.62-90.66L136.16,94.43a8,8,0,0,0,5,9.06l52.8,19.8Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M211.89,119.09a4,4,0,0,0-2.49-2.84l-60.81-22.8,15.33-76.67a4,4,0,0,0-6.84-3.51l-112,120a4,4,0,0,0-1,3.64,4,4,0,0,0,2.49,2.84l60.81,22.8L92.08,239.22a4,4,0,0,0,6.84,3.51l112-120A4,4,0,0,0,211.89,119.09ZM102.68,227l13.24-66.2a4,4,0,0,0-2.52-4.53L55,134.36,153.32,29l-13.24,66.2a4,4,0,0,0,2.52,4.53L201,121.64Z" }))]
]);
var e$39 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M218.34,119.6,183.6,154.34a46.58,46.58,0,0,1-44.31,12.26c-.31.34-.62.67-.95,1L103.6,202.34A46.63,46.63,0,1,1,37.66,136.4L72.4,101.66A46.6,46.6,0,0,1,116.71,89.4c.31-.34.62-.67,1-1L152.4,53.66a46.63,46.63,0,0,1,65.94,65.94Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M240,88.23a54.43,54.43,0,0,1-16,37L189.25,160a54.27,54.27,0,0,1-38.63,16h-.05A54.63,54.63,0,0,1,96,119.84a8,8,0,0,1,16,.45A38.62,38.62,0,0,0,150.58,160h0a38.39,38.39,0,0,0,27.31-11.31l34.75-34.75a38.63,38.63,0,0,0-54.63-54.63l-11,11A8,8,0,0,1,135.7,59l11-11A54.65,54.65,0,0,1,224,48,54.86,54.86,0,0,1,240,88.23ZM109,185.66l-11,11A38.41,38.41,0,0,1,70.6,208h0a38.63,38.63,0,0,1-27.29-65.94L78,107.31A38.63,38.63,0,0,1,144,135.71a8,8,0,0,0,7.78,8.22H152a8,8,0,0,0,8-7.78A54.86,54.86,0,0,0,144,96a54.65,54.65,0,0,0-77.27,0L32,130.75A54.62,54.62,0,0,0,70.56,224h0a54.28,54.28,0,0,0,38.64-16l11-11A8,8,0,0,0,109,185.66Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M208,32H48A16,16,0,0,0,32,48V208a16,16,0,0,0,16,16H208a16,16,0,0,0,16-16V48A16,16,0,0,0,208,32ZM115.7,192.49a43.31,43.31,0,0,1-55-66.43l25.37-25.37a43.35,43.35,0,0,1,61.25,0,42.9,42.9,0,0,1,9.95,15.43,8,8,0,1,1-15,5.6A27.33,27.33,0,0,0,97.37,112L72,137.37a27.32,27.32,0,0,0,34.68,41.91,8,8,0,1,1,9,13.21Zm79.61-62.55-25.37,25.37A43,43,0,0,1,139.32,168h0a43.35,43.35,0,0,1-40.53-28.12,8,8,0,1,1,15-5.6A27.35,27.35,0,0,0,139.28,152h0a27.14,27.14,0,0,0,19.32-8L184,118.63a27.32,27.32,0,0,0-34.68-41.91,8,8,0,1,1-9-13.21,43.32,43.32,0,0,1,55,66.43Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M238,88.18a52.42,52.42,0,0,1-15.4,35.66l-34.75,34.75A52.28,52.28,0,0,1,150.62,174h-.05A52.63,52.63,0,0,1,98,119.9a6,6,0,0,1,6-5.84h.17a6,6,0,0,1,5.83,6.16A40.62,40.62,0,0,0,150.58,162h0a40.4,40.4,0,0,0,28.73-11.9l34.75-34.74A40.63,40.63,0,0,0,156.63,57.9l-11,11a6,6,0,0,1-8.49-8.49l11-11a52.62,52.62,0,0,1,74.43,0A52.83,52.83,0,0,1,238,88.18Zm-127.62,98.9-11,11A40.36,40.36,0,0,1,70.6,210h0a40.63,40.63,0,0,1-28.7-69.36L76.62,105.9A40.63,40.63,0,0,1,146,135.77a6,6,0,0,0,5.83,6.16H152a6,6,0,0,0,6-5.84A52.63,52.63,0,0,0,68.14,97.42L33.38,132.16A52.63,52.63,0,0,0,70.56,222h0a52.26,52.26,0,0,0,37.22-15.42l11-11a6,6,0,1,0-8.49-8.48Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M240,88.23a54.43,54.43,0,0,1-16,37L189.25,160a54.27,54.27,0,0,1-38.63,16h-.05A54.63,54.63,0,0,1,96,119.84a8,8,0,0,1,16,.45A38.62,38.62,0,0,0,150.58,160h0a38.39,38.39,0,0,0,27.31-11.31l34.75-34.75a38.63,38.63,0,0,0-54.63-54.63l-11,11A8,8,0,0,1,135.7,59l11-11A54.65,54.65,0,0,1,224,48,54.86,54.86,0,0,1,240,88.23ZM109,185.66l-11,11A38.41,38.41,0,0,1,70.6,208h0a38.63,38.63,0,0,1-27.29-65.94L78,107.31A38.63,38.63,0,0,1,144,135.71a8,8,0,0,0,16,.45A54.86,54.86,0,0,0,144,96a54.65,54.65,0,0,0-77.27,0L32,130.75A54.62,54.62,0,0,0,70.56,224h0a54.28,54.28,0,0,0,38.64-16l11-11A8,8,0,0,0,109,185.66Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M236,88.12a50.44,50.44,0,0,1-14.81,34.31l-34.75,34.74A50.33,50.33,0,0,1,150.62,172h-.05A50.63,50.63,0,0,1,100,120a4,4,0,0,1,4-3.89h.11a4,4,0,0,1,3.89,4.11A42.64,42.64,0,0,0,150.58,164h0a42.32,42.32,0,0,0,30.14-12.49l34.75-34.74a42.63,42.63,0,1,0-60.29-60.28l-11,11a4,4,0,0,1-5.66-5.65l11-11A50.64,50.64,0,0,1,236,88.12ZM111.78,188.49l-11,11A42.33,42.33,0,0,1,70.6,212h0a42.63,42.63,0,0,1-30.11-72.77l34.75-34.74A42.63,42.63,0,0,1,148,135.82a4,4,0,0,0,8,.23A50.64,50.64,0,0,0,69.55,98.83L34.8,133.57A50.63,50.63,0,0,0,70.56,220h0a50.33,50.33,0,0,0,35.81-14.83l11-11a4,4,0,1,0-5.65-5.66Z" }))]
]);
var e$38 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M252,152a12,12,0,0,1-12,12H228v12a12,12,0,0,1-24,0V164H192a12,12,0,0,1,0-24h12V128a12,12,0,0,1,24,0v12h12A12,12,0,0,1,252,152ZM56,76H68V88a12,12,0,0,0,24,0V76h12a12,12,0,1,0,0-24H92V40a12,12,0,0,0-24,0V52H56a12,12,0,0,0,0,24ZM184,188h-4v-4a12,12,0,0,0-24,0v4h-4a12,12,0,0,0,0,24h4v4a12,12,0,0,0,24,0v-4h4a12,12,0,0,0,0-24ZM222.14,82.83,82.82,222.14a20,20,0,0,1-28.28,0L33.85,201.46a20,20,0,0,1,0-28.29L173.17,33.86a20,20,0,0,1,28.28,0l20.69,20.68A20,20,0,0,1,222.14,82.83ZM159,112,144,97,53.65,187.31l15,15Zm43.31-43.31-15-15L161,80l15,15Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M176,112,74.34,213.66a8,8,0,0,1-11.31,0L42.34,193a8,8,0,0,1,0-11.31L144,80Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M248,152a8,8,0,0,1-8,8H224v16a8,8,0,0,1-16,0V160H192a8,8,0,0,1,0-16h16V128a8,8,0,0,1,16,0v16h16A8,8,0,0,1,248,152ZM56,72H72V88a8,8,0,0,0,16,0V72h16a8,8,0,0,0,0-16H88V40a8,8,0,0,0-16,0V56H56a8,8,0,0,0,0,16ZM184,192h-8v-8a8,8,0,0,0-16,0v8h-8a8,8,0,0,0,0,16h8v8a8,8,0,0,0,16,0v-8h8a8,8,0,0,0,0-16ZM219.31,80,80,219.31a16,16,0,0,1-22.62,0L36.68,198.63a16,16,0,0,1,0-22.63L176,36.69a16,16,0,0,1,22.63,0l20.68,20.68A16,16,0,0,1,219.31,80Zm-54.63,32L144,91.31l-96,96L68.68,208ZM208,68.69,187.31,48l-32,32L176,100.69Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M248,152a8,8,0,0,1-8,8H224v16a8,8,0,0,1-16,0V160H192a8,8,0,0,1,0-16h16V128a8,8,0,0,1,16,0v16h16A8,8,0,0,1,248,152ZM56,72H72V88a8,8,0,0,0,16,0V72h16a8,8,0,0,0,0-16H88V40a8,8,0,0,0-16,0V56H56a8,8,0,0,0,0,16ZM184,192h-8v-8a8,8,0,0,0-16,0v8h-8a8,8,0,0,0,0,16h8v8a8,8,0,0,0,16,0v-8h8a8,8,0,0,0,0-16ZM219.31,80,80,219.31a16,16,0,0,1-22.62,0L36.68,198.63a16,16,0,0,1,0-22.63L176,36.69a16,16,0,0,1,22.63,0l20.68,20.68A16,16,0,0,1,219.31,80ZM208,68.69,187.31,48l-32,32L176,100.69Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M246,152a6,6,0,0,1-6,6H222v18a6,6,0,0,1-12,0V158H192a6,6,0,0,1,0-12h18V128a6,6,0,0,1,12,0v18h18A6,6,0,0,1,246,152ZM56,70H74V88a6,6,0,0,0,12,0V70h18a6,6,0,0,0,0-12H86V40a6,6,0,0,0-12,0V58H56a6,6,0,0,0,0,12ZM184,194H174V184a6,6,0,0,0-12,0v10H152a6,6,0,0,0,0,12h10v10a6,6,0,0,0,12,0V206h10a6,6,0,0,0,0-12ZM217.9,78.59,78.58,217.9a14,14,0,0,1-19.8,0L38.09,197.21a14,14,0,0,1,0-19.8L177.41,38.1a14,14,0,0,1,19.8,0L217.9,58.79A14,14,0,0,1,217.9,78.59ZM167.51,112,144,88.49,46.58,185.9a2,2,0,0,0,0,2.83l20.69,20.68a2,2,0,0,0,2.82,0h0Zm41.9-44.73L188.73,46.59a2,2,0,0,0-2.83,0L152.48,80,176,103.52,209.41,70.1A2,2,0,0,0,209.41,67.27Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M48,64a8,8,0,0,1,8-8H72V40a8,8,0,0,1,16,0V56h16a8,8,0,0,1,0,16H88V88a8,8,0,0,1-16,0V72H56A8,8,0,0,1,48,64ZM184,192h-8v-8a8,8,0,0,0-16,0v8h-8a8,8,0,0,0,0,16h8v8a8,8,0,0,0,16,0v-8h8a8,8,0,0,0,0-16Zm56-48H224V128a8,8,0,0,0-16,0v16H192a8,8,0,0,0,0,16h16v16a8,8,0,0,0,16,0V160h16a8,8,0,0,0,0-16ZM219.31,80,80,219.31a16,16,0,0,1-22.62,0L36.68,198.63a16,16,0,0,1,0-22.63L176,36.69a16,16,0,0,1,22.63,0l20.68,20.68A16,16,0,0,1,219.31,80Zm-54.63,32L144,91.31l-96,96L68.68,208ZM208,68.69,187.31,48l-32,32L176,100.69Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M244,152a4,4,0,0,1-4,4H220v20a4,4,0,0,1-8,0V156H192a4,4,0,0,1,0-8h20V128a4,4,0,0,1,8,0v20h20A4,4,0,0,1,244,152ZM56,68H76V88a4,4,0,0,0,8,0V68h20a4,4,0,0,0,0-8H84V40a4,4,0,0,0-8,0V60H56a4,4,0,0,0,0,8ZM184,196H172V184a4,4,0,0,0-8,0v12H152a4,4,0,0,0,0,8h12v12a4,4,0,0,0,8,0V204h12a4,4,0,0,0,0-8ZM216.48,77.17,77.17,216.49a12,12,0,0,1-17,0L39.51,195.8a12,12,0,0,1,0-17L178.83,39.51a12,12,0,0,1,17,0L216.48,60.2A12,12,0,0,1,216.48,77.17ZM170.34,112,144,85.66,45.17,184.49a4,4,0,0,0,0,5.65l20.68,20.69a4,4,0,0,0,5.66,0Zm40.49-46.14L190.14,45.17a4,4,0,0,0-5.66,0L149.65,80,176,106.34l34.83-34.83A4,4,0,0,0,210.83,65.86Z" }))]
]);
var a$18 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M232.49,215.51,185,168a92.12,92.12,0,1,0-17,17l47.53,47.54a12,12,0,0,0,17-17ZM44,112a68,68,0,1,1,68,68A68.07,68.07,0,0,1,44,112Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M192,112a80,80,0,1,1-80-80A80,80,0,0,1,192,112Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M229.66,218.34,179.6,168.28a88.21,88.21,0,1,0-11.32,11.31l50.06,50.07a8,8,0,0,0,11.32-11.32ZM40,112a72,72,0,1,1,72,72A72.08,72.08,0,0,1,40,112Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M168,112a56,56,0,1,1-56-56A56,56,0,0,1,168,112Zm61.66,117.66a8,8,0,0,1-11.32,0l-50.06-50.07a88,88,0,1,1,11.32-11.31l50.06,50.06A8,8,0,0,1,229.66,229.66ZM112,184a72,72,0,1,0-72-72A72.08,72.08,0,0,0,112,184Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M228.24,219.76l-51.38-51.38a86.15,86.15,0,1,0-8.48,8.48l51.38,51.38a6,6,0,0,0,8.48-8.48ZM38,112a74,74,0,1,1,74,74A74.09,74.09,0,0,1,38,112Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M229.66,218.34l-50.07-50.06a88.11,88.11,0,1,0-11.31,11.31l50.06,50.07a8,8,0,0,0,11.32-11.32ZM40,112a72,72,0,1,1,72,72A72.08,72.08,0,0,1,40,112Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M226.83,221.17l-52.7-52.7a84.1,84.1,0,1,0-5.66,5.66l52.7,52.7a4,4,0,0,0,5.66-5.66ZM36,112a76,76,0,1,1,76,76A76.08,76.08,0,0,1,36,112Z" }))]
]);
var e$37 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M116,72a12,12,0,0,1-12,12H40a12,12,0,0,1,0-24h64A12,12,0,0,1,116,72ZM104,172H84V152a12,12,0,0,0-24,0v20H40a12,12,0,0,0,0,24H60v20a12,12,0,0,0,24,0V196h20a12,12,0,0,0,0-24Zm48,4h64a12,12,0,0,0,0-24H152a12,12,0,0,0,0,24Zm64,16H152a12,12,0,0,0,0,24h64a12,12,0,0,0,0-24Zm-64.49-87.51a12,12,0,0,0,17,0L184,89l15.51,15.52a12,12,0,0,0,17-17L201,72l15.52-15.51a12,12,0,0,0-17-17L184,55,168.49,39.51a12,12,0,0,0-17,17L167,72,151.51,87.51A12,12,0,0,0,151.51,104.49Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M216,56V200a16,16,0,0,1-16,16H56a16,16,0,0,1-16-16V56A16,16,0,0,1,56,40H200A16,16,0,0,1,216,56Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M112,72a8,8,0,0,1-8,8H40a8,8,0,0,1,0-16h64A8,8,0,0,1,112,72Zm-8,104H80V152a8,8,0,0,0-16,0v24H40a8,8,0,0,0,0,16H64v24a8,8,0,0,0,16,0V192h24a8,8,0,0,0,0-16Zm48,0h64a8,8,0,0,0,0-16H152a8,8,0,0,0,0,16Zm64,16H152a8,8,0,0,0,0,16h64a8,8,0,0,0,0-16Zm-61.66-90.34a8,8,0,0,0,11.32,0L184,83.31l18.34,18.35a8,8,0,0,0,11.32-11.32L195.31,72l18.35-18.34a8,8,0,0,0-11.32-11.32L184,60.69,165.66,42.34a8,8,0,0,0-11.32,11.32L172.69,72,154.34,90.34A8,8,0,0,0,154.34,101.66Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M208,32H48A16,16,0,0,0,32,48V208a16,16,0,0,0,16,16H208a16,16,0,0,0,16-16V48A16,16,0,0,0,208,32ZM146.34,77.66a8,8,0,0,1,11.32-11.32L168,76.69l10.34-10.35a8,8,0,0,1,11.32,11.32L179.31,88l10.35,10.34a8,8,0,0,1-11.32,11.32L168,99.31l-10.34,10.35a8,8,0,0,1-11.32-11.32L156.69,88ZM112,176H96v16a8,8,0,0,1-16,0V176H64a8,8,0,0,1,0-16H80V144a8,8,0,0,1,16,0v16h16a8,8,0,0,1,0,16Zm0-80H64a8,8,0,0,1,0-16h48a8,8,0,0,1,0,16Zm80,96H144a8,8,0,0,1,0-16h48a8,8,0,0,1,0,16Zm0-32H144a8,8,0,0,1,0-16h48a8,8,0,0,1,0,16Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M110,72a6,6,0,0,1-6,6H40a6,6,0,0,1,0-12h64A6,6,0,0,1,110,72Zm-6,106H78V152a6,6,0,0,0-12,0v26H40a6,6,0,0,0,0,12H66v26a6,6,0,0,0,12,0V190h26a6,6,0,0,0,0-12Zm48-4h64a6,6,0,0,0,0-12H152a6,6,0,0,0,0,12Zm64,20H152a6,6,0,0,0,0,12h64a6,6,0,0,0,0-12Zm-60.24-93.76a6,6,0,0,0,8.48,0L184,80.49l19.76,19.75a6,6,0,0,0,8.48-8.48L192.49,72l19.75-19.76a6,6,0,0,0-8.48-8.48L184,63.51,164.24,43.76a6,6,0,0,0-8.48,8.48L175.51,72,155.76,91.76A6,6,0,0,0,155.76,100.24Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M112,72a8,8,0,0,1-8,8H40a8,8,0,0,1,0-16h64A8,8,0,0,1,112,72Zm-8,104H80V152a8,8,0,0,0-16,0v24H40a8,8,0,0,0,0,16H64v24a8,8,0,0,0,16,0V192h24a8,8,0,0,0,0-16Zm48,0h64a8,8,0,0,0,0-16H152a8,8,0,0,0,0,16Zm64,16H152a8,8,0,0,0,0,16h64a8,8,0,0,0,0-16Zm-61.66-90.34a8,8,0,0,0,11.32,0L184,83.31l18.34,18.35a8,8,0,0,0,11.32-11.32L195.31,72l18.35-18.34a8,8,0,0,0-11.32-11.32L184,60.69,165.66,42.34a8,8,0,0,0-11.32,11.32L172.69,72,154.34,90.34A8,8,0,0,0,154.34,101.66Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M108,72a4,4,0,0,1-4,4H40a4,4,0,0,1,0-8h64A4,4,0,0,1,108,72Zm-4,108H76V152a4,4,0,0,0-8,0v28H40a4,4,0,0,0,0,8H68v28a4,4,0,0,0,8,0V188h28a4,4,0,0,0,0-8Zm48-8h64a4,4,0,0,0,0-8H152a4,4,0,0,0,0,8Zm64,24H152a4,4,0,0,0,0,8h64a4,4,0,0,0,0-8ZM157.17,98.83a4,4,0,0,0,5.66,0L184,77.66l21.17,21.17a4,4,0,1,0,5.66-5.66L189.66,72l21.17-21.17a4,4,0,1,0-5.66-5.66L184,66.34,162.83,45.17a4,4,0,0,0-5.66,5.66L178.34,72,157.17,93.17A4,4,0,0,0,157.17,98.83Z" }))]
]);
var e$36 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M252,120a52.06,52.06,0,0,0-52-52H160.32c-3.44-.21-52.6-4-99.46-43.3A20,20,0,0,0,28,40V200a19.8,19.8,0,0,0,11.54,18.12,19.86,19.86,0,0,0,21.32-2.81A192.92,192.92,0,0,1,144,174.47v26.2a20,20,0,0,0,8.9,16.64,11.35,11.35,0,0,0,1.39.8l14.44,7.06A20,20,0,0,0,198.37,213l11.09-41.82A52.07,52.07,0,0,0,252,120ZM52,191.63V48.4c36.17,28.07,72.17,38.1,92,41.66V150C124.17,153.52,88.17,163.55,52,191.63ZM176.39,202.2,168,198.1V172h16.4ZM200,148H168V92h32a28,28,0,1,1,0,56Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M240,120a40,40,0,0,1-40,40H160V80h40A40,40,0,0,1,240,120Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M248,120a48.05,48.05,0,0,0-48-48H160.2c-2.91-.17-53.62-3.74-101.91-44.24A16,16,0,0,0,32,40V200a16,16,0,0,0,26.29,12.25c37.77-31.68,77-40.76,93.71-43.3v31.72A16,16,0,0,0,159.12,214l11,7.33A16,16,0,0,0,194.5,212l11.77-44.36A48.07,48.07,0,0,0,248,120ZM48,199.93V40h0c42.81,35.91,86.63,45,104,47.24v65.48C134.65,155,90.84,164.07,48,199.93Zm131,8,0,.11-11-7.33V168h21.6ZM200,152H168V88h32a32,32,0,1,1,0,64Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M200,72H160.2c-2.91-.17-53.62-3.74-101.91-44.24A16,16,0,0,0,32,40V200a16,16,0,0,0,26.29,12.25c37.77-31.68,77-40.76,93.71-43.3v31.72A16,16,0,0,0,159.12,214l11,7.33A16,16,0,0,0,194.5,212l11.77-44.36A48,48,0,0,0,200,72ZM179,207.89l0,.11-11-7.33V168h21.6ZM200,152H168V88h32a32,32,0,1,1,0,64Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M246,120a46.05,46.05,0,0,0-46-46H160.15c-2.58-.15-54.1-3.57-103.15-44.71A14,14,0,0,0,34,40V200a13.85,13.85,0,0,0,8.07,12.68A14.16,14.16,0,0,0,48,214a13.9,13.9,0,0,0,9-3.3c40-33.52,81.57-42,97-44.07v34a14,14,0,0,0,6.23,11.65l11,7.33a14,14,0,0,0,21.32-8.17l12.13-45.71A46.07,46.07,0,0,0,246,120ZM49.29,201.52A2,2,0,0,1,46,200V40a1.9,1.9,0,0,1,1.15-1.8A2.08,2.08,0,0,1,48,38a1.91,1.91,0,0,1,1.26.48c44,36.92,89,45.19,104.71,47v69C138.29,156.33,93.3,164.61,49.29,201.52Zm131.64,7a2,2,0,0,1-3.05,1.18l-11-7.33a2,2,0,0,1-.89-1.67V166h26.2ZM200,154H166V86h34a34,34,0,1,1,0,68Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M248,120a48.05,48.05,0,0,0-48-48H160.2c-2.91-.17-53.62-3.74-101.91-44.24A16,16,0,0,0,32,40V200a16,16,0,0,0,26.29,12.25c37.77-31.68,77-40.76,93.71-43.3v31.72A16,16,0,0,0,159.12,214l11,7.33A16,16,0,0,0,194.5,212l11.77-44.36A48.07,48.07,0,0,0,248,120ZM48,199.93V40h0c42.81,35.91,86.63,45,104,47.24v65.48C134.65,155,90.84,164.07,48,199.93Zm131,8,0,.11-11-7.33V168h21.6ZM200,152H168V88h32a32,32,0,1,1,0,64Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M200,76H160.1c-2.19-.11-54.55-3.38-104.38-45.17A12,12,0,0,0,36,40V200a11.88,11.88,0,0,0,6.92,10.87A12.18,12.18,0,0,0,48,212a11.93,11.93,0,0,0,7.69-2.83c42.46-35.62,86.76-43.25,100.28-44.8v36.29a12,12,0,0,0,5.34,10l11,7.33a12,12,0,0,0,18.28-7l12.49-47.09A44,44,0,0,0,200,76Zm-44,80.3c-13.53,1.35-60,8.62-105.42,46.75A4,4,0,0,1,44,200V40a4,4,0,0,1,2.3-3.62A4.32,4.32,0,0,1,48.05,36a3.88,3.88,0,0,1,2.53,1C96,75.09,142.47,82.36,156,83.71ZM182.87,209a4,4,0,0,1-6.1,2.36l-11-7.33a4,4,0,0,1-1.78-3.33V164h30.8ZM200,156H164V84h36a36,36,0,0,1,0,72Z" }))]
]);
var a$17 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M229.7,82.84l-175.94-54-.16-.05A20,20,0,0,0,28,48V192a20,20,0,0,0,19.94,20,20.38,20.38,0,0,0,5.66-.81l.16,0,78.24-24V196a20,20,0,0,0,20,20h32a20,20,0,0,0,20-20V165.06l25.7-7.89A20.1,20.1,0,0,0,244,138V102A20.1,20.1,0,0,0,229.7,82.84ZM52,186.58V53.43L132,78V162ZM180,192H156V179.78l24-7.36Zm40-56.95-64,19.63V85.33L220,105Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M144,69.09V170.91L50.24,199.67A8,8,0,0,1,40,192V48a8,8,0,0,1,10.24-7.67Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M228.54,86.66l-176.06-54A16,16,0,0,0,32,48V192a16,16,0,0,0,16,16,16,16,0,0,0,4.52-.65L136,181.73V192a16,16,0,0,0,16,16h32a16,16,0,0,0,16-16v-29.9l28.54-8.75A16.09,16.09,0,0,0,240,138V102A16.09,16.09,0,0,0,228.54,86.66ZM136,165,48,192V48l88,27Zm48,27H152V176.82L184,167Zm40-54-.11,0L152,160.08V79.92l71.89,22,.11,0v36Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M228.54,86.66l-176.06-54A16,16,0,0,0,32,48V192a16,16,0,0,0,16,16,16,16,0,0,0,4.52-.65L136,181.73V192a16,16,0,0,0,16,16h32a16,16,0,0,0,16-16v-29.9l28.54-8.75A16.09,16.09,0,0,0,240,138V102A16.09,16.09,0,0,0,228.54,86.66ZM184,192H152V176.82L184,167Zm40-54-.11,0L152,160.08V79.91L223.89,102l.11,0v36Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M228,88.59l-176.08-54A14,14,0,0,0,34,48V192a14,14,0,0,0,14,14,14.59,14.59,0,0,0,4-.59L138,179v13a14,14,0,0,0,14,14h32a14,14,0,0,0,14-14V160.62l30-9.19A14.07,14.07,0,0,0,238,138V102A14,14,0,0,0,228,88.59ZM48.56,193.92a2,2,0,0,1-1.76-.32A2,2,0,0,1,46,192V48a2,2,0,0,1,.8-1.6A2.05,2.05,0,0,1,48,46a1.79,1.79,0,0,1,.49.08L138,73.53v92.95ZM186,192a2,2,0,0,1-2,2H152a2,2,0,0,1-2-2V175.35l36-11Zm40-54a2,2,0,0,1-1.44,1.92l-.08,0L150,162.8V77.21l74.56,22.87A2,2,0,0,1,226,102Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M228.54,86.66l-176.06-54A16,16,0,0,0,32,48V192a16,16,0,0,0,16,16,16,16,0,0,0,4.52-.65L136,181.73V192a16,16,0,0,0,16,16h32a16,16,0,0,0,16-16v-29.9l28.54-8.75A16.09,16.09,0,0,0,240,138V102A16.09,16.09,0,0,0,228.54,86.66ZM136,165,48,192V48l88,27Zm48,27H152V176.82L184,167Zm40-54-.11,0L152,160.08V79.92l71.89,22,.11,0v36Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M227.41,90.5l-176-54A12,12,0,0,0,36,48V192a12,12,0,0,0,12,12,12.41,12.41,0,0,0,3.45-.5L140,176.32V192a12,12,0,0,0,12,12h32a12,12,0,0,0,12-12V159.14l31.39-9.63A12.06,12.06,0,0,0,236,138V102A12,12,0,0,0,227.41,90.5ZM49.12,195.84A4,4,0,0,1,44,192V48a4,4,0,0,1,1.6-3.2A4,4,0,0,1,48,44a3.89,3.89,0,0,1,1.07.15L140,72.05V168ZM188,192a4,4,0,0,1-4,4H152a4,4,0,0,1-4-4V173.87l40-12.27Zm40-54a4,4,0,0,1-2.88,3.84l-.05,0L148,165.5v-91l77.12,23.66A4,4,0,0,1,228,102Z" }))]
]);
var e$35 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M168,12A75.9,75.9,0,0,0,92.49,96.33L23.91,189.85a19.89,19.89,0,0,0,2,26l14.29,14.29a19.89,19.89,0,0,0,26,2l93.52-68.58A76,76,0,1,0,168,12Zm52,76a51.66,51.66,0,0,1-7.75,27.27L140.74,43.75A52,52,0,0,1,220,88ZM54.72,210.71l-9.43-9.43,56.19-76.63a76.46,76.46,0,0,0,29.87,29.87ZM116,88a51.63,51.63,0,0,1,7.75-27.27l71.51,71.51A52,52,0,0,1,116,88Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M156.5,151,59,222.45a8,8,0,0,1-10.38-.79l-14.3-14.3A8,8,0,0,1,33.55,197L105,99.5l0,0A64,64,0,0,0,156.48,151Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M168,16A72.07,72.07,0,0,0,96,88a73.29,73.29,0,0,0,.63,9.42L27.12,192.22A15.93,15.93,0,0,0,28.71,213L43,227.29a15.93,15.93,0,0,0,20.78,1.59l94.81-69.53A73.29,73.29,0,0,0,168,160a72,72,0,1,0,0-144Zm56,72a55.72,55.72,0,0,1-11.16,33.52L134.49,43.16A56,56,0,0,1,224,88ZM54.32,216,40,201.68,102.14,117A72.37,72.37,0,0,0,139,153.86ZM112,88a55.67,55.67,0,0,1,11.16-33.51l78.34,78.34A56,56,0,0,1,112,88Zm-2.35,58.34a8,8,0,0,1,0,11.31l-8,8a8,8,0,1,1-11.31-11.31l8-8A8,8,0,0,1,109.67,146.33Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M115.06,46.36a4,4,0,0,0-6.11.54A71.54,71.54,0,0,0,96,88a73.29,73.29,0,0,0,.63,9.42L27.12,192.22A15.93,15.93,0,0,0,28.71,213L43,227.29a15.93,15.93,0,0,0,20.78,1.59l94.81-69.53A73.29,73.29,0,0,0,168,160a71.54,71.54,0,0,0,41.09-12.93,4,4,0,0,0,.54-6.11Zm2.61,103.28-16,16a8,8,0,1,1-11.31-11.31l16-16a8,8,0,0,1,11.31,11.31Zm109.4-20.56a4,4,0,0,1-6.12.54L126.38,35.05a4,4,0,0,1,.54-6.12A71.93,71.93,0,0,1,227.07,129.08Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M168,18A69.94,69.94,0,0,0,98.74,98l-70,95.46a13.92,13.92,0,0,0,1.39,18.17l14.3,14.3a13.93,13.93,0,0,0,18.17,1.39l95.46-70A70,70,0,1,0,168,18Zm58,70a57.65,57.65,0,0,1-13,36.52L131.49,43A57.95,57.95,0,0,1,226,88ZM55.5,217.59a2,2,0,0,1-2.6-.2L38.61,203.1a2,2,0,0,1-.2-2.6l64.22-87.56a70.32,70.32,0,0,0,40.44,40.43ZM110,88a57.73,57.73,0,0,1,13-36.52L204.53,133A58,58,0,0,1,110,88Zm-1.75,59.75a6,6,0,0,1,0,8.49l-8,8a6,6,0,1,1-8.49-8.49l8-8A6,6,0,0,1,108.26,147.74Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M168,16A72.07,72.07,0,0,0,96,88a73.29,73.29,0,0,0,.63,9.42L27.12,192.22A15.93,15.93,0,0,0,28.71,213L43,227.29a15.93,15.93,0,0,0,20.78,1.59l94.81-69.53A73.29,73.29,0,0,0,168,160a72,72,0,1,0,0-144Zm56,72a55.72,55.72,0,0,1-11.16,33.52L134.49,43.16A56,56,0,0,1,224,88ZM54.32,216,40,201.68,102.14,117A72.37,72.37,0,0,0,139,153.86ZM112,88a55.67,55.67,0,0,1,11.16-33.51l78.34,78.34A56,56,0,0,1,112,88Zm-2.35,58.34a8,8,0,0,1,0,11.31l-8,8a8,8,0,1,1-11.31-11.31l8-8A8,8,0,0,1,109.67,146.33Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M168,20a68.08,68.08,0,0,0-68,68,67.19,67.19,0,0,0,.82,10.49L30.34,194.59a11.94,11.94,0,0,0,1.2,15.58l14.29,14.3a11.95,11.95,0,0,0,15.58,1.19l96.11-70.48A68,68,0,1,0,168,20Zm60,68a59.7,59.7,0,0,1-14.87,39.47L128.54,42.87A59.94,59.94,0,0,1,228,88ZM56.68,219.21a4,4,0,0,1-5.2-.4L37.19,204.52a4,4,0,0,1-.4-5.2l66.46-90.62a68.31,68.31,0,0,0,44.05,44.05ZM108,88a59.77,59.77,0,0,1,14.87-39.47l84.6,84.6A60,60,0,0,1,108,88Zm-1.17,61.17a4,4,0,0,1,0,5.65l-8,8a4,4,0,1,1-5.65-5.65l8-8A4,4,0,0,1,106.84,149.16Z" }))]
]);
var a$16 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M215.38,14.54a12,12,0,0,0-10.29-2.18l-128,32A12,12,0,0,0,68,56V159.35A40,40,0,1,0,92,196V113.37l104-26v40A40,40,0,1,0,220,164V24A12,12,0,0,0,215.38,14.54ZM52,212a16,16,0,1,1,16-16A16,16,0,0,1,52,212ZM92,88.63V65.37l104-26V62.63ZM180,180a16,16,0,1,1,16-16A16,16,0,0,1,180,180Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M208,164a28,28,0,1,1-28-28A28,28,0,0,1,208,164ZM52,168a28,28,0,1,0,28,28A28,28,0,0,0,52,168Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M212.92,17.69a8,8,0,0,0-6.86-1.45l-128,32A8,8,0,0,0,72,56V166.08A36,36,0,1,0,88,196V110.25l112-28v51.83A36,36,0,1,0,216,164V24A8,8,0,0,0,212.92,17.69ZM52,216a20,20,0,1,1,20-20A20,20,0,0,1,52,216ZM88,93.75V62.25l112-28v31.5ZM180,184a20,20,0,1,1,20-20A20,20,0,0,1,180,184Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M212.92,17.71a7.89,7.89,0,0,0-6.86-1.46l-128,32A8,8,0,0,0,72,56V166.1A36,36,0,1,0,88,196V102.25l112-28V134.1A36,36,0,1,0,216,164V24A8,8,0,0,0,212.92,17.71Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M211.69,19.27a6,6,0,0,0-5.15-1.09l-128,32A6,6,0,0,0,74,56V170.11A34,34,0,1,0,86,196V108.68l116-29v58.43A34,34,0,1,0,214,164V24A6,6,0,0,0,211.69,19.27ZM52,218a22,22,0,1,1,22-22A22,22,0,0,1,52,218ZM86,96.32V60.68l116-29V67.32ZM180,186a22,22,0,1,1,22-22A22,22,0,0,1,180,186Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M212.92,17.69a8,8,0,0,0-6.86-1.45l-128,32A8,8,0,0,0,72,56V166.08A36,36,0,1,0,88,196V110.25l112-28v51.83A36,36,0,1,0,216,164V24A8,8,0,0,0,212.92,17.69ZM52,216a20,20,0,1,1,20-20A20,20,0,0,1,52,216ZM88,93.75V62.25l112-28v31.5ZM180,184a20,20,0,1,1,20-20A20,20,0,0,1,180,184Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M210.46,20.85a4,4,0,0,0-3.43-.73l-128,32A4,4,0,0,0,76,56V174.87A32,32,0,1,0,84,196V107.12l120-30v65.75A32,32,0,1,0,212,164V24A4,4,0,0,0,210.46,20.85ZM52,220a24,24,0,1,1,24-24A24,24,0,0,1,52,220Zm128-32a24,24,0,1,1,24-24A24,24,0,0,1,180,188ZM84,98.88V59.12l120-30V68.88Z" }))]
]);
var a$15 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M233.86,110.48,65.8,14.58A20,20,0,0,0,37.15,38.64L67.33,128,37.15,217.36A20,20,0,0,0,56,244a20.1,20.1,0,0,0,9.81-2.58l.09-.06,168-96.07a20,20,0,0,0,0-34.81ZM63.19,215.26,88.61,140H144a12,12,0,0,0,0-24H88.61L63.18,40.72l152.76,87.17Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M227.91,134.86,59.93,231a8,8,0,0,1-11.44-9.67L80,128,48.49,34.72a8,8,0,0,1,11.44-9.67l168,95.85A8,8,0,0,1,227.91,134.86Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M231.87,114l-168-95.89A16,16,0,0,0,40.92,37.34L71.55,128,40.92,218.67A16,16,0,0,0,56,240a16.15,16.15,0,0,0,7.93-2.1l167.92-96.05a16,16,0,0,0,.05-27.89ZM56,224a.56.56,0,0,0,0-.12L85.74,136H144a8,8,0,0,0,0-16H85.74L56.06,32.16A.46.46,0,0,0,56,32l168,95.83Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M240,127.89a16,16,0,0,1-8.18,14L63.9,237.9A16.15,16.15,0,0,1,56,240a16,16,0,0,1-15-21.33l27-79.95A4,4,0,0,1,71.72,136H144a8,8,0,0,0,8-8.53,8.19,8.19,0,0,0-8.26-7.47h-72a4,4,0,0,1-3.79-2.72l-27-79.94A16,16,0,0,1,63.84,18.07l168,95.89A16,16,0,0,1,240,127.89Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M230.88,115.69l-168-95.88a14,14,0,0,0-20,16.87L73.66,128,42.81,219.33A14,14,0,0,0,56,238a14.15,14.15,0,0,0,6.93-1.83L230.84,140.1a14,14,0,0,0,0-24.41Zm-5.95,14L57,225.73a2,2,0,0,1-2.86-2.42.42.42,0,0,0,0-.1L84.3,134H144a6,6,0,0,0,0-12H84.3L54.17,32.8a.3.3,0,0,0,0-.1,1.87,1.87,0,0,1,.6-2.2A1.85,1.85,0,0,1,57,30.25l168,95.89a1.93,1.93,0,0,1,1,1.74A2,2,0,0,1,224.93,129.66Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M231.87,114l-168-95.89A16,16,0,0,0,40.92,37.34L71.55,128,40.92,218.67A16,16,0,0,0,56,240a16.15,16.15,0,0,0,7.93-2.1l167.92-96.05a16,16,0,0,0,.05-27.89ZM56,224a.56.56,0,0,0,0-.12L85.74,136H144a8,8,0,0,0,0-16H85.74L56.06,32.16A.46.46,0,0,0,56,32l168,95.83Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M229.89,117.43l-168-95.88A12,12,0,0,0,44.7,36l31.08,92L44.71,220A12,12,0,0,0,56,236a12.13,12.13,0,0,0,5.93-1.57l167.94-96.08a12,12,0,0,0,0-20.92Zm-4,14L58,227.47a4,4,0,0,1-5.72-4.83l0-.07L82.87,132H144a4,4,0,0,0,0-8H82.87L52.26,33.37A3.89,3.89,0,0,1,53.44,29,4.13,4.13,0,0,1,56,28a3.88,3.88,0,0,1,1.93.54l168,95.87a4,4,0,0,1,0,7Z" }))]
]);
var e$34 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M230.14,70.54,185.46,25.85a20,20,0,0,0-28.29,0L33.86,149.17A19.85,19.85,0,0,0,28,163.31V208a20,20,0,0,0,20,20H92.69a19.86,19.86,0,0,0,14.14-5.86L230.14,98.82a20,20,0,0,0,0-28.28ZM91,204H52V165l84-84,39,39ZM192,103,153,64l18.34-18.34,39,39Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M221.66,90.34,192,120,136,64l29.66-29.66a8,8,0,0,1,11.31,0L221.66,79A8,8,0,0,1,221.66,90.34Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M227.31,73.37,182.63,28.68a16,16,0,0,0-22.63,0L36.69,152A15.86,15.86,0,0,0,32,163.31V208a16,16,0,0,0,16,16H92.69A15.86,15.86,0,0,0,104,219.31L227.31,96a16,16,0,0,0,0-22.63ZM92.69,208H48V163.31l88-88L180.69,120ZM192,108.68,147.31,64l24-24L216,84.68Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M227.31,73.37,182.63,28.68a16,16,0,0,0-22.63,0L36.69,152A15.86,15.86,0,0,0,32,163.31V208a16,16,0,0,0,16,16H92.69A15.86,15.86,0,0,0,104,219.31L227.31,96a16,16,0,0,0,0-22.63ZM192,108.68,147.31,64l24-24L216,84.68Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M225.9,74.78,181.21,30.09a14,14,0,0,0-19.8,0L38.1,153.41a13.94,13.94,0,0,0-4.1,9.9V208a14,14,0,0,0,14,14H92.69a13.94,13.94,0,0,0,9.9-4.1L225.9,94.58a14,14,0,0,0,0-19.8ZM94.1,209.41a2,2,0,0,1-1.41.59H48a2,2,0,0,1-2-2V163.31a2,2,0,0,1,.59-1.41L136,72.48,183.51,120ZM217.41,86.1,192,111.51,144.49,64,169.9,38.58a2,2,0,0,1,2.83,0l44.68,44.69a2,2,0,0,1,0,2.83Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M227.31,73.37,182.63,28.68a16,16,0,0,0-22.63,0L36.69,152A15.86,15.86,0,0,0,32,163.31V208a16,16,0,0,0,16,16H92.69A15.86,15.86,0,0,0,104,219.31L227.31,96a16,16,0,0,0,0-22.63ZM92.69,208H48V163.31l88-88L180.69,120ZM192,108.68,147.31,64l24-24L216,84.68Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M224.49,76.2,179.8,31.51a12,12,0,0,0-17,0L133.17,61.17h0L39.52,154.83A11.9,11.9,0,0,0,36,163.31V208a12,12,0,0,0,12,12H92.69a12,12,0,0,0,8.48-3.51L224.48,93.17a12,12,0,0,0,0-17Zm-129,134.63A4,4,0,0,1,92.69,212H48a4,4,0,0,1-4-4V163.31a4,4,0,0,1,1.17-2.83L136,69.65,186.34,120ZM218.83,87.51,192,114.34,141.66,64l26.82-26.83a4,4,0,0,1,5.66,0l44.69,44.68a4,4,0,0,1,0,5.66Z" }))]
]);
var a$14 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M230.15,70.54,185.46,25.86a20,20,0,0,0-28.28,0L33.86,149.17A19.86,19.86,0,0,0,28,163.31V208a20,20,0,0,0,20,20H216a12,12,0,0,0,0-24H125L230.15,98.83A20,20,0,0,0,230.15,70.54ZM91,204H52V165l84-84,39,39ZM192,103,153,64l18.34-18.34,39,39Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M221.66,90.34,192,120,136,64l29.66-29.66a8,8,0,0,1,11.31,0L221.66,79A8,8,0,0,1,221.66,90.34Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M227.32,73.37,182.63,28.69a16,16,0,0,0-22.63,0L36.69,152A15.86,15.86,0,0,0,32,163.31V208a16,16,0,0,0,16,16H216a8,8,0,0,0,0-16H115.32l112-112A16,16,0,0,0,227.32,73.37ZM48,163.31l88-88L180.69,120l-88,88H48Zm144-54.62L147.32,64l24-24L216,84.69Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M227.32,73.37,182.63,28.69a16,16,0,0,0-22.63,0L36.69,152A15.86,15.86,0,0,0,32,163.31V208a16,16,0,0,0,16,16H216a8,8,0,0,0,0-16H115.32l112-112A16,16,0,0,0,227.32,73.37ZM192,108.69,147.32,64l24-24L216,84.69Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M225.91,74.79,181.22,30.1a14,14,0,0,0-19.8,0L38.1,153.41a13.94,13.94,0,0,0-4.1,9.9V208a14,14,0,0,0,14,14H216a6,6,0,0,0,0-12H110.49L225.91,94.59A14,14,0,0,0,225.91,74.79ZM93.52,210H48a2,2,0,0,1-2-2V163.31a2,2,0,0,1,.59-1.41L136,72.49,183.52,120ZM217.42,86.1,192,111.52,144.49,64,169.9,38.59a2,2,0,0,1,2.83,0l44.69,44.68A2,2,0,0,1,217.42,86.1Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M227.32,73.37,182.63,28.69a16,16,0,0,0-22.63,0L36.69,152A15.86,15.86,0,0,0,32,163.31V208a16,16,0,0,0,16,16H216a8,8,0,0,0,0-16H115.32l112-112A16,16,0,0,0,227.32,73.37ZM92.69,208H48V163.31l88-88L180.69,120ZM192,108.69,147.32,64l24-24L216,84.69Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M224.49,76.2,179.8,31.51a12,12,0,0,0-17,0L39.51,154.83A12,12,0,0,0,36,163.31V208a12,12,0,0,0,12,12H216a4,4,0,0,0,0-8H105.66L224.49,93.17A12,12,0,0,0,224.49,76.2ZM94.34,212H48a4,4,0,0,1-4-4V163.31a4,4,0,0,1,1.17-2.82L136,69.66,186.35,120ZM218.83,87.51,192,114.34,141.66,64l26.83-26.83a4,4,0,0,1,5.66,0l44.68,44.69A4,4,0,0,1,218.83,87.51Z" }))]
]);
var e$33 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M208,28H48A20,20,0,0,0,28,48V208a20,20,0,0,0,20,20H208a20,20,0,0,0,20-20V48A20,20,0,0,0,208,28ZM92,132V52h24v80Zm52,24v48H112V156Zm20-24H140V52h24ZM52,52H68v92a12,12,0,0,0,12,12h8v48H52ZM204,204H168V156h8a12,12,0,0,0,12-12V52h16Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M184,40V144H144V40ZM72,144h40V40H72Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M208,32H48A16,16,0,0,0,32,48V208a16,16,0,0,0,16,16H208a16,16,0,0,0,16-16V48A16,16,0,0,0,208,32ZM80,48h24v88H80Zm32,104a8,8,0,0,0,8-8V48h16v96a8,8,0,0,0,8,8h8v56H104V152Zm40-16V48h24v88ZM48,48H64v96a8,8,0,0,0,8,8H88v56H48ZM208,208H168V152h16a8,8,0,0,0,8-8V48h16V208Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M208,32H48A16,16,0,0,0,32,48V208a16,16,0,0,0,16,16H208a16,16,0,0,0,16-16V48A16,16,0,0,0,208,32ZM88,208H48V48H72v96a8,8,0,0,0,8,8h8Zm64,0H104V152h8a8,8,0,0,0,8-8V48h16v96a8,8,0,0,0,8,8h8Zm56,0H168V152h8a8,8,0,0,0,8-8V48h24V208Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M208,34H48A14,14,0,0,0,34,48V208a14,14,0,0,0,14,14H208a14,14,0,0,0,14-14V48A14,14,0,0,0,208,34ZM78,46h28v92H78Zm34,104a6,6,0,0,0,6-6V46h20v98a6,6,0,0,0,6,6h10v60H102V150Zm38-12V46h28v92ZM46,208V48a2,2,0,0,1,2-2H66v98a6,6,0,0,0,6,6H90v60H48A2,2,0,0,1,46,208Zm164,0a2,2,0,0,1-2,2H166V150h18a6,6,0,0,0,6-6V46h18a2,2,0,0,1,2,2Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M208,32H48A16,16,0,0,0,32,48V208a16,16,0,0,0,16,16H208a16,16,0,0,0,16-16V48A16,16,0,0,0,208,32ZM80,48h24v88H80Zm32,104a8,8,0,0,0,8-8V48h16v96a8,8,0,0,0,8,8h8v56H104V152Zm40-16V48h24v88ZM48,48H64v96a8,8,0,0,0,8,8H88v56H48ZM208,208H168V152h16a8,8,0,0,0,8-8V48h16V208Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M208,36H48A12,12,0,0,0,36,48V208a12,12,0,0,0,12,12H208a12,12,0,0,0,12-12V48A12,12,0,0,0,208,36ZM76,44h32v96H76Zm36,104a4,4,0,0,0,4-4V44h24V144a4,4,0,0,0,4,4h12v64H100V148Zm36-8V44h32v96ZM44,208V48a4,4,0,0,1,4-4H68V144a4,4,0,0,0,4,4H92v64H48A4,4,0,0,1,44,208Zm168,0a4,4,0,0,1-4,4H164V148h20a4,4,0,0,0,4-4V44h20a4,4,0,0,1,4,4Z" }))]
]);
var a$13 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M234.49,111.07,90.41,22.94A20,20,0,0,0,60,39.87V216.13a20,20,0,0,0,30.41,16.93l144.08-88.13a19.82,19.82,0,0,0,0-33.86ZM84,208.85V47.15L216.16,128Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M228.23,134.69,84.15,222.81A8,8,0,0,1,72,216.12V39.88a8,8,0,0,1,12.15-6.69l144.08,88.12A7.82,7.82,0,0,1,228.23,134.69Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M232.4,114.49,88.32,26.35a16,16,0,0,0-16.2-.3A15.86,15.86,0,0,0,64,39.87V216.13A15.94,15.94,0,0,0,80,232a16.07,16.07,0,0,0,8.36-2.35L232.4,141.51a15.81,15.81,0,0,0,0-27ZM80,215.94V40l143.83,88Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M240,128a15.74,15.74,0,0,1-7.6,13.51L88.32,229.65a16,16,0,0,1-16.2.3A15.86,15.86,0,0,1,64,216.13V39.87a15.86,15.86,0,0,1,8.12-13.82,16,16,0,0,1,16.2.3L232.4,114.49A15.74,15.74,0,0,1,240,128Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M231.36,116.19,87.28,28.06a14,14,0,0,0-14.18-.27A13.69,13.69,0,0,0,66,39.87V216.13a13.69,13.69,0,0,0,7.1,12.08,14,14,0,0,0,14.18-.27l144.08-88.13a13.82,13.82,0,0,0,0-23.62Zm-6.26,13.38L81,217.7a2,2,0,0,1-2.06,0,1.78,1.78,0,0,1-1-1.61V39.87a1.78,1.78,0,0,1,1-1.61A2.06,2.06,0,0,1,80,38a2,2,0,0,1,1,.31L225.1,126.43a1.82,1.82,0,0,1,0,3.14Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M232.4,114.49,88.32,26.35a16,16,0,0,0-16.2-.3A15.86,15.86,0,0,0,64,39.87V216.13A15.94,15.94,0,0,0,80,232a16.07,16.07,0,0,0,8.36-2.35L232.4,141.51a15.81,15.81,0,0,0,0-27ZM80,215.94V40l143.83,88Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M230.32,117.9,86.24,29.79a11.91,11.91,0,0,0-12.17-.23A11.71,11.71,0,0,0,68,39.89V216.11a11.71,11.71,0,0,0,6.07,10.33,11.91,11.91,0,0,0,12.17-.23L230.32,138.1a11.82,11.82,0,0,0,0-20.2Zm-4.18,13.37L82.06,219.39a4,4,0,0,1-4.07.07,3.77,3.77,0,0,1-2-3.35V39.89a3.77,3.77,0,0,1,2-3.35,4,4,0,0,1,4.07.07l144.08,88.12a3.8,3.8,0,0,1,0,6.54Z" }))]
]);
var a$12 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M228,128a12,12,0,0,1-12,12H140v76a12,12,0,0,1-24,0V140H40a12,12,0,0,1,0-24h76V40a12,12,0,0,1,24,0v76h76A12,12,0,0,1,228,128Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M216,56V200a16,16,0,0,1-16,16H56a16,16,0,0,1-16-16V56A16,16,0,0,1,56,40H200A16,16,0,0,1,216,56Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M224,128a8,8,0,0,1-8,8H136v80a8,8,0,0,1-16,0V136H40a8,8,0,0,1,0-16h80V40a8,8,0,0,1,16,0v80h80A8,8,0,0,1,224,128Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M208,32H48A16,16,0,0,0,32,48V208a16,16,0,0,0,16,16H208a16,16,0,0,0,16-16V48A16,16,0,0,0,208,32ZM184,136H136v48a8,8,0,0,1-16,0V136H72a8,8,0,0,1,0-16h48V72a8,8,0,0,1,16,0v48h48a8,8,0,0,1,0,16Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M222,128a6,6,0,0,1-6,6H134v82a6,6,0,0,1-12,0V134H40a6,6,0,0,1,0-12h82V40a6,6,0,0,1,12,0v82h82A6,6,0,0,1,222,128Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M224,128a8,8,0,0,1-8,8H136v80a8,8,0,0,1-16,0V136H40a8,8,0,0,1,0-16h80V40a8,8,0,0,1,16,0v80h80A8,8,0,0,1,224,128Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M220,128a4,4,0,0,1-4,4H132v84a4,4,0,0,1-8,0V132H40a4,4,0,0,1,0-8h84V40a4,4,0,0,1,8,0v84h84A4,4,0,0,1,220,128Z" }))]
]);
var a$11 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M144,180a16,16,0,1,1-16-16A16,16,0,0,1,144,180Zm92-52A108,108,0,1,1,128,20,108.12,108.12,0,0,1,236,128Zm-24,0a84,84,0,1,0-84,84A84.09,84.09,0,0,0,212,128ZM128,64c-24.26,0-44,17.94-44,40v4a12,12,0,0,0,24,0v-4c0-8.82,9-16,20-16s20,7.18,20,16-9,16-20,16a12,12,0,0,0-12,12v8a12,12,0,0,0,23.73,2.56C158.31,137.88,172,122.37,172,104,172,81.94,152.26,64,128,64Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M224,128a96,96,0,1,1-96-96A96,96,0,0,1,224,128Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M140,180a12,12,0,1,1-12-12A12,12,0,0,1,140,180ZM128,72c-22.06,0-40,16.15-40,36v4a8,8,0,0,0,16,0v-4c0-11,10.77-20,24-20s24,9,24,20-10.77,20-24,20a8,8,0,0,0-8,8v8a8,8,0,0,0,16,0v-.72c18.24-3.35,32-17.9,32-35.28C168,88.15,150.06,72,128,72Zm104,56A104,104,0,1,1,128,24,104.11,104.11,0,0,1,232,128Zm-16,0a88,88,0,1,0-88,88A88.1,88.1,0,0,0,216,128Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M128,24A104,104,0,1,0,232,128,104.11,104.11,0,0,0,128,24Zm0,168a12,12,0,1,1,12-12A12,12,0,0,1,128,192Zm8-48.72V144a8,8,0,0,1-16,0v-8a8,8,0,0,1,8-8c13.23,0,24-9,24-20s-10.77-20-24-20-24,9-24,20v4a8,8,0,0,1-16,0v-4c0-19.85,17.94-36,40-36s40,16.15,40,36C168,125.38,154.24,139.93,136,143.28Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M138,180a10,10,0,1,1-10-10A10,10,0,0,1,138,180ZM128,74c-21,0-38,15.25-38,34v4a6,6,0,0,0,12,0v-4c0-12.13,11.66-22,26-22s26,9.87,26,22-11.66,22-26,22a6,6,0,0,0-6,6v8a6,6,0,0,0,12,0v-2.42c18.11-2.58,32-16.66,32-33.58C166,89.25,149,74,128,74Zm102,54A102,102,0,1,1,128,26,102.12,102.12,0,0,1,230,128Zm-12,0a90,90,0,1,0-90,90A90.1,90.1,0,0,0,218,128Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M140,180a12,12,0,1,1-12-12A12,12,0,0,1,140,180ZM128,72c-22.06,0-40,16.15-40,36v4a8,8,0,0,0,16,0v-4c0-11,10.77-20,24-20s24,9,24,20-10.77,20-24,20a8,8,0,0,0-8,8v8a8,8,0,0,0,16,0v-.72c18.24-3.35,32-17.9,32-35.28C168,88.15,150.06,72,128,72Zm104,56A104,104,0,1,1,128,24,104.11,104.11,0,0,1,232,128Zm-16,0a88,88,0,1,0-88,88A88.1,88.1,0,0,0,216,128Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M136,180a8,8,0,1,1-8-8A8,8,0,0,1,136,180ZM128,76c-19.85,0-36,14.36-36,32v4a4,4,0,0,0,8,0v-4c0-13.23,12.56-24,28-24s28,10.77,28,24-12.56,24-28,24a4,4,0,0,0-4,4v8a4,4,0,0,0,8,0v-4.2c18-1.77,32-15.36,32-31.8C164,90.36,147.85,76,128,76Zm100,52A100,100,0,1,1,128,28,100.11,100.11,0,0,1,228,128Zm-8,0a92,92,0,1,0-92,92A92.1,92.1,0,0,0,220,128Z" }))]
]);
var e$32 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M20,128A76.08,76.08,0,0,1,96,52h99l-3.52-3.51a12,12,0,1,1,17-17l24,24a12,12,0,0,1,0,17l-24,24a12,12,0,0,1-17-17L195,76H96a52.06,52.06,0,0,0-52,52,12,12,0,0,1-24,0Zm204-12a12,12,0,0,0-12,12,52.06,52.06,0,0,1-52,52H61l3.52-3.51a12,12,0,1,0-17-17l-24,24a12,12,0,0,0,0,17l24,24a12,12,0,1,0,17-17L61,204h99a76.08,76.08,0,0,0,76-76A12,12,0,0,0,224,116Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M224,64v64a64,64,0,0,1-64,64H32V128A64,64,0,0,1,96,64Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M24,128A72.08,72.08,0,0,1,96,56H204.69L194.34,45.66a8,8,0,0,1,11.32-11.32l24,24a8,8,0,0,1,0,11.32l-24,24a8,8,0,0,1-11.32-11.32L204.69,72H96a56.06,56.06,0,0,0-56,56,8,8,0,0,1-16,0Zm200-8a8,8,0,0,0-8,8,56.06,56.06,0,0,1-56,56H51.31l10.35-10.34a8,8,0,0,0-11.32-11.32l-24,24a8,8,0,0,0,0,11.32l24,24a8,8,0,0,0,11.32-11.32L51.31,200H160a72.08,72.08,0,0,0,72-72A8,8,0,0,0,224,120Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M24,128A72.08,72.08,0,0,1,96,56h96V40a8,8,0,0,1,13.66-5.66l24,24a8,8,0,0,1,0,11.32l-24,24A8,8,0,0,1,192,88V72H96a56.06,56.06,0,0,0-56,56,8,8,0,0,1-16,0Zm200-8a8,8,0,0,0-8,8,56.06,56.06,0,0,1-56,56H64V168a8,8,0,0,0-13.66-5.66l-24,24a8,8,0,0,0,0,11.32l24,24A8,8,0,0,0,64,216V200h96a72.08,72.08,0,0,0,72-72A8,8,0,0,0,224,120Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M26,128A70.08,70.08,0,0,1,96,58H209.51L195.76,44.24a6,6,0,0,1,8.48-8.48l24,24a6,6,0,0,1,0,8.48l-24,24a6,6,0,0,1-8.48-8.48L209.51,70H96a58.07,58.07,0,0,0-58,58,6,6,0,0,1-12,0Zm198-6a6,6,0,0,0-6,6,58.07,58.07,0,0,1-58,58H46.49l13.75-13.76a6,6,0,0,0-8.48-8.48l-24,24a6,6,0,0,0,0,8.48l24,24a6,6,0,0,0,8.48-8.48L46.49,198H160a70.08,70.08,0,0,0,70-70A6,6,0,0,0,224,122Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M24,128A72.08,72.08,0,0,1,96,56H204.69L194.34,45.66a8,8,0,0,1,11.32-11.32l24,24a8,8,0,0,1,0,11.32l-24,24a8,8,0,0,1-11.32-11.32L204.69,72H96a56.06,56.06,0,0,0-56,56,8,8,0,0,1-16,0Zm200-8a8,8,0,0,0-8,8,56.06,56.06,0,0,1-56,56H51.31l10.35-10.34a8,8,0,0,0-11.32-11.32l-24,24a8,8,0,0,0,0,11.32l24,24a8,8,0,0,0,11.32-11.32L51.31,200H160a72.08,72.08,0,0,0,72-72A8,8,0,0,0,224,120Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M28,128A68.07,68.07,0,0,1,96,60H214.34L197.17,42.83a4,4,0,0,1,5.66-5.66l24,24a4,4,0,0,1,0,5.66l-24,24a4,4,0,0,1-5.66-5.66L214.34,68H96a60.07,60.07,0,0,0-60,60,4,4,0,0,1-8,0Zm196-4a4,4,0,0,0-4,4,60.07,60.07,0,0,1-60,60H41.66l17.17-17.17a4,4,0,0,0-5.66-5.66l-24,24a4,4,0,0,0,0,5.66l24,24a4,4,0,1,0,5.66-5.66L41.66,196H160a68.07,68.07,0,0,0,68-68A4,4,0,0,0,224,124Z" }))]
]);
var e$31 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M227.85,46.89a20,20,0,0,0-18.74-18.74c-13.13-.77-46.65.42-74.48,28.24L131,60H74.36a19.83,19.83,0,0,0-14.14,5.86L25.87,100.19a20,20,0,0,0,11.35,33.95l37.14,5.18,42.32,42.32,5.19,37.18A19.88,19.88,0,0,0,135.34,235a20.13,20.13,0,0,0,6.37,1,19.9,19.9,0,0,0,14.1-5.87l34.34-34.35A19.85,19.85,0,0,0,196,181.64V125l3.6-3.59C227.43,93.54,228.62,60,227.85,46.89ZM76,84h31L75.75,115.28l-27.23-3.8ZM151.6,73.37A72.27,72.27,0,0,1,204,52a72.17,72.17,0,0,1-21.38,52.41L128,159,97,128ZM172,180l-27.49,27.49-3.8-27.23L172,149Zm-72,22c-8.71,11.85-26.19,26-60,26a12,12,0,0,1-12-12c0-33.84,14.12-51.32,26-60A12,12,0,1,1,68.18,175.3C62.3,179.63,55.51,187.8,53,203c15.21-2.51,23.37-9.3,27.7-15.18A12,12,0,1,1,100,202Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M184,120v61.65a8,8,0,0,1-2.34,5.65l-34.35,34.35a8,8,0,0,1-13.57-4.53L128,176ZM136,72H74.35a8,8,0,0,0-5.65,2.34L34.35,108.69a8,8,0,0,0,4.53,13.57L80,128ZM40,216c37.65,0,50.69-19.69,54.56-28.18L68.18,161.44C59.69,165.31,40,178.35,40,216Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M223.85,47.12a16,16,0,0,0-15-15c-12.58-.75-44.73.4-71.41,27.07L132.69,64H74.36A15.91,15.91,0,0,0,63,68.68L28.7,103a16,16,0,0,0,9.07,27.16l38.47,5.37,44.21,44.21,5.37,38.49a15.94,15.94,0,0,0,10.78,12.92,16.11,16.11,0,0,0,5.1.83A15.91,15.91,0,0,0,153,227.3L187.32,193A15.91,15.91,0,0,0,192,181.64V123.31l4.77-4.77C223.45,91.86,224.6,59.71,223.85,47.12ZM74.36,80h42.33L77.16,119.52,40,114.34Zm74.41-9.45a76.65,76.65,0,0,1,59.11-22.47,76.46,76.46,0,0,1-22.42,59.16L128,164.68,91.32,128ZM176,181.64,141.67,216l-5.19-37.17L176,139.31Zm-74.16,9.5C97.34,201,82.29,224,40,224a8,8,0,0,1-8-8c0-42.29,23-57.34,32.86-61.85a8,8,0,0,1,6.64,14.56c-6.43,2.93-20.62,12.36-23.12,38.91,26.55-2.5,36-16.69,38.91-23.12a8,8,0,1,1,14.56,6.64Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M101.85,191.14C97.34,201,82.29,224,40,224a8,8,0,0,1-8-8c0-42.29,23-57.34,32.86-61.85a8,8,0,0,1,6.64,14.56c-6.43,2.93-20.62,12.36-23.12,38.91,26.55-2.5,36-16.69,38.91-23.12a8,8,0,1,1,14.56,6.64Zm122-144a16,16,0,0,0-15-15c-12.58-.75-44.73.4-71.4,27.07h0L88,108.7A8,8,0,0,1,76.67,97.39l26.56-26.57A4,4,0,0,0,100.41,64H74.35A15.9,15.9,0,0,0,63,68.68L28.7,103a16,16,0,0,0,9.07,27.16l38.47,5.37,44.21,44.21,5.37,38.49a15.94,15.94,0,0,0,10.78,12.92,16.11,16.11,0,0,0,5.1.83A15.91,15.91,0,0,0,153,227.3L187.32,193A16,16,0,0,0,192,181.65V155.59a4,4,0,0,0-6.83-2.82l-26.57,26.56a8,8,0,0,1-11.71-.42,8.2,8.2,0,0,1,.6-11.1l49.27-49.27h0C223.45,91.86,224.6,59.71,223.85,47.12Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M221.86,47.24a14,14,0,0,0-13.11-13.1c-12.31-.73-43.77.39-69.88,26.5L133.52,66H74.35a13.9,13.9,0,0,0-9.89,4.1L30.11,104.44a14,14,0,0,0,7.94,23.76l39.13,5.46,45.16,45.16L127.8,218a14,14,0,0,0,23.76,7.92l34.35-34.35a13.91,13.91,0,0,0,4.1-9.89V122.48l5.35-5.35h0C221.46,91,222.59,59.56,221.86,47.24ZM38.11,115a2,2,0,0,1,.49-2L72.94,78.58A2,2,0,0,1,74.35,78h47.17L77.87,121.64l-38.14-5.32A1.93,1.93,0,0,1,38.11,115ZM178,181.65a2,2,0,0,1-.59,1.41L143.08,217.4a2,2,0,0,1-3.4-1.11l-5.32-38.16L178,134.48Zm8.87-73h0L128,167.51,88.49,128l58.87-58.88a78.47,78.47,0,0,1,60.69-23A2,2,0,0,1,209.88,48,78.47,78.47,0,0,1,186.88,108.64ZM100,190.31C95.68,199.84,81.13,222,40,222a6,6,0,0,1-6-6c0-41.13,22.16-55.68,31.69-60a6,6,0,1,1,5,10.92c-7,3.17-22.53,13.52-24.47,42.91,29.39-1.94,39.74-17.52,42.91-24.47a6,6,0,1,1,10.92,5Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M223.85,47.12a16,16,0,0,0-15-15c-12.58-.75-44.73.4-71.41,27.07L132.69,64H74.36A15.91,15.91,0,0,0,63,68.68L28.7,103a16,16,0,0,0,9.07,27.16l38.47,5.37,44.21,44.21,5.37,38.49a15.94,15.94,0,0,0,10.78,12.92,16.11,16.11,0,0,0,5.1.83A15.91,15.91,0,0,0,153,227.3L187.32,193A15.91,15.91,0,0,0,192,181.64V123.31l4.77-4.77C223.45,91.86,224.6,59.71,223.85,47.12ZM74.36,80h42.33L77.16,119.52,40,114.34Zm74.41-9.45a76.65,76.65,0,0,1,59.11-22.47,76.46,76.46,0,0,1-22.42,59.16L128,164.68,91.32,128ZM176,181.64,141.67,216l-5.19-37.17L176,139.31Zm-74.16,9.5C97.34,201,82.29,224,40,224a8,8,0,0,1-8-8c0-42.29,23-57.34,32.86-61.85a8,8,0,0,1,6.64,14.56c-6.43,2.93-20.62,12.36-23.12,38.91,26.55-2.5,36-16.69,38.91-23.12a8,8,0,1,1,14.56,6.64Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M219.86,47.36a12,12,0,0,0-11.22-11.22c-12-.71-42.82.38-68.35,25.91L134.35,68h-60a11.9,11.9,0,0,0-8.48,3.52L31.52,105.85a12,12,0,0,0,6.81,20.37l39.79,5.55,46.11,46.11,5.55,39.81a12,12,0,0,0,20.37,6.79l34.34-34.35a11.9,11.9,0,0,0,3.52-8.48v-60l5.94-5.94C219.48,90.18,220.57,59.41,219.86,47.36ZM36.21,115.6a3.94,3.94,0,0,1,1-4.09L71.53,77.17A4,4,0,0,1,74.35,76h52L78.58,123.76,39.44,118.3A3.94,3.94,0,0,1,36.21,115.6ZM180,181.65a4,4,0,0,1-1.17,2.83l-34.35,34.34a4,4,0,0,1-6.79-2.25l-5.46-39.15L180,129.65Zm-52-11.31L85.66,128l60.28-60.29c23.24-23.24,51.25-24.23,62.22-23.58a3.93,3.93,0,0,1,3.71,3.71c.65,11-.35,39-23.58,62.22ZM98.21,189.48C94,198.66,80,220,40,220a4,4,0,0,1-4-4c0-40,21.34-54,30.52-58.21a4,4,0,0,1,3.32,7.28c-7.46,3.41-24.43,14.66-25.76,46.85,32.19-1.33,43.44-18.3,46.85-25.76a4,4,0,1,1,7.28,3.32Z" }))]
]);
var e$30 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M232.49,112.49l-48,48a12,12,0,0,1-17-17L195,116H165a84,84,0,0,0-81.36,63,12,12,0,1,1-23.24-6A107.94,107.94,0,0,1,165,92H195L167.51,64.48a12,12,0,0,1,17-17l48,48A12,12,0,0,1,232.49,112.49ZM192,204H44V88a12,12,0,0,0-24,0V216a12,12,0,0,0,12,12H192a12,12,0,0,0,0-24Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M224,104l-48,48V56Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M229.66,98.34l-48-48A8,8,0,0,0,168,56V96h-3A103.94,103.94,0,0,0,64.25,174a8,8,0,0,0,15.5,4A88,88,0,0,1,165,112h3v40a8,8,0,0,0,13.66,5.66l48-48A8,8,0,0,0,229.66,98.34ZM184,132.69V75.31L212.69,104ZM200,216a8,8,0,0,1-8,8H32a8,8,0,0,1-8-8V88a8,8,0,0,1,16,0V208H192A8,8,0,0,1,200,216Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M229.66,109.66l-48,48A8,8,0,0,1,168,152V112h-3a88,88,0,0,0-85.23,66,8,8,0,0,1-15.5-4A103.94,103.94,0,0,1,165,96h3V56a8,8,0,0,1,13.66-5.66l48,48A8,8,0,0,1,229.66,109.66ZM192,208H40V88a8,8,0,0,0-16,0V216a8,8,0,0,0,8,8H192a8,8,0,0,0,0-16Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M228.24,108.24l-48,48a6,6,0,0,1-8.48-8.48L209.51,110H165a89.94,89.94,0,0,0-87.17,67.5,6,6,0,0,1-11.62-3A101.94,101.94,0,0,1,165,98h44.53L171.76,60.24a6,6,0,0,1,8.48-8.48l48,48A6,6,0,0,1,228.24,108.24ZM192,210H38V88a6,6,0,0,0-12,0V216a6,6,0,0,0,6,6H192a6,6,0,0,0,0-12Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M229.66,109.66l-48,48a8,8,0,0,1-11.32-11.32L204.69,112H165a88,88,0,0,0-85.23,66,8,8,0,0,1-15.5-4A103.94,103.94,0,0,1,165,96h39.71L170.34,61.66a8,8,0,0,1,11.32-11.32l48,48A8,8,0,0,1,229.66,109.66ZM192,208H40V88a8,8,0,0,0-16,0V216a8,8,0,0,0,8,8H192a8,8,0,0,0,0-16Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M226.83,106.83l-48,48a4,4,0,0,1-5.66-5.66L214.34,108H165a92,92,0,0,0-89.11,69A4,4,0,0,1,72,180a3.87,3.87,0,0,1-1-.13A4,4,0,0,1,68.13,175,99.93,99.93,0,0,1,165,100h49.36L173.17,58.83a4,4,0,0,1,5.66-5.66l48,48A4,4,0,0,1,226.83,106.83ZM192,212H36V88a4,4,0,0,0-8,0V216a4,4,0,0,0,4,4H192a4,4,0,0,0,0-8Z" }))]
]);
var e$29 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M176,156a43.78,43.78,0,0,0-29.09,11L106.1,140.8a44.07,44.07,0,0,0,0-25.6L146.91,89a43.83,43.83,0,1,0-13-20.17L93.09,95a44,44,0,1,0,0,65.94L133.9,187.2A44,44,0,1,0,176,156Zm0-120a20,20,0,1,1-20,20A20,20,0,0,1,176,36ZM64,148a20,20,0,1,1,20-20A20,20,0,0,1,64,148Zm112,72a20,20,0,1,1,20-20A20,20,0,0,1,176,220Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M208,200a32,32,0,1,1-32-32A32,32,0,0,1,208,200ZM176,88a32,32,0,1,0-32-32A32,32,0,0,0,176,88Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M176,160a39.89,39.89,0,0,0-28.62,12.09l-46.1-29.63a39.8,39.8,0,0,0,0-28.92l46.1-29.63a40,40,0,1,0-8.66-13.45l-46.1,29.63a40,40,0,1,0,0,55.82l46.1,29.63A40,40,0,1,0,176,160Zm0-128a24,24,0,1,1-24,24A24,24,0,0,1,176,32ZM64,152a24,24,0,1,1,24-24A24,24,0,0,1,64,152Zm112,72a24,24,0,1,1,24-24A24,24,0,0,1,176,224Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M212,200a36,36,0,1,1-69.85-12.25l-53-34.05a36,36,0,1,1,0-51.4l53-34a36.09,36.09,0,1,1,8.67,13.45l-53,34.05a36,36,0,0,1,0,24.5l53,34.05A36,36,0,0,1,212,200Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M176,162a37.91,37.91,0,0,0-28.3,12.67L98.8,143.24a37.89,37.89,0,0,0,0-30.48l48.9-31.43a38,38,0,1,0-6.5-10.09L92.3,102.67a38,38,0,1,0,0,50.66l48.9,31.43A38,38,0,1,0,176,162Zm0-132a26,26,0,1,1-26,26A26,26,0,0,1,176,30ZM64,154a26,26,0,1,1,26-26A26,26,0,0,1,64,154Zm112,72a26,26,0,1,1,26-26A26,26,0,0,1,176,226Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M176,160a39.89,39.89,0,0,0-28.62,12.09l-46.1-29.63a39.8,39.8,0,0,0,0-28.92l46.1-29.63a40,40,0,1,0-8.66-13.45l-46.1,29.63a40,40,0,1,0,0,55.82l46.1,29.63A40,40,0,1,0,176,160Zm0-128a24,24,0,1,1-24,24A24,24,0,0,1,176,32ZM64,152a24,24,0,1,1,24-24A24,24,0,0,1,64,152Zm112,72a24,24,0,1,1,24-24A24,24,0,0,1,176,224Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M176,164a36,36,0,0,0-27.92,13.3L96.25,144a35.92,35.92,0,0,0,0-32L148.08,78.7A35.93,35.93,0,1,0,143.75,72L91.92,105.3a36,36,0,1,0,0,45.4L143.75,184A36,36,0,1,0,176,164Zm0-136a28,28,0,1,1-28,28A28,28,0,0,1,176,28ZM64,156a28,28,0,1,1,28-28A28,28,0,0,1,64,156Zm112,72a28,28,0,1,1,28-28A28,28,0,0,1,176,228Z" }))]
]);
var e$28 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M144.49,136.49l-40,40a12,12,0,0,1-17-17L107,140H24a12,12,0,0,1,0-24h83L87.51,96.49a12,12,0,0,1,17-17l40,40A12,12,0,0,1,144.49,136.49ZM200,28H136a12,12,0,0,0,0,24h52V204H136a12,12,0,0,0,0,24h64a12,12,0,0,0,12-12V40A12,12,0,0,0,200,28Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M200,40V216H40a16,16,0,0,1-16-16V56A16,16,0,0,1,40,40Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M141.66,133.66l-40,40a8,8,0,0,1-11.32-11.32L116.69,136H24a8,8,0,0,1,0-16h92.69L90.34,93.66a8,8,0,0,1,11.32-11.32l40,40A8,8,0,0,1,141.66,133.66ZM200,32H136a8,8,0,0,0,0,16h56V208H136a8,8,0,0,0,0,16h64a8,8,0,0,0,8-8V40A8,8,0,0,0,200,32Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M141.66,133.66l-40,40A8,8,0,0,1,88,168V136H24a8,8,0,0,1,0-16H88V88a8,8,0,0,1,13.66-5.66l40,40A8,8,0,0,1,141.66,133.66ZM200,32H136a8,8,0,0,0,0,16h56V208H136a8,8,0,0,0,0,16h64a8,8,0,0,0,8-8V40A8,8,0,0,0,200,32Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M140.24,132.24l-40,40a6,6,0,0,1-8.48-8.48L121.51,134H24a6,6,0,0,1,0-12h97.51L91.76,92.24a6,6,0,0,1,8.48-8.48l40,40A6,6,0,0,1,140.24,132.24ZM200,34H136a6,6,0,0,0,0,12h58V210H136a6,6,0,0,0,0,12h64a6,6,0,0,0,6-6V40A6,6,0,0,0,200,34Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M141.66,133.66l-40,40a8,8,0,0,1-11.32-11.32L116.69,136H24a8,8,0,0,1,0-16h92.69L90.34,93.66a8,8,0,0,1,11.32-11.32l40,40A8,8,0,0,1,141.66,133.66ZM200,32H136a8,8,0,0,0,0,16h56V208H136a8,8,0,0,0,0,16h64a8,8,0,0,0,8-8V40A8,8,0,0,0,200,32Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M138.83,130.83l-40,40a4,4,0,0,1-5.66-5.66L126.34,132H24a4,4,0,0,1,0-8H126.34L93.17,90.83a4,4,0,0,1,5.66-5.66l40,40A4,4,0,0,1,138.83,130.83ZM200,36H136a4,4,0,0,0,0,8h60V212H136a4,4,0,0,0,0,8h64a4,4,0,0,0,4-4V40A4,4,0,0,0,200,36Z" }))]
]);
var e$27 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M124,216a12,12,0,0,1-12,12H48a12,12,0,0,1-12-12V40A12,12,0,0,1,48,28h64a12,12,0,0,1,0,24H60V204h52A12,12,0,0,1,124,216Zm108.49-96.49-40-40a12,12,0,0,0-17,17L195,116H112a12,12,0,0,0,0,24h83l-19.52,19.51a12,12,0,0,0,17,17l40-40A12,12,0,0,0,232.49,119.51Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M224,56V200a16,16,0,0,1-16,16H48V40H208A16,16,0,0,1,224,56Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M120,216a8,8,0,0,1-8,8H48a8,8,0,0,1-8-8V40a8,8,0,0,1,8-8h64a8,8,0,0,1,0,16H56V208h56A8,8,0,0,1,120,216Zm109.66-93.66-40-40a8,8,0,0,0-11.32,11.32L204.69,120H112a8,8,0,0,0,0,16h92.69l-26.35,26.34a8,8,0,0,0,11.32,11.32l40-40A8,8,0,0,0,229.66,122.34Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M120,216a8,8,0,0,1-8,8H48a8,8,0,0,1-8-8V40a8,8,0,0,1,8-8h64a8,8,0,0,1,0,16H56V208h56A8,8,0,0,1,120,216Zm109.66-93.66-40-40A8,8,0,0,0,176,88v32H112a8,8,0,0,0,0,16h64v32a8,8,0,0,0,13.66,5.66l40-40A8,8,0,0,0,229.66,122.34Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M118,216a6,6,0,0,1-6,6H48a6,6,0,0,1-6-6V40a6,6,0,0,1,6-6h64a6,6,0,0,1,0,12H54V210h58A6,6,0,0,1,118,216Zm110.24-92.24-40-40a6,6,0,0,0-8.48,8.48L209.51,122H112a6,6,0,0,0,0,12h97.51l-29.75,29.76a6,6,0,1,0,8.48,8.48l40-40A6,6,0,0,0,228.24,123.76Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M120,216a8,8,0,0,1-8,8H48a8,8,0,0,1-8-8V40a8,8,0,0,1,8-8h64a8,8,0,0,1,0,16H56V208h56A8,8,0,0,1,120,216Zm109.66-93.66-40-40a8,8,0,0,0-11.32,11.32L204.69,120H112a8,8,0,0,0,0,16h92.69l-26.35,26.34a8,8,0,0,0,11.32,11.32l40-40A8,8,0,0,0,229.66,122.34Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M116,216a4,4,0,0,1-4,4H48a4,4,0,0,1-4-4V40a4,4,0,0,1,4-4h64a4,4,0,0,1,0,8H52V212h60A4,4,0,0,1,116,216Zm110.83-90.83-40-40a4,4,0,0,0-5.66,5.66L214.34,124H112a4,4,0,0,0,0,8H214.34l-33.17,33.17a4,4,0,0,0,5.66,5.66l40-40A4,4,0,0,0,226.83,125.17Z" }))]
]);
var l$2 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M10.05,110.42l112,64a12,12,0,0,0,11.9,0l112-64a12,12,0,0,0,0-20.84l-112-64a12,12,0,0,0-11.9,0l-112,64a12,12,0,0,0,0,20.84Zm118-60.6L215.81,100,128,150.18,40.19,100Zm122.42,92.23A12,12,0,0,1,246,158.42l-112,64a12,12,0,0,1-11.9,0l-112-64A12,12,0,1,1,22,137.58l106,60.6,106-60.6A12,12,0,0,1,250.42,142.05Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M240,104,128,168,16,104,128,40Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M12,111l112,64a8,8,0,0,0,7.94,0l112-64a8,8,0,0,0,0-13.9l-112-64a8,8,0,0,0-7.94,0l-112,64A8,8,0,0,0,12,111ZM128,49.21,223.87,104,128,158.79,32.13,104ZM247,140A8,8,0,0,1,244,151L132,215a8,8,0,0,1-7.94,0L12,151A8,8,0,1,1,20,137.05l108,61.74,108-61.74A8,8,0,0,1,247,140Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M12,111l112,64a8,8,0,0,0,7.94,0l112-64a8,8,0,0,0,0-13.9l-112-64a8,8,0,0,0-7.94,0l-112,64A8,8,0,0,0,12,111Z" }), /* @__PURE__ */ _("path", { d: "M236,137.05,128,198.79,20,137.05A8,8,0,1,0,12,151l112,64a8,8,0,0,0,7.94,0l112-64a8,8,0,1,0-7.94-13.9Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M13,109.21l112,64a6,6,0,0,0,6,0l112-64a6,6,0,0,0,0-10.42l-112-64a6,6,0,0,0-6,0l-112,64a6,6,0,0,0,0,10.42Zm115-62.3L227.91,104,128,161.09,28.09,104ZM245.21,141a6,6,0,0,1-2.23,8.19l-112,64a6,6,0,0,1-6,0l-112-64a6,6,0,0,1,6-10.42l109,62.3,109-62.3A6,6,0,0,1,245.21,141Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M12,111l112,64a8,8,0,0,0,7.94,0l112-64a8,8,0,0,0,0-13.9l-112-64a8,8,0,0,0-7.94,0l-112,64A8,8,0,0,0,12,111ZM128,49.21,223.87,104,128,158.79,32.13,104ZM246.94,140A8,8,0,0,1,244,151L132,215a8,8,0,0,1-7.94,0L12,151A8,8,0,0,1,20,137.05l108,61.74,108-61.74A8,8,0,0,1,246.94,140Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M14,107.47l112,64a4,4,0,0,0,4,0l112-64a4,4,0,0,0,0-6.94l-112-64a4,4,0,0,0-4,0l-112,64a4,4,0,0,0,0,6.94ZM128,44.61,231.94,104,128,163.39,24.06,104ZM243.47,142a4,4,0,0,1-1.49,5.45l-112,64a4,4,0,0,1-4,0l-112-64a4,4,0,0,1,4-6.94l110,62.86,110-62.86A4,4,0,0,1,243.47,142Z" }))]
]);
var l$1 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M243,96a20.33,20.33,0,0,0-17.74-14l-56.59-4.57L146.83,24.62a20.36,20.36,0,0,0-37.66,0L87.35,77.44,30.76,82A20.45,20.45,0,0,0,19.1,117.88l43.18,37.24-13.2,55.7A20.37,20.37,0,0,0,79.57,233L128,203.19,176.43,233a20.39,20.39,0,0,0,30.49-22.15l-13.2-55.7,43.18-37.24A20.43,20.43,0,0,0,243,96ZM172.53,141.7a12,12,0,0,0-3.84,11.86L181.58,208l-47.29-29.08a12,12,0,0,0-12.58,0L74.42,208l12.89-54.4a12,12,0,0,0-3.84-11.86L41.2,105.24l55.4-4.47a12,12,0,0,0,10.13-7.38L128,41.89l21.27,51.5a12,12,0,0,0,10.13,7.38l55.4,4.47Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M229.06,108.79l-48.7,42,14.88,62.79a8.4,8.4,0,0,1-12.52,9.17L128,189.09,73.28,222.74a8.4,8.4,0,0,1-12.52-9.17l14.88-62.79-48.7-42A8.46,8.46,0,0,1,31.73,94L95.64,88.8l24.62-59.6a8.36,8.36,0,0,1,15.48,0l24.62,59.6L224.27,94A8.46,8.46,0,0,1,229.06,108.79Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M239.18,97.26A16.38,16.38,0,0,0,224.92,86l-59-4.76L143.14,26.15a16.36,16.36,0,0,0-30.27,0L90.11,81.23,31.08,86a16.46,16.46,0,0,0-9.37,28.86l45,38.83L53,211.75a16.38,16.38,0,0,0,24.5,17.82L128,198.49l50.53,31.08A16.4,16.4,0,0,0,203,211.75l-13.76-58.07,45-38.83A16.43,16.43,0,0,0,239.18,97.26Zm-15.34,5.47-48.7,42a8,8,0,0,0-2.56,7.91l14.88,62.8a.37.37,0,0,1-.17.48c-.18.14-.23.11-.38,0l-54.72-33.65a8,8,0,0,0-8.38,0L69.09,215.94c-.15.09-.19.12-.38,0a.37.37,0,0,1-.17-.48l14.88-62.8a8,8,0,0,0-2.56-7.91l-48.7-42c-.12-.1-.23-.19-.13-.5s.18-.27.33-.29l63.92-5.16A8,8,0,0,0,103,91.86l24.62-59.61c.08-.17.11-.25.35-.25s.27.08.35.25L153,91.86a8,8,0,0,0,6.75,4.92l63.92,5.16c.15,0,.24,0,.33.29S224,102.63,223.84,102.73Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M234.29,114.85l-45,38.83L203,211.75a16.4,16.4,0,0,1-24.5,17.82L128,198.49,77.47,229.57A16.4,16.4,0,0,1,53,211.75l13.76-58.07-45-38.83A16.46,16.46,0,0,1,31.08,86l59-4.76,22.76-55.08a16.36,16.36,0,0,1,30.27,0l22.75,55.08,59,4.76a16.46,16.46,0,0,1,9.37,28.86Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M237.28,97.87A14.18,14.18,0,0,0,224.76,88l-60.25-4.87-23.22-56.2a14.37,14.37,0,0,0-26.58,0L91.49,83.11,31.24,88a14.18,14.18,0,0,0-12.52,9.89A14.43,14.43,0,0,0,23,113.32L69,152.93l-14,59.25a14.4,14.4,0,0,0,5.59,15,14.1,14.1,0,0,0,15.91.6L128,196.12l51.58,31.71a14.1,14.1,0,0,0,15.91-.6,14.4,14.4,0,0,0,5.59-15l-14-59.25L233,113.32A14.43,14.43,0,0,0,237.28,97.87Zm-12.14,6.37-48.69,42a6,6,0,0,0-1.92,5.92l14.88,62.79a2.35,2.35,0,0,1-.95,2.57,2.24,2.24,0,0,1-2.6.1L131.14,184a6,6,0,0,0-6.28,0L70.14,217.61a2.24,2.24,0,0,1-2.6-.1,2.35,2.35,0,0,1-1-2.57l14.88-62.79a6,6,0,0,0-1.92-5.92l-48.69-42a2.37,2.37,0,0,1-.73-2.65,2.28,2.28,0,0,1,2.07-1.65l63.92-5.16a6,6,0,0,0,5.06-3.69l24.63-59.6a2.35,2.35,0,0,1,4.38,0l24.63,59.6a6,6,0,0,0,5.06,3.69l63.92,5.16a2.28,2.28,0,0,1,2.07,1.65A2.37,2.37,0,0,1,225.14,104.24Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M239.18,97.26A16.38,16.38,0,0,0,224.92,86l-59-4.76L143.14,26.15a16.36,16.36,0,0,0-30.27,0L90.11,81.23,31.08,86a16.46,16.46,0,0,0-9.37,28.86l45,38.83L53,211.75a16.38,16.38,0,0,0,24.5,17.82L128,198.49l50.53,31.08A16.4,16.4,0,0,0,203,211.75l-13.76-58.07,45-38.83A16.43,16.43,0,0,0,239.18,97.26Zm-15.34,5.47-48.7,42a8,8,0,0,0-2.56,7.91l14.88,62.8a.37.37,0,0,1-.17.48c-.18.14-.23.11-.38,0l-54.72-33.65a8,8,0,0,0-8.38,0L69.09,215.94c-.15.09-.19.12-.38,0a.37.37,0,0,1-.17-.48l14.88-62.8a8,8,0,0,0-2.56-7.91l-48.7-42c-.12-.1-.23-.19-.13-.5s.18-.27.33-.29l63.92-5.16A8,8,0,0,0,103,91.86l24.62-59.61c.08-.17.11-.25.35-.25s.27.08.35.25L153,91.86a8,8,0,0,0,6.75,4.92l63.92,5.16c.15,0,.24,0,.33.29S224,102.63,223.84,102.73Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M235.36,98.49A12.21,12.21,0,0,0,224.59,90l-61.47-5L139.44,27.67a12.37,12.37,0,0,0-22.88,0L92.88,85,31.41,90a12.45,12.45,0,0,0-7.07,21.84l46.85,40.41L56.87,212.64a12.35,12.35,0,0,0,18.51,13.49L128,193.77l52.62,32.36a12.12,12.12,0,0,0,13.69-.51,12.28,12.28,0,0,0,4.82-13l-14.32-60.42,46.85-40.41A12.29,12.29,0,0,0,235.36,98.49Zm-8.93,7.26-48.68,42a4,4,0,0,0-1.28,3.95l14.87,62.79a4.37,4.37,0,0,1-1.72,4.65,4.24,4.24,0,0,1-4.81.18L130.1,185.67a4,4,0,0,0-4.2,0L71.19,219.32a4.24,4.24,0,0,1-4.81-.18,4.37,4.37,0,0,1-1.72-4.65L79.53,151.7a4,4,0,0,0-1.28-3.95l-48.68-42A4.37,4.37,0,0,1,28.25,101a4.31,4.31,0,0,1,3.81-3L96,92.79a4,4,0,0,0,3.38-2.46L124,30.73a4.35,4.35,0,0,1,8.08,0l24.62,59.6A4,4,0,0,0,160,92.79l63.9,5.15a4.31,4.31,0,0,1,3.81,3A4.37,4.37,0,0,1,226.43,105.75Z" }))]
]);
var a$10 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M128,20A108,108,0,1,0,236,128,108.12,108.12,0,0,0,128,20Zm0,192a84,84,0,1,1,84-84A84.09,84.09,0,0,1,128,212Zm40-112v56a12,12,0,0,1-12,12H100a12,12,0,0,1-12-12V100a12,12,0,0,1,12-12h56A12,12,0,0,1,168,100Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M128,32a96,96,0,1,0,96,96A96,96,0,0,0,128,32Zm32,128H96V96h64Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M128,24A104,104,0,1,0,232,128,104.11,104.11,0,0,0,128,24Zm0,192a88,88,0,1,1,88-88A88.1,88.1,0,0,1,128,216ZM160,88H96a8,8,0,0,0-8,8v64a8,8,0,0,0,8,8h64a8,8,0,0,0,8-8V96A8,8,0,0,0,160,88Zm-8,64H104V104h48Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M128,24A104,104,0,1,0,232,128,104.11,104.11,0,0,0,128,24Zm32,132a4,4,0,0,1-4,4H100a4,4,0,0,1-4-4V100a4,4,0,0,1,4-4h56a4,4,0,0,1,4,4Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M128,26A102,102,0,1,0,230,128,102.12,102.12,0,0,0,128,26Zm0,192a90,90,0,1,1,90-90A90.1,90.1,0,0,1,128,218ZM160,90H96a6,6,0,0,0-6,6v64a6,6,0,0,0,6,6h64a6,6,0,0,0,6-6V96A6,6,0,0,0,160,90Zm-6,64H102V102h52Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M128,24A104,104,0,1,0,232,128,104.11,104.11,0,0,0,128,24Zm0,192a88,88,0,1,1,88-88A88.1,88.1,0,0,1,128,216ZM160,88H96a8,8,0,0,0-8,8v64a8,8,0,0,0,8,8h64a8,8,0,0,0,8-8V96A8,8,0,0,0,160,88Zm-8,64H104V104h48Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M128,28A100,100,0,1,0,228,128,100.11,100.11,0,0,0,128,28Zm0,192a92,92,0,1,1,92-92A92.1,92.1,0,0,1,128,220ZM160,92H96a4,4,0,0,0-4,4v64a4,4,0,0,0,4,4h64a4,4,0,0,0,4-4V96A4,4,0,0,0,160,92Zm-4,64H100V100h56Z" }))]
]);
var a$9 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M120,137,48,201A12,12,0,1,1,32,183l61.91-55L32,73A12,12,0,1,1,48,55l72,64A12,12,0,0,1,120,137Zm96,43H120a12,12,0,0,0,0,24h96a12,12,0,0,0,0-24Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M216,80V192H40V64H200A16,16,0,0,1,216,80Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M117.31,134l-72,64a8,8,0,1,1-10.63-12L100,128,34.69,70A8,8,0,1,1,45.32,58l72,64a8,8,0,0,1,0,12ZM216,184H120a8,8,0,0,0,0,16h96a8,8,0,0,0,0-16Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M216,40H40A16,16,0,0,0,24,56V200a16,16,0,0,0,16,16H216a16,16,0,0,0,16-16V56A16,16,0,0,0,216,40ZM77.66,173.66a8,8,0,0,1-11.32-11.32L100.69,128,66.34,93.66A8,8,0,0,1,77.66,82.34l40,40a8,8,0,0,1,0,11.32ZM192,176H128a8,8,0,0,1,0-16h64a8,8,0,0,1,0,16Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M116,132.48l-72,64a6,6,0,0,1-8-9L103,128,36,68.49a6,6,0,0,1,8-9l72,64a6,6,0,0,1,0,9ZM216,186H120a6,6,0,0,0,0,12h96a6,6,0,0,0,0-12Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M117.31,134l-72,64a8,8,0,1,1-10.63-12L100,128,34.69,70A8,8,0,1,1,45.32,58l72,64a8,8,0,0,1,0,12ZM216,184H120a8,8,0,0,0,0,16h96a8,8,0,0,0,0-16Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M116,128a4,4,0,0,1-1.34,3l-72,64a4,4,0,1,1-5.32-6L106,128,37.34,67a4,4,0,0,1,5.32-6l72,64A4,4,0,0,1,116,128Zm100,60H120a4,4,0,0,0,0,8h96a4,4,0,0,0,0-8Z" }))]
]);
var a$8 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M240.49,83.51l-60-60a12,12,0,0,0-17,0L34.28,152.75a48.77,48.77,0,0,0,69,69L214.48,110.49l21.31-7.11a12,12,0,0,0,4.7-19.87ZM86.28,204.75a24.77,24.77,0,0,1-35-35l28.13-28.13c7.73-2.41,19.58-3,35.06,5a83.94,83.94,0,0,0,21.95,8ZM204.2,88.62a12.15,12.15,0,0,0-4.69,2.89l-38.89,38.9c-7.73,2.41-19.58,3-35.06-5a83.94,83.94,0,0,0-21.94-8L172,49l37.79,37.79Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M167.18,140.82,94.77,213.23a36.77,36.77,0,0,1-52,0h0a36.77,36.77,0,0,1,0-52l30-30c9.37-3.65,25.78-6.36,47.18,4.82S157.81,144.47,167.18,140.82Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M237.66,86.34l-60-60a8,8,0,0,0-11.32,0L37.11,155.57a44.77,44.77,0,0,0,63.32,63.32L212.32,107l22.21-7.4a8,8,0,0,0,3.13-13.25ZM89.11,207.57a28.77,28.77,0,0,1-40.68-40.68l28.8-28.8c8.47-2.9,21.75-4,39.07,5,10.6,5.54,20.18,8,28.56,8.73ZM205.47,92.41a8,8,0,0,0-3.13,1.93l-39.57,39.57c-8.47,2.9-21.75,4-39.07-5-10.6-5.54-20.18-8-28.56-8.73L172,43.31,217.19,88.5Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M237.66,86.34l-60-60a8,8,0,0,0-11.32,0L37.11,155.57a44.77,44.77,0,0,0,63.32,63.32L212.32,107l22.21-7.4a8,8,0,0,0,3.13-13.25Zm-32.19,6.07a8,8,0,0,0-3.13,1.93l-39.57,39.57c-8.47,2.9-21.75,4-39.07-5-10.6-5.54-20.18-8-28.56-8.73L172,43.31,217.19,88.5Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M236.24,87.76l-60-60a6,6,0,0,0-8.48,0L38.53,157A42.77,42.77,0,1,0,99,217.47L211.24,105.24l22.66-7.55a6,6,0,0,0,2.34-9.93ZM90.53,209A30.77,30.77,0,1,1,47,165.47l29.13-29.12c8.84-3.14,22.84-4.56,41.08,5,12.28,6.41,23.13,8.66,32.27,8.71ZM206.1,94.31a6,6,0,0,0-2.34,1.45l-39.9,39.89c-8.84,3.14-22.84,4.56-41.08-5C110.5,124.27,99.65,122,90.51,122L172,40.49l48.89,48.89Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M237.66,86.34l-60-60a8,8,0,0,0-11.32,0L37.11,155.57a44.77,44.77,0,0,0,63.32,63.32L212.32,107l22.21-7.4a8,8,0,0,0,3.13-13.25ZM89.11,207.57a28.77,28.77,0,0,1-40.68-40.68l28.8-28.8c8.47-2.9,21.75-4,39.07,5,10.6,5.54,20.18,8,28.56,8.73ZM205.47,92.41a8,8,0,0,0-3.13,1.93l-39.57,39.57c-8.47,2.9-21.75,4-39.07-5-10.6-5.54-20.18-8-28.56-8.73L172,43.31,217.19,88.5Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M234.83,89.18l-60-60a4,4,0,0,0-5.66,0L39.94,158.41A40.78,40.78,0,0,0,97.6,216.08L210.16,103.5l23.1-7.7a4,4,0,0,0,1.57-6.62ZM91.94,210.42A32.77,32.77,0,1,1,45.6,164.07L75,134.63c9.2-3.38,23.94-5.08,43.11,4.93,12.09,6.31,22.74,8.48,31.66,8.48,1.64,0,3.2-.09,4.73-.22ZM206.74,96.21a4.06,4.06,0,0,0-1.57,1L165,137.39c-9.2,3.38-23.94,5.08-43.11-4.93-14.3-7.47-26.58-9.13-36.38-8.27L172,37.66l52.6,52.6Z" }))]
]);
var e$26 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M216,48H180V36A28,28,0,0,0,152,8H104A28,28,0,0,0,76,36V48H40a12,12,0,0,0,0,24h4V208a20,20,0,0,0,20,20H192a20,20,0,0,0,20-20V72h4a12,12,0,0,0,0-24ZM100,36a4,4,0,0,1,4-4h48a4,4,0,0,1,4,4V48H100Zm88,168H68V72H188ZM116,104v64a12,12,0,0,1-24,0V104a12,12,0,0,1,24,0Zm48,0v64a12,12,0,0,1-24,0V104a12,12,0,0,1,24,0Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M200,56V208a8,8,0,0,1-8,8H64a8,8,0,0,1-8-8V56Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M216,48H176V40a24,24,0,0,0-24-24H104A24,24,0,0,0,80,40v8H40a8,8,0,0,0,0,16h8V208a16,16,0,0,0,16,16H192a16,16,0,0,0,16-16V64h8a8,8,0,0,0,0-16ZM96,40a8,8,0,0,1,8-8h48a8,8,0,0,1,8,8v8H96Zm96,168H64V64H192ZM112,104v64a8,8,0,0,1-16,0V104a8,8,0,0,1,16,0Zm48,0v64a8,8,0,0,1-16,0V104a8,8,0,0,1,16,0Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M216,48H176V40a24,24,0,0,0-24-24H104A24,24,0,0,0,80,40v8H40a8,8,0,0,0,0,16h8V208a16,16,0,0,0,16,16H192a16,16,0,0,0,16-16V64h8a8,8,0,0,0,0-16ZM112,168a8,8,0,0,1-16,0V104a8,8,0,0,1,16,0Zm48,0a8,8,0,0,1-16,0V104a8,8,0,0,1,16,0Zm0-120H96V40a8,8,0,0,1,8-8h48a8,8,0,0,1,8,8Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M216,50H174V40a22,22,0,0,0-22-22H104A22,22,0,0,0,82,40V50H40a6,6,0,0,0,0,12H50V208a14,14,0,0,0,14,14H192a14,14,0,0,0,14-14V62h10a6,6,0,0,0,0-12ZM94,40a10,10,0,0,1,10-10h48a10,10,0,0,1,10,10V50H94ZM194,208a2,2,0,0,1-2,2H64a2,2,0,0,1-2-2V62H194ZM110,104v64a6,6,0,0,1-12,0V104a6,6,0,0,1,12,0Zm48,0v64a6,6,0,0,1-12,0V104a6,6,0,0,1,12,0Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M216,48H176V40a24,24,0,0,0-24-24H104A24,24,0,0,0,80,40v8H40a8,8,0,0,0,0,16h8V208a16,16,0,0,0,16,16H192a16,16,0,0,0,16-16V64h8a8,8,0,0,0,0-16ZM96,40a8,8,0,0,1,8-8h48a8,8,0,0,1,8,8v8H96Zm96,168H64V64H192ZM112,104v64a8,8,0,0,1-16,0V104a8,8,0,0,1,16,0Zm48,0v64a8,8,0,0,1-16,0V104a8,8,0,0,1,16,0Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M216,52H172V40a20,20,0,0,0-20-20H104A20,20,0,0,0,84,40V52H40a4,4,0,0,0,0,8H52V208a12,12,0,0,0,12,12H192a12,12,0,0,0,12-12V60h12a4,4,0,0,0,0-8ZM92,40a12,12,0,0,1,12-12h48a12,12,0,0,1,12,12V52H92ZM196,208a4,4,0,0,1-4,4H64a4,4,0,0,1-4-4V60H196ZM108,104v64a4,4,0,0,1-8,0V104a4,4,0,0,1,8,0Zm48,0v64a4,4,0,0,1-8,0V104a4,4,0,0,1,8,0Z" }))]
]);
var e$25 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M228,144v64a12,12,0,0,1-12,12H40a12,12,0,0,1-12-12V144a12,12,0,0,1,24,0v52H204V144a12,12,0,0,1,24,0ZM96.49,80.49,116,61v83a12,12,0,0,0,24,0V61l19.51,19.52a12,12,0,1,0,17-17l-40-40a12,12,0,0,0-17,0l-40,40a12,12,0,1,0,17,17Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M216,48V208H40V48A16,16,0,0,1,56,32H200A16,16,0,0,1,216,48Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M224,144v64a8,8,0,0,1-8,8H40a8,8,0,0,1-8-8V144a8,8,0,0,1,16,0v56H208V144a8,8,0,0,1,16,0ZM93.66,77.66,120,51.31V144a8,8,0,0,0,16,0V51.31l26.34,26.35a8,8,0,0,0,11.32-11.32l-40-40a8,8,0,0,0-11.32,0l-40,40A8,8,0,0,0,93.66,77.66Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M224,144v64a8,8,0,0,1-8,8H40a8,8,0,0,1-8-8V144a8,8,0,0,1,16,0v56H208V144a8,8,0,0,1,16,0ZM88,80h32v64a8,8,0,0,0,16,0V80h32a8,8,0,0,0,5.66-13.66l-40-40a8,8,0,0,0-11.32,0l-40,40A8,8,0,0,0,88,80Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M222,144v64a6,6,0,0,1-6,6H40a6,6,0,0,1-6-6V144a6,6,0,0,1,12,0v58H210V144a6,6,0,0,1,12,0ZM92.24,76.24,122,46.49V144a6,6,0,0,0,12,0V46.49l29.76,29.75a6,6,0,0,0,8.48-8.48l-40-40a6,6,0,0,0-8.48,0l-40,40a6,6,0,0,0,8.48,8.48Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M224,144v64a8,8,0,0,1-8,8H40a8,8,0,0,1-8-8V144a8,8,0,0,1,16,0v56H208V144a8,8,0,0,1,16,0ZM93.66,77.66,120,51.31V144a8,8,0,0,0,16,0V51.31l26.34,26.35a8,8,0,0,0,11.32-11.32l-40-40a8,8,0,0,0-11.32,0l-40,40A8,8,0,0,0,93.66,77.66Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M220,144v64a4,4,0,0,1-4,4H40a4,4,0,0,1-4-4V144a4,4,0,0,1,8,0v60H212V144a4,4,0,0,1,8,0ZM90.83,74.83,124,41.66V144a4,4,0,0,0,8,0V41.66l33.17,33.17a4,4,0,1,0,5.66-5.66l-40-40a4,4,0,0,0-5.66,0l-40,40a4,4,0,0,0,5.66,5.66Z" }))]
]);
var a$7 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M234.38,210a123.36,123.36,0,0,0-60.78-53.23,76,76,0,1,0-91.2,0A123.36,123.36,0,0,0,21.62,210a12,12,0,1,0,20.77,12c18.12-31.32,50.12-50,85.61-50s67.49,18.69,85.61,50a12,12,0,0,0,20.77-12ZM76,96a52,52,0,1,1,52,52A52.06,52.06,0,0,1,76,96Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M192,96a64,64,0,1,1-64-64A64,64,0,0,1,192,96Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M230.92,212c-15.23-26.33-38.7-45.21-66.09-54.16a72,72,0,1,0-73.66,0C63.78,166.78,40.31,185.66,25.08,212a8,8,0,1,0,13.85,8c18.84-32.56,52.14-52,89.07-52s70.23,19.44,89.07,52a8,8,0,1,0,13.85-8ZM72,96a56,56,0,1,1,56,56A56.06,56.06,0,0,1,72,96Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M230.93,220a8,8,0,0,1-6.93,4H32a8,8,0,0,1-6.92-12c15.23-26.33,38.7-45.21,66.09-54.16a72,72,0,1,1,73.66,0c27.39,8.95,50.86,27.83,66.09,54.16A8,8,0,0,1,230.93,220Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M229.19,213c-15.81-27.32-40.63-46.49-69.47-54.62a70,70,0,1,0-63.44,0C67.44,166.5,42.62,185.67,26.81,213a6,6,0,1,0,10.38,6C56.4,185.81,90.34,166,128,166s71.6,19.81,90.81,53a6,6,0,1,0,10.38-6ZM70,96a58,58,0,1,1,58,58A58.07,58.07,0,0,1,70,96Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M230.92,212c-15.23-26.33-38.7-45.21-66.09-54.16a72,72,0,1,0-73.66,0C63.78,166.78,40.31,185.66,25.08,212a8,8,0,1,0,13.85,8c18.84-32.56,52.14-52,89.07-52s70.23,19.44,89.07,52a8,8,0,1,0,13.85-8ZM72,96a56,56,0,1,1,56,56A56.06,56.06,0,0,1,72,96Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M227.46,214c-16.52-28.56-43-48.06-73.68-55.09a68,68,0,1,0-51.56,0c-30.64,7-57.16,26.53-73.68,55.09a4,4,0,0,0,6.92,4C55,184.19,89.62,164,128,164s73,20.19,92.54,54a4,4,0,0,0,3.46,2,3.93,3.93,0,0,0,2-.54A4,4,0,0,0,227.46,214ZM68,96a60,60,0,1,1,60,60A60.07,60.07,0,0,1,68,96Z" }))]
]);
var a$6 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M128,20A108,108,0,1,0,236,128,108.12,108.12,0,0,0,128,20ZM79.57,196.57a60,60,0,0,1,96.86,0,83.72,83.72,0,0,1-96.86,0ZM100,120a28,28,0,1,1,28,28A28,28,0,0,1,100,120ZM194,179.94a83.48,83.48,0,0,0-29-23.42,52,52,0,1,0-74,0,83.48,83.48,0,0,0-29,23.42,84,84,0,1,1,131.9,0Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M224,128a95.76,95.76,0,0,1-31.8,71.37A72,72,0,0,0,128,160a40,40,0,1,0-40-40,40,40,0,0,0,40,40,72,72,0,0,0-64.2,39.37h0A96,96,0,1,1,224,128Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M128,24A104,104,0,1,0,232,128,104.11,104.11,0,0,0,128,24ZM74.08,197.5a64,64,0,0,1,107.84,0,87.83,87.83,0,0,1-107.84,0ZM96,120a32,32,0,1,1,32,32A32,32,0,0,1,96,120Zm97.76,66.41a79.66,79.66,0,0,0-36.06-28.75,48,48,0,1,0-59.4,0,79.66,79.66,0,0,0-36.06,28.75,88,88,0,1,1,131.52,0Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M172,120a44,44,0,1,1-44-44A44.05,44.05,0,0,1,172,120Zm60,8A104,104,0,1,1,128,24,104.11,104.11,0,0,1,232,128Zm-16,0a88.09,88.09,0,0,0-91.47-87.93C77.43,41.89,39.87,81.12,40,128.25a87.65,87.65,0,0,0,22.24,58.16A79.71,79.71,0,0,1,84,165.1a4,4,0,0,1,4.83.32,59.83,59.83,0,0,0,78.28,0,4,4,0,0,1,4.83-.32,79.71,79.71,0,0,1,21.79,21.31A87.62,87.62,0,0,0,216,128Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M128,26A102,102,0,1,0,230,128,102.12,102.12,0,0,0,128,26ZM71.44,198a66,66,0,0,1,113.12,0,89.8,89.8,0,0,1-113.12,0ZM94,120a34,34,0,1,1,34,34A34,34,0,0,1,94,120Zm99.51,69.64a77.53,77.53,0,0,0-40-31.38,46,46,0,1,0-51,0,77.53,77.53,0,0,0-40,31.38,90,90,0,1,1,131,0Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M128,24A104,104,0,1,0,232,128,104.11,104.11,0,0,0,128,24ZM74.08,197.5a64,64,0,0,1,107.84,0,87.83,87.83,0,0,1-107.84,0ZM96,120a32,32,0,1,1,32,32A32,32,0,0,1,96,120Zm97.76,66.41a79.66,79.66,0,0,0-36.06-28.75,48,48,0,1,0-59.4,0,79.66,79.66,0,0,0-36.06,28.75,88,88,0,1,1,131.52,0Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M128,28A100,100,0,1,0,228,128,100.11,100.11,0,0,0,128,28ZM68.87,198.42a68,68,0,0,1,118.26,0,91.8,91.8,0,0,1-118.26,0Zm124.3-5.55a75.61,75.61,0,0,0-44.51-34,44,44,0,1,0-41.32,0,75.61,75.61,0,0,0-44.51,34,92,92,0,1,1,130.34,0ZM128,156a36,36,0,1,1,36-36A36,36,0,0,1,128,156Z" }))]
]);
var e$24 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M256,136a12,12,0,0,1-12,12h-8v8a12,12,0,0,1-24,0v-8h-8a12,12,0,0,1,0-24h8v-8a12,12,0,0,1,24,0v8h8A12,12,0,0,1,256,136Zm-54.81,56.28a12,12,0,1,1-18.38,15.44C169.12,191.42,145,172,108,172c-28.89,0-55.46,12.68-74.81,35.72a12,12,0,0,1-18.38-15.44A124.08,124.08,0,0,1,63.5,156.53a72,72,0,1,1,89,0A124,124,0,0,1,201.19,192.28ZM108,148a48,48,0,1,0-48-48A48.05,48.05,0,0,0,108,148Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M168,100a60,60,0,1,1-60-60A60,60,0,0,1,168,100Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M256,136a8,8,0,0,1-8,8H232v16a8,8,0,0,1-16,0V144H200a8,8,0,0,1,0-16h16V112a8,8,0,0,1,16,0v16h16A8,8,0,0,1,256,136Zm-57.87,58.85a8,8,0,0,1-12.26,10.3C165.75,181.19,138.09,168,108,168s-57.75,13.19-77.87,37.15a8,8,0,0,1-12.25-10.3c14.94-17.78,33.52-30.41,54.17-37.17a68,68,0,1,1,71.9,0C164.6,164.44,183.18,177.07,198.13,194.85ZM108,152a52,52,0,1,0-52-52A52.06,52.06,0,0,0,108,152Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M256,136a8,8,0,0,1-8,8H232v16a8,8,0,0,1-16,0V144H200a8,8,0,0,1,0-16h16V112a8,8,0,0,1,16,0v16h16A8,8,0,0,1,256,136ZM144,157.68a68,68,0,1,0-71.9,0c-20.65,6.76-39.23,19.39-54.17,37.17A8,8,0,0,0,24,208H192a8,8,0,0,0,6.13-13.15C183.18,177.07,164.6,164.44,144,157.68Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M254,136a6,6,0,0,1-6,6H230v18a6,6,0,0,1-12,0V142H200a6,6,0,0,1,0-12h18V112a6,6,0,0,1,12,0v18h18A6,6,0,0,1,254,136Zm-57.41,60.14a6,6,0,1,1-9.18,7.72C166.9,179.45,138.69,166,108,166s-58.89,13.45-79.41,37.86a6,6,0,0,1-9.18-7.72C35.14,177.41,55,164.48,77,158.25a66,66,0,1,1,62,0C161,164.48,180.86,177.41,196.59,196.14ZM108,154a54,54,0,1,0-54-54A54.06,54.06,0,0,0,108,154Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M256,136a8,8,0,0,1-8,8H232v16a8,8,0,0,1-16,0V144H200a8,8,0,0,1,0-16h16V112a8,8,0,0,1,16,0v16h16A8,8,0,0,1,256,136Zm-57.87,58.85a8,8,0,0,1-12.26,10.3C165.75,181.19,138.09,168,108,168s-57.75,13.19-77.87,37.15a8,8,0,0,1-12.25-10.3c14.94-17.78,33.52-30.41,54.17-37.17a68,68,0,1,1,71.9,0C164.6,164.44,183.18,177.07,198.13,194.85ZM108,152a52,52,0,1,0-52-52A52.06,52.06,0,0,0,108,152Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M252,136a4,4,0,0,1-4,4H228v20a4,4,0,0,1-8,0V140H200a4,4,0,0,1,0-8h20V112a4,4,0,0,1,8,0v20h20A4,4,0,0,1,252,136Zm-56.94,61.43a4,4,0,0,1-6.12,5.14C168,177.7,139.3,164,108,164s-60,13.7-80.94,38.57a4,4,0,1,1-6.12-5.14c16.71-19.9,38.13-33.13,61.89-38.59a64,64,0,1,1,50.34,0C156.93,164.3,178.35,177.53,195.06,197.43ZM108,156a56,56,0,1,0-56-56A56.06,56.06,0,0,0,108,156Z" }))]
]);
var e$23 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M164.38,181.1a52,52,0,1,0-72.76,0,75.89,75.89,0,0,0-30,28.89,12,12,0,0,0,20.78,12,53,53,0,0,1,91.22,0,12,12,0,1,0,20.78-12A75.89,75.89,0,0,0,164.38,181.1ZM100,144a28,28,0,1,1,28,28A28,28,0,0,1,100,144Zm147.21,9.59a12,12,0,0,1-16.81-2.39c-8.33-11.09-19.85-19.59-29.33-21.64a12,12,0,0,1-1.82-22.91,20,20,0,1,0-24.78-28.3,12,12,0,1,1-21-11.6,44,44,0,1,1,73.28,48.35,92.18,92.18,0,0,1,22.85,21.69A12,12,0,0,1,247.21,153.59Zm-192.28-24c-9.48,2.05-21,10.55-29.33,21.65A12,12,0,0,1,6.41,136.79,92.37,92.37,0,0,1,29.26,115.1a44,44,0,1,1,73.28-48.35,12,12,0,1,1-21,11.6,20,20,0,1,0-24.78,28.3,12,12,0,0,1-1.82,22.91Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M168,144a40,40,0,1,1-40-40A40,40,0,0,1,168,144ZM64,56A32,32,0,1,0,96,88,32,32,0,0,0,64,56Zm128,0a32,32,0,1,0,32,32A32,32,0,0,0,192,56Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M244.8,150.4a8,8,0,0,1-11.2-1.6A51.6,51.6,0,0,0,192,128a8,8,0,0,1,0-16,24,24,0,1,0-23.24-30,8,8,0,1,1-15.5-4A40,40,0,1,1,219,117.51a67.94,67.94,0,0,1,27.43,21.68A8,8,0,0,1,244.8,150.4ZM190.92,212a8,8,0,1,1-13.85,8,57,57,0,0,0-98.15,0,8,8,0,1,1-13.84-8,72.06,72.06,0,0,1,33.74-29.92,48,48,0,1,1,58.36,0A72.06,72.06,0,0,1,190.92,212ZM128,176a32,32,0,1,0-32-32A32,32,0,0,0,128,176ZM72,120a8,8,0,0,0-8-8A24,24,0,1,1,87.24,82a8,8,0,1,0,15.5-4A40,40,0,1,0,37,117.51,67.94,67.94,0,0,0,9.6,139.19a8,8,0,1,0,12.8,9.61A51.6,51.6,0,0,1,64,128,8,8,0,0,0,72,120Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M64.12,147.8a4,4,0,0,1-4,4.2H16a8,8,0,0,1-7.8-6.17,8.35,8.35,0,0,1,1.62-6.93A67.79,67.79,0,0,1,37,117.51a40,40,0,1,1,66.46-35.8,3.94,3.94,0,0,1-2.27,4.18A64.08,64.08,0,0,0,64,144C64,145.28,64,146.54,64.12,147.8Zm182-8.91A67.76,67.76,0,0,0,219,117.51a40,40,0,1,0-66.46-35.8,3.94,3.94,0,0,0,2.27,4.18A64.08,64.08,0,0,1,192,144c0,1.28,0,2.54-.12,3.8a4,4,0,0,0,4,4.2H240a8,8,0,0,0,7.8-6.17A8.33,8.33,0,0,0,246.17,138.89Zm-89,43.18a48,48,0,1,0-58.37,0A72.13,72.13,0,0,0,65.07,212,8,8,0,0,0,72,224H184a8,8,0,0,0,6.93-12A72.15,72.15,0,0,0,157.19,182.07Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M243.6,148.8a6,6,0,0,1-8.4-1.2A53.58,53.58,0,0,0,192,126a6,6,0,0,1,0-12,26,26,0,1,0-25.18-32.5,6,6,0,0,1-11.62-3,38,38,0,1,1,59.91,39.63A65.69,65.69,0,0,1,244.8,140.4,6,6,0,0,1,243.6,148.8ZM189.19,213a6,6,0,0,1-2.19,8.2,5.9,5.9,0,0,1-3,.81,6,6,0,0,1-5.2-3,59,59,0,0,0-101.62,0,6,6,0,1,1-10.38-6A70.1,70.1,0,0,1,103,182.55a46,46,0,1,1,50.1,0A70.1,70.1,0,0,1,189.19,213ZM128,178a34,34,0,1,0-34-34A34,34,0,0,0,128,178ZM70,120a6,6,0,0,0-6-6A26,26,0,1,1,89.18,81.49a6,6,0,1,0,11.62-3,38,38,0,1,0-59.91,39.63A65.69,65.69,0,0,0,11.2,140.4a6,6,0,1,0,9.6,7.2A53.58,53.58,0,0,1,64,126,6,6,0,0,0,70,120Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M244.8,150.4a8,8,0,0,1-11.2-1.6A51.6,51.6,0,0,0,192,128a8,8,0,0,1-7.37-4.89,8,8,0,0,1,0-6.22A8,8,0,0,1,192,112a24,24,0,1,0-23.24-30,8,8,0,1,1-15.5-4A40,40,0,1,1,219,117.51a67.94,67.94,0,0,1,27.43,21.68A8,8,0,0,1,244.8,150.4ZM190.92,212a8,8,0,1,1-13.84,8,57,57,0,0,0-98.16,0,8,8,0,1,1-13.84-8,72.06,72.06,0,0,1,33.74-29.92,48,48,0,1,1,58.36,0A72.06,72.06,0,0,1,190.92,212ZM128,176a32,32,0,1,0-32-32A32,32,0,0,0,128,176ZM72,120a8,8,0,0,0-8-8A24,24,0,1,1,87.24,82a8,8,0,1,0,15.5-4A40,40,0,1,0,37,117.51,67.94,67.94,0,0,0,9.6,139.19a8,8,0,1,0,12.8,9.61A51.6,51.6,0,0,1,64,128,8,8,0,0,0,72,120Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M237,147.44a4,4,0,0,1-5.48-1.4c-8.33-14-20.93-22-34.56-22a4,4,0,0,1-1.2-.2,36.76,36.76,0,0,1-3.8.2,4,4,0,0,1,0-8,28,28,0,1,0-27.12-35,4,4,0,0,1-7.75-2,36,36,0,1,1,54,39.48c10.81,3.85,20.51,12,27.31,23.48A4,4,0,0,1,237,147.44ZM187.46,214a4,4,0,0,1-1.46,5.46,3.93,3.93,0,0,1-2,.54,4,4,0,0,1-3.46-2,61,61,0,0,0-105.08,0,4,4,0,0,1-6.92-4,68.35,68.35,0,0,1,39.19-31,44,44,0,1,1,40.54,0A68.35,68.35,0,0,1,187.46,214ZM128,180a36,36,0,1,0-36-36A36,36,0,0,0,128,180ZM64,116A28,28,0,1,1,91.12,81a4,4,0,0,0,7.75-2A36,36,0,1,0,45.3,118.75,63.55,63.55,0,0,0,12.8,141.6a4,4,0,0,0,6.4,4.8A55.55,55.55,0,0,1,64,124a4,4,0,0,0,0-8Z" }))]
]);
var a$5 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M238.29,138.22l-104,64A12,12,0,0,1,116,192V85.47L30.29,138.22a12,12,0,0,1-12.58-20.44l104-64A12,12,0,0,1,140,64V170.53l85.71-52.75a12,12,0,1,1,12.58,20.44Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M128,64v64H24Zm104,64H128v64Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M236.19,134.81l-104,64A8,8,0,0,1,120,192V78.32L28.19,134.81a8,8,0,0,1-8.38-13.62l104-64A8,8,0,0,1,136,64V177.68l91.81-56.49a8,8,0,0,1,8.38,13.62Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M216,40H40A16,16,0,0,0,24,56V200a16,16,0,0,0,16,16H216a16,16,0,0,0,16-16V56A16,16,0,0,0,216,40Zm-11.56,94.66-72,48A8,8,0,0,1,128,184a8,8,0,0,1-8-8V95L60.44,134.66a8,8,0,1,1-8.88-13.32l72-48A8,8,0,0,1,136,80v81.05l59.56-39.71a8,8,0,0,1,8.88,13.32Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M235.14,133.11l-104,64A6,6,0,0,1,122,192V74.74L27.15,133.11a6,6,0,1,1-6.29-10.22l104-64A6,6,0,0,1,134,64V181.26l94.85-58.37a6,6,0,1,1,6.29,10.22Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M236.19,134.81l-104,64A8,8,0,0,1,120,192V78.32L28.19,134.81a8,8,0,0,1-8.38-13.62l104-64A8,8,0,0,1,136,64V177.68l91.81-56.49a8,8,0,0,1,8.38,13.62Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M234.1,131.41l-104,64a4,4,0,0,1-2.1.59,4,4,0,0,1-4-4V71.16L26.1,131.41a4,4,0,0,1-4.2-6.82l104-64A4,4,0,0,1,132,64V184.84l97.9-60.25a4,4,0,1,1,4.2,6.82Z" }))]
]);
var e$22 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M60,96v64a12,12,0,0,1-24,0V96a12,12,0,0,1,24,0ZM88,20A12,12,0,0,0,76,32V224a12,12,0,0,0,24,0V32A12,12,0,0,0,88,20Zm40,32a12,12,0,0,0-12,12V192a12,12,0,0,0,24,0V64A12,12,0,0,0,128,52Zm40,32a12,12,0,0,0-12,12v64a12,12,0,0,0,24,0V96A12,12,0,0,0,168,84Zm40-16a12,12,0,0,0-12,12v96a12,12,0,0,0,24,0V80A12,12,0,0,0,208,68Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M208,96v64H48V96Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M56,96v64a8,8,0,0,1-16,0V96a8,8,0,0,1,16,0ZM88,24a8,8,0,0,0-8,8V224a8,8,0,0,0,16,0V32A8,8,0,0,0,88,24Zm40,32a8,8,0,0,0-8,8V192a8,8,0,0,0,16,0V64A8,8,0,0,0,128,56Zm40,32a8,8,0,0,0-8,8v64a8,8,0,0,0,16,0V96A8,8,0,0,0,168,88Zm40-16a8,8,0,0,0-8,8v96a8,8,0,0,0,16,0V80A8,8,0,0,0,208,72Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M216,40H40A16,16,0,0,0,24,56V200a16,16,0,0,0,16,16H216a16,16,0,0,0,16-16V56A16,16,0,0,0,216,40ZM72,152a8,8,0,0,1-16,0V104a8,8,0,0,1,16,0Zm32,32a8,8,0,0,1-16,0V72a8,8,0,0,1,16,0Zm32-16a8,8,0,0,1-16,0V88a8,8,0,0,1,16,0Zm32-16a8,8,0,0,1-16,0V104a8,8,0,0,1,16,0Zm32,8a8,8,0,0,1-16,0V96a8,8,0,0,1,16,0Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M54,96v64a6,6,0,0,1-12,0V96a6,6,0,0,1,12,0ZM88,26a6,6,0,0,0-6,6V224a6,6,0,0,0,12,0V32A6,6,0,0,0,88,26Zm40,32a6,6,0,0,0-6,6V192a6,6,0,0,0,12,0V64A6,6,0,0,0,128,58Zm40,32a6,6,0,0,0-6,6v64a6,6,0,0,0,12,0V96A6,6,0,0,0,168,90Zm40-16a6,6,0,0,0-6,6v96a6,6,0,0,0,12,0V80A6,6,0,0,0,208,74Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M56,96v64a8,8,0,0,1-16,0V96a8,8,0,0,1,16,0ZM88,24a8,8,0,0,0-8,8V224a8,8,0,0,0,16,0V32A8,8,0,0,0,88,24Zm40,32a8,8,0,0,0-8,8V192a8,8,0,0,0,16,0V64A8,8,0,0,0,128,56Zm40,32a8,8,0,0,0-8,8v64a8,8,0,0,0,16,0V96A8,8,0,0,0,168,88Zm40-16a8,8,0,0,0-8,8v96a8,8,0,0,0,16,0V80A8,8,0,0,0,208,72Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M52,96v64a4,4,0,0,1-8,0V96a4,4,0,0,1,8,0ZM88,28a4,4,0,0,0-4,4V224a4,4,0,0,0,8,0V32A4,4,0,0,0,88,28Zm40,32a4,4,0,0,0-4,4V192a4,4,0,0,0,8,0V64A4,4,0,0,0,128,60Zm40,32a4,4,0,0,0-4,4v64a4,4,0,0,0,8,0V96A4,4,0,0,0,168,92Zm40-16a4,4,0,0,0-4,4v96a4,4,0,0,0,8,0V80A4,4,0,0,0,208,76Z" }))]
]);
var e$21 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M225.24,174.74a12,12,0,0,1-1.58,16.89C205.49,206.71,189.06,212,174.15,212c-19.76,0-36.86-9.29-51.88-17.44-25.06-13.62-44.86-24.37-74.61.3a12,12,0,1,1-15.32-18.48c42.25-35,75-17.23,101.39-2.92,25.06,13.61,44.86,24.37,74.61-.3A12,12,0,0,1,225.24,174.74Zm-16.9-57.59c-29.75,24.67-49.55,13.91-74.61.3-26.35-14.3-59.14-32.11-101.39,2.92a12,12,0,0,0,15.32,18.48c29.75-24.67,49.55-13.92,74.61-.3,15,8.15,32.12,17.44,51.88,17.44,14.91,0,31.34-5.29,49.51-20.36a12,12,0,0,0-15.32-18.48ZM47.66,82.84c29.75-24.67,49.55-13.92,74.61-.3,15,8.15,32.12,17.44,51.88,17.44,14.91,0,31.34-5.29,49.51-20.36a12,12,0,0,0-15.32-18.48c-29.75,24.67-49.55,13.92-74.61.3-26.35-14.3-59.14-32.11-101.39,2.93A12,12,0,1,0,47.66,82.84Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M216,70.39v112c-72,59.69-104-56.47-176,3.22v-112C112,13.92,144,130.08,216,70.39Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M222.16,177.25a8,8,0,0,1-1,11.25c-17.36,14.39-32.86,19.5-47,19.5-18.58,0-34.82-8.82-49.93-17-25.35-13.76-47.24-25.64-79.07.74a8,8,0,1,1-10.22-12.31c40.17-33.28,70.32-16.92,96.93-2.48,25.35,13.75,47.24,25.63,79.07-.74A8,8,0,0,1,222.16,177.25Zm-11.27-57c-31.83,26.38-53.72,14.5-79.07.74-26.61-14.43-56.76-30.79-96.93,2.49a8,8,0,0,0,10.22,12.31c31.83-26.38,53.72-14.5,79.07-.74,15.11,8.19,31.35,17,49.93,17,14.14,0,29.64-5.11,47-19.5a8,8,0,1,0-10.22-12.31ZM45.11,79.8c31.83-26.37,53.72-14.49,79.07-.74,15.11,8.2,31.35,17,49.93,17,14.14,0,29.64-5.12,47-19.5a8,8,0,1,0-10.22-12.31c-31.83,26.38-53.72,14.5-79.07.74C105.21,50.58,75.06,34.22,34.89,67.5A8,8,0,1,0,45.11,79.8Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M208,32H48A16,16,0,0,0,32,48V208a16,16,0,0,0,16,16H208a16,16,0,0,0,16-16V48A16,16,0,0,0,208,32ZM197.2,176.87c-13.07,11.18-24.9,15.1-35.64,15.1-14.26,0-26.62-6.92-37.47-13-18.41-10.31-32.95-18.45-54.89.31a8,8,0,1,1-10.4-12.16c30.42-26,54.09-12.76,73.11-2.11,18.41,10.31,33,18.45,54.89-.31a8,8,0,0,1,10.4,12.16Zm0-44c-13.07,11.18-24.9,15.1-35.64,15.1-14.26,0-26.62-6.92-37.47-13-18.41-10.31-32.95-18.45-54.89.31a8,8,0,0,1-10.4-12.16c30.42-26,54.09-12.76,73.11-2.11,18.41,10.31,33,18.45,54.89-.31a8,8,0,1,1,10.4,12.16Zm0-44c-13.07,11.18-24.9,15.1-35.64,15.1-14.26,0-26.62-6.92-37.47-13-18.41-10.31-32.95-18.45-54.89.31A8,8,0,0,1,58.8,79.13c30.42-26,54.09-12.76,73.11-2.11,18.41,10.31,33,18.45,54.89-.31a8,8,0,1,1,10.4,12.16Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M220.62,178.58a6,6,0,0,1-.79,8.45c-16.87,14-32,19-45.75,19-18.19,0-34.13-8.66-48.94-16.7-26-14.12-48.44-26.31-81.31,1A6,6,0,0,1,36.17,181c39.13-32.45,68.65-16.41,94.69-2.26s48.44,26.31,81.31-1A6,6,0,0,1,220.62,178.58Zm-8.45-56.81c-32.87,27.27-55.32,15.07-81.31,1S75.3,92.54,36.17,125a6,6,0,0,0,7.66,9.25c32.87-27.27,55.32-15.08,81.31-1,14.81,8,30.75,16.71,48.94,16.71,13.79,0,28.88-5,45.75-19a6,6,0,0,0-7.66-9.24ZM43.83,78.21c32.87-27.27,55.32-15.07,81.31-1C140,85.3,155.89,94,174.08,94c13.79,0,28.88-5,45.75-19a6,6,0,1,0-7.66-9.24c-32.87,27.27-55.32,15.07-81.31,1S75.3,36.52,36.17,69a6,6,0,1,0,7.66,9.24Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M222.16,177.25a8,8,0,0,1-1,11.25c-17.36,14.39-32.86,19.5-47,19.5-18.58,0-34.82-8.82-49.93-17-25.35-13.76-47.24-25.64-79.07.74a8,8,0,1,1-10.22-12.31c40.17-33.28,70.32-16.92,96.93-2.48,25.35,13.75,47.24,25.63,79.07-.74A8,8,0,0,1,222.16,177.25Zm-11.27-57c-31.83,26.38-53.72,14.5-79.07.74-26.61-14.43-56.76-30.79-96.93,2.49a8,8,0,0,0,10.22,12.31c31.83-26.38,53.72-14.5,79.07-.74,15.11,8.19,31.35,17,49.93,17,14.14,0,29.64-5.11,47-19.5a8,8,0,1,0-10.22-12.31ZM45.11,79.8c31.83-26.37,53.72-14.49,79.07-.74,15.11,8.2,31.35,17,49.93,17,14.14,0,29.64-5.12,47-19.5a8,8,0,1,0-10.22-12.31c-31.83,26.38-53.72,14.5-79.07.74C105.21,50.58,75.06,34.22,34.89,67.5A8,8,0,1,0,45.11,79.8Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M219.08,179.84a4,4,0,0,1-.53,5.63C203.56,197.9,188.9,204,173.93,204a54.84,54.84,0,0,1-6.12-.34c-15-1.65-28.6-9-41.72-16.14-25.52-13.86-49.62-27-83.54,1.18a4,4,0,0,1-5.1-6.16c17-14.12,33.62-20.08,50.74-18.19,15,1.64,28.6,9,41.72,16.14,25.52,13.86,49.62,26.94,83.54-1.18A4,4,0,0,1,219.08,179.84Zm-5.63-56.53c-33.92,28.12-58,15-83.54,1.17-13.12-7.12-26.69-14.49-41.72-16.14-17.12-1.88-33.72,4.07-50.74,18.19a4,4,0,1,0,5.1,6.16c33.92-28.12,58-15,83.54-1.17,13.12,7.12,26.69,14.49,41.72,16.14a57.34,57.34,0,0,0,6.12.34c15,0,29.63-6.1,44.62-18.53a4,4,0,1,0-5.1-6.16ZM42.55,76.69c33.92-28.13,58-15,83.54-1.18,13.12,7.13,26.69,14.5,41.72,16.14a54.84,54.84,0,0,0,6.12.34c15,0,29.63-6.1,44.62-18.53a4,4,0,1,0-5.1-6.16c-33.92,28.13-58,15-83.54,1.18C116.79,61.35,103.22,54,88.19,52.34c-17.12-1.88-33.72,4.07-50.74,18.19a4,4,0,1,0,5.1,6.16Z" }))]
]);
var e$20 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M230.47,67.5a12,12,0,0,0-19.26-4.32L172.43,99l-12.68-2.72L157,83.57l35.79-38.78a12,12,0,0,0-4.32-19.26A76.07,76.07,0,0,0,88.41,121.64L30.92,174.18a4.68,4.68,0,0,0-.39.38,36,36,0,0,0,50.91,50.91l.38-.39,52.54-57.49A76.05,76.05,0,0,0,230.47,67.5ZM160,148a51.5,51.5,0,0,1-23.35-5.52,12,12,0,0,0-14.26,2.62L64.31,208.66a12,12,0,0,1-17-17l63.55-58.07a12,12,0,0,0,2.62-14.26A51.5,51.5,0,0,1,108,96a52.06,52.06,0,0,1,52-52h.89L135.17,71.87a12,12,0,0,0-2.91,10.65l5.66,26.35a12,12,0,0,0,9.21,9.21l26.35,5.66a12,12,0,0,0,10.65-2.91L212,95.12c0,.3,0,.59,0,.89A52.06,52.06,0,0,1,160,148Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M224,96a64,64,0,0,1-94.94,56L73,217A24,24,0,0,1,39,183L104,126.94a64,64,0,0,1,80-90.29L144,80l5.66,26.34L176,112l43.35-40A63.8,63.8,0,0,1,224,96Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M226.76,69a8,8,0,0,0-12.84-2.88l-40.3,37.19-17.23-3.7-3.7-17.23,37.19-40.3A8,8,0,0,0,187,29.24,72,72,0,0,0,88,96,72.34,72.34,0,0,0,94,124.94L33.79,177c-.15.12-.29.26-.43.39a32,32,0,0,0,45.26,45.26c.13-.13.27-.28.39-.42L131.06,162A72,72,0,0,0,232,96,71.56,71.56,0,0,0,226.76,69ZM160,152a56.14,56.14,0,0,1-27.07-7,8,8,0,0,0-9.92,1.77L67.11,211.51a16,16,0,0,1-22.62-22.62L109.18,133a8,8,0,0,0,1.77-9.93,56,56,0,0,1,58.36-82.31l-31.2,33.81a8,8,0,0,0-1.94,7.1L141.83,108a8,8,0,0,0,6.14,6.14l26.35,5.66a8,8,0,0,0,7.1-1.94l33.81-31.2A56.06,56.06,0,0,1,160,152Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M232,96a72,72,0,0,1-100.94,66L79,222.22c-.12.14-.26.29-.39.42a32,32,0,0,1-45.26-45.26c.14-.13.28-.27.43-.39L94,124.94a72.07,72.07,0,0,1,83.54-98.78,8,8,0,0,1,3.93,13.19L144,80l5.66,26.35L176,112l40.65-37.52a8,8,0,0,1,13.19,3.93A72.6,72.6,0,0,1,232,96Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M224.91,69.75a6,6,0,0,0-9.63-2.16l-41.07,37.9L154.7,101.3l-4.19-19.51,37.9-41.07a6,6,0,0,0-2.16-9.63,70,70,0,0,0-89.77,94.39l-61.39,53c-.11.09-.21.19-.32.3A30,30,0,0,0,77.2,221.23c.11-.11.21-.21.3-.32l53-61.39a70,70,0,0,0,94.39-89.77ZM160,154a58,58,0,0,1-28-7.22,6,6,0,0,0-7.45,1.33L68.57,212.88a18,18,0,0,1-25.45-25.45l64.76-55.94A6,6,0,0,0,109.2,124a58,58,0,0,1,64-84.53L139.58,75.93a6,6,0,0,0-1.45,5.33l5.65,26.35a6,6,0,0,0,4.61,4.61l26.35,5.65a6,6,0,0,0,5.33-1.45L216.49,82.8A58.06,58.06,0,0,1,160,154Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M226.76,69a8,8,0,0,0-12.84-2.88l-40.3,37.19-17.23-3.7-3.7-17.23,37.19-40.3A8,8,0,0,0,187,29.24,72,72,0,0,0,88,96,72.34,72.34,0,0,0,94,124.94L33.79,177c-.15.12-.29.26-.43.39a32,32,0,0,0,45.26,45.26c.13-.13.27-.28.39-.42L131.06,162A72,72,0,0,0,232,96,71.56,71.56,0,0,0,226.76,69ZM160,152a56.14,56.14,0,0,1-27.07-7,8,8,0,0,0-9.92,1.77L67.11,211.51a16,16,0,0,1-22.62-22.62L109.18,133a8,8,0,0,0,1.77-9.93,56,56,0,0,1,58.36-82.31l-31.2,33.81a8,8,0,0,0-1.94,7.1L141.83,108a8,8,0,0,0,6.14,6.14l26.35,5.66a8,8,0,0,0,7.1-1.94l33.81-31.2A56.06,56.06,0,0,1,160,152Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M223.05,70.5a4,4,0,0,0-6.42-1.44l-41.82,38.6L153,103l-4.68-21.79,38.6-41.82a4,4,0,0,0-1.44-6.43A68,68,0,0,0,98.94,126L36.4,180l-.21.2a28,28,0,0,0,39.6,39.6l.2-.21,54-62.54A68,68,0,0,0,228,96,67.51,67.51,0,0,0,223.05,70.5ZM160,156a60,60,0,0,1-29-7.47,4,4,0,0,0-5,.89L70,214.25A20,20,0,0,1,41.75,186l64.82-56a4,4,0,0,0,.89-5,60,60,0,0,1,69.46-86.59L141.05,77.29a4,4,0,0,0-1,3.55l5.66,26.35a4,4,0,0,0,3.07,3.07l26.35,5.66a4,4,0,0,0,3.55-1l38.87-35.87A60.05,60.05,0,0,1,160,156Z" }))]
]);
var a$4 = /* @__PURE__ */ new Map([
	["bold", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M208.49,191.51a12,12,0,0,1-17,17L128,145,64.49,208.49a12,12,0,0,1-17-17L111,128,47.51,64.49a12,12,0,0,1,17-17L128,111l63.51-63.52a12,12,0,0,1,17,17L145,128Z" }))],
	["duotone", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", {
		d: "M216,56V200a16,16,0,0,1-16,16H56a16,16,0,0,1-16-16V56A16,16,0,0,1,56,40H200A16,16,0,0,1,216,56Z",
		opacity: "0.2"
	}), /* @__PURE__ */ _("path", { d: "M205.66,194.34a8,8,0,0,1-11.32,11.32L128,139.31,61.66,205.66a8,8,0,0,1-11.32-11.32L116.69,128,50.34,61.66A8,8,0,0,1,61.66,50.34L128,116.69l66.34-66.35a8,8,0,0,1,11.32,11.32L139.31,128Z" }))],
	["fill", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M208,32H48A16,16,0,0,0,32,48V208a16,16,0,0,0,16,16H208a16,16,0,0,0,16-16V48A16,16,0,0,0,208,32ZM181.66,170.34a8,8,0,0,1-11.32,11.32L128,139.31,85.66,181.66a8,8,0,0,1-11.32-11.32L116.69,128,74.34,85.66A8,8,0,0,1,85.66,74.34L128,116.69l42.34-42.35a8,8,0,0,1,11.32,11.32L139.31,128Z" }))],
	["light", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M204.24,195.76a6,6,0,1,1-8.48,8.48L128,136.49,60.24,204.24a6,6,0,0,1-8.48-8.48L119.51,128,51.76,60.24a6,6,0,0,1,8.48-8.48L128,119.51l67.76-67.75a6,6,0,0,1,8.48,8.48L136.49,128Z" }))],
	["regular", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M205.66,194.34a8,8,0,0,1-11.32,11.32L128,139.31,61.66,205.66a8,8,0,0,1-11.32-11.32L116.69,128,50.34,61.66A8,8,0,0,1,61.66,50.34L128,116.69l66.34-66.35a8,8,0,0,1,11.32,11.32L139.31,128Z" }))],
	["thin", /* @__PURE__ */ _(k, null, /* @__PURE__ */ _("path", { d: "M202.83,197.17a4,4,0,0,1-5.66,5.66L128,133.66,58.83,202.83a4,4,0,0,1-5.66-5.66L122.34,128,53.17,58.83a4,4,0,0,1,5.66-5.66L128,122.34l69.17-69.17a4,4,0,1,1,5.66,5.66L133.66,128Z" }))]
]);
var o$30 = R({
	color: "currentColor",
	size: "1em",
	weight: "regular",
	mirrored: !1
});
var p = D((s$4, a$36) => {
	const { alt: n$4, color: r$11, size: t$12, weight: o$34, mirrored: c$7, children: i$6, weights: m$5, ...x$4 } = s$4, { color: d$5 = "currentColor", size: l$10, weight: f$5 = "regular", mirrored: g$5 = !1, ...w$5 } = x$3(o$30);
	return /* @__PURE__ */ _("svg", {
		ref: a$36,
		xmlns: "http://www.w3.org/2000/svg",
		width: t$12 != null ? t$12 : l$10,
		height: t$12 != null ? t$12 : l$10,
		fill: r$11 != null ? r$11 : d$5,
		viewBox: "0 0 256 256",
		transform: c$7 || g$5 ? "scale(-1, 1)" : void 0,
		...w$5,
		...x$4
	}, !!n$4 && /* @__PURE__ */ _("title", null, n$4), i$6, m$5.get(o$34 != null ? o$34 : f$5));
});
p.displayName = "IconBase";
var r$6 = D((e$59, c$7) => /* @__PURE__ */ _(p, {
	ref: c$7,
	...e$59,
	weights: a$31
}));
r$6.displayName = "ArrowClockwiseIcon";
var r$2 = D((e$59, s$4) => /* @__PURE__ */ _(p, {
	ref: s$4,
	...e$59,
	weights: e$54
}));
r$2.displayName = "ArrowsClockwiseIcon";
var o$6 = D((r$11, t$12) => /* @__PURE__ */ _(p, {
	ref: t$12,
	...r$11,
	weights: e$53
}));
o$6.displayName = "ArticleIcon";
var e$3 = D((r$11, t$12) => /* @__PURE__ */ _(p, {
	ref: t$12,
	...r$11,
	weights: e$52
}));
e$3.displayName = "BookOpenIcon";
var e$19 = D((r$11, t$12) => /* @__PURE__ */ _(p, {
	ref: t$12,
	...r$11,
	weights: t$7
}));
e$19.displayName = "CaretDownIcon";
var t = D((o$34, r$11) => /* @__PURE__ */ _(p, {
	ref: r$11,
	...o$34,
	weights: a$30
}));
t.displayName = "CaretLeftIcon";
var e$9 = D((o$34, r$11) => /* @__PURE__ */ _(p, {
	ref: r$11,
	...o$34,
	weights: t$6
}));
e$9.displayName = "CaretRightIcon";
var o$26 = D((r$11, t$12) => /* @__PURE__ */ _(p, {
	ref: t$12,
	...r$11,
	weights: a$29
}));
o$26.displayName = "CaretUpIcon";
var e = D((o$34, r$11) => /* @__PURE__ */ _(p, {
	ref: r$11,
	...o$34,
	weights: e$51
}));
e.displayName = "ChalkboardTeacherIcon";
var o$9 = D((c$7, r$11) => /* @__PURE__ */ _(p, {
	ref: r$11,
	...c$7,
	weights: a$28
}));
o$9.displayName = "CheckIcon";
var c = D((e$59, r$11) => /* @__PURE__ */ _(p, {
	ref: r$11,
	...e$59,
	weights: a$27
}));
c.displayName = "CircleNotchIcon";
var c$1 = D((e$59, r$11) => /* @__PURE__ */ _(p, {
	ref: r$11,
	...e$59,
	weights: a$26
}));
c$1.displayName = "ClockIcon";
var e$1 = D((r$11, t$12) => /* @__PURE__ */ _(p, {
	ref: t$12,
	...r$11,
	weights: l$5
}));
e$1.displayName = "CodeIcon";
var r$4 = D((c$7, e$59) => /* @__PURE__ */ _(p, {
	ref: e$59,
	...c$7,
	weights: l$4
}));
r$4.displayName = "DiscordLogoIcon";
var a = D((e$59, r$11) => /* @__PURE__ */ _(p, {
	ref: r$11,
	...e$59,
	weights: e$50
}));
a.displayName = "DownloadIcon";
var e$12 = D((a$36, m$5) => /* @__PURE__ */ _(p, {
	ref: m$5,
	...a$36,
	weights: e$49
}));
e$12.displayName = "DownloadSimpleIcon";
var o$27 = D((m$5, p$6) => /* @__PURE__ */ _(p, {
	ref: p$6,
	...m$5,
	weights: a$25
}));
o$27.displayName = "EnvelopeSimpleIcon";
var o$14 = D((r$11, t$12) => /* @__PURE__ */ _(p, {
	ref: t$12,
	...r$11,
	weights: a$24
}));
o$14.displayName = "ExclamationMarkIcon";
var o$10 = D((r$11, t$12) => /* @__PURE__ */ _(p, {
	ref: t$12,
	...r$11,
	weights: a$23
}));
o$10.displayName = "EyeIcon";
var o$11 = D((a$36, r$11) => /* @__PURE__ */ _(p, {
	ref: r$11,
	...a$36,
	weights: e$48
}));
o$11.displayName = "EyeSlashIcon";
var o$20 = D((r$11, a$36) => /* @__PURE__ */ _(p, {
	ref: a$36,
	...r$11,
	weights: e$47
}));
o$20.displayName = "FadersIcon";
var o$25 = D((r$11, i$6) => /* @__PURE__ */ _(p, {
	ref: i$6,
	...r$11,
	weights: a$22
}));
o$25.displayName = "FireSimpleIcon";
var a$1 = D((p$6, c$7) => /* @__PURE__ */ _(p, {
	ref: c$7,
	...p$6,
	weights: e$46
}));
a$1.displayName = "FloppyDiskBackIcon";
var o = D((r$11, a$36) => /* @__PURE__ */ _(p, {
	ref: a$36,
	...r$11,
	weights: l$3
}));
o.displayName = "GearSixIcon";
var t$4 = D((e$59, r$11) => /* @__PURE__ */ _(p, {
	ref: r$11,
	...e$59,
	weights: e$45
}));
t$4.displayName = "GithubLogoIcon";
var e$4 = D((r$11, t$12) => /* @__PURE__ */ _(p, {
	ref: t$12,
	...r$11,
	weights: e$44
}));
e$4.displayName = "GlobeIcon";
var o$1 = D((a$36, r$11) => /* @__PURE__ */ _(p, {
	ref: r$11,
	...a$36,
	weights: e$43
}));
o$1.displayName = "HeadphonesIcon";
var o$13 = D((r$11, t$12) => /* @__PURE__ */ _(p, {
	ref: t$12,
	...r$11,
	weights: a$21
}));
o$13.displayName = "HeartIcon";
var e$7 = D((r$11, s$4) => /* @__PURE__ */ _(p, {
	ref: s$4,
	...r$11,
	weights: e$42
}));
e$7.displayName = "HouseIcon";
var o$19 = D((t$12, e$59) => /* @__PURE__ */ _(p, {
	ref: e$59,
	...t$12,
	weights: e$41
}));
o$19.displayName = "InfinityIcon";
var e$16 = D((r$11, t$12) => /* @__PURE__ */ _(p, {
	ref: t$12,
	...r$11,
	weights: a$20
}));
e$16.displayName = "InfoIcon";
var e$8 = D((o$34, a$36) => /* @__PURE__ */ _(p, {
	ref: a$36,
	...o$34,
	weights: e$40
}));
e$8.displayName = "LightbulbFilamentIcon";
var t$2 = D((n$4, i$6) => /* @__PURE__ */ _(p, {
	ref: i$6,
	...n$4,
	weights: a$19
}));
t$2.displayName = "LightningIcon";
var e$2 = D((r$11, t$12) => /* @__PURE__ */ _(p, {
	ref: t$12,
	...r$11,
	weights: e$39
}));
e$2.displayName = "LinkIcon";
var o$2 = D((c$7, e$59) => /* @__PURE__ */ _(p, {
	ref: e$59,
	...c$7,
	weights: e$38
}));
o$2.displayName = "MagicWandIcon";
var o$3 = D((s$4, n$4) => /* @__PURE__ */ _(p, {
	ref: n$4,
	...s$4,
	weights: a$18
}));
o$3.displayName = "MagnifyingGlassIcon";
var t$5 = D((a$36, e$59) => /* @__PURE__ */ _(p, {
	ref: e$59,
	...a$36,
	weights: e$37
}));
t$5.displayName = "MathOperationsIcon";
var o$18 = D((a$36, r$11) => /* @__PURE__ */ _(p, {
	ref: r$11,
	...a$36,
	weights: e$36
}));
o$18.displayName = "MegaphoneIcon";
var o$28 = D((a$36, m$5) => /* @__PURE__ */ _(p, {
	ref: m$5,
	...a$36,
	weights: a$17
}));
o$28.displayName = "MegaphoneSimpleIcon";
var e$17 = D((r$11, t$12) => /* @__PURE__ */ _(p, {
	ref: t$12,
	...r$11,
	weights: e$35
}));
e$17.displayName = "MicrophoneStageIcon";
var e$15 = D((s$4, t$12) => /* @__PURE__ */ _(p, {
	ref: t$12,
	...s$4,
	weights: a$16
}));
e$15.displayName = "MusicNotesIcon";
var a$3 = D((o$34, r$11) => /* @__PURE__ */ _(p, {
	ref: r$11,
	...o$34,
	weights: a$15
}));
a$3.displayName = "PaperPlaneRightIcon";
var o$12 = D((i$6, m$5) => /* @__PURE__ */ _(p, {
	ref: m$5,
	...i$6,
	weights: e$34
}));
o$12.displayName = "PencilSimpleIcon";
var i = D((o$34, n$4) => /* @__PURE__ */ _(p, {
	ref: n$4,
	...o$34,
	weights: a$14
}));
i.displayName = "PencilSimpleLineIcon";
var e$18 = D((a$36, r$11) => /* @__PURE__ */ _(p, {
	ref: r$11,
	...a$36,
	weights: e$33
}));
e$18.displayName = "PianoKeysIcon";
var a$2 = D((e$59, r$11) => /* @__PURE__ */ _(p, {
	ref: r$11,
	...e$59,
	weights: a$13
}));
a$2.displayName = "PlayIcon";
var e$10 = D((r$11, s$4) => /* @__PURE__ */ _(p, {
	ref: s$4,
	...r$11,
	weights: a$12
}));
e$10.displayName = "PlusIcon";
var e$5 = D((t$12, r$11) => /* @__PURE__ */ _(p, {
	ref: r$11,
	...t$12,
	weights: a$11
}));
e$5.displayName = "QuestionIcon";
var o$16 = D((t$12, a$36) => /* @__PURE__ */ _(p, {
	ref: a$36,
	...t$12,
	weights: e$32
}));
o$16.displayName = "RepeatIcon";
var c$2 = D((e$59, t$12) => /* @__PURE__ */ _(p, {
	ref: t$12,
	...e$59,
	weights: e$31
}));
c$2.displayName = "RocketLaunchIcon";
var o$17 = D((r$11, a$36) => /* @__PURE__ */ _(p, {
	ref: a$36,
	...r$11,
	weights: e$30
}));
o$17.displayName = "ShareIcon";
var o$7 = D((r$11, t$12) => /* @__PURE__ */ _(p, {
	ref: t$12,
	...r$11,
	weights: e$29
}));
o$7.displayName = "ShareNetworkIcon";
var n$1 = D((e$59, r$11) => /* @__PURE__ */ _(p, {
	ref: r$11,
	...e$59,
	weights: e$28
}));
n$1.displayName = "SignInIcon";
var t$1 = D((e$59, r$11) => /* @__PURE__ */ _(p, {
	ref: r$11,
	...e$59,
	weights: e$27
}));
t$1.displayName = "SignOutIcon";
var o$21 = D((t$12, a$36) => /* @__PURE__ */ _(p, {
	ref: a$36,
	...t$12,
	weights: l$2
}));
o$21.displayName = "StackSimpleIcon";
var r$5 = D((t$12, a$36) => /* @__PURE__ */ _(p, {
	ref: a$36,
	...t$12,
	weights: l$1
}));
r$5.displayName = "StarIcon";
var e$13 = D((r$11, t$12) => /* @__PURE__ */ _(p, {
	ref: t$12,
	...r$11,
	weights: a$10
}));
e$13.displayName = "StopCircleIcon";
var o$8 = D((r$11, a$36) => /* @__PURE__ */ _(p, {
	ref: a$36,
	...r$11,
	weights: a$9
}));
o$8.displayName = "TerminalIcon";
var o$22 = D((t$12, r$11) => /* @__PURE__ */ _(p, {
	ref: r$11,
	...t$12,
	weights: a$8
}));
o$22.displayName = "TestTubeIcon";
var r$1 = D((a$36, e$59) => /* @__PURE__ */ _(p, {
	ref: e$59,
	...a$36,
	weights: e$26
}));
r$1.displayName = "TrashIcon";
var e$14 = D((a$36, m$5) => /* @__PURE__ */ _(p, {
	ref: m$5,
	...a$36,
	weights: e$25
}));
e$14.displayName = "UploadSimpleIcon";
var o$4 = D((r$11, s$4) => /* @__PURE__ */ _(p, {
	ref: s$4,
	...r$11,
	weights: a$7
}));
o$4.displayName = "UserIcon";
var r$3 = D((o$34, c$7) => /* @__PURE__ */ _(p, {
	ref: c$7,
	...o$34,
	weights: a$6
}));
r$3.displayName = "UserCircleIcon";
var o$15 = D((r$11, s$4) => /* @__PURE__ */ _(p, {
	ref: s$4,
	...r$11,
	weights: e$24
}));
o$15.displayName = "UserPlusIcon";
var r = D((o$34, s$4) => /* @__PURE__ */ _(p, {
	ref: s$4,
	...o$34,
	weights: e$23
}));
r.displayName = "UsersThreeIcon";
var t$3 = D((a$36, e$59) => /* @__PURE__ */ _(p, {
	ref: e$59,
	...a$36,
	weights: a$5
}));
t$3.displayName = "WaveSawtoothIcon";
var e$6 = D((r$11, a$36) => /* @__PURE__ */ _(p, {
	ref: a$36,
	...r$11,
	weights: e$22
}));
e$6.displayName = "WaveformIcon";
var o$23 = D((a$36, r$11) => /* @__PURE__ */ _(p, {
	ref: r$11,
	...a$36,
	weights: e$21
}));
o$23.displayName = "WavesIcon";
var o$5 = D((r$11, c$7) => /* @__PURE__ */ _(p, {
	ref: c$7,
	...r$11,
	weights: e$20
}));
o$5.displayName = "WrenchIcon";
var e$11 = D((r$11, t$12) => /* @__PURE__ */ _(p, {
	ref: t$12,
	...r$11,
	weights: a$4
}));
e$11.displayName = "XIcon";
function cn(...inputs) {
	return inputs.flat(Infinity).map((input) => {
		if (!input) return "";
		if (typeof input === "string" || typeof input === "number") return input;
		if (Array.isArray(input)) return cn(...input);
		if (typeof input === "object") return Object.entries(input).filter(([_$5, value]) => Boolean(value)).map(([key]) => key).join(" ");
		return "";
	}).filter(Boolean).join(" ");
}
var f = 0;
Array.isArray;
function u(e$59, t$12, n$4, o$34, i$6, u$5) {
	t$12 || (t$12 = {});
	var a$36, c$7, p$6 = t$12;
	if ("ref" in p$6) for (c$7 in p$6 = {}, t$12) "ref" == c$7 ? a$36 = t$12[c$7] : p$6[c$7] = t$12[c$7];
	var l$10 = {
		type: e$59,
		props: p$6,
		key: n$4,
		ref: a$36,
		__k: null,
		__: null,
		__b: 0,
		__e: null,
		__c: null,
		constructor: void 0,
		__v: --f,
		__i: -1,
		__u: 0,
		__source: i$6,
		__self: u$5
	};
	if ("function" == typeof e$59 && (a$36 = e$59.defaultProps)) for (c$7 in a$36) void 0 === p$6[c$7] && (p$6[c$7] = a$36[c$7]);
	return l.vnode && l.vnode(l$10), l$10;
}
const pathname = c$3(window.location.pathname);
const title = c$3("loopmaster");
const section = c$3(null);
const subsection = c$3(null);
m(() => {
	document.title = `${subsection.value ? `${subsection.value} - ` : ""}${section.value ? `${section.value} - ` : ""}${title.value}`;
});
const navigate = (path) => {
	if (path === pathname.value) return;
	history.pushState({}, "", path);
	pathname.value = path;
};
const Link$1 = (props) => {
	return /* @__PURE__ */ u("a", {
		href: props.to,
		style: props.style,
		title: props.title,
		class: cn(props.class),
		rel: props.target === "_blank" ? "noopener noreferrer" : props.rel,
		onClick: (e$59) => {
			if (props.to.startsWith("https://")) return;
			e$59.preventDefault();
			props.onClick?.();
			navigate(props.to);
		},
		target: props.target,
		"data-selected": props.dataSelected ? "" : void 0,
		children: props.children
	});
};
window.addEventListener("popstate", (e$59) => {
	pathname.value = window.location.pathname;
});
m(() => {
	let side = null;
	let main = "browse";
	const p$6 = pathname.value;
	if (p$6.startsWith("/docs")) {
		side = "docs";
		main = "docs";
		section.value = "Docs";
	} else if (p$6.startsWith("/tutorials")) {
		side = "tutorials";
		main = "tutorials";
		section.value = "Tutorials";
	} else if (p$6.startsWith("/browse")) {
		side = "browse";
		main = "browse";
		section.value = "Browse";
	} else if (p$6.startsWith("/admin")) {
		side = "admin";
		main = "admin";
		section.value = "Admin";
	} else if (p$6.startsWith("/u/")) {
		side = "artist";
		main = "artist";
		section.value = "Artist";
	} else if (p$6.startsWith("/p/")) {
		sidebarTab.value = null;
		main = "project";
		section.value = null;
	} else if (p$6 === "/projects") {
		side = "projects";
		main = "editor";
		section.value = "Projects";
	} else if (p$6 === "/help") {
		side = "help";
		main = "help";
		section.value = "Help";
	} else if (p$6 === "/about") {
		side = "help";
		main = "about";
		section.value = "About";
	} else if (p$6 === "/themes") {
		side = "themes";
		main = mainPage.value;
		section.value = "Themes";
	} else if (p$6 === "/tools") {
		side = "tools";
		main = mainPage.value;
		section.value = "Tools";
	} else if (p$6 === "/settings") {
		side = "settings";
		main = mainPage.value;
		section.value = "Settings";
	} else if (p$6 === "/account") {
		side = "account";
		main = mainPage.value;
		section.value = "Account";
	} else if (p$6 === "/export-audio") {
		side = "export-audio";
		main = mainPage.value;
		section.value = "Export Audio";
	} else if (p$6 === "/share-project") {
		side = "share-project";
		main = mainPage.value;
		section.value = "Share Project";
	} else if (p$6 === "/bytecode") {
		side = "bytecode";
		main = mainPage.value;
		section.value = "Bytecode";
	} else if (p$6 === "/console") {
		side = "console";
		main = mainPage.value;
		section.value = "Console";
	} else if (p$6 === "/ai") {
		side = "ai";
		main = mainPage.value;
		section.value = "AI";
	} else if (p$6 === "/dj") {
		side = "dj";
		main = "dj";
		section.value = "DJ";
	} else if (p$6 === "/") {
		sidebarTab.value = null;
		main = null;
		section.value = null;
	}
	if (side) sidebarTab.value = side;
	mainPage.value = main;
});
const Header = ({ children, class: className }) => {
	return /* @__PURE__ */ u("div", {
		class: `px-4 w-full h-[50px] min-h-[50px] leading-none text-white flex items-end pb-1.5 border-b-2 border-[${primaryColor.value}] ${className}`,
		children: /* @__PURE__ */ u("div", {
			class: "flex items-center justify-center gap-2",
			children
		})
	});
};
const Main = ({ children, class: className }) => {
	return /* @__PURE__ */ u("div", {
		class: cn("text-white/50 h-[calc(100dvh-50px)] overflow-y-scroll max-h-[calc(100dvh-50px)]", className),
		children
	});
};
const AboutMain = () => {
	return /* @__PURE__ */ u(k, { children: [/* @__PURE__ */ u(Header, { children: [/* @__PURE__ */ u(e$16, { size: 24 }), /* @__PURE__ */ u("h2", {
		class: "text-white font-semibold",
		children: "About"
	})] }), /* @__PURE__ */ u(Main, {
		class: "p-4 pl-12 max-w-[42rem]",
		children: [
			/* @__PURE__ */ u("section", {
				class: "mb-6",
				children: /* @__PURE__ */ u("p", {
					class: "text-white/70 text-sm leading-relaxed",
					children: "loopmaster is a live coding environment for audio. Write code in real time and hear the result instantly. Built-in synths, effects, and sequencing run in the browser with no installation."
				})
			}),
			/* @__PURE__ */ u("section", {
				class: "mb-6",
				children: [/* @__PURE__ */ u("h2", {
					class: "text-white font-semibold mb-2 border-b border-white",
					children: "Contact"
				}), /* @__PURE__ */ u("ul", {
					class: "text-sm text-white/70 space-y-1",
					children: [
						/* @__PURE__ */ u("li", { children: /* @__PURE__ */ u(Link$1, {
							to: "https://discord.gg/NSWaB9dRYh",
							target: "_blank",
							class: "text-white/90 hover:underline",
							children: "Discord"
						}) }),
						/* @__PURE__ */ u("li", { children: /* @__PURE__ */ u(Link$1, {
							to: "https://loopmaster.featurebase.app/",
							target: "_blank",
							class: "text-white/90 hover:underline",
							children: "Feedback"
						}) }),
						/* @__PURE__ */ u("li", { children: /* @__PURE__ */ u(Link$1, {
							to: "https://github.com/loopmaster-xyz/loopmaster",
							target: "_blank",
							class: "text-white/90 hover:underline",
							children: "GitHub"
						}) })
					]
				})]
			}),
			/* @__PURE__ */ u("section", { children: [
				/* @__PURE__ */ u("h2", {
					class: "text-white font-semibold mb-2 border-b border-white",
					children: "Legal"
				}),
				/* @__PURE__ */ u("h3", {
					id: "terms",
					class: "text-white/90 font-medium text-sm mt-3 mb-1",
					children: "Terms of Service"
				}),
				/* @__PURE__ */ u("p", {
					class: "text-white/70 text-sm leading-relaxed mb-4",
					children: "By using LoopMaster you agree to use the service responsibly. Do not upload content that infringes others rights or violates applicable law. We may modify or discontinue the service at any time."
				}),
				/* @__PURE__ */ u("h3", {
					id: "privacy",
					class: "text-white/90 font-medium text-sm mt-3 mb-1",
					children: "Privacy Policy"
				}),
				/* @__PURE__ */ u("p", {
					class: "text-white/70 text-sm leading-relaxed",
					children: "We store account data and project content necessary to provide the service. We do not sell your data. Session and usage information may be collected for operation and improvement of the service."
				})
			] })
		]
	})] });
};
function useAsyncMemo(fn$1, deps = []) {
	const signal = useSignal(null);
	useReactiveEffect(() => {
		fn$1().then((v$4) => signal.value = v$4);
	}, deps);
	return signal;
}
function timeAgo(date) {
	const diff = (/* @__PURE__ */ new Date()).getTime() - date.getTime();
	const seconds = Math.floor(diff / 1e3);
	const minutes = Math.floor(seconds / 60);
	const hours = Math.floor(minutes / 60);
	const days = Math.floor(hours / 24);
	const weeks = Math.floor(days / 7);
	const months = Math.floor(days / 30);
	const years = Math.floor(months / 12);
	if (years > 0) return `${years}y`;
	if (months > 0) return `${months}mo`;
	if (weeks > 0) return `${weeks}w`;
	if (days > 0) return `${days}d`;
	if (hours > 0) return `${hours}h`;
	if (minutes > 0) return `${minutes}m`;
	if (seconds > 0) return `${seconds}s`;
	return "just now";
}
const SidebarLink = ({ to, children, className, target, dataSelected = false }) => /* @__PURE__ */ u(Link$1, {
	to,
	class: cn("group px-2 py-1 hover:bg-white/5 flex flex-row items-center justify-start gap-2 outline-none focus:bg-white/5", className),
	target,
	dataSelected,
	children
});
const SidebarMain = ({ children, class: className }) => {
	return /* @__PURE__ */ u("div", {
		class: cn("flex flex-col w-52 py-2.5 text-neutral-400 text-sm select-none", className),
		children
	});
};
var adminIcons = {
	users: o$4,
	projects: e$6,
	actions: c$2
};
const AdminIcon = ({ section: section$2, size = 24 }) => {
	const Icon = adminIcons[section$2];
	if (!Icon) return null;
	return /* @__PURE__ */ u(Icon, { size });
};
const Admin = () => {
	return /* @__PURE__ */ u(SidebarMain, { children: [
		/* @__PURE__ */ u(SidebarLink, {
			to: "/admin/users",
			children: [/* @__PURE__ */ u(AdminIcon, {
				section: "users",
				size: 16
			}), "Users"]
		}),
		/* @__PURE__ */ u(SidebarLink, {
			to: "/admin/projects",
			children: [/* @__PURE__ */ u(AdminIcon, {
				section: "projects",
				size: 16
			}), "Projects"]
		}),
		" ",
		/* @__PURE__ */ u(SidebarLink, {
			to: "/admin/actions",
			children: [/* @__PURE__ */ u(AdminIcon, {
				section: "actions",
				size: 16
			}), "Actions"]
		})
	] });
};
const Avatar = ({ userId, fallback = null, size = 16 }) => {
	const image = useAsyncMemo(async () => {
		const data = await api.fetchAvatar(userId, cacheBust.value);
		if (!data) return null;
		return new Blob([data], { type: "image/jpeg" });
	}, [cacheBust.value]);
	return image.value ? /* @__PURE__ */ u("img", {
		src: URL.createObjectURL(image.value),
		class: `rounded-full w-[${size}px] h-[${size}px]`,
		alt: "Avatar"
	}) : fallback;
};
const Grid = ({ children, cols = 3, class: className }) => {
	return /* @__PURE__ */ u("div", {
		class: `grid grid-cols-${cols} gap-4 ${className}`,
		children
	});
};
const GridItem = ({ children, to, class: className }) => {
	return /* @__PURE__ */ u(Link$1, {
		to,
		target: to.startsWith("https://") ? "_blank" : void 0,
		class: cn("w-30 md:h-[110px] gap-1 px-2 py-1 text-white hover:bg-white/5 flex flex-col items-center justify-center outline-none focus:bg-white/5", className),
		children
	});
};
var COLORS_NB = 9;
var DEFAULT_SATURATION = 95;
var DEFAULT_LIGHTNESS = 45;
var MAGIC_NUMBER = 5;
function simpleHash(str) {
	return str.split("").reduce((hash, char) => (hash ^ char.charCodeAt(0)) * -MAGIC_NUMBER, MAGIC_NUMBER) >>> 2;
}
function minidenticon(seed = "", saturation = DEFAULT_SATURATION, lightness = DEFAULT_LIGHTNESS, hashFn = simpleHash) {
	const hash = hashFn(seed);
	const hue = hash % COLORS_NB * (360 / COLORS_NB);
	return [...Array(seed ? 25 : 0)].reduce((acc, e$59, i$6) => hash & 1 << i$6 % 15 ? acc + `<rect x="${i$6 > 14 ? 7 - ~~(i$6 / 5) : ~~(i$6 / 5)}" y="${i$6 % 5}" width="1" height="1" shape-rendering="crispEdges" />` : acc, `<svg viewBox="-1.5 -1.5 8 8" xmlns="http://www.w3.org/2000/svg" fill="hsl(${hue} ${saturation}% ${lightness}%)">`) + "</svg>";
}
const Minidenticon = ({ username, saturation, lightness, ...props }) => {
	const svgText = T(() => minidenticon(username, saturation, lightness), [
		username,
		saturation,
		lightness
	]);
	return /* @__PURE__ */ u("img", {
		src: `data:image/svg+xml;utf8,${encodeURIComponent(svgText)}`,
		alt: username,
		...props
	});
};
var AdminUsers = () => {
	const users = useAsyncMemo(async () => {
		return await api.fetchAdminUsers();
	});
	const sortColumn = useSignal("updatedAt");
	const sortDesc = useSignal(true);
	const setUsers = (fn$1) => {
		if (users.value) users.value = fn$1(users.value);
	};
	const sortedUsers = useComputed(() => {
		const list = users.value ?? [];
		const col = sortColumn.value;
		if (!col) return list;
		return [...list].sort((a$36, b$4) => {
			const diff = a$36[col] - b$4[col];
			return sortDesc.value ? -diff : diff;
		});
	});
	const toggleSort = (col) => {
		if (sortColumn.value === col) sortDesc.value = !sortDesc.value;
		else {
			sortColumn.value = col;
			sortDesc.value = true;
		}
	};
	const SortHeader = ({ col, label }) => /* @__PURE__ */ u("th", {
		class: "cursor-pointer hover:text-white select-none",
		onClick: () => toggleSort(col),
		children: /* @__PURE__ */ u("span", {
			class: "inline-flex items-center gap-0.5",
			children: [label, sortColumn.value === col ? sortDesc.value ? /* @__PURE__ */ u(e$19, { size: 12 }) : /* @__PURE__ */ u(o$26, { size: 12 }) : /* @__PURE__ */ u(e$19, {
				size: 12,
				class: "opacity-40"
			})]
		})
	});
	return /* @__PURE__ */ u(Main, {
		class: "px-8 py-4",
		children: /* @__PURE__ */ u("table", {
			class: "table-auto text-sm w-full text-left",
			children: [/* @__PURE__ */ u("thead", { children: /* @__PURE__ */ u("tr", { children: [
				/* @__PURE__ */ u("th", {}),
				/* @__PURE__ */ u("th", { children: "ID" }),
				/* @__PURE__ */ u("th", { children: "Artist" }),
				/* @__PURE__ */ u("th", { children: "Email" }),
				/* @__PURE__ */ u(SortHeader, {
					col: "createdAt",
					label: "Created At"
				}),
				/* @__PURE__ */ u(SortHeader, {
					col: "updatedAt",
					label: "Updated At"
				}),
				/* @__PURE__ */ u("th", { children: "Actions" })
			] }) }), /* @__PURE__ */ u("tbody", { children: sortedUsers.value.map((user) => /* @__PURE__ */ u("tr", {
				class: "border-t border-white/10",
				children: [
					/* @__PURE__ */ u("td", {
						class: "flex items-center justify-center",
						children: /* @__PURE__ */ u(Avatar, {
							userId: user.id,
							fallback: /* @__PURE__ */ u(Minidenticon, {
								username: user.id,
								width: 12,
								height: 12,
								class: "bg-white/20 rounded-full"
							}),
							size: 24
						})
					}),
					/* @__PURE__ */ u("td", { children: user.id }),
					/* @__PURE__ */ u("td", {
						class: "text-white",
						children: /* @__PURE__ */ u(Link$1, {
							to: `/u/${user.id}/${user.artistName}`,
							children: user.artistName
						})
					}),
					/* @__PURE__ */ u("td", {
						class: "text-white",
						children: /* @__PURE__ */ u(Link$1, {
							to: `mailto:${user.email}`,
							children: user.email
						})
					}),
					/* @__PURE__ */ u("td", { children: [
						timeAgo(new Date(user.createdAt)),
						" - ",
						new Date(user.createdAt).toLocaleString()
					] }),
					/* @__PURE__ */ u("td", { children: [
						timeAgo(new Date(user.updatedAt)),
						" - ",
						new Date(user.updatedAt).toLocaleString()
					] }),
					/* @__PURE__ */ u("td", {
						class: "inline-flex items-center gap-1",
						children: [
							!user.sentWelcomeEmail && /* @__PURE__ */ u("button", {
								class: "hover:text-white",
								title: "Send welcome email",
								onMouseDown: () => {
									api.sendWelcomeEmail(user.id).then(() => {
										setUsers((us) => us.map((u$5) => u$5.id === user.id ? {
											...u$5,
											sentWelcomeEmail: true
										} : u$5));
									}).catch((e$59) => {
										console.error(e$59);
										alert(e$59 instanceof Error ? e$59.message : "Failed");
									});
								},
								children: /* @__PURE__ */ u(o$27, { size: 16 })
							}),
							(!user.sentBetaEmail || user.email === "gstagas@gmail.com") && /* @__PURE__ */ u("button", {
								class: "hover:text-white",
								title: "Send beta email",
								onMouseDown: () => {
									api.sendBetaEmail(user.id).then(() => {
										setUsers((us) => us.map((u$5) => u$5.id === user.id ? {
											...u$5,
											sentBetaEmail: true
										} : u$5));
									}).catch((e$59) => {
										console.error(e$59);
										alert(e$59 instanceof Error ? e$59.message : "Failed");
									});
								},
								children: /* @__PURE__ */ u(o$28, { size: 16 })
							}),
							/* @__PURE__ */ u("button", {
								class: "hover:text-white",
								title: "Delete user",
								onMouseDown: () => {
									if (!confirm("Delete this user?")) return;
									api.deleteUser(user.id).then(() => {
										setUsers((us) => us.filter((u$5) => u$5.id !== user.id));
									}).catch((e$59) => {
										console.error(e$59);
										alert(e$59 instanceof Error ? e$59.message : "Failed");
									});
								},
								children: /* @__PURE__ */ u(r$1, { size: 16 })
							})
						]
					})
				]
			}, user.id)) })]
		})
	});
};
var AdminProjects = () => {
	const projects$1 = useAsyncMemo(async () => {
		return await api.fetchAdminProjects();
	});
	const publicProjects = useAsyncMemo(async () => {
		return await api.fetchAdminPublicProjects();
	});
	const Table$1 = ({ projects: projects$2 }) => /* @__PURE__ */ u("table", {
		class: "table-auto text-sm w-full text-left",
		children: [/* @__PURE__ */ u("thead", { children: /* @__PURE__ */ u("tr", { children: [
			/* @__PURE__ */ u("th", { children: "ID" }),
			/* @__PURE__ */ u("th", { children: "Name" }),
			/* @__PURE__ */ u("th", { children: "Artist" }),
			/* @__PURE__ */ u("th", { children: "Public" }),
			/* @__PURE__ */ u("th", { children: "Comments" }),
			/* @__PURE__ */ u("th", { children: "Likes" }),
			/* @__PURE__ */ u("th", { children: "Remixes" }),
			/* @__PURE__ */ u("th", { children: "Created At" }),
			/* @__PURE__ */ u("th", { children: "Updated At" }),
			/* @__PURE__ */ u("th", { children: "Actions" })
		] }) }), /* @__PURE__ */ u("tbody", { children: projects$2.map((project) => /* @__PURE__ */ u("tr", {
			class: "border-t border-white/10",
			children: [
				/* @__PURE__ */ u("td", { children: project.id }),
				/* @__PURE__ */ u("td", {
					class: "text-white",
					children: /* @__PURE__ */ u(Link$1, {
						to: `/p/${project.id}`,
						children: project.name
					})
				}),
				/* @__PURE__ */ u("td", {
					class: "text-white",
					children: /* @__PURE__ */ u(Link$1, {
						to: `/u/${project.artistName}`,
						children: project.artistName
					})
				}),
				/* @__PURE__ */ u("td", { children: project.isPublic ? "Yes" : "No" }),
				/* @__PURE__ */ u("td", { children: project.comments?.length ?? 0 }),
				/* @__PURE__ */ u("td", { children: project.likes?.length ?? 0 }),
				/* @__PURE__ */ u("td", { children: project.remixes?.length ?? 0 }),
				/* @__PURE__ */ u("td", { children: new Date(project.createdAt).toLocaleString() }),
				/* @__PURE__ */ u("td", { children: new Date(project.updatedAt).toLocaleString() }),
				/* @__PURE__ */ u("td", {
					class: "items-center justify-center inline-flex",
					children: /* @__PURE__ */ u("button", {
						class: "hover:text-white",
						onMouseDown: () => {
							api.deleteProject(project.id);
						},
						children: /* @__PURE__ */ u(r$1, { size: 16 })
					})
				})
			]
		}, project.id)) })]
	});
	return /* @__PURE__ */ u(Main, {
		class: "px-8 py-4 gap-1 flex flex-col text-white/50",
		children: [
			/* @__PURE__ */ u("button", {
				class: "hover:text-white flex items-center gap-1",
				onClick: () => {
					api.reindexPublicProjects().then(() => {
						alert("Done");
					});
				},
				children: [/* @__PURE__ */ u(r$2, { size: 16 }), "Reindex Public Projects"]
			}),
			/* @__PURE__ */ u("h2", {
				class: "text-lg font-bold",
				children: "All Projects"
			}),
			/* @__PURE__ */ u(Table$1, { projects: projects$1.value ?? [] }),
			/* @__PURE__ */ u("h2", {
				class: "text-lg font-bold",
				children: "Public Projects"
			}),
			/* @__PURE__ */ u(Table$1, { projects: publicProjects.value?.publicProjects ?? [] }),
			/* @__PURE__ */ u("h2", {
				class: "text-lg font-bold",
				children: "Public Projects by Timestamp"
			}),
			/* @__PURE__ */ u(Table$1, { projects: publicProjects.value?.publicProjectsByTimestamp ?? [] }),
			/* @__PURE__ */ u("h2", {
				class: "text-lg font-bold",
				children: "Public Projects by User ID"
			}),
			/* @__PURE__ */ u(Table$1, { projects: publicProjects.value?.publicProjectsByUserId ?? [] })
		]
	});
};
var AdminActions = () => {
	const usersFileRef = A(null);
	const profileImagesFileRef = A(null);
	const backupFileRef = A(null);
	const uploadV1 = async () => {
		const usersFile = usersFileRef.current?.files?.[0];
		const profileImagesFile = profileImagesFileRef.current?.files?.[0];
		if (!usersFile) {
			alert("Select users JSON file");
			return;
		}
		try {
			const usersText = await usersFile.text();
			const users = JSON.parse(usersText);
			if (!Array.isArray(users)) {
				alert("Users file: expected JSON array");
				return;
			}
			let profileImages = [];
			if (profileImagesFile) {
				const profileImagesText = await profileImagesFile.text();
				const parsed = JSON.parse(profileImagesText);
				profileImages = Array.isArray(parsed) ? parsed : [];
			}
			const result = await api.uploadUsersFromV1(users, profileImages);
			alert(`Imported ${result.imported} users (${result.skipped} skipped), ${result.avatarsImported} avatars`);
		} catch (e$59) {
			console.error(e$59);
			alert(e$59 instanceof Error ? e$59.message : "Upload failed");
		}
		usersFileRef.current && (usersFileRef.current.value = "");
		profileImagesFileRef.current && (profileImagesFileRef.current.value = "");
	};
	return /* @__PURE__ */ u(Main, {
		class: "p-4",
		children: [
			/* @__PURE__ */ u("label", {
				class: "flex flex-row items-center gap-2",
				children: ["Edit docs", /* @__PURE__ */ u("input", {
					type: "checkbox",
					checked: admin.editDocs,
					onChange: (e$59) => {
						admin.editDocs = e$59.target.checked;
					}
				})]
			}),
			/* @__PURE__ */ u("button", {
				class: "hover:bg-white/5 p-2",
				onClick: () => {
					const docs$1 = {};
					for (let key in localStorage) if (key.startsWith("docs-")) {
						const [, name] = key.split("-");
						docs$1[name] = JSON.parse(localStorage.getItem(key)).buffer.code;
					}
					navigator.clipboard.writeText(JSON.stringify(docs$1, null, 2));
				},
				children: "Copy docs to clipboard"
			}),
			/* @__PURE__ */ u("button", {
				class: "hover:bg-white/5 p-2 flex items-center gap-1",
				onClick: () => {
					navigator.clipboard.writeText(favIconSvgText.value);
				},
				children: "Copy favicon SVG to clipboard"
			}),
			/* @__PURE__ */ u("button", {
				class: "hover:bg-white/5 p-2 flex items-center gap-1",
				onClick: () => {
					api.fetchAdminBackup().then((blob) => {
						const url = URL.createObjectURL(blob);
						const a$36 = document.createElement("a");
						a$36.href = url;
						a$36.download = `backup-${(/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-").slice(0, -5)}.zip`;
						document.body.appendChild(a$36);
						a$36.click();
						document.body.removeChild(a$36);
						URL.revokeObjectURL(url);
					}).catch((e$59) => {
						console.error(e$59);
						alert(e$59 instanceof Error ? e$59.message : "Failed");
					});
				},
				children: [/* @__PURE__ */ u(a, { size: 16 }), "Download backup"]
			}),
			/* @__PURE__ */ u("div", {
				class: "flex flex-col gap-2 mt-2",
				children: [/* @__PURE__ */ u("div", {
					class: "flex items-center gap-2",
					children: [/* @__PURE__ */ u("input", {
						ref: backupFileRef,
						type: "file",
						accept: ".zip,application/zip",
						class: "text-sm"
					}), /* @__PURE__ */ u("span", {
						class: "text-white/50 text-sm",
						children: "backup.zip"
					})]
				}), /* @__PURE__ */ u("button", {
					class: "hover:bg-white/5 p-2 flex items-center gap-1 w-fit",
					onClick: async () => {
						const file = backupFileRef.current?.files?.[0];
						if (!file) {
							alert("Select backup zip file");
							return;
						}
						if (!confirm("This will clear all users, projects, one-liners and related data, then restore from the backup. Continue?")) return;
						try {
							const result = await api.restoreBackup(file);
							alert(`Restore completed${"users" in result ? ` (users: ${result.users}, projects: ${result.projects}, one-liners: ${result.oneLiners}, avatars: ${result.avatars})` : ""}`);
						} catch (e$59) {
							console.error(e$59);
							alert(e$59 instanceof Error ? e$59.message : "Restore failed");
						}
						backupFileRef.current && (backupFileRef.current.value = "");
					},
					children: [/* @__PURE__ */ u(e$14, { size: 16 }), "Restore from backup"]
				})]
			}),
			/* @__PURE__ */ u("button", {
				class: "hover:bg-white/5 p-2 flex items-center gap-1",
				onClick: () => {
					api.resetMigrations().then(() => {
						alert("Migrations reset. Restart the server to re-run from scratch.");
					});
				},
				children: [/* @__PURE__ */ u(r$6, { size: 16 }), "Reset migrations"]
			}),
			/* @__PURE__ */ u("div", {
				class: "flex flex-col gap-2",
				children: [
					/* @__PURE__ */ u("div", {
						class: "flex items-center gap-2",
						children: [/* @__PURE__ */ u("input", {
							ref: usersFileRef,
							type: "file",
							accept: ".json,application/json",
							class: "text-sm"
						}), /* @__PURE__ */ u("span", {
							class: "text-white/50 text-sm",
							children: "users.json"
						})]
					}),
					/* @__PURE__ */ u("div", {
						class: "flex items-center gap-2",
						children: [/* @__PURE__ */ u("input", {
							ref: profileImagesFileRef,
							type: "file",
							accept: ".json,application/json",
							class: "text-sm"
						}), /* @__PURE__ */ u("span", {
							class: "text-white/50 text-sm",
							children: "profile_images.json"
						})]
					}),
					/* @__PURE__ */ u("button", {
						class: "hover:bg-white/5 p-2 flex items-center gap-1 w-fit",
						onClick: uploadV1,
						children: [/* @__PURE__ */ u(e$14, { size: 16 }), "Upload Users from V1"]
					})
				]
			}),
			/* @__PURE__ */ u("button", {
				class: "hover:bg-white/5 p-2 flex items-center gap-1",
				onClick: () => {
					if (!confirm("Remove all users except admins?")) return;
					api.removeAllUsers().then((result) => {
						alert(`Removed ${result.removed} users`);
					}).catch((e$59) => {
						console.error(e$59);
						alert(e$59 instanceof Error ? e$59.message : "Failed");
					});
				},
				children: [/* @__PURE__ */ u(r$1, { size: 16 }), "Remove all users"]
			}),
			/* @__PURE__ */ u("textarea", {
				class: "text-black w-full h-full",
				onClick: (e$59) => {
					navigator.clipboard.writeText(e$59.target.value);
				},
				value: [...new Set([...definitions.values()].sort((a$36, b$4) => a$36.name.localeCompare(b$4.name)).map((d$5) => `${definitionToCode(d$5, true)}: ${d$5.description.join(" ")}`)).values()].join("\n")
			}),
			/* @__PURE__ */ u("textarea", {
				class: "text-black w-full h-full",
				onClick: (e$59) => {
					navigator.clipboard.writeText(e$59.target.value);
				},
				value: projects.value?.filter((p$6) => p$6.isSaved).map((p$6) => `${p$6.name}\n------\n${p$6.doc.code}`).join("\n======\n")
			})
		]
	});
};
const AdminMain = () => {
	const section$2 = useComputed(() => pathname.value.split("/")[2] ?? "");
	return /* @__PURE__ */ u(k, { children: [/* @__PURE__ */ u(Header, { children: [/* @__PURE__ */ u(AdminIcon, { section: section$2.value }), /* @__PURE__ */ u("span", {
		class: "text-md font-bold",
		children: toPascalCase(section$2.value)
	})] }), section$2.value === "users" ? /* @__PURE__ */ u(AdminUsers, {}) : section$2.value === "projects" ? /* @__PURE__ */ u(AdminProjects, {}) : section$2.value === "actions" ? /* @__PURE__ */ u(AdminActions, {}) : /* @__PURE__ */ u(Main, {
		class: "p-4",
		children: /* @__PURE__ */ u(Grid, {
			cols: 3,
			children: [
				/* @__PURE__ */ u(GridItem, {
					to: "/admin/users",
					children: [/* @__PURE__ */ u(AdminIcon, {
						section: "users",
						size: 24
					}), "Users"]
				}),
				/* @__PURE__ */ u(GridItem, {
					to: "/admin/projects",
					children: [/* @__PURE__ */ u(AdminIcon, {
						section: "projects",
						size: 24
					}), "Projects"]
				}),
				/* @__PURE__ */ u(GridItem, {
					to: "/admin/actions",
					children: [/* @__PURE__ */ u(AdminIcon, {
						section: "actions",
						size: 24
					}), "Actions"]
				})
			]
		})
	})] });
};
var default_key = "sharethis";
var social_icon = {
	display: "inline-block",
	width: "50px",
	height: "50px",
	position: "relative",
	overflow: "hidden",
	verticalAlign: "middle"
};
var social_container = {
	position: "absolute",
	top: "0",
	left: "0",
	width: "100%",
	height: "100%"
};
var social_svg = {
	...social_container,
	fillRule: "evenodd"
};
var social_svg_g = {
	transition: "fill 170ms ease-in-out",
	fill: "transparent"
};
var makeUriRegex = (socials = []) => new RegExp("(?:[/.]|^)($SOCIALS)([.]|$|/)".replace("$SOCIALS", socials.join("|").replace(/\./gu, "\\.")), "u");
var social_icons = /* @__PURE__ */ new Map();
var network_names = /* @__PURE__ */ new Set();
var uri_regex = makeUriRegex();
function register(social, icon) {
	social_icons.set(social, icon);
	network_names.add(social);
	uri_regex = makeUriRegex([...network_names].sort((pre, post) => post.length - pre.length));
	return icon;
}
function networkFor(url) {
	if (!url) return default_key;
	if (url.startsWith("mailto:")) return "mailto";
	return url.match(uri_regex)?.[1] || default_key;
}
var SocialIcon = /* @__PURE__ */ D(function SocialIcon$1(props, ref) {
	const { as = "a", href, url, network, bgColor, fgColor, className, label, children, fallback, defaultSVG, borderRadius: br = "50%", ...rest } = props;
	const networkKey = network || networkFor(url);
	const ariaLabel = label || props["aria-label"] || networkKey;
	const fallbackIcon = (typeof fallback === "string" ? social_icons.get(fallback) : fallback || defaultSVG) || social_icons.get(default_key);
	const { color, path } = networkKey === default_key ? fallbackIcon : social_icons.get(networkKey) || {};
	const borderRadius = typeof br != "string" ? "50%" : br;
	return /* @__PURE__ */ _(as, {
		href: href || url,
		className: `social-icon${className ? ` ${className}` : ""}`,
		...rest,
		style: {
			...social_icon,
			...rest.style
		},
		"aria-label": ariaLabel,
		ref
	}, /* @__PURE__ */ u("span", {
		className: "social-container",
		style: social_container,
		children: /* @__PURE__ */ u("svg", {
			role: "img",
			"aria-label": `${ariaLabel} social icon`,
			className: "social-svg",
			viewBox: "0 0 64 64",
			style: {
				...social_svg,
				borderRadius
			},
			children: [/* @__PURE__ */ u("g", {
				className: "social-svg-icon",
				style: {
					...social_svg_g,
					fill: fgColor || "white"
				},
				children: /* @__PURE__ */ u("path", { d: `M0,0H64V64H0Z${path}` })
			}), /* @__PURE__ */ u("g", {
				className: "social-svg-mask",
				style: {
					...social_svg_g,
					fill: bgColor || color
				},
				children: /* @__PURE__ */ u("path", { d: path })
			})]
		})
	}), children);
});
register("auth0", {
	"color": "#191919",
	"path": "M0 0v64h64V0Zm34.088 16.287c3.965.307 7.705 1.604 9.787 2.45a2.73 2.73 0 0 1 1.707 2.523v8.164a.79.79 0 0 1-.92.776l-.77-.124c-5.246-.858-9.356-5.162-10.22-10.37l-.004-.003-.29-2.504c-.06-.393.202-.95.71-.912m-3.363.006c.507-.038.777.515.707.913l-.291 2.503c-.865 5.205-4.974 9.51-10.221 10.369v.004l-.77.124a.79.79 0 0 1-.92-.776v-8.164c0-1.107.676-2.104 1.707-2.522 2.086-.845 5.823-2.145 9.788-2.45m-10.82 15.92c.346 0 .762.12 1.019.149 7.168 1.403 10.496 6.133 10.496 15.089 0 .45-.45.758-.826.51-3.297-2.207-10.55-7.967-11.3-15.175-.014-.454.264-.574.61-.574m25.001 0c.347-.001.626.119.612.573-.75 7.208-8.005 12.968-11.301 15.175-.376.248-.826-.06-.826-.51 0-8.956 3.33-13.686 10.498-15.09.257-.028.67-.148 1.017-.149"
});
register("bandsintown", {
	"color": "#1B8793",
	"path": "M0 0v64h64V0zm32.6 24.7h5.6v7.8h-5.6zm-6.8 0h5.6v7.8h-5.6zM44.9 46H19.1V18h5.6v22.4h14.6v-1.1H25.8v-5.6h19V46zm0-13.4h-5.6V18h5.6z"
});
register("behance", {
	"color": "#007CFF",
	"path": "M40.4 30.1q-.9 0-1.5.3c-.4.2-.7.4-.9.7s-.4.6-.5.9-.2.6-.2.9h6c-.1-.9-.4-1.6-.8-2.1-.5-.5-1.2-.7-2.1-.7m-14.9 2.7h-4.4v5.1h4.3c.4 0 .8 0 1.1-.1.4-.1.7-.2 1-.4s.5-.4.7-.7.2-.7.2-1.2c0-1-.3-1.6-.8-2-.5-.5-1.2-.7-2.1-.7m1.5-3.3c.5-.3.7-.9.7-1.7 0-.4-.1-.8-.2-1.1q-.3-.45-.6-.6-.45-.3-.9-.3c-.3-.1-.7-.1-1-.1h-3.8V30h4.1c.6.1 1.2-.1 1.7-.5M0 0v64h64V0zm36.6 23.8h7.5v1.8h-7.5zm-4.7 14.3c-.4.7-.9 1.2-1.5 1.7-.6.4-1.3.8-2.1 1q-1.2.3-2.4.3H17V22.6h8.7c.9 0 1.7.1 2.4.2.7.2 1.3.4 1.9.8.5.4.9.8 1.2 1.4s.4 1.3.4 2.2-.2 1.7-.6 2.3-1 1.1-1.9 1.5c1.1.3 2 .9 2.5 1.7.6.8.8 1.8.8 3 .1.9-.1 1.7-.5 2.4M47 35.3h-9.6c0 1.1.4 2.1.9 2.6s1.3.8 2.4.8c.7 0 1.4-.2 1.9-.6s.9-.8 1-1.2h3.2c-.5 1.6-1.3 2.8-2.4 3.4-1.1.7-2.4 1-3.9 1-1.1 0-2-.2-2.9-.5-.8-.3-1.6-.8-2.2-1.4s-1-1.4-1.4-2.2c-.3-.9-.5-1.8-.5-2.8s.2-1.9.5-2.8.8-1.6 1.4-2.2 1.3-1.1 2.2-1.5c.8-.4 1.8-.5 2.8-.5 1.1 0 2.1.2 3 .7q1.2.6 2.1 1.8c.5.7.9 1.6 1.2 2.5.3.8.3 1.8.3 2.9"
});
register("bsky.app", {
	"color": "#1185fe",
	"path": "M0 0v64h64V0Zm45.498 17.766a2.84 2.84 0 0 1 1.354.312c.578.296.932.915 1.103 1.92.085.513.046 2.326-.086 3.666-.013.125-.038.494-.064.822-.02.322-.054.696-.067.82-.013.125-.039.434-.058.69-.027.25-.06.585-.073.736-.02.158-.046.408-.066.559-.099.92-.118 1.07-.13 1.104-.014.02-.041.244-.067.494-.171 1.662-1.354 3.376-2.938 4.263-1.261.703-2.667 1.045-4.336 1.051-.801.007-.927.041-.447.133.94.17 2.005.518 2.86.945 2.247 1.11 3.041 2.747 2.331 4.778-.118.322-.25.636-.302.695-.053.052-.092.131-.092.164 0 .066-.617 1.025-.8 1.242-.06.072-.219.264-.35.428-.355.434-1.004 1.097-1.346 1.373-.164.131-.31.25-.33.27-.184.203-1.333.946-1.938 1.261-.808.42-1.425.591-2.135.598-.722.006-.953-.033-1.439-.256-1.386-.63-2.418-2.34-3.39-5.586-.421-1.426-.54-1.826-.598-2.082-.066-.276-.131-.218-.256.223-.381 1.38-1.117 3.344-1.623 4.363-.92 1.853-1.927 2.937-3.11 3.357-.499.178-1.45.166-2.029-.025-1.452-.486-2.899-1.623-4.357-3.443-1.426-1.774-2.116-3.292-2.037-4.475.046-.69.118-.933.447-1.426.302-.453.841-.914 1.44-1.236.426-.23 1.28-.584 1.609-.676.111-.026.375-.099.592-.158.216-.066.453-.126.525-.139.867-.17 1.255-.255 1.295-.281.026-.02-.302-.04-.723-.047-.42 0-.947-.026-1.164-.053-.453-.059-1.445-.276-1.642-.36a6 6 0 0 0-.46-.17c-1.241-.441-2.378-1.33-3.087-2.427-.316-.486-.659-1.221-.73-1.576a10 10 0 0 1-.19-1.123c-.027-.217-.054-.466-.067-.558a33 33 0 0 1-.197-1.873c-.026-.29-.053-.632-.066-.756a72 72 0 0 1-.073-.756c-.02-.29-.05-.631-.064-.756-.164-1.938-.172-3.68-.008-4.238.302-1.019.73-1.466 1.623-1.715.29-.08 1.157-.078 1.531.008 1.183.25 3.576 1.655 5.008 2.93.072.065.237.21.361.322.927.828 2.543 2.522 3.358 3.521.23.29.447.553.486.592.033.04.139.17.23.289.093.118.196.25.23.29.098.104 1.065 1.43 1.486 2.042.492.71 1.201 1.847 1.378 2.229.138.282.256.387.256.236 0-.105.836-1.485 1.434-2.365 1.866-2.76 4.257-5.488 6.353-7.262.566-.473.769-.63 1.63-1.22 1.648-1.126 2.937-1.676 4.015-1.688"
});
register("codepen", {
	"color": "#151515",
	"path": "M0 0v64h64V0zm32 48c-8.8 0-16-7.2-16-16s7.2-16 16-16 16 7.2 16 16-7.2 16-16 16m.5-25.7q-.45-.3-.9 0l-9.1 5.9c-.2.2-.4.4-.4.7v6.2c0 .3.1.6.4.7l9.1 5.9q.45.3.9 0l9.1-5.9c.2-.2.4-.4.4-.7v-6.2c0-.3-.1-.6-.4-.7zm.3 2.2 6.8 4.5-3 2-3.7-2.5v-4zm-1.6 0v4L27.4 31l-3-2zm-7.4 6.1 2.1 1.4-2.1 1.4zm7.4 8.9L24.4 35l3-2 3.7 2.5v4zM32 34l-3-2 3-2 3 2zm.8 5.5v-4l3.7-2.5 3 2zm7.4-6.1L38.1 32l2.1-1.4z"
});
register("clubhouse", {
	"color": "#1F1F1A",
	"path": "M0 0v64.271h64.203V0zm32.694 15.453c1.277 0 2.24.566 2.804 1.842.824-.538 1.956-.738 2.92-.483 1.305.34 2.1 1.249 2.581 4.03.17.882.423 1.96.735 2.895.396 1.194.85 2.128 1.643 3.518.255.425.566.908.878 1.361l.256-.51c.764-1.562 2.268-3.093 4.45-3.093.937 0 1.956.34 2.522 1.305a3.04 3.04 0 0 1 .51 1.7c0 .737-.311 1.475-.566 2.042-.057.114-.084.17-.084.198-.652 1.36-1.53 3.066-1.53 5.05 0 5.76-2.127 8.71-3.77 10.242-1.674 1.562-4.28 2.893-7.313 2.893-2.152 0-4.393-.623-6.234-1.843-2.52-1.672-4.052-4.255-5.44-6.524-1.136-1.9-1.958-3.43-3.176-6.324-.708-1.617-1.36-3.293-1.897-5.079-.482-1.562-.228-2.696.393-3.433.625-.766 1.505-1.135 2.468-1.192.17 0 .34.001.51.03a6 6 0 0 1-.2-1.475c0-1.846 1.448-3.207 3.403-3.207.255 0 .51.028.736.085-.028-.312-.056-.567-.056-.822 0-2.016 1.644-3.206 3.457-3.206m0 1.704c-.822 0-1.812.424-1.812 1.502 0 .709.197 1.758.395 2.606.34.825.398 1.336.823 3.122.255 1.052.565 1.958.877 2.752.368.967.793 1.79 1.388 2.896.283.538.426.539 1.106.17.538-.284 1.33-.625 1.924-.824-1.02-2.211-1.869-4.057-2.294-5.616-.113-.454-.51-2.272-.623-3.066-.085-.794-.17-1.473-.368-2.21-.226-.908-.538-1.332-1.416-1.332m4.87 1.252c-.445-.004-.919.14-1.216.395-.312.283-.425.509-.34 1.132.142 1.364.368 2.414.623 3.406.595 2.325 1.585 4.142 2.095 5.22.17.368.313.511.596.483.397-.029.623-.058.878-.03.34.029.596.228.596.568 0 .283-.143.397-.653.51-1.048.227-2.38.595-3.684 1.333-1.107.626-2.07 1.392-2.948 2.498-.085.113-.172.17-.313.17-.198 0-.368-.227-.538-.454s-.283-.397-.283-.567c0-.199.085-.37.283-.624.312-.426.68-.737.68-.935 0-.142-.254-.482-.48-.879-.368-.68-.992-2.044-1.417-3.065-.651-1.56-1.105-3.546-1.36-4.766-.312-1.332-.794-1.702-1.53-1.702-1.02 0-1.698.595-1.698 1.503 0 .598.197 1.391.594 2.696.255.85.51 1.7.736 2.296a53 53 0 0 0 1.218 3.066c.368.822.906 1.787 1.16 2.269.142.255.397.68.397.935 0 .454-.338.708-.791.708-.255 0-.482-.113-.737-.51-.311-.457-.992-1.788-1.473-2.78-.369-.823-.992-2.3-1.304-3.32-.51-1.616-.85-2.24-1.727-2.213-.51.029-.936.2-1.247.568-.312.397-.339 1.02-.084 1.843.538 1.73 1.163 3.317 1.835 4.943 1.192 2.807 1.957 4.257 3.062 6.1 1.388 2.268 2.75 4.538 4.93 5.984 1.558 1.02 3.46 1.561 5.3 1.561 2.578 0 4.762-1.137 6.15-2.441 1.419-1.305 3.23-3.859 3.23-8.993 0-2.354 1.02-4.4 1.644-5.732.17-.34.537-1.049.537-1.56 0-.226-.055-.537-.197-.764-.255-.397-.652-.54-1.133-.54-1.504 0-2.468 1.136-3.006 2.128a7 7 0 0 0-.537 1.36c-.312 1.049-.624 1.475-1.53 2.212-.482.426-1.076.964-1.415 1.39-.567.767-.738 1.42-.88 2.44-.028.256-.51.369-1.104.369-.34 0-.453-.113-.453-.652 0-.567.198-1.418.623-2.183.595-1.05 1.246-1.617 1.898-2.156s.85-.765.963-1.105c-.595-.797-1.16-1.618-1.614-2.412-.822-1.446-1.36-2.526-1.784-3.83a25 25 0 0 1-.794-3.152c-.34-1.988-.679-2.497-1.33-2.667a1.8 1.8 0 0 0-.428-.054m-23.056.313c.206-.014.437.052.698.187.806.42 3.65 2.637 4.193 3.076.526.422.454.641.178 1.185-.275.544-.533.683-1.022.528-.978-.309-3.882-2.07-4.64-2.523-.684-.413-.773-.784-.296-1.689.264-.499.545-.742.889-.764m-1.79 9.45c.139-.014.296-.005.469.012.803.077 4.524.682 5.116.865.613.19.698.47.623 1.005-.095.696-.409.829-.81.841-.855.024-4.407-.129-5.218-.209-.706-.07-.992-.381-.915-1.404.062-.824.319-1.068.735-1.11m7.768 7.597c.308.018.54.218.713.653.255.637.08.89-.463 1.228-.6.372-3.78 2.04-4.499 2.305-.512.19-1.068.146-1.395-.824-.402-1.198.162-1.482.965-1.794.711-.275 3.66-1.344 4.345-1.53a1 1 0 0 1 .334-.038"
});
register("developer.mozilla", {
	"color": "#236ab4",
	"path": "M0 0v64h64V0zm32 48.35h-3.69v-32.7l-10.15 32.7h-4.15l10.11-32.7H32zm18 0h-3.69v-32.7l-10.12 32.7h-4.15l10.11-32.7H50z"
});
register("dev.to", {
	"color": "#000000",
	"path": "M0 0h64v64H0Zm10.29 20.228v23.636h6.535c5.18.008 6.816-4.062 6.816-6.75V26.982c-.003-2.688-1.683-6.754-6.675-6.754zm18.637.004c-1.57.039-2.817 1.363-2.778 2.957v17.87c.04 1.595 1.348 2.856 2.918 2.813h8.762V39.65h-7.508v-5.49h4.59v-4.22h-4.59v-5.49h7.508v-4.218zm11.39 0 5.43 20.687c1.492 3.52 4.828 4.39 6.687 0l5.418-20.687h-4.59l-4.167 16.246-4.188-16.246zM14.74 24.65h2.457q.823 0 1.645.62.814.624.82 1.868v9.95c0 .827-.273 1.452-.82 1.866q-.82.621-1.641.621h-2.46z"
});
register("discord", {
	"color": "#5865F2",
	"path": "M0 0v64h64V0zm36.903 18.5a29.6 29.6 0 0 1 7.374 2.269c4.045 5.914 6.055 12.585 5.313 20.283a29.6 29.6 0 0 1-9.05 4.537 21.7 21.7 0 0 1-1.936-3.12 19.3 19.3 0 0 0 3.055-1.46 11 11 0 0 1-.747-.562 21.25 21.25 0 0 1-18.082 0c-.242.186-.492.377-.748.562a19 19 0 0 0 3.05 1.457 22 22 0 0 1-1.937 3.123 29.7 29.7 0 0 1-9.043-4.54c-.633-6.638.632-13.37 5.299-20.275a29.8 29.8 0 0 1 7.38-2.274q.522.935.944 1.92a27.5 27.5 0 0 1 8.183 0q.422-.985.945-1.92m-10.97 18.467c-1.762 0-3.218-1.6-3.218-3.568s1.405-3.581 3.213-3.581c1.807 0 3.252 1.614 3.222 3.581-.031 1.968-1.42 3.568-3.216 3.568m11.875 0c-1.765 0-3.216-1.6-3.216-3.568s1.406-3.581 3.216-3.581 3.244 1.614 3.213 3.581c-.03 1.968-1.417 3.568-3.213 3.568"
});
register("dribbble", {
	"color": "#ea4c89",
	"path": "M34.3 34.3c-7.7 2.7-10.5 8-10.7 8.5 2.3 1.8 5.2 2.9 8.4 2.9 1.9 0 3.7-.4 5.3-1.1-.2-1.2-1-5.4-3-10.3.1-.1.1 0 0 0m-3-6.7c-2.3-4-4.7-7.4-5.1-7.9-3.8 1.8-6.7 5.3-7.6 9.6.6-.1 6.3 0 12.7-1.7m1.7 4.5c.2-.1.4-.1.5-.2-.3-.8-.7-1.6-1.1-2.3-6.8 2-13.4 2-14 1.9v.4c0 3.5 1.3 6.7 3.5 9.1.3-.4 4-6.6 11.1-8.9m8.1-10.3c-2.4-2.1-5.6-3.4-9.1-3.4-1.1 0-2.2.1-3.2.4.4.5 2.9 3.9 5.1 8 4.9-1.9 6.9-4.7 7.2-5m-6.2 7c.3.7.6 1.3.9 2 .1.2.2.5.3.7 4.5-.6 9.1.3 9.5.4 0-3.2-1.2-6.2-3.1-8.5-.2.4-2.5 3.3-7.6 5.4m2.1 4.8c1.8 4.9 2.5 8.9 2.7 9.7 3.1-2.1 5.2-5.4 5.9-9.2-.6-.1-4.3-1.2-8.6-.5M0 0v64h64V0zm32 48c-8.8 0-16-7.2-16-16s7.2-16 16-16 16 7.2 16 16-7.2 16-16 16"
});
register("dropbox", {
	"color": "#1081DE",
	"path": "M0 0v64h64V0zm41.5 41.2L32 46.9l-9.4-5.7v-2.1l2.8 1.8 6.6-5.5 6.6 5.5 2.8-1.8v2.1zm6.5-7.5-9.4 6.1-6.6-5.5-6.6 5.5-9.4-6.1 6.5-5.2-6.5-5.2 9.4-6.1 6.6 5.5 6.6-5.5 9.4 6.1-6.5 5.2zm-25.5-5.2 9.5 5.9 9.5-5.9-9.5-5.9z"
});
register("email", {
	"color": "#7f7f7f",
	"path": "M41.1 25H22.9l9.1 7.1zm2.9 1.6-12 9.3-12-9.3V39h24zM0 0v64h64V0zm47 42H17V22h30z"
});
register("facebook", {
	"color": "#3b5998",
	"path": "M0 0v64h64V0zm39.6 22h-2.8c-2.2 0-2.6 1.1-2.6 2.6V28h5.3l-.7 5.3h-4.6V47h-5.5V33.3H24V28h4.6v-4c0-4.6 2.8-7 6.9-7 2 0 3.6.1 4.1.2z"
});
register("fivehundredpix", {
	"color": "#222222",
	"path": "M33.3 31.3c-.4-.2-.7-.4-1.1-.6-.3-.1-.8-.1-.9-.1-1.1 0-1.9.6-2.2 2.1v.9c0 .1.1.4.2.7.3.9 1.4 1.3 2.1 1.3s1.2-.2 1.9-.6c.5-.3 1-.7 1.4-1.1.2-.2.5-.5.5-.6.1-.5-1.5-1.7-1.9-2m9.5-.7c-1.3 0-2.4 1-3.8 2.6 1.3 1.5 2.6 2.3 3.9 2.3 1.5 0 2.2-1.1 2.2-2.4.1-1.4-.8-2.5-2.3-2.5M0 0v64h64V0zm42.9 38.5c-2 0-3.8-1-5.7-3.3-2.2 2.4-3.7 3.3-5.7 3.3-1.8 0-3.7-.7-4.8-3.1-1.2 2.5-3.3 3.2-5.1 3.2-1.6 0-3.8-.4-5-2.5-.1-.1-.6-1.3-.6-1.6v-.7h3c.1 1.6 1.3 2.2 2.4 2.2 1.3 0 2.4-.9 2.6-2.6v-.7c-.2-1.8-1.3-2.4-2.6-2.4-.8 0-1.6.2-2.3 1.2h-2.7v-.2l1.5-8h8.4v2.5h-6.2l-.6 3.3c1-.9 2-1.1 2.9-1.1 1.4 0 3.2.6 4.1 2.6 1-2.4 3-3.2 4.7-3.2 2 0 3.9 1 5.8 3.5 2.1-2.6 3.7-3.5 5.8-3.5 3.3 0 5.1 2.4 5.1 5.4.1 3.1-1.7 5.7-5 5.7"
});
register("flickr", {
	"color": "#0063db",
	"path": "M38 27c-2.8 0-5 2.2-5 5s2.2 5 5 5 5-2.2 5-5-2.2-5-5-5M0 0v64h64V0zm32 48c-8.8 0-16-7.2-16-16s7.2-16 16-16 16 7.2 16 16-7.2 16-16 16m-6-21c-2.8 0-5 2.2-5 5s2.2 5 5 5 5-2.2 5-5-2.2-5-5-5"
});
register("foursquare", {
	"color": "#0072b1",
	"path": "M39.7 20.4H26.4c-.6 0-1 .5-1 1v20.5c0 .1 0 .1.1 0 0 0 4.9-5.9 5.4-6.5.5-.7.8-.8 1.6-.8H37c.6 0 1-.5 1-.8.1-.3.6-3 .7-3.6.1-.5-.4-1.1-.9-1.1h-5.5c-.7 0-1.2-.5-1.2-1.2v-.8c0-.7.5-1.2 1.2-1.2h6.4c.5 0 .9-.4 1-.8l.7-3.6c.2-.6-.2-1.1-.7-1.1M0 0v64h64V0zm44 20.9-1 5.2c-.8 4.2-1.8 9-1.9 9.5-.2.9-.6 2.4-2.7 2.4h-5.1c-.2 0-.2 0-.4.2-.1.1-7.9 9.2-7.9 9.2-.6.7-1.6.6-2 .4-.4-.1-1-.6-1-1.8V19.7c0-1.1.7-2.8 3-2.8h16.5c2.4.1 3.1 1.5 2.5 4"
});
register("gitlab", {
	"color": "#f96424",
	"path": "M0 0v64h64V0zm50.402 32.559-1.969-6.066v.007-.011L44.52 14.454a1.54 1.54 0 0 0-1.476-1.055c-.68.004-1.25.422-1.461 1.062l-3.715 11.426h-11.72l-3.722-11.426a1.52 1.52 0 0 0-1.46-1.062h-.009c-.664 0-1.257.422-1.472 1.062L15.58 26.488v.004s0 .004-.004.008q.005-.007.004-.008l-1.98 6.067c-.297.914.027 1.91.805 2.476l17.082 12.402q.006-.001.007.004c.008.004.016.012.024.016-.008-.004-.012-.012-.02-.016l.004.004h.004q.035.028.082.051l.008.008h.004l.004.004h.008q0 .005.003.004c.004 0 .004.004.008.004q.024.009.047.02.022.006.043.015v.004h.008q.006.004.012.003h.004c0 .004.007.004.011.004h.004q.03.011.063.016.012.007.023.008h.004l.008.004h.015q.004-.001.008.004h.004q.061.006.121.007h.004q.061 0 .121-.007h.004q.006-.005.012-.004h.012q.007-.002.007-.004h.004l.028-.008.062-.016h.004q.006.001.012-.004h.004s.004 0 .008-.003h.007v-.004c.016-.004.032-.012.047-.016l.043-.02.008-.003h.004q.004-.005.008-.004l.008-.004.011-.008q.042-.023.082-.05.002.001.004-.005h.004q.004-.005.008-.004L49.6 35.035a2.21 2.21 0 0 0 .8-2.476zm-7.352-16.98 3.352 10.309h-6.7zm2.766 12.051-1.367 1.75-10.086 12.91 4.77-14.66zM31.171 47.001q.005.004.004.008.001-.004-.004-.008m-1.527-4.707L18.199 27.63h6.68zm-8.688-26.715 3.356 10.309h-6.703zm-5.523 18.047a.47.47 0 0 1-.172-.527l1.473-4.512 10.773 13.805zM31.46 47.415q-.006-.007-.012-.008v-.004q-.013-.008-.02-.015-.022-.018-.039-.036c.004 0 .004.004.004.004s.004 0 .004.004c.028.024.051.047.078.067h.004s0 .004.004.004c-.008-.004-.015-.012-.023-.016m.543-3.504-2.805-8.625-2.484-7.656H37.3zm.574 3.477q-.013.008-.02.015-.004-.001-.003.004a.01.01 0 0 0-.008.008c-.008.004-.016.012-.024.016 0 0 0-.004.004-.004a1 1 0 0 0 .078-.067l.004-.004s.004 0 .004-.003zm15.996-13.762-12.074 8.761L47.28 28.59l1.465 4.508a.47.47 0 0 1-.172.528"
});
register("github", {
	"color": "#24292e",
	"path": "M0 0v64h64V0zm37.1 47.2c-.8.2-1.1-.3-1.1-.8V42c0-1.5-.5-2.5-1.1-3 3.6-.4 7.3-1.7 7.3-7.9 0-1.7-.6-3.2-1.6-4.3.2-.4.7-2-.2-4.2 0 0-1.3-.4-4.4 1.6-1.3-.4-2.6-.5-4-.5s-2.7.2-4 .5c-3.1-2.1-4.4-1.6-4.4-1.6-.9 2.2-.3 3.8-.2 4.2-1 1.1-1.6 2.5-1.6 4.3 0 6.1 3.7 7.5 7.3 7.9-.5.4-.9 1.1-1 2.1-.9.4-3.2 1.1-4.7-1.3 0 0-.8-1.5-2.5-1.6 0 0-1.6 0-.1 1 0 0 1 .5 1.8 2.3 0 0 .9 3.1 5.4 2.1v2.7c0 .4-.3.9-1.1.8-6.3-2-10.9-8-10.9-15.1 0-8.8 7.2-16 16-16s16 7.2 16 16c0 7.1-4.6 13.1-10.9 15.2"
});
register("google", {
	"color": "#dd4b39",
	"path": "M0 0v64h64V0zm31.3 19.1q.45.45.9 1.2c.3.4.5.9.7 1.5q.3.9.3 2.1c0 1.4-.3 2.6-.9 3.4l-.9 1.2c-.4.4-.8.7-1.2 1.1-.2.2-.5.5-.7.8s-.4.7-.4 1.1.1.8.4 1c.2.3.4.5.6.7l1.4 1.1c.8.7 1.6 1.5 2.2 2.3s.9 2 .9 3.3c0 1.9-.9 3.7-2.6 5.2-1.8 1.6-4.3 2.4-7.7 2.4q-4.2 0-6.3-1.8-2.1-1.65-2.1-3.9c0-.7.2-1.6.7-2.5q.6-1.35 2.4-2.4c1.3-.7 2.7-1.2 4.1-1.5 1.4-.2 2.6-.3 3.5-.4-.3-.4-.5-.8-.8-1.2s-.4-.9-.4-1.5c0-.4 0-.6.2-.9.1-.2.2-.5.2-.7-.5.1-.9.1-1.3.1-2.1 0-3.8-.7-4.9-2-1.2-1.2-1.8-2.7-1.8-4.3 0-2 .8-3.8 2.5-5.4 1.1-.9 2.3-1.6 3.5-1.8s2.3-.4 3.4-.4h8L33 18.4h-2.5c.2.2.5.4.8.7M48 32h-4.3v4.2h-2.5V32H37v-2.5h4.2v-4.3h2.5v4.3H48zM27.1 19.1c-.6-.5-1.4-.7-2.2-.7-1.1 0-2 .5-2.7 1.3q-.9 1.35-.9 3c0 1.5.4 3 1.3 4.5.4.7.9 1.4 1.6 1.9.6.5 1.4.8 2.2.8 1.1 0 1.9-.4 2.6-1.1.3-.5.6-1 .7-1.6.1-.5.1-1 .1-1.4q0-2.4-1.2-4.8c-.4-.8-.9-1.5-1.5-1.9m-.2 17.1c-.2 0-.7 0-1.6.1-.8.1-1.7.3-2.5.6-.2.1-.5.2-.9.4s-.7.4-1.1.7q-.6.45-.9 1.2c-.3.5-.4 1.1-.4 1.8 0 1.4.6 2.6 1.9 3.5 1.2.9 2.9 1.4 5 1.4 1.9 0 3.3-.4 4.3-1.3 1-.8 1.5-1.8 1.5-3.1 0-1-.3-1.9-1-2.7-.7-.7-1.8-1.6-3.3-2.6z"
});
register("groupme", {
	"color": "#00aff0",
	"path": "M0 0v64h64V0zm40.321 39.434a10.4 9.517 0 0 1-16.64 0 2.6 2.38 0 1 0-4.161 2.856 15.6 14.276 0 0 0 24.961 0 2.6 2.38 0 0 0-4.16-2.856m-17.42-12.848a2.6 2.38 0 0 0 0 4.759h1.3v1.19a2.6 2.38 0 0 0 5.2 0v-1.19h5.2v1.19a2.6 2.38 0 0 0 5.2 0v-1.19h1.3a2.6 2.38 0 0 0 0-4.759h-1.3v-4.758h1.3a2.6 2.38 0 0 0 0-4.759h-1.3v-1.19a2.6 2.38 0 0 0-5.2 0v1.19h-5.2v-1.19a2.6 2.38 0 0 0-5.2 0v1.19h-1.3a2.6 2.38 0 0 0 0 4.759h1.3v4.758zm6.5-4.758h5.2v4.758h-5.2z"
});
register("google_play", {
	"color": "#40BBC1",
	"path": "M0 0v64h64V0zm40.4 27.1-3.6 3.6-12.3-12.3zM22 44.5V19.4c0-.4.1-.7.2-.9L35.6 32 22.2 45.4c-.1-.2-.2-.5-.2-.9m2.4 1.1 12.4-12.4 3.6 3.6zm22.7-12.4-5 2.8-4-4 3.9-3.9 5.1 2.8c1.2.5 1.2 1.6 0 2.3"
});
register("hashnode", {
	"color": "#2962FF",
	"path": "M0 0v64h64V0zm15 24c-4.4 4.4-4.4 11.5 0 15.9l9.7 9.7c4.4 4.4 11.5 4.4 15.9 0l9.7-9.7c4.4-4.4 4.4-11.5 0-15.9l-9.7-9.7c-4.4-4.4-11.5-4.4-15.9 0zm22.3 13.5c3.1-3.1 3.1-8.1 0-11.1-3.1-3.1-8.1-3.1-11.1 0-3.1 3.1-3.1 8.1 0 11.1 3.1 3.1 8.1 3.1 11.1 0"
});
register("instagram", {
	"color": "#e94475",
	"path": "M0 0v64h64V0zm39.88 25.89c.98 0 1.77-.79 1.77-1.77s-.79-1.77-1.77-1.77-1.77.79-1.77 1.77.79 1.77 1.77 1.77M32 24.42c-4.18 0-7.58 3.39-7.58 7.58s3.4 7.58 7.58 7.58 7.58-3.4 7.58-7.58-3.4-7.58-7.58-7.58m0 12.5c-2.72 0-4.92-2.2-4.92-4.92s2.2-4.92 4.92-4.92 4.92 2.2 4.92 4.92-2.2 4.92-4.92 4.92m0-17.02c3.94 0 4.41.02 5.96.09 1.45.06 2.23.3 2.75.51.69.27 1.18.58 1.7 1.1.51.52.83 1.01 1.1 1.7.2.52.44 1.3.51 2.74.07 1.56.09 2.02.09 5.97 0 3.94-.02 4.4-.09 5.96-.07 1.44-.31 2.22-.51 2.74-.27.69-.59 1.19-1.1 1.7-.52.52-1.01.84-1.7 1.1-.52.2-1.3.45-2.75.51-1.55.07-2.02.09-5.96.09s-4.41-.02-5.96-.09c-1.45-.06-2.23-.3-2.75-.51-.69-.27-1.18-.58-1.7-1.1-.51-.51-.83-1.01-1.1-1.7-.2-.52-.44-1.3-.51-2.74-.07-1.56-.09-2.02-.09-5.96 0-3.95.02-4.41.09-5.97.07-1.44.31-2.22.51-2.74.27-.69.59-1.18 1.1-1.7.52-.52 1.01-.84 1.7-1.1.52-.2 1.3-.45 2.75-.51 1.55-.08 2.02-.09 5.96-.09m0-2.66c-4.01 0-4.51.02-6.09.09-1.57.07-2.64.32-3.58.68-.97.38-1.79.89-2.61 1.71s-1.33 1.65-1.71 2.61c-.36.94-.61 2.01-.68 3.59-.07 1.57-.09 2.07-.09 6.08s.02 4.51.09 6.09c.07 1.57.32 2.64.68 3.58.38.98.89 1.8 1.71 2.62s1.65 1.32 2.61 1.7c.94.37 2.01.62 3.59.69 1.57.07 2.07.09 6.09.09 4.01 0 4.51-.02 6.08-.09s2.65-.32 3.59-.69c.97-.37 1.79-.88 2.61-1.7s1.33-1.65 1.71-2.62c.36-.93.61-2.01.68-3.58.07-1.58.09-2.08.09-6.09s-.02-4.51-.09-6.09c-.07-1.57-.32-2.64-.68-3.58-.38-.98-.89-1.8-1.71-2.62a7.3 7.3 0 0 0-2.61-1.7c-.94-.37-2.01-.62-3.59-.69-1.58-.06-2.08-.08-6.09-.08"
});
register("itch.io", {
	"color": "#fa5c5c",
	"path": "M0 0v64h64V0zm32 16c4.482 0 7.49.028 11.828.197 1.396.921 4.146 4.435 4.172 5.356v1.523c0 1.933-1.624 3.631-3.1 3.631-1.771 0-3.248-1.631-3.248-3.568 0 1.937-1.425 3.568-3.197 3.568-1.771 0-3.152-1.631-3.152-3.568 0 1.937-1.516 3.568-3.287 3.568h-.032c-1.771 0-3.287-1.631-3.287-3.568 0 1.937-1.38 3.568-3.152 3.568s-3.197-1.631-3.197-3.568c0 1.937-1.477 3.568-3.248 3.568-1.476 0-3.1-1.698-3.1-3.63v-1.524c.026-.921 2.776-4.434 4.172-5.356C21.407 16.077 27.518 16 32 16m-3.326 9.797a3.65 4.058 0 0 0 .619.892 3.716 4.13 0 0 0 2.602 1.178q.053 0 .105-.002l.107.002a3.716 4.13 0 0 0 2.602-1.178 3.65 4.058 0 0 0 .617-.892 3.655 4.063 0 0 0 .623.892c.669.727 1.585 1.178 2.596 1.178a3.714 4.129 0 0 0 2.601-1.178c.243-.263.427-.546.596-.875.169.33.404.611.647.875a3.717 4.132 0 0 0 2.601 1.178c.122 0 .25-.037.352-.076a66 66 0 0 1 .222 4.373l.002.006.008 1.73c-.027 3.46.307 11.21-1.373 13.116-2.603.674-7.395.982-12.201.984-4.806-.002-9.598-.31-12.201-.984-1.68-1.905-1.344-9.657-1.371-13.116.002-.666.005-1.147.008-1.73v-.006c.02-1.149.08-2.724.222-4.373.103.04.23.076.352.076a3.717 4.132 0 0 0 2.601-1.178c.243-.264.478-.545.647-.875.168.329.353.612.596.875a3.714 4.129 0 0 0 2.601 1.178c1.01 0 1.927-.45 2.596-1.178a3.655 4.063 0 0 0 .623-.892m9.324 3.84v.002h-.002c-1.058.002-1.997 0-3.162 1.414a24 24 0 0 0-2.834-.16 24 24 0 0 0-2.834.16c-1.165-1.413-2.104-1.412-3.162-1.414h-.002c-.5 0-2.5 0-3.893 4.35l-1.496 5.966c-1.109 4.44.354 4.549 2.18 4.553 2.708-.112 4.209-2.298 4.209-4.485 1.5.274 3.249.41 4.998.41s3.499-.136 4.998-.41c0 2.187 1.499 4.373 4.207 4.485 1.826-.004 3.29-.113 2.182-4.553l-1.496-5.967c-1.394-4.35-3.393-4.351-3.893-4.351M32 33.057s2.851 2.91 3.363 3.945l-1.865-.082v1.809c0 .084-.749.05-1.498.011-.75.039-1.498.073-1.498-.011v-1.81l-1.865.083c.512-1.034 3.36-3.943 3.363-3.945"
});
register("leetcode", {
	"color": "#E7A41F",
	"path": "M0 0h64v64H0zm42.05 42.07a2.12 2.12 0 0 0-3.069-.005l-3.77 3.885a4.65 4.65 0 0 1-6.616.06l-6.758-6.84c-1.824-1.846-2.143-4.74-.56-6.49l6.21-6.625c1.664-1.84 5.04-2.061 6.97-.45l5.508 4.596c.932.779 2.299.628 3.052-.336s.607-2.377-.326-3.156l-5.507-4.596c-1.204-1.005-2.649-1.641-4.161-1.917L36.5 16.5c.85-.91.947-2.264.04-3.116a2.245 2.245 0 0 0-3.181.107l-9.043 9.499-6.063 6.7c-3.252 3.594-2.908 9.19.548 12.688l6.79 6.871a8.887 8.887 0 0 0 12.685-.12l3.77-3.886a2.3 2.3 0 0 0 .005-3.173m-14.396-6.016c0 1.24.971 2.244 2.17 2.244H45.83c1.198 0 2.17-1.005 2.17-2.244s-.972-2.244-2.17-2.244H29.824c-1.199 0-2.17 1.005-2.17 2.244"
});
register("line.me", {
	"color": "#4cc764",
	"path": "M0 0h64v64H0Zm27.54 13.171a26 26 0 0 1 6.17-.319c3.058.196 5.992.9 8.776 2.19 3.394 1.572 6.257 3.797 8.336 6.945 1.942 2.94 2.79 6.171 2.425 9.69-.286 2.758-1.398 5.185-3.046 7.382s-3.614 4.082-5.734 5.811c-3.558 2.901-7.32 5.505-11.32 7.758-.463.26-.954.469-1.437.69a2.4 2.4 0 0 1-.457.14c-.9.212-1.32-.166-1.184-1.077.099-.663.247-1.32.322-1.986.062-.558.074-1.124.062-1.686-.01-.494-.3-.862-.747-1.026-.574-.211-1.166-.405-1.767-.504-4.812-.789-9.1-2.66-12.59-6.137-2.247-2.238-3.792-4.89-4.423-8.028-.762-3.794-.064-7.333 1.949-10.61 1.868-3.044 4.503-5.257 7.642-6.896 2.205-1.15 4.545-1.912 7.023-2.337m4.31 18.669v-2.078c.126.159.192.239.254.323 1.294 1.747 2.59 3.492 3.875 5.244.176.24.369.352.67.335.392-.022.787-.004 1.181-.006.414-.002.54-.12.541-.529q.003-4.543 0-9.085c0-.4-.133-.531-.542-.538-.394-.006-.788-.002-1.182-.001-.512.002-.618.107-.618.621v5.291c-.149-.192-.234-.299-.316-.409-1.28-1.73-2.563-3.458-3.837-5.193-.153-.209-.324-.318-.585-.313-.426.01-.852-.004-1.278.004-.369.008-.503.14-.504.51q-.006 4.575 0 9.15c.001.362.143.488.516.491q.639.005 1.279 0c.428-.002.545-.118.546-.555.002-1.066 0-2.132 0-3.263m12.106 1.473h-1.79v-1.558h.366q1.79.001 3.58-.001c.39 0 .52-.125.527-.514.008-.405.004-.81.001-1.216-.002-.507-.11-.614-.627-.614l-3.484-.002c-.123 0-.245-.012-.355-.018v-1.54h.38q1.773.001 3.546-.001c.409 0 .533-.124.539-.535q.01-.656-.001-1.312c-.006-.35-.137-.493-.486-.494q-2.925-.009-5.849 0c-.353 0-.48.14-.48.489q-.003 4.59 0 9.18c0 .356.125.479.484.48q2.907.003 5.816 0c.383 0 .51-.13.516-.525q.007-.624 0-1.248c-.003-.447-.122-.568-.574-.57-.681-.005-1.363-.002-2.109-.002m-26.32 1.893c.006.32.178.454.488.454 1.949-.002 3.898 0 5.847-.002.35 0 .476-.13.482-.486.006-.395.002-.79.002-1.184 0-.585-.087-.674-.66-.674l-3.451-.001c-.113 0-.226-.01-.365-.018v-7.159c0-.519-.106-.627-.612-.63q-.56-.003-1.118 0c-.515.001-.613.101-.613.622zm10.432-1.51v-7.606c0-.465-.117-.581-.589-.585q-.543-.002-1.085 0c-.58 0-.68.103-.681.693v8.756c0 .086-.004.171.002.256.024.286.163.451.468.45.468-.003.936.003 1.405-.002.34-.004.475-.144.478-.492.004-.468.001-.937.001-1.47z"
});
register("itunes", {
	"color": "#E049D1",
	"path": "M0 0v64h64V0zm42.5 40c0 2.2-1.8 4-4 4h-2c-1.9 0-3.4-1.5-3.4-3.4s1.5-3.4 3.4-3.4h2.8c.8 0 1.4-.6 1.4-1.4v-11c0-.5-.4-.9-.9-.9h-.2l-12.1 2.4c-.4.1-.7.4-.7.9V43c0 2.2-1.8 4-4 4h-2c-1.9 0-3.4-1.5-3.4-3.4s1.5-3.4 3.4-3.4h2.8c.8 0 1.4-.6 1.4-1.4V21.3c0-.7.5-1.2 1.1-1.4l14.7-3h.3c.8 0 1.4.6 1.4 1.4z"
});
register("linkedin", {
	"color": "#007fb1",
	"path": "M0 0v64h64V0zm25.8 44h-5.4V26.6h5.4zm-2.7-19.7c-1.7 0-3.1-1.4-3.1-3.1s1.4-3.1 3.1-3.1 3.1 1.4 3.1 3.1-1.4 3.1-3.1 3.1M46 44h-5.4v-8.4c0-2 0-4.6-2.8-4.6s-3.2 2.2-3.2 4.5V44h-5.4V26.6h5.2V29h.1c.7-1.4 2.5-2.8 5.1-2.8 5.5 0 6.5 3.6 6.5 8.3V44z"
});
register("linktree", {
	"color": "#43e660",
	"path": "M.053.053v64h64v-64zM29.688 16h4.626v7.8l5.338-5.474 3.096 3.174-5.596 5.324h7.873v4.405h-7.918l5.633 5.474-3.088 3.11-7.65-7.688-7.652 7.688-3.098-3.098 5.635-5.475h-7.912v-4.404h7.875L21.252 21.5l3.098-3.186 5.337 5.487zm-.014 21.549h4.629V48h-4.63z"
});
register("mailto", {
	"color": "#7f7f7f",
	"path": "M41.1 25H22.9l9.1 7.1zm2.9 1.6-12 9.3-12-9.3V39h24zM0 0v64h64V0zm47 42H17V22h30z"
});
register("mastodon", {
	"color": "#17063B",
	"path": "M-.135-.135v64.541h64.678V-.134ZM31.91 16c4.394-.016 8.82.462 11.213 1.488 0 0 4.875 2.042 4.875 8.992 0 0 .064 5.126-.684 8.688-.477 2.26-4.218 4.734-8.515 5.213-1.54.17-7.13 1.013-13.686-.48q-.002.5.069.995c.507 3.546 3.767 3.76 6.861 3.86 3.123.093 5.646-.723 5.646-.723l.13 2.639s-1.924 1.093-5.815 1.295c-2.144.113-4.811-.05-7.912-.815C15.994 45.143 16 34.754 16 26.48c0-6.95 4.883-8.992 4.883-8.992 2.27-.96 6.633-1.472 11.027-1.488m-4.703 5.3c-1.505-.036-3.027.51-4.016 1.532-1.802 1.918-1.406 3.174-1.406 11.816h3.569v-7.513c0-3.518 4.882-3.651 4.882.49v4.354h3.537v-4.354c0-4.141 4.887-4.006 4.887-.488v7.515h3.56v-.004c0-8.636.404-9.883-1.406-11.816-1.962-2.032-6.087-2.196-7.927.43l-.883 1.383-.887-1.383c-.916-1.306-2.405-1.924-3.91-1.961"
});
register("matrix", {
	"color": "#000000",
	"path": "M0 0v64h64V0zm16 16h3.04v.732h-2.198v30.536h2.197V48H16zm28.96 0H48v32h-3.04v-.732h2.198V16.732h-2.197zM29.769 26.104c.72 0 1.377.143 1.974.42.598.277 1.046.775 1.36 1.476q.509-.749 1.378-1.322.87-.574 2.061-.574.904 0 1.68.222c.517.147.955.382 1.324.707.368.327.652.745.861 1.268q.306.783.307 1.89v7.637h-3.131V31.36q0-.573-.043-1.082a2.3 2.3 0 0 0-.24-.88 1.5 1.5 0 0 0-.584-.596q-.39-.222-1.047-.223-.665 0-1.07.252a1.84 1.84 0 0 0-.641.666 2.6 2.6 0 0 0-.309.928 7.4 7.4 0 0 0-.08 1.047v6.357h-3.132v-6.4c0-.339-.005-.67-.024-1.002a2.8 2.8 0 0 0-.191-.918 1.4 1.4 0 0 0-.553-.67c-.259-.167-.635-.254-1.139-.254q-.224 0-.586.1a2 2 0 0 0-.705.375q-.344.277-.586.793-.24.519-.24 1.36v6.622H23.28v-11.42h2.953v1.541h.045a4.4 4.4 0 0 1 1.49-1.365c.578-.327 1.249-.486 2-.486"
});
register("medium", {
	"color": "#000000",
	"path": "M0 0v64h64V0zm25.025 22.914c4.985 0 9.026 4.068 9.026 9.086s-4.041 9.086-9.026 9.086S16 37.018 16 32s4.041-9.086 9.025-9.086m14.413.531c2.492 0 4.511 3.83 4.511 8.555h.002c0 4.724-2.021 8.555-4.514 8.555-2.492 0-4.511-3.831-4.511-8.555s2.02-8.555 4.511-8.555m6.974.89C47.288 24.336 48 27.768 48 32c0 4.231-.711 7.664-1.588 7.664S44.826 36.232 44.826 32s.71-7.664 1.586-7.664"
});
register("meetup", {
	"color": "#E51937",
	"path": "M0 0v64h64V0zm47.8 44.3c-.4.2-2.5.9-3.9 1-.6.1-1.1-.6-1.4-1.5C41 39.2 39 32 37.3 27.2c0 3.7-.3 10.8-.4 12-.1 1.7-.4 3.7-1.8 3.9-1.1.2-2.4.4-4 .4-1.3 0-1.8-.9-2.4-1.8-1-1.4-3.1-4.8-4.1-6.9.3 2.3.7 4.7.9 5.8.1.8 0 1.5-.6 1.9-1 .7-3.2 1.4-4.1 1.4-.8 0-1.5-.8-1.6-1.6-.7-3.4-1.2-8-1.1-11.1 0-2.8 0-5.9.2-8.3 0-.7.3-1.1.9-1.4 1.2-.5 3-.6 4.7-.3.8.1 1 .8 1.4 1.4 1.7 2.8 3.8 6.7 5.7 10.6 0-6.3 1.9-11.9 3.5-15.3.5-1.1.9-1.4 1.9-1.4 1.3 0 2.9.2 4.1.4 1.1.2 1.5 1.6 1.7 2.5 1.2 4.5 4.7 18.7 5.5 22.4.1 1 .6 2.2.1 2.5"
});
register("misskey", {
	"color": "#86b300",
	"path": "M0 0h64v64H0Zm16.97 18.07c-.57 0-1.13.1-1.66.29-.94.33-1.72.93-2.32 1.78-.58.83-.87 1.75-.87 2.78v18.16c0 1.33.47 2.47 1.41 3.44.97.94 2.12 1.41 3.44 1.41 1.36 0 2.5-.47 3.44-1.41.97-.97 1.45-2.12 1.45-3.44v-3.3c.01-.72.75-.53 1.12 0 .7 1.21 2.33 2.24 3.9 2.24s3.15-.86 3.9-2.24c.28-.33 1.08-.9 1.16 0v3.3c0 1.33.47 2.47 1.41 3.44.97.94 2.12 1.41 3.44 1.41 1.35 0 2.5-.47 3.44-1.41.97-.97 1.45-2.12 1.45-3.44V22.92c0-1.02-.3-1.95-.91-2.78-.58-.86-1.34-1.45-2.28-1.78-.55-.19-1.11-.29-1.66-.29-1.49 0-2.75.58-3.77 1.74l-4.92 5.76c-.11.08-.48.72-1.26.72s-1.1-.63-1.21-.72l-4.96-5.76c-1-1.16-2.24-1.74-3.74-1.74m30.68 0c-1.16 0-2.16.41-2.98 1.24q-1.2 1.2-1.2 2.94c0 1.16.4 2.16 1.2 2.98.83.8 1.82 1.2 2.98 1.2s2.16-.4 2.99-1.2c.83-.83 1.24-1.82 1.24-2.98s-.41-2.14-1.24-2.94c-.84-.83-1.83-1.24-2.99-1.24m.04 9.2c-1.16 0-2.16.41-2.99 1.24s-1.24 1.82-1.24 2.99v10.24c0 1.16.41 2.16 1.24 2.98.83.8 1.82 1.2 2.99 1.2q1.74 0 2.94-1.2c.83-.83 1.24-1.82 1.24-2.98V31.5c0-1.16-.41-2.16-1.24-2.99-.8-.82-1.78-1.24-2.94-1.24"
});
register("onlyfans", {
	"color": "#00aeef",
	"path": "M0-.006v64.012h64V-.006zm25.348 18.014a14 14 0 0 1 9.148 3.41c2.534-3.084 5.779-3.41 11.82-3.41h7.032c-1.176 5.179-5.229 9.138-12.264 10.5 3.557 1.024 7.756 0 7.756 0-1.22 5.32-5.083 8.65-10.654 9.056l-.063.12a14 14 0 0 1-.623 1.199 14 14 0 0 1-.357.63 14 14 0 0 1-.713.987 14 14 0 0 1-.526.674 14 14 0 0 1-.771.797 14 14 0 0 1-.696.66 14 14 0 0 1-.83.637 14 14 0 0 1-.822.578 14 14 0 0 1-.877.49 14 14 0 0 1-.943.475 14 14 0 0 1-.904.343 14 14 0 0 1-1.024.338 14 14 0 0 1-.935.207 14 14 0 0 1-1.077.188 14 14 0 0 1-.953.068 14 14 0 0 1-.724.053l.011-.035a14 14 0 1 1-.011-27.965m0 9.8a4.2 4.2 0 0 0 0 8.399 4.194 4.194 0 0 0 4.199-4.2 4.2 4.2 0 0 0-4.2-4.198"
});
register("opensea", {
	"color": "#2081E2",
	"path": "M0 0h64v64H0Zm33 12.8c.5 0 .956.204 1.281.536.326.332.528.787.528 1.293v3.101l.375.106q.046.014.086.043c.092.069.222.172.39.297.132.105.275.232.445.363.34.273.744.627 1.188 1.031.118.102.235.208.34.313a27 27 0 0 1 1.824 1.847c.171.194.337.391.508.598.17.21.354.418.512.625.207.276.427.56.62.86.093.14.2.288.29.43.25.377.469.768.68 1.16.088.18.178.376.257.57a8.5 8.5 0 0 1 .54 1.59c.035.115.06.24.074.351v.027c.039.158.053.326.066.496a5.3 5.3 0 0 1-.094 1.641c-.05.234-.112.454-.191.688-.08.223-.16.455-.262.675-.197.457-.43.913-.707 1.34a8 8 0 0 1-.297.485c-.115.167-.234.326-.34.48a10 10 0 0 1-.457.59 6 6 0 0 1-.445.559c-.22.26-.428.505-.648.742a7 7 0 0 1-.418.453c-.142.158-.287.298-.418.43-.22.22-.404.393-.559.535l-.363.332a.3.3 0 0 1-.196.07h-2.8v3.594h3.527c.789 0 1.536-.28 2.14-.793.208-.181 1.112-.96 2.18-2.14a.3.3 0 0 1 .137-.083l9.734-2.816a.287.287 0 0 1 .364.277v2.059c0 .118-.07.223-.176.27-.644.275-2.852 1.29-3.77 2.566-2.34 3.258-4.127 7.918-8.125 7.918H24.14c-5.91 0-10.699-4.808-10.699-10.739v-.191c0-.158.128-.285.286-.285h9.296c.184 0 .318.17.301.351a3.17 3.17 0 0 0 .332 1.785 3.27 3.27 0 0 0 2.934 1.82h4.605v-3.593h-4.55a.294.294 0 0 1-.239-.46c.05-.077.105-.154.164-.243a33 33 0 0 0 1.657-2.645c.417-.73.822-1.506 1.148-2.289a5 5 0 0 0 .172-.43c.089-.25.18-.48.246-.714.066-.198.12-.404.172-.598a9.3 9.3 0 0 0 .219-2.098 10 10 0 0 0-.04-.87c-.013-.313-.05-.626-.09-.938a10 10 0 0 0-.128-.836 14 14 0 0 0-.266-1.25l-.035-.156c-.079-.286-.146-.562-.238-.848a32 32 0 0 0-.871-2.59c-.115-.325-.248-.637-.38-.949-.193-.47-.393-.896-.574-1.3a18 18 0 0 1-.25-.524 17 17 0 0 0-.269-.574c-.066-.142-.143-.271-.195-.403l-.563-1.039a.183.183 0 0 1 .207-.265l3.52.953h.008l.011.004.465.128.512.145.187.05v-2.09c0-1.008.805-1.827 1.805-1.827m-8.488 6.903a.28.28 0 0 1 .238.168c1.39 3.117 2.59 6.993 2.027 9.406-.24.993-.897 2.34-1.636 3.582q-.145.272-.313.528a.28.28 0 0 1-.234.125H16.03a.284.284 0 0 1-.242-.438l.137-.215 8.324-13.023a.28.28 0 0 1 .262-.133"
});
register("patreon", {
	"color": "#000000",
	"path": "M0 0h64v64H0Zm52.853 23.459c-.008-5.72-4.462-10.41-9.69-12.1-6.492-2.1-15.053-1.796-21.252 1.127-7.511 3.546-9.871 11.312-9.959 19.055-.07 6.369.564 23.139 10.022 23.259 7.03.088 8.077-8.969 11.328-13.33 2.314-3.104 5.294-3.979 8.96-4.886 6.303-1.562 10.6-6.536 10.591-13.125m0 0"
});
register("pinterest", {
	"color": "#cb2128",
	"path": "M0 0v64h64V0zm32 48c-1.6 0-3.1-.2-4.5-.7.6-1 1.3-2.2 1.6-3.4.2-.7 1.1-4.4 1.1-4.4.6 1.1 2.2 2 3.9 2 5.1 0 8.6-4.7 8.6-11 0-4.7-4-9.2-10.1-9.2-7.6 0-11.4 5.5-11.4 10 0 2.8 1 5.2 3.3 6.1.4.1.7 0 .8-.4.1-.3.2-1 .3-1.3.1-.4.1-.5-.2-.9-.6-.8-1.1-1.7-1.1-3.1 0-4 3-7.7 7.9-7.7 4.3 0 6.7 2.6 6.7 6.1 0 4.6-2 8.5-5.1 8.5-1.7 0-2.9-1.4-2.5-3.1.5-2 1.4-4.2 1.4-5.7 0-1.3-.7-2.4-2.2-2.4-1.7 0-3.1 1.8-3.1 4.1 0 1.5.5 2.5.5 2.5s-1.8 7.4-2.1 8.7c-.3 1.2-.3 2.6-.3 3.7C19.9 44.2 16 38.6 16 32c0-8.8 7.2-16 16-16s16 7.2 16 16-7.2 16-16 16"
});
register("pixiv", {
	"color": "#0097fa",
	"path": "M0 0v64h64V0zm33.553 16.469c-11.844 0-19.903 9.146-19.903 9.146l2.27 3.606s1.26.106.592-2.018c.573-1.086 1.698-2.545 3.892-4.232v24.008c-.946.268-2.194.768-1.34 1.623h6.518c.86-.861-.493-1.38-1.32-1.623v-5.663s4.469 1.756 9.29 1.756c4.234 0 8.088-1.26 10.954-3.537 2.869-2.264 4.712-5.642 4.703-9.506a12.75 12.75 0 0 0-4.41-9.709c-2.793-2.438-6.705-3.847-11.246-3.847zm-.397 2.027c3.601.003 6.425 1.36 8.338 3.43 1.907 2.075 2.948 4.83 2.957 8.04-.012 3.126-1.124 5.698-3.107 7.673-1.98 1.959-4.864 3.195-8.188 3.195h-.021c-3.699 0-6.816-.72-8.873-1.732V21.088c2.261-1.605 5.928-2.598 8.894-2.592"
});
register("ravelry", {
	"color": "#EE6E62",
	"path": "M0 0h64v64H0Zm42.692 28.943s-2.184-.397-3.752-.397c-3.584 0-4.424 1.987-4.424 4.939v12.488H24.83V20.542h9.687v4.257c1.176-3.576 3.528-4.825 8.176-4.825z"
});
register("rdio", {
	"color": "#0475C5",
	"path": "M0 0v64h64V0zm43.9 30.5c.1.5.1 1 .1 1.5 0 6.4-5.1 11.6-12 11.6s-12-5.1-12-11.5V32c0-6.4 5.1-11.6 12-11.6 1.2 0 2.3.2 3.4.5v6.8l-.6-.3c-3-1-6.2.4-7.7 2.9v.1c-1.5 2.5-.8 5.3 2.1 6.3 3 1 6.2-.4 7.7-2.9v-.1c.5-.8.8-1.7.8-2.6v-9.3c.2.1.3.2.5.3.1.1.3.2.4.2 1.5 1 5.4 3.5 8.7 3.4 1.7.1.2 3.8-3.4 4.8"
});
register("sharethis", {
	"color": "#00BF00",
	"path": "M0 0h64v64H0zm28.388 32c0 .084-.02.163-.025.247l8.802 4.4a4.3 4.3 0 0 1 2.782-1.037 4.335 4.335 0 0 1 4.335 4.335 4.335 4.335 0 1 1-8.67 0c0-.086.02-.163.025-.247l-8.802-4.4a4.3 4.3 0 0 1-2.782 1.034 4.335 4.335 0 0 1 0-8.67c1.065 0 2.027.402 2.782 1.037l8.802-4.4c-.005-.083-.024-.162-.024-.249a4.333 4.333 0 0 1 4.334-4.332 4.335 4.335 0 0 1 0 8.67 4.28 4.28 0 0 1-2.782-1.04l-8.802 4.403c.005.084.024.163.024.25"
});
register("rss", {
	"color": "#EF8733",
	"path": "M0 0v64h64V0zm24 44c-2.2 0-4-1.8-4-4s1.8-4 4-4 4 1.8 4 4-1.8 4-4 4m11-1c-1.1 0-2-.9-2-2 0-5.5-4.5-10-10-10-1.1 0-2-.9-2-2s.9-2 2-2c7.7 0 14 6.3 14 14 0 1.1-.9 2-2 2m9 0c-1.1 0-2-.9-2-2 0-10.5-8.5-19-19-19-1.1 0-2-.9-2-2s.9-2 2-2c12.7 0 23 10.3 23 23 0 1.1-.9 2-2 2"
});
register("slack", {
	"color": "#4A164A",
	"path": "M0 0v64h64V0Zm12.636 37.56c0 5.066 8 5.066 8 0v-3.8h-4c-2.209 0-4 1.7-4 3.8m25.28-6.346c2.21 0 4-1.702 4-3.8V17.287c0-5.066-8-5.066-8 0v10.127c0 2.113 1.815 3.82 4.04 3.8zm14.64-3.8c0-5.067-8-5.067-8 0v3.8h4c2.24.042 4.08-1.672 4.08-3.8zm-25.24 6.345c-2.209 0-4 1.702-4 3.8v10.127c0 5.067 8 5.067 8 0V37.559c0-2.098-1.79-3.8-4-3.8m10.64 10.127h-4v3.8c0 3.386 4.309 5.08 6.829 2.687s.735-6.487-2.829-6.487m10.68-10.127h-10.68c-5.324.009-5.324 7.592 0 7.6h10.68c5.325-.008 5.325-7.591 0-7.6m-21.32-10.145h-10.68c-5.342-.008-5.342 7.608 0 7.6h10.68c5.325-.009 5.325-7.592 0-7.6m0-10.127c-5.324.008-5.324 7.592 0 7.6h4v-3.8c0-2.126-1.804-3.8-4-3.8"
});
register("reddit", {
	"color": "#FF4500",
	"path": "M0 0v64h64V0zm53.344 32a4.67 4.67 0 0 0-7.903-3.2 22.77 22.77 0 0 0-12.32-3.937L35.2 14.88l6.848 1.441a3.2 3.2 0 0 0 3.02 2.852 3.2 3.2 0 1 0-2.602-4.805l-7.84-1.566a1 1 0 0 0-.754.136.98.98 0 0 0-.43.63l-2.37 11.105a22.8 22.8 0 0 0-12.477 3.937 4.672 4.672 0 1 0-5.152 7.648q-.06.704 0 1.407c0 7.168 8.351 12.992 18.656 12.992 10.3 0 18.656-5.824 18.656-12.992a9.4 9.4 0 0 0 0-1.406A4.68 4.68 0 0 0 53.344 32m-32 3.2a3.198 3.198 0 1 1 6.398 0 3.195 3.195 0 0 1-3.199 3.198c-1.766 0-3.2-1.43-3.2-3.199M39.938 44a12.3 12.3 0 0 1-7.907 2.465A12.3 12.3 0 0 1 24.13 44a.87.87 0 0 1 .055-1.16.87.87 0 0 1 1.16-.055A10.48 10.48 0 0 0 32 44.801a10.5 10.5 0 0 0 6.688-1.953.9.9 0 0 1 1.265.015.9.9 0 0 1-.016 1.266Zm-.579-5.473a3.2 3.2 0 0 1-3.199-3.199 3.198 3.198 0 1 1 6.398 0 3.2 3.2 0 0 1-3.23 3.328Zm0 0"
});
register("smugmug", {
	"color": "#8cca1e",
	"path": "M0 0v64h64V0zm36.1 19.8c.2-1.3 1.3-2.6 3.2-2.8 2.4-.2 3.8 1.3 3.8 2.8 0 1.3-1.2 2.6-3.8 2.8-2.4.1-3.4-1.3-3.2-2.8m-13.6.4c.2-1.4 1.4-2.8 3.3-2.8 2.3 0 3.5 1.1 3.6 2.4.2 1.5-1.1 3.1-3.9 3.1-2.4.1-3.2-1.3-3-2.7M28.8 47c-10.9 0-12-17.5-6.9-17.5 12.1-.3 12.5-.3 19-1C51.7 27.4 39.2 47 28.8 47m11.5-15.4c-3.9 0-6.8.5-17.8.9-1.6.1-2.9 11.4 6.6 11.4 7.5 0 15.2-12.3 11.2-12.3"
});
register("snapchat", {
	"color": "#FFC91B",
	"path": "M0 0v64h64V0zm47.927 39.545c-.326.76-1.702 1.318-4.21 1.707-.083.113-.17.511-.223.754a11 11 0 0 1-.183.743c-.104.357-.367.554-.74.554h-.037a4 4 0 0 1-.723-.089 8.5 8.5 0 0 0-1.706-.181c-.397 0-.809.034-1.222.103-.809.135-1.496.62-2.293 1.184-1.139.805-2.43 1.718-4.392 1.718-.088 0-.171-.003-.234-.006a2 2 0 0 1-.162.006c-1.962 0-3.253-.912-4.393-1.718-.796-.562-1.483-1.048-2.292-1.183a7.5 7.5 0 0 0-1.223-.103c-.716 0-1.288.112-1.706.193-.278.055-.519.102-.723.102-.505 0-.701-.308-.776-.565-.077-.262-.131-.51-.183-.751-.053-.244-.14-.644-.224-.758-2.507-.389-3.884-.948-4.21-1.711a.9.9 0 0 1-.071-.298.664.664 0 0 1 .555-.692c4.349-.716 6.308-5.181 6.389-5.371l.015-.032c.232-.471.284-.866.154-1.172-.251-.592-1.177-.885-1.789-1.08-.17-.054-.331-.105-.464-.157-1.482-.585-1.688-1.258-1.601-1.719.122-.64.903-1.07 1.555-1.07q.284 0 .507.104c.557.261 1.053.394 1.472.394.314 0 .513-.075.622-.136l-.048-.779c-.136-2.173-.307-4.877.403-6.469 2.111-4.732 6.585-5.1 7.905-5.1l.554-.005.078-.001h.001c1.324 0 5.807.368 7.919 5.103.711 1.593.54 4.299.403 6.474l-.006.092-.042.685c.099.055.272.121.537.134.4-.018.863-.149 1.379-.391.219-.103.454-.124.613-.124.232 0 .468.045.667.128l.002.001c.592.212.965.638.974 1.117.011.609-.533 1.135-1.617 1.564-.132.052-.293.103-.465.158-.612.194-1.538.488-1.788 1.079-.13.306-.079.701.154 1.172l.015.032c.081.189 2.038 4.654 6.389 5.371a.664.664 0 0 1 .555.691.9.9 0 0 1-.071.298"
});
register("soundcloud", {
	"color": "#FF5700",
	"path": "M0 0v64h64V0zm18.5 36.3c0 .7-.6 1.2-1.2 1.2-.7 0-1.2-.6-1.2-1.2v-4.9c0-.6.6-1.1 1.2-1.1.7 0 1.2.5 1.2 1.1zm4.9 1.2c0 .7-.6 1.2-1.2 1.2s-1.2-.5-1.2-1.2V29c0-.6.6-1.1 1.2-1.1s1.2.5 1.2 1.1zm5 0c0 .7-.6 1.2-1.2 1.2-.7 0-1.2-.6-1.2-1.2V26.2c0-.6.6-1.1 1.2-1.1.7 0 1.2.5 1.2 1.1zm15.2 1.2H31.4c-.3 0-.5-.2-.5-.5V24.3c0-.3.1-.4.4-.5.9-.3 1.8-.5 2.8-.5 4 0 7.4 3.1 7.7 7.1.5-.2 1.1-.3 1.7-.3 2.4 0 4.4 2 4.4 4.4.1 2.3-1.9 4.2-4.3 4.2"
});
register("spotify", {
	"color": "#2EBD59",
	"path": "M39 37.7c-4.2-2.6-9.4-3.2-15.5-1.8-.5.1-.9.7-.8 1.2s.7.9 1.2.7q8.4-1.95 14.1 1.5c.5.3 1.1.1 1.4-.3.2-.4.1-1-.4-1.3m1.9-4.7c-4.9-3-12.2-3.9-18-2.1-.7.2-1 .9-.8 1.6s.9 1 1.6.8c5.1-1.5 11.6-.8 15.9 1.9.6.4 1.4.2 1.7-.4.4-.7.2-1.4-.4-1.8M0 0v64h64V0zm32 48c-8.8 0-16-7.2-16-16s7.2-16 16-16 16 7.2 16 16-7.2 16-16 16m11-20.4c-5.9-3.5-15.3-3.9-21-2.1-.8.2-1.2 1.1-1 1.9s1.1 1.2 1.9 1c4.9-1.5 13.4-1.2 18.6 1.9.7.4 1.6.2 2.1-.5.3-.8.1-1.8-.6-2.2"
});
register("squarespace", {
	"color": "#1C1C1C",
	"path": "M0 0v64h64V0zm39.6 21.1c.6.6.6 1.6 0 2.2s-1.6.6-2.2 0c-1.2-1.2-3.2-1.2-4.4 0l-9.8 9.8c-.6.6-1.6.6-2.2 0s-.6-1.6 0-2.2l9.8-9.8c2.5-2.4 6.4-2.4 8.8 0M17.8 36.4c-2.4-2.4-2.4-6.3 0-8.7l7.5-7.5c1.2-1.2 3.2-1.2 4.4 0L20 29.8c-1.2 1.2-1.2 3.2 0 4.4s3.2 1.2 4.4 0l9.8-9.8c.6-.6 1.6-.6 2.2 0s.6 1.6 0 2.2l-9.8 9.8c-2.5 2.4-6.4 2.4-8.8 0m6.6 6.5c-.6-.6-.6-1.6 0-2.2s1.6-.6 2.2 0c1.2 1.2 3.2 1.2 4.4 0l9.8-9.8c.6-.6 1.6-.6 2.2 0s.6 1.6 0 2.2l-9.8 9.8c-2.5 2.4-6.4 2.4-8.8 0m21.8-6.5-7.5 7.5c-1.2 1.2-3.2 1.2-4.4 0l9.6-9.6c1.2-1.2 1.2-3.2 0-4.4s-3.2-1.2-4.4 0l-9.8 9.8c-.6.6-1.6.6-2.2 0s-.6-1.6 0-2.2l9.8-9.8c2.4-2.4 6.3-2.4 8.7 0 2.6 2.3 2.6 6.3.2 8.7"
});
register("substack", {
	"color": "#ff6719",
	"path": "M0 0h64v64H0Zm20.098 18.477v3.195h23.805v-3.195zm0 6.075v3.24h23.805v-3.24zm0 6.075v14.895c.972-.28 1.95-1.042 2.835-1.536l5.94-3.317c.735-.411 1.472-.818 2.205-1.234.239-.136.644-.475.925-.47.278.005.681.346.919.482q1.03.588 2.07 1.157c2.094 1.149 4.162 2.343 6.256 3.492.809.445 1.754 1.221 2.655 1.426V30.627z"
});
register("t.me", {
	"color": "#49a9e9",
	"path": "M0 0v64h64V0zm11.887 33.477c3.73-2.055 7.894-3.77 11.785-5.497 6.695-2.824 13.414-5.597 20.203-8.18 1.324-.44 3.695-.87 3.93 1.087-.13 2.773-.653 5.527-1.012 8.281-.914 6.055-1.969 12.094-2.996 18.133-.356 2.008-2.875 3.05-4.488 1.761-3.871-2.613-7.778-5.207-11.598-7.882-1.254-1.274-.094-3.102 1.027-4.012 3.188-3.145 6.575-5.816 9.598-9.121.816-1.973-1.594-.313-2.39.2-4.368 3.007-8.63 6.202-13.235 8.847-2.352 1.297-5.094.187-7.445-.535-2.11-.871-5.2-1.75-3.38-3.082m0 0"
});
register("stackoverflow", {
	"color": "#ed803d",
	"path": "M64 0v64H0V0zM46.145 37.265H42.8v10.038H19.376V37.265H16.03V50.65h30.115zm-6.688 2.46L23.023 36.27l.69-3.287 16.435 3.456zm.964-4.234-15.224-7.09 1.418-3.045 15.224 7.09zm1.895-3.811L29.41 20.932l2.15-2.58 12.906 10.747zm-7.27-16.688 2.695-2.004 10.022 13.476-2.695 2.004zm4.407 28.965H22.722v-3.346h16.73z"
});
register("telegram", {
	"color": "#49a9e9",
	"path": "M0 0v64h64V0zm11.887 33.477c3.73-2.055 7.894-3.77 11.785-5.497 6.695-2.824 13.414-5.597 20.203-8.18 1.324-.44 3.695-.87 3.93 1.087-.13 2.773-.653 5.527-1.012 8.281-.914 6.055-1.969 12.094-2.996 18.133-.356 2.008-2.875 3.05-4.488 1.761-3.871-2.613-7.778-5.207-11.598-7.882-1.254-1.274-.094-3.102 1.027-4.012 3.188-3.145 6.575-5.816 9.598-9.121.816-1.973-1.594-.313-2.39.2-4.368 3.007-8.63 6.202-13.235 8.847-2.352 1.297-5.094.187-7.445-.535-2.11-.871-5.2-1.75-3.38-3.082m0 0"
});
register("threads", {
	"color": "#000000",
	"path": "M0 0v64h64V0zm32.28 15.75h.02c3.718.026 6.827.982 9.241 2.84 2.272 1.75 3.872 4.238 4.753 7.404l-2.763.771c-1.495-5.362-5.278-8.102-11.245-8.145-3.94.03-6.918 1.267-8.855 3.678-1.81 2.259-2.747 5.523-2.783 9.702.036 4.18.971 7.443 2.785 9.702 1.937 2.415 4.918 3.652 8.857 3.678 3.552-.026 5.902-.855 7.855-2.77 2.23-2.184 2.19-4.864 1.476-6.496-.42-.962-1.184-1.76-2.214-2.368-.26 1.83-.843 3.311-1.74 4.43-1.199 1.49-2.898 2.306-5.05 2.423-1.628.088-3.198-.295-4.414-1.085-1.44-.933-2.28-2.355-2.372-4.013-.088-1.612.553-3.094 1.801-4.173 1.193-1.03 2.87-1.636 4.852-1.75 1.46-.081 2.827-.016 4.088.192-.169-1.004-.506-1.803-1.013-2.378-.696-.793-1.77-1.196-3.194-1.206h-.04c-1.144 0-2.697.315-3.685 1.787l-2.379-1.595c1.326-1.97 3.477-3.056 6.064-3.056h.058c4.326.026 6.904 2.676 7.16 7.297q.22.093.435.19c2.018.95 3.494 2.387 4.271 4.159 1.079 2.466 1.18 6.486-2.097 9.694-2.505 2.45-5.543 3.559-9.852 3.588h-.02c-4.85-.033-8.577-1.63-11.083-4.75-2.226-2.78-3.377-6.644-3.416-11.486v-.024c.04-4.846 1.19-8.706 3.42-11.485 2.502-3.123 6.233-4.722 11.079-4.755m1.368 16.669q-.49 0-1.001.03c-2.487.14-4.038 1.28-3.95 2.901.091 1.7 1.967 2.49 3.771 2.393 1.658-.088 3.816-.735 4.18-5.025-.917-.198-1.92-.3-3-.3"
});
register("tiktok", {
	"color": "#000000",
	"path": "M0 0v64h64V0zm32.781 16h5.494c-.008 0-.064.526.075 1.34h-.008c.166.98.617 2.381 1.824 3.762a8.857 8.858 0 0 0 1.617 1.375 7 7 0 0 0 .631.367c1.405.7 2.777.913 3.453.84v5.457s-1.93-.081-3.361-.461c-1.996-.534-3.276-1.354-3.276-1.354s-.888-.587-.955-.627v11.274c0 .626-.164 2.194-.662 3.502a10.6 10.6 0 0 1-1.843 3.062s-1.227 1.52-3.381 2.541c-1.943.92-3.652.9-4.162.92 0 0-2.951.119-5.612-1.69l-.013-.013v.014a11.2 11.2 0 0 1-2.381-2.246c-.842-1.074-1.36-2.348-1.492-2.721v-.014c-.212-.634-.657-2.168-.59-3.648.106-2.609.983-4.216 1.215-4.616a10.8 10.8 0 0 1 2.351-2.902 10.2 10.2 0 0 1 7.867-2.3l-.006 5.595a4.6 4.6 0 0 0-1.427-.227c-2.56 0-4.637 2.09-4.637 4.668s2.076 4.666 4.637 4.666a4.6 4.6 0 0 0 2.273-.6 4.67 4.67 0 0 0 2.348-3.704v-.012a.2.2 0 0 0 .004-.047q.005-.054.006-.103c.012-.279.011-.563.011-.848z"
});
register("tumblr", {
	"color": "#2c4762",
	"path": "M0 0v64h64V0zm35.4 47c-6.5.1-9-4.7-9-8v-9.8h-3v-3.9c4.6-1.6 5.6-5.7 5.9-8.1 0-.2.1-.2.2-.2h4.4v7.6h6v4.5h-6v9.3c0 1.3.5 3 2.9 3 .8 0 1.9-.3 2.4-.5l1.4 4.3c-.5.8-3 1.8-5.2 1.8"
});
register("upwork", {
	"color": "#3da800",
	"path": "M0 0h64v64H0Zm24.938 17.111h5.6c1.1 3.8 3.099 8.2 5.599 12.1 1.6-5.5 5.6-9 10.9-9 6.1 0 11.1 5.002 11.1 11.102 0 6.4-5 11.398-11.1 11.398-3 0-5.5-.8-7.7-2.2l-2.4 11.901h-5.7l3.5-16.3c-1.5-2.1-2.9-4.5-4-6.7v2.5c0 6.1-4.9 11-10.9 11s-10.9-4.9-10.9-11V17.211h5.4v14.602c0 2.9 2.4 5.298 5.3 5.298s5.3-2.398 5.3-5.298zm22.199 8.801c-4.1 0-5.4 4-5.8 6.4v.1l-.6 2.2c1.8 1.5 4.1 2.5 6.3 2.5 2.9 0 5.6-2.5 5.7-5.6 0-3.1-2.5-5.6-5.6-5.6"
});
register("twitch", {
	"color": "#6441A5",
	"path": "M0 0v64h64V0zm47 35.8-7.6 7.6h-5.7l-3.8 3.8H26v-3.8h-7V23.1l1.9-5.1H47zm-17.8 7L33 39h7l4.5-4.5v-14h-21V39h5.7zm8.3-17.2H40v7.6h-2.5zm-7 0H33v7.6h-2.5z"
});
register("twitter", {
	"color": "#00aced",
	"path": "M0 0v64h64V0zm44.7 25.5v.8C44.7 35 38.1 45 26.1 45c-3.7 0-7.2-1.1-10.1-2.9.5.1 1 .1 1.6.1 3.1 0 5.9-1 8.2-2.8-2.9-.1-5.3-2-6.1-4.6.4.1.8.1 1.2.1.6 0 1.2-.1 1.7-.2-3-.6-5.3-3.3-5.3-6.4v-.1c.9.5 1.9.8 3 .8-1.8-1.2-2.9-3.2-2.9-5.5q0-1.8.9-3.3c3.2 4 8.1 6.6 13.5 6.9-.1-.5-.2-1-.2-1.5 0-3.6 2.9-6.6 6.6-6.6 1.9 0 3.6.8 4.8 2.1 1.5-.3 2.9-.8 4.2-1.6-.5 1.5-1.5 2.8-2.9 3.6 1.3-.2 2.6-.5 3.8-1-1 1.3-2.1 2.4-3.4 3.4"
});
register("vevo", {
	"color": "#ED1A3B",
	"path": "M0 0v64h64V0zm34.2 41.9c-1.4 2.1-2.9 3.1-5 3.1 0 0-3 .2-4.1-3.4L20 21h8.1l3 12.3c1.4-2.1 5.1-7.7 5.1-7.7 1.4-1.9 2.2-4.6 6.8-4.6h5z"
});
register("vimeo", {
	"color": "#1ab7ea",
	"path": "M0 0v64h64V0zm40.9 37c-4.1 5.3-7.5 8-10.4 8-1.7 0-3.2-1.6-4.4-4.8-.8-3-1.6-5.9-2.4-8.9-.9-3.2-1.9-4.8-2.9-4.8-.2 0-1 .5-2.4 1.4L17 26c1.5-1.3 2.9-2.6 4.4-3.9 2-1.7 3.5-2.6 4.4-2.7 2.3-.2 3.8 1.4 4.3 4.8q.9 5.55 1.2 6.9c.7 3.1 1.4 4.6 2.2 4.6.6 0 1.6-1 2.8-3 1.3-2 1.9-3.5 2-4.5.2-1.7-.5-2.6-2-2.6-.7 0-1.5.2-2.2.5 1.5-4.8 4.3-7.2 8.4-7 3.1.1 4.5 2.1 4.4 6 0 2.8-2.1 6.8-6 11.9"
});
register("vk", {
	"color": "#45668e",
	"path": "M0 0v64h64V0zm44.94 44.84h-.2c-2.17-.36-3.66-1.92-4.92-3.37-.72-.81-1.82-2.66-3.12-2.47-1.85.3-.93 3.52-1.71 4.9-.62 1.11-3.29.91-5.12.71-5.79-.62-8.75-3.77-11.35-7.14A64 64 0 0 1 11.6 26a10.6 10.6 0 0 1-1.51-4.49c.91-.81 2.47-.51 4.02-.51 1.31 0 3.36-.29 4.32.2.57.26 1.14 1.8 1.57 2.8a37 37 0 0 0 3.31 5.82c.56.81 1.41 2.35 2.41 2.14s1.06-2.63 1.1-4.18c0-1.77 0-4-.5-4.9S25 22 24.15 21.47c.73-1.49 2.72-1.63 5.12-1.63 2 0 4.84-.23 5.62 1.12s.25 3.85.2 5.71c-.06 2.09-.41 4.25 1 5.21 1.09-.12 1.68-1.2 2.31-2A28 28 0 0 0 41.72 24c.44-1 .91-2.65 1.71-3 1.21-.47 3.15-.1 4.92-.1 1.46 0 4.05-.41 4.52.61.39.85-.75 3-1.1 3.57a62 62 0 0 1-4.12 5.61c-.58.78-1.78 2-1.71 3.27.05.94 1 1.67 1.71 2.35a33 33 0 0 1 3.92 4.18c.47.62 1.5 2 1.4 2.76-.31 2.56-6.09.99-8.03 1.59"
});
register("vsco", {
	"color": "#83878A",
	"path": "M0 0v64h64V0zm18.5 34.5c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5S21 30.6 21 32c-.1 1.4-1.2 2.5-2.5 2.5m6.6 6.6c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5 2.5 1.1 2.5 2.5-1.1 2.5-2.5 2.5m.1-13.4c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5 2.5 1.1 2.5 2.5-1.1 2.5-2.5 2.5M32 48c-1.4 0-2.5-1.1-2.5-2.5S30.6 43 32 43s2.5 1.1 2.5 2.5S33.4 48 32 48m-2.5-16.1c0-1.4 1.1-2.5 2.5-2.5s2.5 1.1 2.5 2.5-1.1 2.5-2.5 2.5-2.5-1.1-2.5-2.5m2.5-11c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5 2.5 1.1 2.5 2.5-1.1 2.5-2.5 2.5m6.7 1.8c1.4 0 2.5 1.1 2.5 2.5s-1.1 2.5-2.5 2.5-2.5-1.1-2.5-2.5 1.1-2.5 2.5-2.5m.1 18.5c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5 2.5 1.1 2.5 2.5c-.1 1.4-1.2 2.5-2.5 2.5m6.7-6.7c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5S48 30.6 48 32s-1.1 2.5-2.5 2.5"
});
register("vine", {
	"color": "#00BF8F",
	"path": "M0 0v64h64V0zm38.4 21.5c-1.2 0-2.1 1.2-2.1 3.4 0 4.6 2.9 7.2 6.7 7.2.7 0 1.4-.1 2.2-.3v3.6c-1.3.3-2.5.4-3.6.4-2.5 5.3-7 9.8-8.6 10.7-1 .5-1.9.6-2.9-.1-1.9-1.1-8.9-6.9-11.2-25H24c1.3 10.9 4.4 16.5 7.9 20.7 1.9-1.9 3.7-4.4 5.2-7.3-3.4-1.7-5.5-5.5-5.5-10s2.6-7.9 7-7.9c4.3 0 6.6 2.7 6.6 7.3 0 1.7-.4 3.7-1 5.2-3.2.6-4.4-1.4-4.4-1.4.2-.8.6-2.1.6-3.3-.1-2.1-.9-3.2-2-3.2"
});
register("wechat", {
	"color": "#00c80f",
	"path": "M65.6 65.6H-1.6V-1.6h67.2zM49.738 46.043c2.846-2.061 4.662-5.107 4.662-8.498 0-6.207-6.043-11.244-13.492-11.244-7.453 0-13.494 5.037-13.494 11.244 0 6.213 6.041 11.246 13.494 11.246 1.537 0 3.025-.221 4.402-.615l.395-.059c.262 0 .498.078.717.207l2.955 1.707.26.082a.45.45 0 0 0 .451-.449l-.074-.328-.605-2.271-.047-.287a.9.9 0 0 1 .376-.735M25.793 13.887C16.85 13.887 9.6 19.93 9.6 27.383c0 4.066 2.182 7.723 5.596 10.197.275.195.453.518.453.879l-.055.344-.732 2.725-.086.393c0 .301.24.541.539.541l.311-.1 3.545-2.049c.27-.152.551-.248.861-.248l.475.068a19 19 0 0 0 5.287.742l.891-.021a10.3 10.3 0 0 1-.543-3.309c0-6.793 6.611-12.305 14.768-12.305l.879.021c-1.225-6.443-7.918-11.374-15.996-11.374m10.615 21.859a1.798 1.798 0 1 1-.001-3.6 1.798 1.798 0 0 1 .001 3.6m8.996 0a1.798 1.798 0 1 1-.001-3.6 1.798 1.798 0 0 1 .001 3.6M20.395 25.221a2.16 2.16 0 1 1 .002-4.318 2.16 2.16 0 0 1-.002 4.318m10.796 0c-1.193 0-2.158-.965-2.158-2.158s.965-2.158 2.158-2.158 2.158.965 2.158 2.158-.964 2.158-2.158 2.158"
});
register("wa.me", {
	"color": "#25D366",
	"path": "M0 0v64h64V0zm48 31.59c0 8.605-7.031 15.586-15.71 15.586-2.755 0-5.34-.703-7.595-1.942L16 48l2.836-8.363a15.43 15.43 0 0 1-2.254-8.047c0-8.61 7.031-15.59 15.707-15.59C40.97 16 48 22.98 48 31.59M32.29 18.484c-7.282 0-13.208 5.88-13.208 13.106 0 2.867.938 5.52 2.516 7.68l-1.649 4.867 5.074-1.61a13.2 13.2 0 0 0 7.27 2.164c7.281 0 13.207-5.875 13.207-13.101s-5.926-13.106-13.21-13.106m7.933 16.696c-.098-.16-.352-.258-.739-.45-.382-.187-2.277-1.113-2.629-1.242-.355-.125-.613-.191-.867.192-.258.383-.996 1.242-1.218 1.5-.227.254-.45.285-.836.093-.387-.191-1.625-.593-3.098-1.894-1.145-1.012-1.918-2.262-2.14-2.645-.223-.382-.024-.59.167-.78.176-.173.387-.446.578-.669.196-.223.258-.383.387-.637.129-.257.063-.48-.035-.671-.094-.192-.867-2.07-1.188-2.836s-.64-.637-.863-.637c-.226 0-.484-.031-.738-.031a1.4 1.4 0 0 0-1.027.476c-.356.383-1.348 1.309-1.348 3.188s1.379 3.695 1.57 3.949c.196.258 2.664 4.238 6.578 5.77 3.914 1.53 3.914 1.019 4.621.956.707-.066 2.278-.925 2.602-1.816.32-.894.32-1.66.223-1.816m0 0"
});
register("whatsapp", {
	"color": "#25D366",
	"path": "M0 0v64h64V0zm48 31.59c0 8.605-7.031 15.586-15.71 15.586-2.755 0-5.34-.703-7.595-1.942L16 48l2.836-8.363a15.43 15.43 0 0 1-2.254-8.047c0-8.61 7.031-15.59 15.707-15.59C40.97 16 48 22.98 48 31.59M32.29 18.484c-7.282 0-13.208 5.88-13.208 13.106 0 2.867.938 5.52 2.516 7.68l-1.649 4.867 5.074-1.61a13.2 13.2 0 0 0 7.27 2.164c7.281 0 13.207-5.875 13.207-13.101s-5.926-13.106-13.21-13.106m7.933 16.696c-.098-.16-.352-.258-.739-.45-.382-.187-2.277-1.113-2.629-1.242-.355-.125-.613-.191-.867.192-.258.383-.996 1.242-1.218 1.5-.227.254-.45.285-.836.093-.387-.191-1.625-.593-3.098-1.894-1.145-1.012-1.918-2.262-2.14-2.645-.223-.382-.024-.59.167-.78.176-.173.387-.446.578-.669.196-.223.258-.383.387-.637.129-.257.063-.48-.035-.671-.094-.192-.867-2.07-1.188-2.836s-.64-.637-.863-.637c-.226 0-.484-.031-.738-.031a1.4 1.4 0 0 0-1.027.476c-.356.383-1.348 1.309-1.348 3.188s1.379 3.695 1.57 3.949c.196.258 2.664 4.238 6.578 5.77 3.914 1.53 3.914 1.019 4.621.956.707-.066 2.278-.925 2.602-1.816.32-.894.32-1.66.223-1.816m0 0"
});
register("x", {
	"color": "#000000",
	"path": "M0 0v64h64V0zm16 17.537h10.125l6.992 9.242 8.084-9.242h4.908L35.39 29.79 48 46.463h-9.875l-7.734-10.111-8.85 10.11h-4.908l11.465-13.105zm5.73 2.783 17.75 23.205h2.72L24.647 20.32z"
});
register("xiaohongshu", {
	"color": "#ff2741",
	"path": "M8.494-.006h47.784c4.552 0 8.596 3.953 8.715 8.5V56.28a8.91 8.91 90 0 1-8.717 8.702H8.509A8.92 8.92 90 0 1 .004 56.26V8.514C.114 4.038 4.018.12 8.494-.006m4.247 23.213c-.033 5.045-.016 10.092-.041 15.138a.533.533 90 0 1-.54.66c-.607.036-1.217.015-1.826.02a61 61 0 0 0 1.307 2.978c1.148-.038 2.458.201 3.438-.55.88-.656 1.162-1.82 1.145-2.87 0-5.125 0-10.253-.023-15.378a263 263 0 0 0-3.46.002m14.236-.228q-1.29 2.963-2.63 5.9c-.254.586-.56 1.363-.028 1.893.683.62 1.686.381 2.524.437-.581 1.467-1.346 2.861-1.836 4.364-.271.741.407 1.495 1.148 1.503 1.343.091 2.69 0 4.036.035.44-.982.881-1.962 1.313-2.95-.785 0-1.577.056-2.348-.099.835-2.096 1.825-4.125 2.71-6.196-1.083-.127-2.31.226-3.3-.196.483-1.625 1.361-3.115 1.98-4.696-1.192-.005-2.38-.013-3.568.005zm18.469.013v1.322h-2.33v3.536c.779 0 1.556 0 2.332.016q.03 1.523 0 3.066c-1.167.023-2.338 0-3.506.018a149 149 0 0 0 0 3.529c1.17.013 2.344 0 3.514 0v7.512h3.516v-7.507c1.711 0 3.42-.025 5.13 0 .602-.05 1.29.37 1.27 1.033a28 28 90 0 1 0 2.813.574.574 90 0 1-.538.607c-.978.07-1.958 0-2.938.033.432 1.015.85 2.03 1.34 3.033 1.613-.083 3.583.323 4.812-1.015 1.167-1.082.817-2.793.865-4.204-.073-1.485.29-3.163-.632-4.463-.784-1.102-2.198-1.401-3.473-1.424-.076-1.777.348-3.856-.96-5.3-1.218-1.367-3.18-1.372-4.866-1.306v-1.32c-1.193.013-2.366.015-3.536.02zM32.9 24.317v3.534h2.206v10.596c-1.053.018-2.11 0-3.163.013a315 315 0 0 0-1.61 3.528c3.93.016 7.87 0 11.79 0V38.46c-1.13 0-2.262 0-3.392-.013V27.843h2.214v-3.536c-2.676.005-5.36 0-8.045.01m23.19.325c-.985.746-.662 2.112-.705 3.175.657 0 1.317.036 1.975-.022 1.056-.097 1.85-1.328 1.426-2.323-.332-1.092-1.807-1.567-2.696-.83M6.86 27.848c-.178 2.315-.358 4.628-.526 6.943a5.6 5.6 90 0 1-.335 1.539 156 156 0 0 0 1.823 4.061c1.421-1.901 1.95-4.298 2.097-6.625.124-1.98.345-3.958.416-5.94-1.165.04-2.323.012-3.476.022m11.71 0 .508 6.44c.185 2.153.741 4.347 2.056 6.093a172 172 0 0 0 1.82-4.062 5.5 5.5 90 0 1-.355-1.546c-.167-2.307-.35-4.615-.528-6.923q-1.757-.01-3.508-.002zm4.357 13.884c1.797.53 3.7.167 5.546.266a295 295 0 0 0 1.612-3.536c-1.845-.071-3.724.193-5.534-.272q-.83 1.765-1.632 3.542zM48.94 27.86c.762.109 1.777-.31 2.359.304.096.927.025 1.859.035 2.793h-2.37q-.024-1.549-.024-3.097"
});
register("yandex", {
	"color": "#fc3f1d",
	"path": "M0 0v64h64V0Zm18.656 16h5.91l7.248 15.793c2.124 4.604 3.05 6.998 3.05 12.293V48H29.46v-3.223c0-4.374-.507-6.539-2.262-10.314zm21.008 0h5.68L38.51 31.47h-5.586z"
});
register("xing", {
	"color": "#0698A0",
	"path": "M1.008 0C.45 0 0 .45 0 1.01v62.11c0 .56.45 1.01 1.008 1.01h62.02c.56 0 1.009-.45 1.009-1.01V1.01c0-.56-.45-1.01-1.009-1.01ZM41.72 16.032h5.482c.327 0 .585.106.723.296.143.197.139.459-.012.714L35.898 35.145a.025.025 0 0 0 0 .032l7.65 11.91c.152.257.156.517.012.715-.138.19-.394.295-.721.295h-5.42c-.83 0-1.247-.47-1.516-.88l-7.71-12.056c.386-.58 12.074-18.248 12.074-18.248.291-.446.642-.88 1.452-.88m-22.794 6.334h5.425c.832 0 1.24.456 1.51.867l3.731 5.544-5.857 8.828c-.277.427-.668.893-1.48.893h-5.426c-.326 0-.571-.125-.71-.315-.142-.198-.15-.453 0-.709l5.766-8.672c.006-.01.006-.015 0-.025l-3.668-5.413c-.152-.258-.175-.513-.032-.71.138-.192.414-.288.74-.288"
});
register("yelp", {
	"color": "#B90C04",
	"path": "M0 0v64h64V0zm22.4 37.9q-.6 0-.9-.6c-.1-.3-.2-.7-.3-1.3-.2-1.7 0-4.2.5-5 .2-.4.6-.6 1-.6.3 0 .5.1 5.5 2.1l1.5.6c.5.2.9.7.8 1.4 0 .6-.4 1.1-.9 1.2l-2.1.7c-4.7 1.5-4.8 1.5-5.1 1.5M33 41c0 4.9 0 5-.1 5.3-.1.4-.4.6-.9.7-1.2.2-5.1-1.2-6-2.2q-.3-.3-.3-.6c0-.2 0-.3.1-.4.1-.2.2-.4 3.7-4.5l1-1.2c.3-.4 1-.6 1.5-.4.6.2.9.7.9 1.2.1-.1.1 2.1.1 2.1m-.8-10.2c-.3.1-1 .3-2-1.2 0 0-6.4-10.1-6.5-10.4s0-.7.3-1.1c1-1 6.1-2.4 7.5-2.1.4.1.7.4.9.8.1.4.7 9.8.8 11.9 0 1.8-.8 2-1 2.1m3.2.5 1.3-1.8c2.8-3.9 3-4.1 3.2-4.2.3-.2.7-.2 1.1 0 1.1.5 3.4 3.9 3.5 5.2 0 .4-.1.8-.5 1-.2.1-.4.2-5.7 1.5-.8.2-1.3.3-1.6.4-.5.1-1.1-.1-1.4-.6-.2-.5-.2-1.1.1-1.5m9.3 8.3c-.2 1.3-2.7 4.5-3.9 5-.4.2-.8.1-1.1-.1-.2-.2-.4-.5-3.2-5l-.8-1.3c-.3-.5-.3-1.1.1-1.6s.9-.6 1.4-.5l2.1.7c4.6 1.5 4.8 1.6 5 1.7.4.3.5.7.4 1.1"
});
register("youtube", {
	"color": "#ff3333",
	"path": "M0 0v64h64V0zm47 33.1c0 2.4-.3 4.9-.3 4.9s-.3 2.1-1.2 3c-1.1 1.2-2.4 1.2-3 1.3-4.2.2-10.5.3-10.5.3s-7.8-.1-10.2-.3c-.7-.1-2.2-.1-3.3-1.3-.9-.9-1.2-3-1.2-3s-.3-2.4-.3-4.9v-2.3c0-2.4.3-4.9.3-4.9s.3-2.1 1.2-3c1.1-1.2 2.4-1.2 3-1.3 4.2-.3 10.5-.3 10.5-.3s6.3 0 10.5.3c.6.1 1.9.1 3 1.3.9.9 1.2 3 1.2 3s.3 2.4.3 4.9zm-18.1 2.8 8.1-4.2-8.1-4.2z"
});
const GradientIcon = ({ path, size = 24, class: className }) => /* @__PURE__ */ u("svg", {
	width: size,
	height: size,
	viewBox: "0 0 256 256",
	class: className,
	children: [/* @__PURE__ */ u("defs", { children: /* @__PURE__ */ u("linearGradient", {
		id: "gradient",
		x1: "0",
		y1: "0",
		x2: ".75",
		y2: ".75",
		children: [/* @__PURE__ */ u("stop", {
			offset: "0%",
			"stop-color": primaryGradientA.value
		}), /* @__PURE__ */ u("stop", {
			offset: "100%",
			"stop-color": primaryGradientB.value
		})]
	}) }), /* @__PURE__ */ u("path", {
		d: path,
		fill: "url(#gradient)"
	})]
});
const PlayGradientIcon = ({ size = 24 }) => /* @__PURE__ */ u(GradientIcon, {
	size,
	path: "M240,128a15.74,15.74,0,0,1-7.6,13.51L88.32,229.65a16,16,0,0,1-16.2.3A15.86,15.86,0,0,1,64,216.13V39.87a15.86,15.86,0,0,1,8.12-13.82,16,16,0,0,1,16.2.3L232.4,114.49A15.74,15.74,0,0,1,240,128Z"
});
const PauseGradientIcon = ({ size = 24 }) => /* @__PURE__ */ u(GradientIcon, {
	size,
	path: "M216,48V208a16,16,0,0,1-16,16H160a16,16,0,0,1-16-16V48a16,16,0,0,1,16-16h40A16,16,0,0,1,216,48ZM96,32H56A16,16,0,0,0,40,48V208a16,16,0,0,0,16,16H96a16,16,0,0,0,16-16V48A16,16,0,0,0,96,32Z"
});
const StopGradientIcon = ({ size = 24 }) => /* @__PURE__ */ u(GradientIcon, {
	size,
	path: "M216,56V200a16,16,0,0,1-16,16H56a16,16,0,0,1-16-16V56A16,16,0,0,1,56,40H200A16,16,0,0,1,216,56Z"
});
const HeartGradientIcon = ({ size = 24, class: className }) => /* @__PURE__ */ u(GradientIcon, {
	size,
	class: className,
	path: "M240,102c0,70-103.79,126.66-108.21,129a8,8,0,0,1-7.58,0C119.79,228.66,16,172,16,102A62.07,62.07,0,0,1,78,40c20.65,0,38.73,8.88,50,23.89C139.27,48.88,157.35,40,178,40A62.07,62.07,0,0,1,240,102Z"
});
const editorSettings = {
	showGutter: !isMobile(),
	lineHeight: isMobile() ? 14 : 18,
	fontSize: isMobile() ? "8pt" : "11.5pt",
	colors: {
		black: "#272822",
		red: "#f92672",
		green: "#a6e22e",
		yellow: "#e6db74",
		blue: "#66d9ef",
		purple: "#ae81ff",
		cyan: "#38ccd1",
		white: "#f8f8f2",
		gray: "#75715e",
		brightBlack: "#272822",
		brightRed: "#fd5ff1",
		brightGreen: "#a1efe4",
		brightYellow: "#ffd866",
		brightBlue: "#66d9ef",
		brightPurple: "#ae81ff",
		brightCyan: "#a1efe4",
		brightWhite: "#f9f8f5"
	},
	syntax: (c$7) => ({
		keyword: {
			color: c$7.blue,
			style: "italic",
			weight: "regular"
		},
		function: {
			color: c$7.green,
			style: "normal",
			weight: "regular"
		},
		identifier: {
			color: c$7.white,
			style: "normal",
			weight: "regular"
		},
		string: {
			color: c$7.yellow,
			style: "normal",
			weight: "regular"
		},
		number: {
			color: c$7.purple,
			style: "normal",
			weight: "regular"
		},
		boolean: {
			color: c$7.red,
			style: "normal",
			weight: "regular"
		},
		null: {
			color: c$7.blue,
			style: "normal",
			weight: "regular"
		},
		operator: {
			color: c$7.red,
			style: "normal",
			weight: "regular"
		},
		punctuation: {
			color: c$7.cyan,
			style: "normal",
			weight: "regular"
		},
		comment: {
			color: c$7.gray,
			style: "normal",
			weight: "regular"
		},
		text: {
			color: c$7.white,
			style: "normal",
			weight: "regular"
		},
		special: {
			color: c$7.red,
			style: "normal",
			weight: "bold"
		}
	})
};
const createEditorOnHover = (editor$1, getInline) => {
	const { onHoverToken, onCaretToken } = createDefinitionTooltipHandlers(editor$1, getInline);
	editor$1.onHoverToken = onHoverToken;
	editor$1.onCaretToken = onCaretToken;
};
const InlineEditor = ({ code, doc, id, ready, header = null, headerHeight = 0, autoHeight = true, showGutter = true, persisted = true, class: className = "" }) => {
	const ref = A(null);
	const inline = useSignal(null);
	const waveBackground = useSignal(theme.value.black);
	useReactiveEffect(() => {
		if (!ctx.value) return;
		getProgramContext(ctx.value, id, {
			doc: doc ?? (persisted ? createPersistedDoc(id, tokenize) : createDoc(tokenize)),
			waveBackground
		}).then((instance) => {
			if (doc) code = doc.code ?? "";
			code ??= "";
			const lines = code.split("\n");
			if (lines.at(-1)?.length === 0) lines.pop();
			n(() => {
				inline.value = instance;
				inline.value.doc.code ||= lines.join("\n");
				inline.value.fullResync.value = true;
				if (ready) setTimeout(() => {
					ready.value = true;
				}, 1e3);
			});
		});
	}, [ctx]);
	const editor$1 = T(() => createEditor({
		wordWrap: false,
		autoHeight,
		paddingTop: 15,
		paddingLeft: isMobile() || !showGutter ? 15 : 5,
		paddingRight: isMobile() || !showGutter ? 15 : 12,
		paddingBottom: 15,
		...editorSettings,
		showGutter
	}), [autoHeight]);
	useReactiveEffect(() => {
		if (!inline.value) return;
		o$24(() => {
			if (inline.value) editor$1.setDoc(inline.value.doc);
		});
	}, [editor$1]);
	useReactiveEffect(() => {
		if (!inline.value) return;
		if (doc) code = doc.code ?? "";
		inline.value.doc.code = code ?? "";
		inline.value.fullResync.value = true;
	}, [code, inline]);
	useReactiveEffect(() => {
		if (!ctx.value || !inline.value || playingContext.value !== inline.value) return;
		ctx.value.historiesRefreshed.value;
		o$24(() => {
			if (inline.value) editor$1.setDoc(inline.value.doc);
		});
	}, [editor$1]);
	useReactiveEffect(() => {
		Object.assign(editor$1.settings.colors, {
			...theme.value,
			black: luminate(theme.value.black, .04)
		});
		waveBackground.value = editor$1.settings.colors.black;
	}, [editor$1]);
	useReactiveEffect(() => {
		createEditorOnHover(editor$1, () => inline.value);
	}, [editor$1]);
	y(() => {
		if (ref.current) ref.current.appendChild(editor$1.canvas);
	}, [ref, editor$1]);
	const isCurrentPlaying = useComputed(() => inline.value !== null && playingInlineContext.value === inline.value);
	y(() => () => editor$1.dispose(), []);
	const PlayButton = () => /* @__PURE__ */ u("button", {
		class: cn("group flex px-3 py-2 active:hover:scale-95 outline-none focus:bg-white/5", { "absolute right-0": isMobile() && header }),
		onMouseDown: async (e$59) => {
			e$59.preventDefault();
			e$59.stopPropagation();
			if (!ctx.value) return;
			if (!inline.value) return;
			if (isCurrentPlaying.value) {
				await inlineTransport.stop();
				return;
			}
			if (playingInlineContext.value === inline.value && (e$59.ctrlKey || e$59.metaKey || e$59.button === MouseButton.Right)) await inlineTransport.restart();
			else await inlineTransport.start(inline.value);
		},
		children: isCurrentPlaying.value ? /* @__PURE__ */ u(StopGradientIcon, { size: 24 }) : /* @__PURE__ */ u(PlayGradientIcon, { size: 24 })
	});
	return /* @__PURE__ */ u("div", {
		class: `bg-[${editor$1.settings.colors.black}] ${className} relative`,
		children: [
			(!header || !isMobile()) && /* @__PURE__ */ u("div", {
				class: cn("mb-0 flex flex-row absolute ", {
					"top-[4px] right-[calc(100%-2px)]": !isMobile(),
					"right-0 bottom-0 translate-y-[100%]": isMobile()
				}),
				children: /* @__PURE__ */ u(PlayButton, {})
			}),
			header?.(isMobile() ? /* @__PURE__ */ u(PlayButton, {}) : void 0),
			/* @__PURE__ */ u("div", {
				ref,
				class: autoHeight ? "w-full" : `w-full h-[calc(100%-${headerHeight}px)]`
			})
		]
	});
};
const BrowseProject = ({ project, autoHeight = false, header, headerHeight = 48 }) => {
	signalify(project);
	project.likes.forEach((like) => {
		signalify(like);
	});
	project.comments.forEach((comment) => {
		signalify(comment);
	});
	project.remixes.forEach((remix) => {
		signalify(remix);
	});
	const rows = useSignal(1);
	const commentText = useSignal("");
	const commentSending = useSignal(false);
	const handleChange = (event) => {
		const textarea$1 = event.target;
		rows.value = textarea$1.value.split("\n").length;
		commentText.value = textarea$1.value;
	};
	const handleCommentSend = async () => {
		const commentTextToSend = commentText.value;
		commentText.value = "";
		commentSending.value = true;
		try {
			const comment = await api.commentProject(project.id, commentTextToSend);
			project.comments = [...project.comments, comment];
			rows.value = 1;
		} finally {
			commentSending.value = false;
		}
	};
	return /* @__PURE__ */ u("div", {
		class: "flex flex-col",
		children: [/* @__PURE__ */ u(InlineEditor, {
			id: project.id,
			code: project.code,
			autoHeight,
			class: !autoHeight ? "w-full h-[45dvh]" : "w-full h-full",
			headerHeight,
			header: header || ((inner) => /* @__PURE__ */ u("div", {
				class: "h-[48px] px-4 bg-black/40 flex flex-row items-center justify-start relative gap-3",
				children: [
					/* @__PURE__ */ u("div", {
						class: "flex flex-row gap-2 items-center justify-start",
						children: [
							/* @__PURE__ */ u(Link$1, {
								to: `/u/${project.userId}/${project.artistName}`,
								class: `inline-flex flex-row items-center gap-2 text-[${primaryColor.value}] hover:text-[${primaryGradientA.value}]`,
								children: [/* @__PURE__ */ u(Avatar, {
									userId: project.userId,
									size: 16,
									fallback: /* @__PURE__ */ u(Minidenticon, {
										username: project.userId,
										width: 16,
										height: 16,
										class: "bg-white/20 rounded-full"
									})
								}), project.artistName]
							}),
							" ",
							"- ",
							/* @__PURE__ */ u(Link$1, {
								to: `/p/${project.id}`,
								class: "text-white hover:underline",
								children: project.name
							}),
							/* @__PURE__ */ u("span", {
								class: "ml-1.5 text-white/50 text-xs h-5 flex items-end justify-end flex-col",
								children: timeAgo(new Date(project.updatedAt))
							})
						]
					}),
					!isMobile() && /* @__PURE__ */ u(k, { children: [/* @__PURE__ */ u("button", {
						class: "group h-5 flex flex-row gap-1 text-xs items-end justify-end",
						onClick: () => {
							if (!session.value) {
								alert("You must be logged in to like a project");
								sidebarTab.value = "account";
								return;
							}
							if (session.value.likes?.includes(project.id)) {
								session.value = {
									...session.value,
									likes: session.value.likes?.filter((l$10) => l$10 !== project.id) ?? []
								};
								project.likes = project.likes.filter((l$10) => l$10.userId !== session.value.userId);
								api.unlikeProject(project.id);
								return;
							} else {
								session.value = {
									...session.value,
									likes: [...session.value?.likes ?? [], project.id]
								};
								project.likes = [...project.likes, {
									userId: session.value.userId,
									artistName: session.value.artistName
								}];
								api.likeProject(project.id);
							}
						},
						children: [/* @__PURE__ */ u("div", {
							class: "relative -top-[1px]",
							children: [session.value?.likes?.includes(project.id) ? /* @__PURE__ */ u(HeartGradientIcon, { size: 16 }) : /* @__PURE__ */ u(o$13, {
								size: 16,
								weight: "regular",
								class: "group-hover:opacity-0"
							}), !session.value?.likes?.includes(project.id) && /* @__PURE__ */ u(o$13, {
								size: 16,
								weight: session.value?.likes?.includes(project.id) ? "regular" : "fill",
								class: "absolute inset-0 opacity-0 group-hover:opacity-100"
							})]
						}), /* @__PURE__ */ u("span", { children: project.likes.length })]
					}), /* @__PURE__ */ u("button", {
						class: "group h-5 items-end justify-end",
						children: /* @__PURE__ */ u("div", {
							class: "relative top-[1px] flex flex-row gap-2 items-center justify-center",
							children: [/* @__PURE__ */ u(o$7, { size: 16 }), /* @__PURE__ */ u("div", {
								class: "opacity-0 scale-x-0 group-hover:opacity-100 group-hover:scale-x-100 origin-left group-hover:transition-all group-hover:duration-200 flex flex-row gap-2",
								children: [
									/* @__PURE__ */ u(SocialIcon, {
										as: "span",
										network: "x",
										style: {
											width: 20,
											height: 20
										},
										className: "grayscale hover:grayscale-0"
									}),
									/* @__PURE__ */ u(SocialIcon, {
										as: "span",
										network: "mastodon",
										style: {
											width: 20,
											height: 20
										},
										className: "grayscale hover:grayscale-0"
									}),
									/* @__PURE__ */ u(SocialIcon, {
										as: "span",
										network: "facebook",
										style: {
											width: 20,
											height: 20
										},
										className: "grayscale hover:grayscale-0"
									}),
									/* @__PURE__ */ u(SocialIcon, {
										as: "span",
										network: "reddit",
										style: {
											width: 20,
											height: 20
										},
										className: "grayscale hover:grayscale-0"
									}),
									/* @__PURE__ */ u(SocialIcon, {
										as: "span",
										network: "whatsapp",
										style: {
											width: 20,
											height: 20
										},
										className: "grayscale hover:grayscale-0"
									}),
									/* @__PURE__ */ u(SocialIcon, {
										as: "span",
										network: "telegram",
										style: {
											width: 20,
											height: 20
										},
										className: "grayscale hover:grayscale-0"
									})
								]
							})]
						})
					})] }),
					inner
				]
			}))
		}), /* @__PURE__ */ u("div", {
			class: `bg-[${luminate(theme.value.black, .04)}]`,
			children: /* @__PURE__ */ u("div", {
				class: "bg-black/40 flex flex-col",
				children: [project.comments.length ? /* @__PURE__ */ u("div", {
					class: "flex flex-col justify-start py-2 text-sm border-b-2 border-white/5",
					children: project.comments.sort((a$36, b$4) => a$36.createdAt - b$4.createdAt).map((comment) => /* @__PURE__ */ u("div", {
						class: "group w-full flex flex-row gap-2 py-0.5 px-3 items-center justify-start hover:bg-white/5",
						children: [
							/* @__PURE__ */ u("div", {
								class: "flex flex-row gap-2 items-center justify-start",
								children: /* @__PURE__ */ u(Link$1, {
									to: `/u/${comment.userId}/${comment.artistName}`,
									class: "flex flex-row gap-2 items-center justify-start hover:text-white",
									children: [/* @__PURE__ */ u(Avatar, {
										userId: comment.userId,
										fallback: /* @__PURE__ */ u(Minidenticon, {
											username: comment.userId,
											width: 16,
											height: 16,
											class: "bg-white/20 rounded-full"
										})
									}), comment.artistName]
								})
							}),
							/* @__PURE__ */ u("span", {
								class: "text-white",
								children: comment.comment
							}),
							session.value?.userId === comment.userId && /* @__PURE__ */ u("button", {
								class: "opacity-0 group-hover:opacity-100 text-white/50 text-xs hover:text-white ml-auto",
								onClick: () => {
									if (confirm("Are you sure you want to delete this comment?")) {
										api.deleteComment(project.id, comment.id);
										project.comments = project.comments.filter((c$7) => c$7.id !== comment.id);
									}
								},
								children: /* @__PURE__ */ u(r$1, { size: 16 })
							})
						]
					}, comment.id))
				}) : null, !isMobile() && (session.value ? /* @__PURE__ */ u("div", {
					class: "relative flex flex-row gap-2 items-end justify-start",
					children: [commentSending.value ? /* @__PURE__ */ u("div", {
						class: "relative right-1 flex flex-row gap-2 cursor-wait w-full items-center justify-start text-white/30 text-sm py-2 px-4",
						children: [/* @__PURE__ */ u(c, {
							size: 16,
							class: "animate-spin"
						}), /* @__PURE__ */ u("span", { children: "Sending..." })]
					}) : /* @__PURE__ */ u(k, { children: [/* @__PURE__ */ u("div", {
						class: "absolute top-2.5 left-3",
						children: /* @__PURE__ */ u(Avatar, {
							userId: session.value?.userId ?? "",
							size: 16,
							fallback: /* @__PURE__ */ u(Minidenticon, {
								username: session.value?.userId ?? "",
								width: 16,
								height: 16,
								class: "bg-white/20 rounded-full"
							})
						})
					}), /* @__PURE__ */ u("textarea", {
						class: "text-sm text-white bg-transparent w-full px-4 pl-9 py-2 outline-none resize-none",
						wrap: "off",
						rows,
						value: commentText,
						onChange: handleChange,
						onKeyDown: (e$59) => {
							if (e$59.key === "Enter" && !e$59.ctrlKey && !e$59.metaKey && !e$59.shiftKey && !e$59.altKey) {
								handleCommentSend();
								e$59.preventDefault();
							}
						},
						placeholder: "Leave a comment..."
					})] }), /* @__PURE__ */ u("button", {
						class: cn(`flex flex-row gap-2 items-center justify-center text-sm text-white hover:bg-[${luminate(theme.value.black, .01)}77] px-4 py-2`, { "opacity-50 cursor-wait": commentSending.value }),
						disabled: commentSending.value,
						onClick: handleCommentSend,
						children: [commentSending.value ? "Sending..." : "Send", commentSending.value ? /* @__PURE__ */ u(c, {
							size: 16,
							class: "animate-spin"
						}) : /* @__PURE__ */ u(a$3, { size: 16 })]
					})]
				}) : /* @__PURE__ */ u("div", {
					class: "relative flex flex-row gap-2 items-end justify-start",
					children: /* @__PURE__ */ u("div", {
						class: "text-white/50 text-sm py-2 px-4 flex flex-row gap-1 items-center justify-start",
						children: [/* @__PURE__ */ u("button", {
							onClick: () => {
								sidebarTab.value = "account";
							},
							class: "text-white hover:underline",
							children: "Log in"
						}), "to leave a comment."]
					})
				}))]
			})
		})]
	}, project.id);
};
const BrowseProjects = ({ projects: projects$1 }) => {
	widgetOptions.showVisuals = true;
	widgetOptions.showKnobs = true;
	widgetOptions.noHeader = true;
	return /* @__PURE__ */ u(Main, {
		class: "flex flex-col text-white/50 md:px-8 md:pl-12 py-8 gap-8",
		children: projects$1.map((project) => /* @__PURE__ */ u(BrowseProject, { project }, project.id))
	}, "projects");
};
const ArtistMain = () => {
	const userId = useComputed(() => pathname.value.split("/")[2] ?? "");
	const projects$1 = useAsyncMemo(async () => {
		if (!userId.value) return [];
		return await api.fetchUserProjects(userId.value);
	});
	useReactiveEffect(() => {
		userProjectsCount.value = projects$1.value?.length ?? 0;
	}, [projects$1.value]);
	return /* @__PURE__ */ u(k, { children: [/* @__PURE__ */ u(Header, {}), /* @__PURE__ */ u(BrowseProjects, { projects: projects$1.value ?? [] })] });
};
function toCamelCase(s$4) {
	return s$4.charAt(0).toLowerCase() + s$4.slice(1).replace(/-(.)/g, (_$5, c$7) => c$7.toUpperCase());
}
function toTitleCase(s$4) {
	return s$4.charAt(0).toUpperCase() + s$4.slice(1).toLowerCase().replace(/-(.)/g, (_$5, c$7) => "-" + c$7.toUpperCase());
}
const Spinner = ({ lineWidth = 2.8 }) => /* @__PURE__ */ u("svg", {
	width: "100%",
	height: "100%",
	fill: "currentColor",
	viewBox: "0 0 24 24",
	xmlns: "http://www.w3.org/2000/svg",
	className: "block",
	preserveAspectRatio: "none",
	children: [
		/* @__PURE__ */ u("style", { children: `
      .spinner_7uc5{
        animation:spinner_3l8F .9s linear infinite;
        animation-delay:-.9s
      }
      .spinner_RibN{animation-delay:-.7s}
      .spinner_ZAxd{animation-delay:-.5s}
      @keyframes spinner_3l8F{
        0%,66.66%{
          animation-timing-function:cubic-bezier(0.14,.73,.34,1);
          y:6px;
          height:12px
        }
        33.33%{
          animation-timing-function:cubic-bezier(0.65,.26,.82,.45);
          y:1px;
          height:22px
        }
      }
    ` }),
		/* @__PURE__ */ u("rect", {
			className: "spinner_7uc5 spinner_ZAxd",
			x: "1",
			y: "6",
			width: lineWidth,
			height: "12"
		}),
		/* @__PURE__ */ u("rect", {
			className: "spinner_7uc5 spinner_RibN",
			x: "5.8",
			y: "6",
			width: lineWidth,
			height: "12"
		}),
		/* @__PURE__ */ u("rect", {
			className: "spinner_7uc5",
			x: "10.6",
			y: "6",
			width: lineWidth,
			height: "12"
		}),
		/* @__PURE__ */ u("rect", {
			className: "spinner_7uc5 spinner_RibN",
			x: "15.4",
			y: "6",
			width: lineWidth,
			height: "12"
		}),
		/* @__PURE__ */ u("rect", {
			className: "spinner_7uc5 spinner_ZAxd",
			x: "20.2",
			y: "6",
			width: lineWidth,
			height: "12"
		})
	]
});
const SpinnerSmall = () => /* @__PURE__ */ u("div", {
	className: "w-5 h-5",
	children: /* @__PURE__ */ u(Spinner, { lineWidth: 2 })
});
const SpinnerLarge = () => /* @__PURE__ */ u("div", {
	className: "w-7 h-6",
	children: /* @__PURE__ */ u(Spinner, { lineWidth: 1.25 })
});
var oneLinerDoc = createPersistedDoc("one-liner", tokenize);
const OneLiners = ({ oneLiners }) => {
	const list = useSignal(oneLiners);
	const doc = oneLinerDoc;
	y(() => {
		list.value = oneLiners;
	}, [oneLiners]);
	y(() => {
		if (!doc.code || doc.code.trim() === "") doc.code = "// sine wave\n\nsine(a4) |> out($)";
	}, []);
	const postOneLiner = q(async () => {
		list.value = [await api.postBrowseOneLiner(doc.buffer.code.value), ...list.value];
	}, [doc]);
	const deleteOneLiner = async (oneLiner) => {
		if (!confirm("Are you sure you want to delete this one-liner?")) return;
		await api.deleteBrowseOneLiner(oneLiner);
		list.value = list.value.filter((o$34) => o$34.id !== oneLiner.id);
	};
	return /* @__PURE__ */ u(Main, { children: [/* @__PURE__ */ u("div", {
		class: "flex flex-col items-start gap-4 p-4 pl-12",
		children: [
			/* @__PURE__ */ u("p", { children: "One-liners are short, simple code snippets that are easy to understand and help you learn to use loopmaster." }),
			/* @__PURE__ */ u("p", { children: [
				"Post your own one-liner here: (or ",
				/* @__PURE__ */ u(Link$1, {
					class: "text-white",
					to: "/docs",
					children: "read the docs"
				}),
				" or",
				" ",
				/* @__PURE__ */ u(Link$1, {
					class: "text-white",
					to: "/tutorials",
					children: "the tutorials"
				}),
				")"
			] }),
			/* @__PURE__ */ u("div", {
				class: "w-full",
				children: /* @__PURE__ */ u(InlineEditor, {
					showGutter: false,
					doc,
					id: "one-liner"
				})
			}),
			/* @__PURE__ */ u("button", {
				onClick: postOneLiner,
				class: "bg-white/5 px-3 py-1 hover:bg-white/10 text-white flex items-center gap-2",
				children: ["Post ", /* @__PURE__ */ u(a$3, { size: 16 })]
			}),
			/* @__PURE__ */ u("div", { class: `border-b-2 border-[${primaryColor.value}] w-full` })
		]
	}), list.value.length === 0 ? /* @__PURE__ */ u("div", {
		class: "flex flex-col items-center justify-center text-white pt-16",
		children: /* @__PURE__ */ u(SpinnerLarge, {})
	}) : /* @__PURE__ */ u("div", {
		class: "flex flex-col items-start gap-4 p-4 pl-12",
		children: list.value.map((oneLiner) => /* @__PURE__ */ u("div", {
			class: "w-full flex flex-row",
			children: [/* @__PURE__ */ u(InlineEditor, {
				showGutter: false,
				class: "flex-1",
				code: oneLiner.code,
				id: `one-liner-${oneLiner.id}`,
				persisted: false
			}, oneLiner.id), session.value && session.value.isAdmin && /* @__PURE__ */ u("button", {
				onClick: () => deleteOneLiner(oneLiner),
				children: /* @__PURE__ */ u(r$1, { size: 16 })
			})]
		}))
	})] }, "one-liners");
};
var icons = {
	newest: /* @__PURE__ */ u(c$1, { size: 24 }),
	popular: /* @__PURE__ */ u(r$5, { size: 24 }),
	hottest: /* @__PURE__ */ u(o$25, { size: 24 }),
	liked: /* @__PURE__ */ u(o$13, { size: 24 }),
	oneLiners: /* @__PURE__ */ u(e$1, { size: 24 })
};
const BrowseMain = () => {
	const section$2 = useComputed(() => pathname.value.split("/")[2] ?? "");
	const browseLoading = useSignal(false);
	const projects$1 = useAsyncMemo(async () => {
		browseLoading.value = true;
		projects$1.value = [];
		try {
			if (section$2.value === "newest") return await api.fetchBrowseNewest();
			if (section$2.value === "popular") return await api.fetchBrowsePopular();
			if (section$2.value === "hottest") return await api.fetchBrowseHottest();
			if (section$2.value === "liked") return await api.fetchBrowseLiked();
			if (section$2.value === "one-liners") return await api.fetchBrowseOneLiners();
			return [];
		} finally {
			browseLoading.value = false;
		}
	});
	useReactiveEffect(() => {
		browseProjects.value = projects$1.value;
	});
	return /* @__PURE__ */ u(k, { children: [/* @__PURE__ */ u(Header, { children: [icons[toCamelCase(section$2.value ?? "")], /* @__PURE__ */ u("span", {
		class: "text-md font-bold",
		children: toTitleCase(section$2.value)
	})] }, "header"), browseLoading.value ? /* @__PURE__ */ u(Main, {
		class: "cursor-wait text-white w-full h-full flex items-center justify-center",
		children: /* @__PURE__ */ u(SpinnerLarge, {})
	}, "spinner") : section$2.value === "one-liners" ? /* @__PURE__ */ u(OneLiners, { oneLiners: projects$1.value ?? [] }) : /* @__PURE__ */ u(BrowseProjects, { projects: projects$1.value ?? [] })] });
};
const Editor = ({ doc, header }) => {
	widgetOptions.showVisuals = settings.showVisuals;
	widgetOptions.showKnobs = settings.showKnobs;
	widgetOptions.noHeader = false;
	const ref = A(null);
	const editor$1 = editor.value = T(() => createEditor({
		wordWrap: true,
		autoHeight: false,
		paddingLeft: 5,
		paddingTop: !header ? 15.5 : 17,
		paddingRight: 12,
		paddingBottom: !header ? 15.5 : 17,
		...editorSettings
	}), []);
	y(() => {
		editor$1.header = header;
	}, [editor$1, header]);
	y(() => {
		editor$1.focus();
	}, [editor$1]);
	useReactiveEffect(() => {
		if (doc.value) o$24(() => {
			if (doc.value) editor$1.setDoc(doc.value);
		});
	}, [editor$1]);
	useReactiveEffect(() => {
		Object.assign(editor$1.settings.colors, theme.value);
	}, [editor$1]);
	useReactiveEffect(() => {
		createEditorOnHover(editor$1);
	}, [editor$1]);
	useReactiveEffect(() => {
		editor$1.settings.wordWrap = settings.wordWrap;
	}, [editor$1]);
	y(() => {
		if (ref.current) {
			ref.current.appendChild(editor$1.canvas);
			editor$1.canvas.focus();
		}
	}, [ref, editor$1]);
	y(() => () => editor$1.dispose(), []);
	return /* @__PURE__ */ u("div", {
		ref,
		class: "w-full h-full"
	});
};
function Fader({ value, min, max, step = .01, faderWidth = 12, onChange, className = "", "aria-label": ariaLabel, mode = "crossfade" }) {
	const containerRef = A(null);
	const [isDragging, setIsDragging] = d(false);
	const normalized = (value - min) / (max - min);
	normalized * 200;
	const handleInteraction = q((clientX) => {
		if (!containerRef.current) return;
		const rect = containerRef.current.getBoundingClientRect();
		const x$4 = clientX - rect.left;
		const newValue = min + Math.max(0, Math.min(1, x$4 / rect.width)) * (max - min);
		if (step) onChange(Math.round(newValue / step) * step);
		else onChange(newValue);
	}, [
		min,
		max,
		step,
		onChange
	]);
	const handleMouseDown = (e$59) => {
		e$59.preventDefault();
		setIsDragging(true);
		handleInteraction(e$59.clientX);
	};
	y(() => {
		if (!isDragging) return;
		const handleMouseMove = (e$59) => {
			handleInteraction(e$59.clientX);
		};
		const handleMouseUp = () => {
			setIsDragging(false);
		};
		document.addEventListener("mousemove", handleMouseMove);
		document.addEventListener("mouseup", handleMouseUp);
		return () => {
			document.removeEventListener("mousemove", handleMouseMove);
			document.removeEventListener("mouseup", handleMouseUp);
		};
	}, [isDragging, handleInteraction]);
	return /* @__PURE__ */ u("div", {
		ref: containerRef,
		className: `relative cursor-pointer select-none ${className}`,
		onMouseDown: handleMouseDown,
		role: "slider",
		"aria-label": ariaLabel,
		"aria-valuenow": value,
		"aria-valuemin": min,
		"aria-valuemax": max,
		tabIndex: 0,
		onKeyDown: (e$59) => {
			if (e$59.key === "ArrowLeft" || e$59.key === "ArrowDown") {
				e$59.preventDefault();
				onChange(Math.max(min, value - (step || .01)));
			} else if (e$59.key === "ArrowRight" || e$59.key === "ArrowUp") {
				e$59.preventDefault();
				onChange(Math.min(max, value + (step || .01)));
			}
		},
		children: mode === "volume" ? /* @__PURE__ */ u("svg", {
			width: "100%",
			height: "100%",
			viewBox: "0 0 200 30",
			preserveAspectRatio: "none",
			className: "block",
			children: [
				/* @__PURE__ */ u("polygon", {
					points: "200,25 0,15 0,15 200,5",
					fill: "#444"
				}),
				/* @__PURE__ */ u("g", {
					style: { clipPath: `inset(0px ${(1 - normalized) * 200}px 0px 0px)` },
					children: /* @__PURE__ */ u("polygon", {
						points: "200,25 0,15 0,15 200,5",
						fill: "#ff7316",
						opacity: "0.7"
					})
				}),
				/* @__PURE__ */ u("g", {
					transform: `translate(${normalized * (200 - faderWidth) + faderWidth / 2}, 0)`,
					children: /* @__PURE__ */ u("polygon", {
						points: `-${faderWidth / 2},0 ${faderWidth / 2},0 ${faderWidth / 2},30 -${faderWidth / 2},30`,
						fill: "#f97316",
						stroke: "#ff8c42",
						strokeWidth: "0.5"
					})
				})
			]
		}) : /* @__PURE__ */ u("svg", {
			width: "100%",
			height: "100%",
			viewBox: "0 0 200 30",
			preserveAspectRatio: "none",
			className: "block",
			children: [
				/* @__PURE__ */ u("defs", { children: /* @__PURE__ */ u("linearGradient", {
					id: "gradient",
					x1: "0",
					y1: "0",
					x2: ".75",
					y2: ".75",
					children: [/* @__PURE__ */ u("stop", {
						offset: "0%",
						"stop-color": primaryGradientA.value
					}), /* @__PURE__ */ u("stop", {
						offset: "100%",
						"stop-color": primaryGradientB.value
					})]
				}) }),
				/* @__PURE__ */ u("polygon", {
					points: "0,25 100,15 100,15 0,5",
					fill: "#fff1"
				}),
				/* @__PURE__ */ u("polygon", {
					points: "100,15 200,25 200,5 100,15",
					fill: "#fff1"
				}),
				normalized <= .5 ? /* @__PURE__ */ u("g", {
					style: { clipPath: `inset(0px 0px 0px ${normalized * 200}px)` },
					children: /* @__PURE__ */ u("polygon", {
						points: "0,25 100,15 100,15 0,5",
						fill: "url(#gradient)",
						opacity: "0.7"
					})
				}) : /* @__PURE__ */ u("g", {
					style: { clipPath: `inset(0px ${(.5 - (normalized - .5)) * 200}px 0px 0px)` },
					children: /* @__PURE__ */ u("polygon", {
						points: "100,15 200,25 200,5 100,15",
						fill: "url(#gradient)",
						opacity: "0.7"
					})
				}),
				/* @__PURE__ */ u("g", {
					transform: `translate(${normalized * (200 - faderWidth) + faderWidth / 2}, 0)`,
					children: /* @__PURE__ */ u("polygon", {
						points: `-${faderWidth / 2},0 ${faderWidth / 2},0 ${faderWidth / 2},30 -${faderWidth / 2},30`,
						fill: "url(#gradient)",
						stroke: "url(#gradient)",
						strokeWidth: "0.5"
					})
				})
			]
		})
	});
}
const Nav = ({ transport: t$12 = transport }) => /* @__PURE__ */ u("div", {
	class: `absolute flex left-0 right-0 pointer-events-none items-center min-h-[50px] border-b-2 border-[${primaryColor.value}]`,
	children: [
		/* @__PURE__ */ u("button", {
			class: "px-3 h-[48px] pointer-events-auto hover:bg-white/5 active:hover:scale-95 outline-none focus:bg-white/5",
			onMouseDown: (e$59) => {
				e$59.preventDefault();
				editor.value?.focus();
				if (e$59.ctrlKey || e$59.metaKey || e$59.button === MouseButton.Right) t$12.restart();
				else t$12.start();
			},
			children: /* @__PURE__ */ u(PlayGradientIcon, {})
		}),
		/* @__PURE__ */ u("button", {
			class: "px-3 h-[48px] pointer-events-auto hover:bg-white/5 active:hover:scale-95 outline-none focus:bg-white/5",
			onMouseDown: (e$59) => {
				e$59.preventDefault();
				editor.value?.focus();
				if (e$59.ctrlKey || e$59.metaKey || e$59.button === MouseButton.Right) t$12.restart();
				else t$12.pause();
			},
			children: /* @__PURE__ */ u(PauseGradientIcon, {})
		}),
		/* @__PURE__ */ u("button", {
			class: "px-3 h-[48px] pointer-events-auto hover:bg-white/5 active:hover:scale-95 outline-none focus:bg-white/5",
			onMouseDown: (e$59) => {
				e$59.preventDefault();
				editor.value?.focus();
				if (e$59.ctrlKey || e$59.metaKey || e$59.button === MouseButton.Right) t$12.restart();
				else t$12.stop();
			},
			children: /* @__PURE__ */ u(StopGradientIcon, {})
		})
	]
});
const DJMain = () => {
	return /* @__PURE__ */ u(k, { children: [/* @__PURE__ */ u("div", {
		class: `w-full h-[50px] min-h-[50px] z-10 leading-none text-white flex items-center border-b-2 border-[${primaryColor.value}]`,
		children: /* @__PURE__ */ u("div", {
			class: "flex flex-row w-full justify-between items-center",
			children: [
				/* @__PURE__ */ u("h2", {
					class: "flex-1 font-bold text-left",
					children: ["A: ", djTitleA.value]
				}),
				/* @__PURE__ */ u("div", {
					class: "flex flex-row items-center gap-1 relative",
					children: [/* @__PURE__ */ u("div", {
						class: "h-10",
						children: /* @__PURE__ */ u(Fader, {
							className: "h-10",
							faderWidth: 8,
							value: djCrossfade.value,
							min: 0,
							max: 1,
							step: .01,
							onChange: (v$4) => djCrossfade.value = v$4
						})
					}), /* @__PURE__ */ u("div", {
						class: "absolute left-0 translate-x-[-100%] flex flex-row items-center gap-1 text-xs",
						children: [/* @__PURE__ */ u("span", {
							class: "opacity-70",
							children: "BPM"
						}), /* @__PURE__ */ u("input", {
							type: "number",
							min: 40,
							max: 240,
							step: 1,
							value: djBpm.value,
							onInput: (e$59) => {
								const el = e$59.currentTarget;
								djBpm.value = Number(el.value) || 0;
							},
							class: "w-16 bg-transparent px-1 py-0.5 text-xs outline-none focus:border-white"
						})]
					})]
				}),
				/* @__PURE__ */ u("h2", {
					class: "flex-1 font-bold text-right",
					children: [djTitleB.value, " :B"]
				})
			]
		})
	}), /* @__PURE__ */ u(Main, {
		class: "flex flex-row w-full",
		children: [/* @__PURE__ */ u("div", {
			class: "flex flex-col flex-1",
			children: [/* @__PURE__ */ u("div", {
				class: "relative",
				children: /* @__PURE__ */ u(Nav, { transport: djTransport })
			}), /* @__PURE__ */ u(Editor, {
				doc: djDocA,
				header: djHeaderA.value
			})]
		}), /* @__PURE__ */ u("div", {
			class: "flex flex-col flex-1",
			children: [/* @__PURE__ */ u("div", {
				class: "relative",
				children: /* @__PURE__ */ u(Nav, { transport: djTransport })
			}), /* @__PURE__ */ u(Editor, {
				doc: djDocB,
				header: djHeaderB.value
			})]
		})]
	})] });
};
const docs = {
	"hhsynth": "\nhhsynth(trig:every(1/16)) |> out($)",
	"bs": "\nwhite() |> bs($,100+10k*lfosine(1),1) |> out($)",
	"write": "flanger=(in,seconds=0.5)->{\n  buf=alloc(1)\n  sample=read(buf,seconds)\n  write(in+sample*.95,buf)\n  sample\n}\n\ntri(ntof(60))*ad(trig:every(1/2)) |> $+flanger($*.41,.0036+0.004*lfosine(4)) |> out($)\n",
	"mix": "drums() |> out($)\n\n\nmix=>dc($) |> limiter($)",
	"bpm": "bpm=144\n\ndrums() |> out($)",
	"impulse": "\ntri([60,63,65,69][t]|>ntof($))*ad(trig:impulse(8)) |> out($)",
	"miditohz": "a",
	"[].step": "\n[60,63,65].step(impulse(4)) |> ntof($) |> saw($) |> out($)",
	"bss": "\nwhite() |> bss($,100+10k*lfosine(1),.5) |> out($)",
	"freesound": "\n\nsampler(freesound(350547),trig:1) |> out($)",
	"saw": "\nsaw(ntof(31)) |> out($)",
	"[].Step": "a",
	"scale": "scale='dorian'\n\n;(#scale*o2).walk(1/4) |> saw($) |> out($)",
	"[].map": "\n[60,63,65].map(ntof)[t] |> saw($)*ad(trig:every(1/8)) |> out($)",
	"compressor": "\ndrums() |> compressor($,.0001,.002,-20,6,2)*4.0 |> out($)",
	"lforamp": "\npink()*lforamp(1) |> out($)",
	"hp": "\nwhite() |> hp($,100+10k*lfosine(1),1) |> out($)",
	"isinf": "\nisinf(1/0) |> print($)",
	"hp1": "\nwhite() |> hp1($,100+10k*lfosine(1)) |> out($)",
	"inc": "\npink()*inc(1,trig:every(1/2)) |> out($)",
	"bd": "\nbd() |> out($)",
	"timeline": "\nsaw(330) |> lp($,150+2k*ad(trig:every(1/4))) \n\n* timeline('1,1e2 2,0e-2 3,1e-3 4,0e-2',4) |> out($)",
	"hold": "\n[60,0,63,0,65,0][t*2] |> hold($) |> print($) |> ntof($) |> tri($) |> out($)",
	"sampler": "\n\nsampler(freesound(350547),trig:1) |> out($)",
	"dattorro": `scale='dorian'

drums() |> out($)

trig:=euclid(5,8,bar:1);[#1,#3,#5,#7,#9].random(trig)*[o1,o2,o3][t]

|> saw($)*ad(.0001,.13,trig)*.4 |> lp($,100+10k*ad(trig))


|> $+delay($,.15,.2) |> $+dattorro($) |> out($)`,
	"#scale": "scale='dorian'\n\n;(#scale*o2).walk(1/4) |> saw($) |> out($)",
	"exp2": "\nexp2(sine(ntof(30))) |> dc($) |> out($)",
	"lfosah": "\nsine(24*lfosah(1/16)|>ntof(floor(60+$))) |> out($)",
	"sine": "melody=[60,63,69].map(ntof)\n\nsine(melody[t])*ad(trig:every(1/16))*ad(trig:every(1/16)) |> out($)",
	"safediv": "\nsafediv(1,0) |> print($)",
	"square": "\nsquare(sine(ntof(30))) |> out($)",
	"acos": "\nacos(sine(ntof(30))) |> out($)",
	"aps": "phaser=(in,stages=10)->{\n  a = lfosine(.5)\n\n  y = in\n  for (i in 0 .. stages-1) {\n    y = aps(y,99+999*a)\n  }\n\n  y + in\n}\n\nsaw(299)*.4 |> phaser($) |> out($)",
	"log10": "\nlog10(abs(sine(ntof(30)))+.01) |> dc($) |> out($)",
	"round": "\nround(sine(ntof(30))) |> out($)",
	"tan": "\ntan(sine(ntof(30))) |> out($)",
	"random": "\nrandom() |> print($) |> out($)",
	"lerp": "\nntof(30) |> lerp(sqr($),saw($),lfosine(1)) |> out($)",
	"outs": "\nsaw(ntof(30)) |> out($)\n\ntri(ntof(30)) |> outs($)",
	"brown": "\nbrown() |> out($)",
	"diodeladder": "trig=every(1/16) \n\ndiodeladder([68,99,56,85][t*2]/2 |> ntof($) |> slew($,.00003,e:.5) |> ramp($),\n\ncutoff:99+.3k*(1.00+7*fractal(rate:.015)**2)*ad(.002,4.0,10,trig),\n\nq:.99,k:.0001,sat:.86) |> tanh($*5) |> dc($) |> $*.25+drums() |> limiter($) |> out($)",
	"lfosine": "\npink()*lfosine(1) |> out($)",
	"o0": "\n(#vi7sus4*o2).map(saw).avg() |> out($)",
	"#i": "\n(#vi7sus4*o2).map(saw).avg() |> out($)",
	"isfunction": "\nisfunction(() -> {}) |> print($)\n\nisfunction(1) |> print($)",
	"hs": "\nwhite() |> hs($,100+10k*lfosine(1),1,-30) |> out($)",
	"[].walk": "\n[60,63,65].walk(1/8,.25) |> ntof($) |> saw($) |> out($)",
	"asin": "\nasin(sine(ntof(30))) |> out($)",
	"max": "\nntof(30) |> max(sine($),saw($)) |> out($)",
	"pink": "\npink() |> out($)",
	"hps": "\nwhite() |> hps($,100+10k*lfosine(1),.5) |> out($)",
	"pitchshift": "\n\nslicer(freesound(350547),slice:random(),trig:every(1/2)) \n\n|> pitchshift($,.6+.8*lfotri(2)) |> out($)",
	"smootherstep": "\nntof(30) |> smootherstep(sqr($),saw($),lfosine(1)) |> dc($) |> out($)",
	"envfollow": "kick=(x,trig=1)->sine(x+18000*ad(.001,.8,trig)**300,offset:.5,trig)*ad(.012,.8,trig)**16\n\nk=kick(52,trig:every(1/4)) |> out($)\n\npink() |> $*envfollow(k) |> out($)\n",
	"avg": "\n[1,2,3].avg() |> print($)",
	"hypot": "\nhypot(sine(ntof(30)),saw(ntof(43))) |> dc($) |> out($)",
	"fractal": "\nsine(100+sine(173*fractal(rate:.007))*fractal(rate:.005)*607) |> out($)",
	"record": "kicksynth=(x,trig=1)->sine(x+18000*ad(.001,.8,trig)**300,offset:.5,trig)*ad(.012,.8,trig)**16\n\nkick=(y=52,trig=every(1/4))->{ \n  sample=record(.2,()->kicksynth(y))\n  \n  sampler(sample,trig,offset:.05)\n}\n\nkick(52,trig:every(1/4)) |> out(       $)\n",
	"slew": "\n[60,63,65][t] |> ntof($) |> saw(slew($,.0001))*ad(trig:every(1/8)) |> out($)",
	"select": "\nntof(30) |> select(fract(t)>.5,tri($),saw($)) |> out($)",
	"lpm": "\nwhite() |> lpm($,100+10k*lfosine(1),.5) |> out($)",
	"lp": "\nwhite() |> lp($,100+10k*lfosine(1),1) |> out($)",
	"limiter": "\ndrums() |> limiter($,-15)*5.0 |> out($)",
	"#1": "\n([#1,#3,#5,#7]*o3).map(saw).avg() |> out($)",
	"pwm": "\npwm(ntof(37),width:lfosine(1)) |> out($)",
	"tram": "trig=tram('x-x-x-[xxx]-',1/2)\n\nsine(80+100*ad(.001,.92,4,trig))*ad(.00001,.12,4,trig) |> out($*.75)",
	"white": "\nwhite() |> out($)",
	"lps": "\nwhite() |> lps($,100+10k*lfosine(1),.5) |> out($)",
	"zerox": "\nsaw(ntof(51))*ad(trig:zerox(saw(1))) |> out($)",
	"isnan": "\nisnan(0/0) |> print($)",
	"isscalar": "\nisscalar(sine(1)) |> print($)\n\nisscalar(1) |> print($)",
	"mod": "\nntof(30) |> mod(sine($),saw($)) |> out($)",
	"lfosaw": "\npink()*lfosaw(1) |> out($)",
	"out": "\nsine(ntof(69)) |> out($)",
	"bp": "\nwhite() |> bp($,100+10k*lfosine(1),1) |> out($)",
	"sdsynth": "\nsdsynth(trig:tram('-x',1/2)) |> out($)",
	"ceil": "\nceil(sine(ntof(30))) |> out($)",
	"sd": "\nsd() |> out($)",
	"every": "\ntri([60,63,65,69][t]|>ntof($))*ad(trig:every(1/8)) |> out($)",
	"tri": "\ntri(ntof(31)) |> out($)",
	"c4": "\n;[c4,a4,f4,e4][t] |> saw($) |> out($)",
	"ntof": "\n[60,63,65][t] |> ntof($) |> saw($)*ad(trig:every(1/8)) |> out($)",
	"heaviside": "\nheaviside(sine(ntof(30))) |> dc($) |> out($)",
	"karplus": "\nkarplus([49,58,53,64][swing(t,.85)]|>ntof($),seed:33,trig:every(1/8)) |> out($)",
	"trunc": "\ntrunc(4.2) |> print($)\n\ntrunc(-4.2) |> print($)",
	"slicer": "hihats=()->{\n  sample=freesound(274511)\n\n  slicer(sample,slice:1-(sine(.4*co)*.5+.5),speed:1,threshold:.008,trig:every(1/16))\n}\n\nhihats() |> out($)",
	"smooth": "\nsine(100+sine(173*smooth(rate:1.007))*smooth(rate:1.005)*607) |> out($)",
	"bdsynth": "\nbdsynth() |> out($)",
	"isarray": "\nisarray([]) |> print($)\n\nisarray(0) |> print($)",
	"emit": "a",
	"snap": "\nsnap(lfosine(1),.2) |> ntof(48+$*12) |> saw($) |> out($)",
	"tube": "\nsaw(ntof(30)) |> tube($,3,.2) |> out($)",
	"freeverb": "\ndrums() |> out($)\n\ntrig=tram('x-x-x-[xxx]-',1/2) \n\ntri(95+[158,100][t*8]*ad(.001,.77,trig)**2)*ad(.00001,.24,trig)**3*.4\n\n\n\n|> $+freeverb($,.55,.6)*1 |> out($)\n\n;[47,50,51][t*4]|>ntof($)*1 |> rhodes70($,trig:every(1/16))*.08 |> out($)\n\n;[51,54,55][t*4]|>ntof($)*2 |> rhodes70($,trig:every(1/16))*.03 |> out($)",
	"step": "\nstep(lfosine(1),sine(ntof(30))) |> dc($) |> out($)",
	"tune": "scale='dorian' tune=1.50\n\n;(#scale*o2).walk(1/4) |> saw($) |> out($)",
	"lfotri": "\npink()*lfotri(1) |> out($)",
	"ramp": "\nramp(ntof(31)) |> out($)",
	"clamp": "\nclamp(sine(ntof(30)),-.1,.1) |> out($)",
	"transpose": "scale='dorian' transpose=1\n\n;(#scale*o2).walk(1/4) |> saw($) |> out($)",
	"wrap": "\nwrap(sine(ntof(30)),-.1,.1) |> out($)",
	"chorus": "\nsaw(ntof(30)) |> chorus($) |> out($)",
	"dc": "\nrandom()+1 |> dc($) |> out($)",
	"alloc": "flanger=(in,seconds=0.5)->{\n  buf=alloc(1)\n  sample=read(buf,seconds)\n  write(in+sample*.95,buf)\n  sample\n}\n\ntri(ntof(60))*ad(trig:every(1/2)) |> $+flanger($*.41,.0036+0.004*lfosine(4)) |> out($)\n",
	"[].Walk": "a",
	"bps": "\nwhite() |> bps($,100+10k*lfosine(1),.50) |> out($)",
	"sout": "\nsaw(ntof(30)) |> out($)\n\ntri(ntof(30)) |> sout($)",
	"sah": "\nrandom() |> sah($,every(1/4)) |> ntof(60+floor($*12)) |> saw($) |> out($)",
	"sqrt": "\nsqrt(sine(ntof(30))) |> out($)",
	"peak": "\nwhite() |> peak($,100+10k*lfosine(1),1,10) |> out($)",
	"rhodes70": "a",
	"exp": "\nexp(sine(ntof(30))) |> dc($) |> out($)",
	"floor": "\nfloor(sine(ntof(30))) |> dc($) |> out($)",
	"min": "\nntof(30) |> min(sine($),saw($)) |> out($)",
	"flanger": "\nsaw(ntof(30)) |> flanger($) |> out($)",
	"rhodes": "trig=every(1/16)\n\nrhodes([60,63,65,70][t*2]|>ntof($),.7,trig)*ad(.0001,.36,4,trig) |> out($)",
	"at": "trig=at(1/16)+at(3/16)+at(4/16,prob:.6)\n\ntri([60,67,62,63][t]|>ntof($)|>$/2+sine($/3)*$/2)*ad(.0003,.11,e:.5,trig)*.3+drums() |> out($)",
	"moddelay": "\nsaw(ntof(30)) |> moddelay($,.3,.3,.11,.20) |> out($)",
	"solo": "\nsaw(ntof(30)) |> out($)\n\ntri(ntof(30)) |> solo($)",
	"fold": "\nfold(sine(ntof(30)),-.2,.2) |> out($)",
	"isundefined": "\nisundefined(undefined) |> print($)\n\nisundefined(1) |> print($)",
	"log2": "\nlog2(abs(sine(ntof(30)))+.01) |> dc($) |> out($)",
	"adsr": "\ndrums() |> out($)\n\nplay(mini('<octave -1 octave 1>/2\n  scale pent [1;2 4 [4 2] 5];.4/2'),(hz,vel,trig)->\n\n  (saw(hz/3)+sqr(hz))*adsr(.001,.03,.6,.04,2,trig)*.25 \n  \n  |> lps($,100+15k*ad(.001,.5,8,trig),.8)\n\n) |> out($)",
	"hpm": "\nwhite() |> hpm($,100+10k*lfosine(1),.5) |> out($)",
	"read": "flanger=(in,seconds=0.5)->{\n  buf=alloc(1)\n  sample=read(buf,seconds)\n  write(in+sample*.95,buf)\n  sample\n}\n\ntri(ntof(60))*ad(trig:every(1/2)) |> $+flanger($*.41,.0036+0.004*lfosine(4)) |> out($)\n",
	"ad": "\ntri([c4,a4,f4,e4][t])*ad(a:.03,d:.15,e:5,trig:every(1/8)) |> out($)",
	"velvet": "\ndrums() |> out($)\n\nsupersaw([62,63,65,68][t]|>ntof($)*[1,.5][t/4])*ad(trig:every(1/16))\n\n|> lp($,1k+8k*ad(e:5,trig:every(1/16)))*.35\n\n\n\n|> $+velvet($,room:.8) |> out($)",
	"mini": "\ndrums() |> out($)\n\nplay(mini('<octave -1 octave 1>/2\n  scale pent [1;2 4 [4 2] 5];.4/2'),(hz,vel,trig)->\n\n  (saw(hz/3)+sqr(hz))*adsr(.001,.03,.6,.04,2,trig)*.25 \n  \n  |> lps($,100+15k*ad(.001,.5,8,trig),.8)\n\n) |> out($)",
	"map": "",
	"tanh": "\ntanh(sine(ntof(30))*5) |> out($)",
	"drums": "\ndrums() |> out($)",
	"euclid": "\ntri([60,63,65,69][t]|>ntof($))*ad(trig:euclid(5,8)) |> out($)",
	"t": "\n[60,63,65][t] |> ntof($) |> saw($)*ad(trig:every(1/8)) |> out($)",
	"atan": "\natan(sine(ntof(30))) |> out($)",
	"supersaw": "\nsupersaw([50,57,60,62][t*2]|>ntof($))*lfosqr(1/16) |> out($)",
	"ap": "phaser=(in,stages=10)->{\n  a = lfosine(.5)\n\n  y = in\n  for (i in 0 .. stages-1) {\n    y = ap(y,99+999*a)\n  }\n\n  y + in\n}\n\nsaw(299)*.4 |> phaser($) |> out($)",
	"ch": "\nch() |> out($)",
	"fract": "\nfract(sine(ntof(12))*180) |> dc($) |> out($)",
	"swing": "\n[60,63,64,65][swing(t*2,.7)] |> ntof($)/2 |> saw($) |> out($)",
	"gauss": "\ngauss() |> out($)",
	"lp1": "\nwhite() |> lp1($,100+10k*lfosine(1)) |> out($)",
	"label": "a",
	"log": "\nlog(abs(sine(ntof(30)))+.01) |> dc($) |> out($)",
	"print": "\nprint(42)",
	"smoothstep": "\nntof(30) |> smoothstep(sqr($),saw($),lfosine(1)) |> dc($) |> out($)",
	"fdn": "\ndrums(342) |> out($)\n\nsynth=x->(sqr(x)+ramp(x/1.502)+pink()*.8)/6  |> lps($,100+5000*ad(e:9,trig:every(1/16)),.7)*.4\n\nsynth([60,0,63,61][t] |> hold($) |> ntof($)/2)*ad(trig:every(1/8)) \n\n\n|> $+fdn($,room:.68) |> out($)",
	"pingpong": "\nntof(30) |> pingpong(sine($),-.1,.1) |> out($)",
	"cube": "\ncube(sine(ntof(30))) |> out($)",
	"isaudio": "\nisaudio(sine(1)) |> print($)\n\nisaudio(1) |> print($)",
	"lfosqr": "\npink()*lfosqr(1/4) |> out($)",
	"peaks": "\nwhite() |> peaks($,100+10k*lfosine(1),.5) |> out($)",
	"sin": "\nsin(phasor(ntof(50))*3.14*2) |> out($)",
	"sign": "\nsign(sine(ntof(30))) |> out($)",
	"phasor": "\npink()*phasor(2) |> out($)",
	"oh": "\noh() |> out($)",
	"dtof": "\n;[dtof(1),dtof(3),dtof(5)][t]*o2 |> saw($) |> out($)",
	"cos": "\ncos(sine(ntof(30))) |> dc($) |> out($)",
	"oversample": "\noversample(8,() -> pwm(ntof(51),lfosine(8))) |> out($)",
	"abs": "\nabs(sine(ntof(30))) |> out($)",
	"delay": "\ndrums(362) |> out($)\n\nsaw([56,56,59,55][t] |> ntof($))*ad(trig:every(1/5))*.16\n\n|> lp($,100+5434*ad(e:8,trig:every(1/5))) \n\n|> delay($,1/8,.7) |> out($)",
	"mtof": "a",
	"sqr": "\nsqr(ntof(31)) |> out($)",
	"ls": "\nwhite() |> ls($,100+10k*lfosine(1),1,-30) |> out($)",
	"sam": `
sampler(sam('hello world'),trig:every(1)) |> out($)`,
	"espeak": `
sampler(espeak('hello world'),trig:every(1)) |> out($)`
};
var examples_exports = /* @__PURE__ */ __export({
	sine: () => sine,
	slicer: () => slicer
}, 1);
const sine = [`melody=[60,63,69].map(ntof)

sine(melody[t])*ad(trig:every(1/8)) |> out($)`, `melody=[60,63,69].map(ntof)

sine(melody[t])*ad(trig:every(1/16))*ad(trig:every(1/16)) |> out($)`];
const slicer = [`hihats=()->{
  sample=freesound(274511)



  slicer(sample,slice:1-(sine(.4*co)*.5+.5),speed:1,threshold:.008,trig:every(1/16))
}


hihats() |> out($)
`];
var tokenColor = (type) => {
	const c$7 = theme.value;
	return {
		keyword: c$7.blue,
		function: c$7.green,
		identifier: c$7.white,
		string: c$7.yellow,
		number: c$7.purple,
		boolean: c$7.red,
		null: c$7.blue,
		operator: c$7.red,
		punctuation: c$7.cyan,
		comment: c$7.gray,
		text: c$7.white,
		special: c$7.red
	}[type];
};
const SignatureView = ({ code, class: className, style = {} }) => {
	return /* @__PURE__ */ u("span", {
		class: className,
		style,
		children: tokenize(code).flatMap((lineTokens, i$6) => lineTokens.map((t$12, j$4) => /* @__PURE__ */ u("span", {
			style: { color: tokenColor(t$12.type) },
			children: t$12.text
		}, `${i$6}-${j$4}`)))
	});
};
function withoutPeriod(s$4) {
	return s$4.trimEnd().replace(/[.!?]$/, "");
}
var docsIcons = {
	generators: t$3,
	effects: o$23,
	samplers: e$17,
	filters: o$22,
	utilities: o$5,
	sequencers: e$15,
	mixing: o$20,
	math: t$5,
	synths: e$18,
	buffers: o$21
};
const DocsIcon = ({ category, size = 24 }) => {
	return /* @__PURE__ */ u(docsIcons[category] ?? o$5, { size });
};
var docItemsList = [...new Set([...definitions.values()])].map((d$5) => ({
	docPath: getDocPath(d$5),
	name: d$5.name,
	description: d$5.description.join(" "),
	category: d$5.category
}));
var categoriesList$1 = [...new Set(docItemsList.map((i$6) => i$6.category))].sort((a$36, b$4) => a$36.localeCompare(b$4));
var fuzzyMatch = (query, text) => {
	if (!text) return false;
	const q$5 = query.toLowerCase();
	const t$12 = text.toLowerCase();
	let i$6 = 0;
	for (let j$4 = 0; j$4 < t$12.length && i$6 < q$5.length; j$4++) if (t$12[j$4] === q$5[i$6]) i$6++;
	return i$6 === q$5.length;
};
var matchScore = (query, name, description) => {
	const q$5 = query.toLowerCase();
	const n$4 = name.toLowerCase();
	const d$5 = description.toLowerCase();
	if (!q$5.length) return 0;
	return (n$4.includes(q$5) ? 4 : fuzzyMatch(q$5, n$4) ? 2 : 0) + (d$5.includes(q$5) ? 1 : fuzzyMatch(q$5, d$5) ? .5 : 0);
};
var filteredDocItems = b(() => {
	const q$5 = docsSearch.value.trim();
	if (!q$5.length) return docItemsList;
	return docItemsList.filter(({ docPath, name, description }) => fuzzyMatch(q$5, docPath) || fuzzyMatch(q$5, name) || fuzzyMatch(q$5, description)).map((item) => ({
		...item,
		score: matchScore(q$5, item.docPath, item.description)
	})).sort((a$36, b$4) => b$4.score - a$36.score || a$36.docPath.localeCompare(b$4.docPath));
});
var DocItem = ({ docPath, category, showIcon = false }) => {
	const currentDocPath = useComputed(() => decodeURIComponent(pathname.value.split("/")[3] ?? ""));
	const selected = useComputed(() => currentDocPath.value === docPath);
	return /* @__PURE__ */ u(SidebarLink, {
		to: `/docs/${category}/${encodeURIComponent(docPath)}`,
		className: cn(showIcon ? "pl-4 h-6" : "pl-8 h-6", { "text-white bg-white/5": selected.value }),
		dataSelected: selected.value,
		children: [showIcon && /* @__PURE__ */ u(DocsIcon, {
			category,
			size: 16
		}), docPath]
	});
};
const Docs = () => {
	const containerRef = A(null);
	const categoryName = useComputed(() => pathname.value.split("/")[2]);
	const genName = useComputed(() => pathname.value.split("/")[3]);
	const isSearching = useComputed(() => docsSearch.value.trim().length > 0);
	y(() => {
		const el = (containerRef.current?.parentElement?.parentElement)?.querySelector("[data-selected]");
		el && requestAnimationFrame(() => el.scrollIntoView({ block: "center" }));
	}, []);
	useReactiveEffect(() => {
		subsection.value = `${genName.value ? `${genName.value} / ` : ""}${categoryName.value ? `${categoryName.value.charAt(0).toUpperCase() + categoryName.value.slice(1)}` : ""}`;
	}, [categoryName]);
	return /* @__PURE__ */ u(SidebarMain, {
		class: "gap-3 pb-12",
		children: /* @__PURE__ */ u("div", {
			ref: containerRef,
			class: "contents",
			children: isSearching.value ? /* @__PURE__ */ u("div", {
				class: "flex flex-col items-stretch justify-between",
				children: filteredDocItems.value.map(({ docPath, category }) => /* @__PURE__ */ u(DocItem, {
					docPath,
					category,
					showIcon: true
				}, `${category}/${docPath}`))
			}) : categoriesList$1.map((category) => /* @__PURE__ */ u("div", {
				class: "flex flex-col items-stretch justify-between",
				children: [/* @__PURE__ */ u(SidebarLink, {
					to: `/docs/${category}`,
					className: cn("justify-start", { "text-white bg-white/5": !genName.value && categoryName.value === category }),
					dataSelected: !genName.value && categoryName.value === category,
					children: [/* @__PURE__ */ u(DocsIcon, {
						category,
						size: 16
					}), /* @__PURE__ */ u("h3", {
						class: "font-bold",
						children: category.charAt(0).toUpperCase() + category.slice(1)
					})]
				}), /* @__PURE__ */ u("div", {
					class: "flex flex-col items-stretch justify-between",
					children: filteredDocItems.value.filter((item) => item.category === category).sort((a$36, b$4) => a$36.docPath.localeCompare(b$4.docPath)).map(({ docPath, category: category$1 }) => /* @__PURE__ */ u(DocItem, {
						docPath,
						category: category$1
					}, docPath))
				})]
			}, category))
		})
	});
};
var units = { "s": "seconds" };
var unitsOverride = { "input": "signal" };
var categoriesList = [...new Set([...new Set([...definitions.values()])].map((d$5) => d$5.category))].sort((a$36, b$4) => a$36.localeCompare(b$4));
var DocsGen = ({ name, category }) => {
	const def = getDefinitionByDocPath(name);
	if (!def) return null;
	const params = (def.parameters ?? []).filter((p$6) => !(def.arrayMethod && p$6.name === "array"));
	return /* @__PURE__ */ u(k, { children: [/* @__PURE__ */ u(Header, { children: [/* @__PURE__ */ u(Link$1, {
		to: `/docs/${category}`,
		class: `flex flex-row items-center gap-2 hover:text-[${primaryColor.value}]`,
		children: [
			/* @__PURE__ */ u(DocsIcon, { category }),
			toPascalCase(category),
			":"
		]
	}), /* @__PURE__ */ u("span", {
		class: "font-semibold text-white",
		children: getDocPath(def)
	})] }), /* @__PURE__ */ u(Main, {
		class: "px-8 pl-12 py-1 pb-8",
		children: [
			/* @__PURE__ */ u("div", {
				class: "flex flex-col py-6 pb-4 gap-4 items-start",
				children: [/* @__PURE__ */ u(SignatureView, {
					code: definitionToCode(def),
					class: "text-md font-[Liga_Space_Mono]",
					style: {
						textAlign: "justify",
						textAlignLast: "right"
					}
				}), /* @__PURE__ */ u("span", {
					class: "text-sm text-white/50",
					children: withPeriod(def.description.join(" "))
				})]
			}),
			params.length > 0 && /* @__PURE__ */ u("div", {
				class: "flex flex-col gap-4",
				children: /* @__PURE__ */ u("table", {
					class: "table-auto text-sm",
					children: [/* @__PURE__ */ u("thead", { children: /* @__PURE__ */ u("tr", { children: [
						/* @__PURE__ */ u("th", {
							class: "pr-10 text-white/30 text-left",
							children: "Name"
						}),
						/* @__PURE__ */ u("th", {
							class: "pr-10 text-white/30",
							children: "Type"
						}),
						/* @__PURE__ */ u("th", {
							class: "pr-10 text-white/30",
							children: "Default"
						}),
						/* @__PURE__ */ u("th", {
							class: "pr-10 text-white/30",
							children: "Range"
						}),
						/* @__PURE__ */ u("th", {
							class: "text-white/30 text-left",
							children: "Description"
						})
					] }) }), /* @__PURE__ */ u("tbody", { children: params.map((p$6, i$6) => /* @__PURE__ */ u("tr", {
						class: i$6 !== 0 ? "border-t border-white/20" : `border-t-2 border-[${primaryColor.value}]`,
						children: [
							/* @__PURE__ */ u("td", {
								class: "pr-10 py-1 text-white font-[Liga_Space_Mono] whitespace-nowrap",
								children: p$6.name
							}),
							/* @__PURE__ */ u("td", {
								class: "pr-10 text-white/50 text-center",
								children: p$6.type ?? unitsOverride[p$6.name] ?? units[p$6.unit] ?? p$6.unit ?? "number"
							}),
							/* @__PURE__ */ u("td", {
								class: "pr-10 text-white/50 text-center font-[Liga_Space_Mono] whitespace-nowrap",
								children: p$6.default ?? ""
							}),
							/* @__PURE__ */ u("td", {
								class: "pr-10 text-white/50 text-center font-[Liga_Space_Mono] whitespace-nowrap",
								children: p$6.type === "function" || p$6.type === "callback" ? "" : p$6.min == null && p$6.max == null ? /* @__PURE__ */ u(o$19, {
									size: 16,
									class: "inline-block"
								}) : /* @__PURE__ */ u(k, { children: [
									p$6.min ?? /* @__PURE__ */ u(o$19, {
										size: 16,
										class: "inline-block"
									}),
									"..",
									p$6.max ?? /* @__PURE__ */ u(o$19, {
										size: 16,
										class: "inline-block"
									})
								] })
							}),
							/* @__PURE__ */ u("td", {
								class: "text-white/50 w-[100%]",
								children: withoutPeriod(p$6.description?.join(" ") ?? "")
							})
						]
					}, p$6.name)) })]
				})
			}),
			/* @__PURE__ */ u("div", {
				class: "flex flex-col mt-6 gap-4",
				children: /* @__PURE__ */ u("div", {
					class: "flex flex-col gap-4",
					children: [...examples_exports[def.name] ?? ["a"]].map((e$59) => /* @__PURE__ */ u(InlineEditor, {
						id: `docs-${getDocPath(def)}-${e$59}`,
						code: admin.editDocs ? e$59 : docs[getDocPath(def)] ?? "",
						persisted: admin.editDocs
					}, e$59))
				})
			}),
			/* @__PURE__ */ u(e$1, {
				size: 20,
				class: "mt-10 mb-2"
			})
		]
	})] });
};
var DocsCategory = ({ category }) => {
	const items = [...new Set([...definitions.values()])].filter((d$5) => d$5.category === category).sort((a$36, b$4) => getDocPath(a$36).localeCompare(getDocPath(b$4)));
	return /* @__PURE__ */ u(k, { children: [/* @__PURE__ */ u(Header, { children: [/* @__PURE__ */ u(DocsIcon, { category }), toPascalCase(category)] }), /* @__PURE__ */ u(Main, {
		class: "px-4 pl-8 py-4",
		children: /* @__PURE__ */ u(Grid, { children: items.map((def) => /* @__PURE__ */ u(GridItem, {
			to: `/docs/${category}/${encodeURIComponent(getDocPath(def))}`,
			class: "items-start justify-start h-auto px-4 py-3",
			children: [
				/* @__PURE__ */ u(SignatureView, {
					code: definitionToCode(def, false),
					class: "text-md font-[Liga_Space_Mono]",
					style: {
						textAlign: "justify",
						textAlignLast: "right"
					}
				}),
				/* @__PURE__ */ u("span", { class: "flex-1" }),
				/* @__PURE__ */ u("span", {
					class: "text-sm text-white/50 justify-self-end",
					children: withPeriod(def.description.join(" "))
				})
			]
		}, getDocPath(def))) })
	})] });
};
const DocsMain = () => {
	widgetOptions.showVisuals = true;
	widgetOptions.showKnobs = true;
	widgetOptions.noHeader = false;
	const selectedCategory = useComputed(() => pathname.value.split("/")[2]);
	const selectedGen = useComputed(() => pathname.value.split("/")[3]);
	return selectedCategory.value ? selectedGen.value ? /* @__PURE__ */ u(DocsGen, {
		name: selectedGen.value,
		category: selectedCategory.value
	}, selectedGen.value) : /* @__PURE__ */ u(DocsCategory, { category: selectedCategory.value }) : /* @__PURE__ */ u(k, { children: [/* @__PURE__ */ u(Header, {}), /* @__PURE__ */ u(Main, {
		class: "p-4",
		children: /* @__PURE__ */ u(Grid, { children: categoriesList.map((category) => /* @__PURE__ */ u(GridItem, {
			to: `/docs/${category}`,
			children: [/* @__PURE__ */ u(DocsIcon, { category }), toPascalCase(category)]
		})) })
	})] });
};
const helpItems = [
	{
		name: "Docs",
		url: "/docs",
		Icon: e$3
	},
	{
		name: "Tutorials",
		url: "/tutorials",
		Icon: e
	},
	{
		name: "Discord",
		url: "https://discord.gg/NSWaB9dRYh",
		Icon: r$4
	},
	{
		name: "Feedback",
		url: "https://loopmaster.featurebase.app/",
		Icon: o$18
	},
	{
		name: "GitHub",
		url: "https://github.com/loopmaster-xyz/loopmaster",
		Icon: t$4
	},
	{
		name: "About",
		url: "/about",
		Icon: e$16
	}
];
const Help = () => {
	return /* @__PURE__ */ u(SidebarMain, { children: helpItems.map((item) => /* @__PURE__ */ u(SidebarLink, {
		to: item.url,
		target: item.url.startsWith("https://") ? "_blank" : void 0,
		children: [/* @__PURE__ */ u(item.Icon, {
			size: 16,
			class: "group-hover:text-white"
		}), /* @__PURE__ */ u("span", { children: item.name })]
	})) });
};
const HelpMain = () => {
	return /* @__PURE__ */ u(k, { children: [/* @__PURE__ */ u(Header, {}), /* @__PURE__ */ u(Main, {
		class: "p-4",
		children: /* @__PURE__ */ u("div", {
			class: "grid grid-cols-3 gap-4",
			children: helpItems.map((item) => /* @__PURE__ */ u(GridItem, {
				to: item.url,
				children: [/* @__PURE__ */ u(item.Icon, { size: 24 }), /* @__PURE__ */ u("span", {
					class: "mt-2",
					children: item.name
				})]
			}))
		})
	})] });
};
const Logo = ({ text = "lm", size = "2.5em", textShadow = false, onClick, onContextMenu, class: className = "" }) => /* @__PURE__ */ u("h1", {
	onClick,
	onContextMenu,
	class: `text-[${size}] relative font-extrabold font-[Turret_Road] select-none ${onClick || onContextMenu ? "cursor-pointer" : ""} ${className}`,
	children: [
		/* @__PURE__ */ u("span", {
			class: "text-transparent",
			children: text
		}),
		/* @__PURE__ */ u("span", {
			class: "bg-clip-text text-transparent absolute z-10 left-0",
			style: primaryGradientStyle.value,
			children: text
		}),
		textShadow && /* @__PURE__ */ u("span", {
			class: "text-black absolute top-0.5 left-0",
			style: { textShadow: `0px 0px 5px #0003` },
			children: text
		})
	]
});
function RadialGradient({ children }) {
	return /* @__PURE__ */ u("div", {
		className: "flex flex-row gap-2 w-full h-full relative items-center justify-center",
		style: { background: `radial-gradient(circle, ${luminate(backgroundColor.value, .08)} 0%, #000 100%)` },
		children
	});
}
const Intro = () => {
	const fadeIn = useSignal(false);
	const zoomOut = useSignal(false);
	const zoomIn = useSignal(false);
	const fadeOut = useSignal(false);
	useReactiveEffect(() => {
		setTimeout(() => {
			fadeIn.value = true;
			setTimeout(() => {
				zoomOut.value = true;
			}, 200);
		}, 100);
	});
	useReactiveEffect(() => {
		if (zoomOut.value === true && !busy.value) setTimeout(() => {
			if (busy.value) return;
			zoomIn.value = true;
			fadeOut.value = true;
			setTimeout(() => {
				showIntro.value = false;
			}, 1e3);
		}, 100);
	});
	return /* @__PURE__ */ u("div", {
		class: cn("bg-black fixed w-full h-full flex flex-col items-center justify-center z-50 transition-opacity duration-700 ease-in-out", fadeOut.value && "opacity-0 pointer-events-none"),
		children: /* @__PURE__ */ u("div", {
			class: cn("absolute inset-0 opacity-0 transition-opacity duration-500 ease-in-out", fadeIn.value && "opacity-100"),
			children: /* @__PURE__ */ u(RadialGradient, { children: /* @__PURE__ */ u("div", {
				class: cn("flex flex-col items-center justify-center text-white", zoomIn.value && "transition-all ease-in-out duration-[1000ms] scale-y-[1.15] scale-x-[1.25] -translate-y-2.5", !zoomOut.value && !zoomIn.value && "opacity-0 scale-y-[1.025] scale-x-[1.1] translate-y-1", zoomOut.value && "transition-all ease-in-out duration-[500ms] opacity-100"),
				children: [/* @__PURE__ */ u(Logo, {
					text: "loopmaster",
					size: "3.5em",
					textShadow: true
				}), /* @__PURE__ */ u(SpinnerLarge, {})]
			}) })
		})
	});
};
var bmc_default = "/assets/bmc-C5cvnaXs.svg";
var whop_default = "data:image/svg+xml,%3csvg%20width='1000'%20height='515'%20viewBox='0%200%201000%20515'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20clip-path='url(%23clip0_3041_689)'%3e%3cpath%20d='M158.881%20-0.00366211C93.2014%20-0.00366211%2047.9251%2028.989%2013.6619%2061.7749C13.6619%2061.7749%20-0.173169%2074.965%200.00164277%2075.3669L143.897%20220.129L287.766%2075.3669C260.521%2037.6314%20209.152%20-0.00366211%20158.881%20-0.00366211Z'%20fill='%23FCF6F5'/%3e%3cpath%20d='M514.191%20-0.00360107C448.513%20-0.00360107%20403.236%2028.989%20368.971%2061.775C368.971%2061.775%20356.336%2074.6133%20355.763%2075.367L177.903%20254.322L321.574%20398.857L643.077%2075.367C615.831%2037.6315%20564.488%20-0.00360107%20514.191%20-0.00360107Z'%20fill='%23FCF6F5'/%3e%3cpath%20d='M870.479%20-0.00360107C804.798%20-0.00360107%20759.524%2028.989%20725.259%2061.775C725.259%2061.775%20712.098%2074.7137%20711.6%2075.367L355.806%20433.351L393.466%20471.237C451.73%20529.852%20547.101%20529.852%20605.365%20471.237L998.914%2075.367H999.365C972.119%2037.6315%20920.773%20-0.00360107%20870.479%20-0.00360107Z'%20fill='%23FCF6F5'/%3e%3c/g%3e%3cdefs%3e%3cclipPath%20id='clip0_3041_689'%3e%3crect%20width='1000'%20height='514.706'%20fill='white'/%3e%3c/clipPath%3e%3c/defs%3e%3c/svg%3e";
var exampleCode = `
fm=>sine($+sine($/2)*$*4)*ad(trig:every(1/8))

  |> lps($,cutoff:500+1000*ad(trig:every(1/8))**70,q:.9)*.3

melody=[62,69,65] fm(melody[t*4]|>ntof($))+drums() |> out($)
`;
var selectedExamples = [
	"delay",
	"freeverb",
	"velvet",
	"fdn",
	"dattorro",
	"diodeladder",
	"adsr",
	"at"
].sort(() => Math.random() - .5).map((example) => docs[example] ?? "");
selectedExamples.unshift(exampleCode);
var features = [
	{
		title: "Live Coding",
		description: "Write audio code in real-time. See and hear your changes instantly as you type.",
		icon: t$2
	},
	{
		title: "Powerful DSP",
		description: "Built-in synthesizers, effects, filters, and sequencing tools. All running in WebAssembly for maximum performance.",
		icon: e$6
	},
	{
		title: "Visual Feedback",
		description: "Visual widgets in the editor show waveforms, envelopes, and triggers. Understand your audio visually.",
		icon: t$3
	},
	{
		title: "Sequencing",
		description: "Arrange your code in a timeline and create complete songs.",
		icon: e$15
	},
	{
		title: "No Installation",
		description: "Runs entirely in your browser. No plugins, no downloads. Just open and create.",
		icon: e$4
	},
	{
		title: "Open Source",
		description: "Built with modern web technologies. Extensible and transparent.",
		icon: e$1
	}
];
var communityFeatures = [
	{
		title: "Artist Page",
		description: "Showcase your unique sound and creations with your own artist page.",
		icon: r$3
	},
	{
		title: "Publish Your Loops",
		description: "Share your audio code with the community. Let others discover and learn from your work.",
		icon: o$17
	},
	{
		title: "Remix Loops",
		description: "Take inspiration from others and make it your own. Build upon the community's creativity.",
		icon: o$16
	}
];
var testimonials = [
	{
		quote: "The most intuitive audio programming environment I've used. The live coding experience is incredible.",
		author: "Carl C.",
		role: "Electronic Music Producer"
	},
	{
		quote: "Finally, a tool that makes audio programming accessible. The visual feedback helps me understand what I'm creating.",
		author: "Sam R.",
		role: "Sound Designer"
	},
	{
		quote: "I love being able to experiment with sounds directly in the browser. No setup, just pure creativity.",
		author: "Jordan K.",
		role: "Music Technologist"
	}
];
var ActionButton = ({ to, text, icon }) => {
	return /* @__PURE__ */ u(Link$1, {
		to,
		class: `flex items-center justify-center gap-2 px-6 py-3 text-white font-semibold`,
		style: {
			...primaryGradientStyle.value,
			clipPath: "polygon(12.5px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 12.5px) 100%, 0 100%, 0 10px)",
			textShadow: `0px 1.25px 0px #000`
		},
		children: [/* @__PURE__ */ u("div", {
			class: "relative",
			children: [/* @__PURE__ */ u("div", {
				class: "text-black relative top-[1.25px]",
				children: icon
			}), /* @__PURE__ */ u("div", {
				class: "absolute top-0 left-0 w-full h-full text-white",
				children: icon
			})]
		}), /* @__PURE__ */ u("span", { children: text })]
	});
};
var ActionGrayButton = ({ to, text, icon }) => {
	return /* @__PURE__ */ u(Link$1, {
		to,
		class: `flex items-center justify-center gap-2 px-6 py-3 text-white font-semibold bg-gradient-to-br from-neutral-500 to-neutral-700`,
		style: {
			clipPath: "polygon(12.5px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 12.5px) 100%, 0 100%, 0 10px)",
			textShadow: `0px 1.25px 0px #000`
		},
		children: [/* @__PURE__ */ u("div", {
			class: "relative",
			children: [/* @__PURE__ */ u("div", {
				class: "text-black relative top-[1.25px]",
				children: icon
			}), /* @__PURE__ */ u("div", {
				class: "absolute top-0 left-0 w-full h-full text-white",
				children: icon
			})]
		}), /* @__PURE__ */ u("span", { children: text })]
	});
};
var EnterAppButton = () => {
	return /* @__PURE__ */ u(ActionButton, {
		to: "/projects",
		text: "Enter App",
		icon: /* @__PURE__ */ u(e$1, {
			weight: "regular",
			size: 24
		})
	});
};
var BrowseLoopsButton = () => {
	return isMobile() ? /* @__PURE__ */ u(ActionButton, {
		to: "/browse/newest",
		text: "Browse Tracks",
		icon: /* @__PURE__ */ u(e$4, {
			weight: "regular",
			size: 24
		})
	}) : /* @__PURE__ */ u(ActionGrayButton, {
		to: "/browse/newest",
		text: "Browse Tracks",
		icon: /* @__PURE__ */ u(e$4, {
			weight: "regular",
			size: 24
		})
	});
};
var ReadTutorialsButton = () => {
	return /* @__PURE__ */ u(ActionGrayButton, {
		to: "/tutorials",
		text: "Read Tutorials",
		icon: /* @__PURE__ */ u(e, {
			weight: "regular",
			size: 24
		})
	});
};
var Card = ({ children, class: className = "" }) => /* @__PURE__ */ u("div", {
	class: `flex flex-col p-6 border-b-2 border-[${primaryColor.value}] bg-white/5 hover:border-[${secondaryColor.value}] transition-colors ${className}`,
	children
});
function Landing() {
	showIntro.value = false;
	widgetOptions.showVisuals = true;
	widgetOptions.showKnobs = true;
	widgetOptions.noHeader = true;
	const code = useSignal(exampleCode);
	const selectedExampleIndex = useSignal(0);
	const randomHistory = useSignal([{
		name: themeName.value,
		variation: themeVariation.value
	}]);
	const randomHistoryIndex = useSignal(0);
	const randomizeTheme = () => {
		if (randomHistoryIndex.value === randomHistory.value.length - 1) {
			const theme$1 = _all_default[Math.floor(Math.random() * _all_default.length)];
			themeName.value = theme$1.name;
			const variations = [
				"A",
				"B",
				"C"
			];
			themeVariation.value = variations[Math.floor(Math.random() * variations.length)];
			randomHistory.value = [...randomHistory.value, {
				name: theme$1.name,
				variation: themeVariation.value
			}];
			randomHistoryIndex.value++;
		} else {
			const { name, variation } = randomHistory.value[++randomHistoryIndex.value];
			themeName.value = name;
			themeVariation.value = variation;
		}
	};
	const previousTheme = (event) => {
		event.preventDefault();
		if (randomHistoryIndex.value === 0) return;
		const { name, variation } = randomHistory.value[--randomHistoryIndex.value];
		themeName.value = name;
		themeVariation.value = variation;
	};
	return /* @__PURE__ */ u("div", {
		class: `min-h-screen bg-[${backgroundColor.value}] text-white relative`,
		children: /* @__PURE__ */ u("div", {
			class: "relative",
			children: [
				/* @__PURE__ */ u("section", {
					class: "relative",
					children: /* @__PURE__ */ u("div", {
						class: "relative max-w-7xl mx-auto px-6 py-6 md:py-14",
						children: [/* @__PURE__ */ u("div", {
							class: "flex flex-col items-center justify-center text-center mb-12",
							children: [/* @__PURE__ */ u(Logo, {
								text: "loopmaster",
								size: isMobile() ? "3.5em" : "4.1em",
								onClick: randomizeTheme,
								onContextMenu: previousTheme
							}), /* @__PURE__ */ u("div", {
								class: "mt-9 flex gap-4 justify-center items-center flex-wrap",
								children: [
									/* @__PURE__ */ u(BrowseLoopsButton, {}),
									!isMobile() && /* @__PURE__ */ u(EnterAppButton, {}),
									/* @__PURE__ */ u(ReadTutorialsButton, {})
								]
							})]
						}), /* @__PURE__ */ u("div", {
							class: "mt-8 max-w-3xl mx-auto",
							children: [
								/* @__PURE__ */ u("div", {
									class: "mb-4 text-center",
									children: [/* @__PURE__ */ u("h2", {
										class: "text-2xl font-semibold text-white mb-2",
										children: "Try it live"
									}), !isMobile() && /* @__PURE__ */ u("p", {
										class: "text-neutral-400",
										children: "Press play and edit the code below to hear your changes"
									})]
								}),
								/* @__PURE__ */ u("div", {
									class: "flex justify-start",
									children: /* @__PURE__ */ u("button", {
										class: "p-2 flex items-center gap-2 text-neutral-400 hover:text-white hover:bg-white/5",
										onClick: () => {
											code.value = selectedExamples[++selectedExampleIndex.value % selectedExamples.length] ?? "";
										},
										children: [/* @__PURE__ */ u(r$2, {
											weight: "regular",
											size: 16
										}), "Try a different example"]
									})
								}),
								/* @__PURE__ */ u("div", {
									class: `bg-black border-b-2 border-[${primaryColor.value}]`,
									children: /* @__PURE__ */ u(InlineEditor, {
										id: "landing-example",
										autoHeight: true,
										code: code.value,
										persisted: false
									})
								})
							]
						})]
					})
				}),
				/* @__PURE__ */ u("section", {
					class: "py-20 relative",
					children: /* @__PURE__ */ u("div", {
						class: "max-w-7xl mx-auto px-6 relative z-10",
						children: [/* @__PURE__ */ u("div", {
							class: "text-center mb-16",
							children: [/* @__PURE__ */ u("h2", {
								class: "text-4xl font-bold text-white mb-4",
								children: "Everything you need"
							}), /* @__PURE__ */ u("p", {
								class: "text-xl text-neutral-400 max-w-2xl mx-auto",
								children: "A complete audio programming environment built for creativity"
							})]
						}), /* @__PURE__ */ u("div", {
							class: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8",
							children: features.map((feature, i$6) => {
								const IconComponent = feature.icon;
								return /* @__PURE__ */ u(Card, { children: [/* @__PURE__ */ u("div", {
									class: `mb-4 text-[${secondaryColor.value}] flex items-center gap-4`,
									children: [/* @__PURE__ */ u(IconComponent, {
										weight: "regular",
										size: 48
									}), /* @__PURE__ */ u("h3", {
										class: "text-xl font-semibold text-white",
										children: feature.title
									})]
								}), /* @__PURE__ */ u("p", {
									class: "text-neutral-400 leading-relaxed",
									children: feature.description
								})] }, i$6);
							})
						})]
					})
				}),
				/* @__PURE__ */ u("section", {
					class: "py-20 relative",
					children: /* @__PURE__ */ u("div", {
						class: "max-w-7xl mx-auto px-6 relative z-10",
						children: [/* @__PURE__ */ u("div", {
							class: "text-center mb-16",
							children: [/* @__PURE__ */ u("h2", {
								class: "text-4xl font-bold text-white mb-4",
								children: "Join a Community"
							}), /* @__PURE__ */ u("p", {
								class: "text-xl text-neutral-400 max-w-2xl mx-auto",
								children: "Connect with creators, share your work, and collaborate"
							})]
						}), /* @__PURE__ */ u("div", {
							class: "grid grid-cols-1 md:grid-cols-3 gap-8",
							children: communityFeatures.map((feature, i$6) => {
								const IconComponent = feature.icon;
								return /* @__PURE__ */ u(Card, { children: [/* @__PURE__ */ u("div", {
									class: `mb-4 text-[${secondaryColor.value}] flex items-center gap-4`,
									children: [/* @__PURE__ */ u(IconComponent, {
										weight: "regular",
										size: 48
									}), /* @__PURE__ */ u("h3", {
										class: "text-xl font-semibold text-white",
										children: feature.title
									})]
								}), /* @__PURE__ */ u("p", {
									class: "text-neutral-400 leading-relaxed",
									children: feature.description
								})] }, i$6);
							})
						})]
					})
				}),
				/* @__PURE__ */ u("section", {
					class: "py-20 relative",
					children: /* @__PURE__ */ u("div", {
						class: "max-w-7xl mx-auto px-6 relative z-10",
						children: [/* @__PURE__ */ u("div", {
							class: "text-center mb-16",
							children: [/* @__PURE__ */ u("h2", {
								class: "text-4xl font-bold text-white mb-4",
								children: "What creators are saying"
							}), /* @__PURE__ */ u("p", {
								class: "text-xl text-neutral-400",
								children: "Join the community of audio programmers"
							})]
						}), /* @__PURE__ */ u("div", {
							class: "grid grid-cols-1 md:grid-cols-3 gap-8",
							children: testimonials.map((testimonial, i$6) => /* @__PURE__ */ u(Card, {
								class: "justify-between",
								children: [/* @__PURE__ */ u("p", {
									class: "text-neutral-300 leading-relaxed mb-4 italic",
									children: [
										"\"",
										testimonial.quote,
										"\""
									]
								}), /* @__PURE__ */ u("div", {
									class: `pt-4 border-t-2 border-[${secondaryColor.value}]`,
									children: [/* @__PURE__ */ u("p", {
										class: "font-semibold text-white",
										children: testimonial.author
									}), /* @__PURE__ */ u("p", {
										class: "text-sm text-neutral-500",
										children: testimonial.role
									})]
								})]
							}, i$6))
						})]
					})
				}),
				/* @__PURE__ */ u("section", {
					class: "py-20 relative",
					children: /* @__PURE__ */ u("div", {
						class: "max-w-4xl mx-auto px-6 text-center relative z-10",
						children: [
							/* @__PURE__ */ u("h2", {
								class: "text-4xl font-bold text-white mb-4",
								children: "Ready to create?"
							}),
							/* @__PURE__ */ u("p", {
								class: "text-xl text-neutral-400 mb-8 max-w-2xl mx-auto",
								children: [
									"Start coding your sounds right now.",
									/* @__PURE__ */ u("br", {}),
									"No signup required, no installation needed."
								]
							}),
							/* @__PURE__ */ u("div", {
								class: "flex gap-4 justify-center items-center flex-wrap",
								children: [
									/* @__PURE__ */ u(BrowseLoopsButton, {}),
									!isMobile() && /* @__PURE__ */ u(EnterAppButton, {}),
									/* @__PURE__ */ u(ReadTutorialsButton, {})
								]
							})
						]
					})
				}),
				/* @__PURE__ */ u("footer", {
					class: "py-12",
					children: /* @__PURE__ */ u("div", {
						class: "max-w-7xl mx-auto px-6",
						children: [/* @__PURE__ */ u("div", {
							class: "flex flex-col md:flex-row justify-between items-center gap-6",
							children: [/* @__PURE__ */ u("div", { children: /* @__PURE__ */ u(Logo, {
								text: "loopmaster",
								size: "2em",
								onClick: randomizeTheme,
								onContextMenu: previousTheme
							}) }), /* @__PURE__ */ u("div", {
								class: "flex flex-col md:flex-row items-center justify-center gap-6 text-neutral-400",
								children: [
									/* @__PURE__ */ u(Link$1, {
										to: "https://github.com/loopmaster-xyz/loopmaster",
										target: "_blank",
										class: "text-sm border-none rounded-md cursor-pointer font-semibold text-white hover:text-[#4c6dee] flex items-center gap-2",
										children: /* @__PURE__ */ u("svg", {
											version: "1.1",
											xmlns: "http://www.w3.org/2000/svg",
											x: "0px",
											y: "0px",
											width: "24px",
											height: "24px",
											viewBox: "0 0 32 32",
											style: "enable-background:new 0 0 32 32;",
											fill: "currentColor",
											children: /* @__PURE__ */ u("g", {
												id: "github-alt",
												children: /* @__PURE__ */ u("path", {
													id: "_x3C_Zusammengesetzter_Pfad_x3E__3_",
													d: "M15.999,0.2C7.273,0.2,0.2,7.453,0.2,16.401c0,7.157,4.526,13.229,10.805,15.372\n		c0.792,0.148,1.079-0.353,1.079-0.782c0-0.383-0.013-1.403-0.021-2.755c-4.394,0.979-5.322-2.172-5.322-2.172\n		c-0.717-1.873-1.754-2.369-1.754-2.369c-1.435-1.007,0.108-0.985,0.108-0.985c1.585,0.117,2.42,1.673,2.42,1.673\n		c1.409,2.473,3.699,1.76,4.599,1.343c0.144-1.044,0.551-1.762,1.003-2.166c-3.509-0.409-7.198-1.799-7.198-8.007\n		c0-1.768,0.616-3.214,1.627-4.346C7.382,10.796,6.84,9.15,7.7,6.918c0,0,1.327-0.436,4.345,1.66C13.305,8.22,14.657,8.04,16,8.034\n		c1.341,0.006,2.693,0.187,3.955,0.545c3.018-2.096,4.341-1.66,4.341-1.66c0.862,2.231,0.32,3.877,0.157,4.288\n		c1.014,1.132,1.625,2.578,1.625,4.346c0,6.224-3.694,7.593-7.216,7.993c0.568,0.502,1.074,1.489,1.074,3\n		c0,2.167-0.018,3.913-0.018,4.443c0,0.435,0.283,0.939,1.086,0.779C27.278,29.621,31.8,23.556,31.8,16.4\n		C31.8,7.453,24.724,0.2,15.999,0.2z"
												})
											})
										})
									}),
									/* @__PURE__ */ u(Link$1, {
										title: "Discord",
										class: "text-sm border-none rounded-md cursor-pointer font-semibold text-white hover:text-[#4c6dee] flex items-center gap-2",
										to: "https://discord.gg/NSWaB9dRYh",
										target: "_blank",
										children: /* @__PURE__ */ u("svg", {
											xmlns: "http://www.w3.org/2000/svg",
											fill: "currentColor",
											width: "32",
											height: "32",
											viewBox: "0 0 20 20",
											children: /* @__PURE__ */ u("path", { d: "M16.074,4.361a14.243,14.243,0,0,0-3.61-1.134,10.61,10.61,0,0,0-.463.96,13.219,13.219,0,0,0-4,0,10.138,10.138,0,0,0-.468-.96A14.206,14.206,0,0,0,3.919,4.364,15.146,15.146,0,0,0,1.324,14.5a14.435,14.435,0,0,0,4.428,2.269A10.982,10.982,0,0,0,6.7,15.21a9.294,9.294,0,0,1-1.494-.727c.125-.093.248-.19.366-.289a10.212,10.212,0,0,0,8.854,0c.119.1.242.2.366.289a9.274,9.274,0,0,1-1.5.728,10.8,10.8,0,0,0,.948,1.562,14.419,14.419,0,0,0,4.431-2.27A15.128,15.128,0,0,0,16.074,4.361Zm-8.981,8.1a1.7,1.7,0,0,1-1.573-1.79A1.689,1.689,0,0,1,7.093,8.881a1.679,1.679,0,0,1,1.573,1.791A1.687,1.687,0,0,1,7.093,12.462Zm5.814,0a1.7,1.7,0,0,1-1.573-1.79,1.689,1.689,0,0,1,1.573-1.791,1.679,1.679,0,0,1,1.573,1.791A1.688,1.688,0,0,1,12.907,12.462Z" })
										})
									}),
									/* @__PURE__ */ u(Link$1, {
										to: "https://whop.com/loopmaster",
										title: "Support me on Whop",
										target: "_blank",
										class: "text-sm border-none rounded-md cursor-pointer font-semibold text-white hover:text-[#4c6dee] flex items-center gap-2",
										children: /* @__PURE__ */ u("img", {
											src: whop_default,
											alt: "Support me on Whop",
											width: 24,
											height: 24
										})
									}),
									/* @__PURE__ */ u(Link$1, {
										to: "https://www.buymeacoffee.com/loopmaster",
										title: "Buy Me a Coffee",
										target: "_blank",
										class: "text-sm border-none rounded-md cursor-pointer font-semibold text-white hover:text-[#4c6dee] flex items-center gap-2",
										children: /* @__PURE__ */ u("img", {
											src: bmc_default,
											alt: "Buy Me a Coffee",
											width: 24,
											height: 24
										})
									}),
									/* @__PURE__ */ u(Link$1, {
										title: "Feedback",
										class: `hover:text-[${secondaryColor.value}] transition-colors border-b-2 border-transparent hover:border-[${secondaryColor.value}]`,
										to: "https://loopmaster.featurebase.app/",
										target: "_blank",
										children: "Feedback"
									}),
									/* @__PURE__ */ u(Link$1, {
										to: "/docs",
										class: `hover:text-[${secondaryColor.value}] transition-colors border-b-2 border-transparent hover:border-[${secondaryColor.value}]`,
										children: "Documentation"
									}),
									/* @__PURE__ */ u(Link$1, {
										to: "/about",
										class: `hover:text-[${secondaryColor.value}] transition-colors border-b-2 border-transparent hover:border-[${secondaryColor.value}]`,
										children: "Contact"
									})
								]
							})]
						}), /* @__PURE__ */ u("div", {
							class: "mt-8 text-center text-sm text-neutral-500",
							children: [
								" ",
								(/* @__PURE__ */ new Date()).getFullYear(),
								" loopmaster. Built for music hackers."
							]
						})]
					})
				})
			]
		})
	});
}
const ProjectMain = () => {
	const projectId = useComputed(() => pathname.value.startsWith("/p/") ? pathname.value.split("/")[2] ?? "" : null);
	const project = useAsyncMemo(async () => {
		if (!projectId.value) return null;
		return await api.fetchProject(projectId.value);
	});
	return /* @__PURE__ */ u(k, { children: [/* @__PURE__ */ u(Header, { class: "justify-center" }), /* @__PURE__ */ u(Main, {
		class: "flex flex-col text-white/50 px-8 pl-12 py-8 gap-8",
		children: project.value && /* @__PURE__ */ u(BrowseProject, {
			project: project.value,
			autoHeight: true
		})
	})] });
};
async function resizeImageToJpeg(file, size) {
	return new Promise((resolve, reject) => {
		const img = new Image();
		const url = URL.createObjectURL(file);
		img.onload = () => {
			URL.revokeObjectURL(url);
			const canvas = document.createElement("canvas");
			canvas.width = size;
			canvas.height = size;
			const ctx$1 = canvas.getContext("2d");
			if (!ctx$1) {
				reject(/* @__PURE__ */ new Error("Failed to get canvas context"));
				return;
			}
			const aspectRatio = img.width / img.height;
			let sourceX = 0;
			let sourceY = 0;
			let sourceWidth = img.width;
			let sourceHeight = img.height;
			if (aspectRatio > 1) {
				sourceWidth = img.height;
				sourceX = (img.width - img.height) / 2;
			} else if (aspectRatio < 1) {
				sourceHeight = img.width;
				sourceY = (img.height - img.width) / 2;
			}
			ctx$1.drawImage(img, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, size, size);
			canvas.toBlob((blob) => {
				if (blob) resolve(blob);
				else reject(/* @__PURE__ */ new Error("Failed to create blob"));
			}, "image/jpeg", .9);
		};
		img.onerror = () => {
			URL.revokeObjectURL(url);
			reject(/* @__PURE__ */ new Error("Failed to load image"));
		};
		img.src = url;
	});
}
var ArtistButton = ({ children, onClick, disabled }) => {
	return /* @__PURE__ */ u("button", {
		disabled,
		onClick,
		class: cn("text-white/50 text-sm flex flex-row items-center gap-2 px-2 py-1 bg-white/5 hover:bg-white/10", { "opacity-50 cursor-wait": disabled }, { "hover:bg-white/5 focus:bg-white/5": !disabled }),
		children
	});
};
const Artist = ({ session: propsSession }) => {
	const accountSession = useSignal(propsSession ?? null);
	const isLogoutLoading = useSignal(false);
	const fileInputRef = A(null);
	const isUploadingAvatar = useSignal(false);
	const isEditingArtistName = useSignal(false);
	const artistNameRef = A(null);
	const userId = useComputed(() => accountSession.value?.userId ?? pathname.value.split("/")[2] ?? "");
	useReactiveEffect(() => {
		if (session.value && !propsSession && userId.value === session.value.userId) accountSession.value = session.value;
	});
	const logout = async () => {
		try {
			isLogoutLoading.value = true;
			await api.logout();
		} finally {
			isLogoutLoading.value = false;
		}
	};
	const handleImageUpload = async (e$59) => {
		const file = e$59.target.files?.[0];
		if (!file?.type.startsWith("image/")) {
			alert("Please select an image file");
			return;
		}
		try {
			isUploadingAvatar.value = true;
			const resizedBlob = await resizeImageToJpeg(file, 190);
			await api.uploadAvatar(resizedBlob);
			cacheBust.value++;
		} catch (err) {
			alert(err.message || "Failed to upload image");
		} finally {
			isUploadingAvatar.value = false;
			if (fileInputRef.current) fileInputRef.current.value = "";
		}
	};
	const handleSubmitArtistName = () => {
		const artistName = artistNameRef.current?.innerText.trim();
		if (artistName) {
			api.updateArtistName(artistName);
			session.value.artistName = artistName;
			browseProjects.value?.forEach((project) => {
				if (project.userId === session.value.userId) project.artistName = artistName;
				project.likes.forEach((like) => {
					if (like.userId === session.value.userId) like.artistName = artistName;
				});
				project.remixes.forEach((remix) => {
					if (remix.userId === session.value.userId) remix.artistName = artistName;
				});
				project.comments.forEach((comment) => {
					if (comment.userId === session.value.userId) comment.artistName = artistName;
				});
			});
		} else artistNameRef.current.innerText = accountSession.value.artistName;
		isEditingArtistName.value = false;
	};
	useReactiveEffect(() => {
		if (artistNameRef.current && isEditingArtistName.value) {
			setTimeout(() => artistNameRef.current?.focus(), 0);
			artistNameRef.current.addEventListener("blur", handleSubmitArtistName, { once: true });
		}
	});
	return /* @__PURE__ */ u(SidebarMain, {
		class: "my-3.5 gap-3 text-center items-center justify-center",
		children: [
			accountSession.value && /* @__PURE__ */ u("input", {
				ref: fileInputRef,
				type: "file",
				accept: "image/*",
				onChange: handleImageUpload,
				className: "hidden"
			}),
			/* @__PURE__ */ u("button", {
				class: cn("group relative flex items-center justify-center", { "cursor-pointer": accountSession.value }, { "cursor-default": !accountSession.value }),
				onClick: () => {
					if (accountSession.value) fileInputRef.current?.click();
				},
				children: [/* @__PURE__ */ u(Avatar, {
					userId: userId.value,
					size: 190,
					fallback: /* @__PURE__ */ u(Minidenticon, {
						username: userId.value,
						width: "190px",
						class: "bg-white/10 rounded-full"
					})
				}), accountSession.value && /* @__PURE__ */ u("span", {
					class: `opacity-0 group-hover:opacity-100 absolute top-1/2 -translate-y-1/2 bg-[${luminate(backgroundColor.value, .4)}] bg-opacity-30 rounded-full p-1 text-white group-hover:text-white`,
					onClick: () => {},
					children: /* @__PURE__ */ u(e$14, { size: "24" })
				})]
			}),
			/* @__PURE__ */ u("div", {
				class: "flex flex-col gap-1",
				children: [
					/* @__PURE__ */ u("h1", {
						ref: artistNameRef,
						class: "relative text-xl text-white font-bold text-center outline-none focus:bg-white/5 px-2",
						onKeyDown: (e$59) => {
							if (e$59.key === "Enter") {
								handleSubmitArtistName();
								e$59.preventDefault();
							}
							if (e$59.key === "Escape") {
								isEditingArtistName.value = false;
								artistNameRef.current.innerText = accountSession.value.artistName;
								e$59.preventDefault();
							}
						},
						contentEditable: isEditingArtistName.value,
						children: [accountSession.value?.artistName ?? pathname.value.split("/")[3] ?? "", accountSession.value && !isEditingArtistName.value && /* @__PURE__ */ u("button", {
							class: "absolute top-1 -right-4 text-neutral-600 hover:text-white",
							onClick: () => {
								isEditingArtistName.value = true;
							},
							children: /* @__PURE__ */ u(o$12, { size: "20" })
						})]
					}),
					accountSession.value && /* @__PURE__ */ u(Link$1, {
						to: `/u/${accountSession.value.userId}/${accountSession.value.artistName}`,
						children: ["@", accountSession.value.artistName]
					}),
					userProjectsCount.value ? `${userProjectsCount.value} tracks` : null
				]
			}),
			accountSession.value ? /* @__PURE__ */ u(ArtistButton, {
				onClick: logout,
				disabled: isLogoutLoading.value,
				children: [isLogoutLoading.value ? /* @__PURE__ */ u(c, {
					size: 16,
					class: "animate-spin"
				}) : /* @__PURE__ */ u(t$1, {
					size: 16,
					class: "group-hover:text-white"
				}), isLogoutLoading.value ? "Logging out..." : "Logout"]
			}) : /* @__PURE__ */ u(ArtistButton, { children: [/* @__PURE__ */ u(o$15, { size: 16 }), "Follow"] })
		]
	});
};
const SidebarButton = ({ children, onClick, class: className, disabled = false }) => /* @__PURE__ */ u("button", {
	class: cn("group px-2 py-1 flex flex-row items-center gap-2 outline-none", { "opacity-50 cursor-wait": disabled }, { "hover:bg-white/5 focus:bg-white/5": !disabled }, className),
	onClick,
	children
});
var Error$1 = ({ message }) => /* @__PURE__ */ u("p", {
	class: "text-red-500 text-sm flex items-center",
	children: [
		/* @__PURE__ */ u(o$14, {
			size: 16,
			class: "inline-block mr-1"
		}),
		" ",
		message
	]
});
const AuthForm = ({ showBoth = false, placement }) => {
	const mode = useSignal(showBoth ? "both" : "login");
	const loginEmail = useSignal("");
	const loginPassword = useSignal("");
	const loginErrorMessage = useSignal("");
	const isLoginLoading = useSignal(false);
	const registerArtistName = useSignal("");
	const registerEmail = useSignal("");
	const registerPassword = useSignal("");
	const registerErrorMessage = useSignal("");
	const isRegisterLoading = useSignal(false);
	useReactiveEffect(() => {
		mode.value;
		loginErrorMessage.value = "";
		registerErrorMessage.value = "";
	});
	const login = async () => {
		try {
			isLoginLoading.value = true;
			session.value = await api.login(loginEmail.value, loginPassword.value);
		} catch (error$1) {
			console.error(error$1);
			loginErrorMessage.value = error$1.message ?? String(error$1);
		} finally {
			isLoginLoading.value = false;
		}
	};
	const register$1 = async () => {
		try {
			isRegisterLoading.value = true;
			session.value = await api.register(registerArtistName.value, registerEmail.value, registerPassword.value);
		} catch (error$1) {
			console.error(error$1);
			registerErrorMessage.value = error$1.message ?? String(error$1);
		} finally {
			isRegisterLoading.value = false;
		}
	};
	return /* @__PURE__ */ u("div", {
		class: "flex flex-col gap-11 h-full w-52 py-2.5 text-neutral-400 text-sm select-none",
		children: [(mode.value === "login" || mode.value === "both") && /* @__PURE__ */ u("form", {
			onSubmit: (e$59) => e$59.preventDefault(),
			class: "py-0 flex flex-col items-stretch justify-between gap-2 cursor-pointer",
			children: [
				placement === "bottom" && loginErrorMessage.value && /* @__PURE__ */ u(Error$1, { message: loginErrorMessage.value }),
				/* @__PURE__ */ u("input", {
					required: true,
					class: "w-full bg-white/5 py-1 px-2 outline-none",
					type: "email",
					placeholder: "Email",
					autocomplete: "email",
					value: loginEmail,
					onChange: (e$59) => loginEmail.value = e$59.target.value
				}),
				/* @__PURE__ */ u("input", {
					required: true,
					class: "w-full bg-white/5 py-1 px-2 outline-none",
					type: "password",
					placeholder: "Password",
					autocomplete: "current-password",
					value: loginPassword,
					onChange: (e$59) => loginPassword.value = e$59.target.value
				}),
				/* @__PURE__ */ u("div", {
					class: "flex flex-row items-center justify-between",
					children: [/* @__PURE__ */ u(SidebarButton, {
						onClick: login,
						disabled: isLoginLoading.value,
						class: mode.value === "both" ? "w-full" : "",
						children: [
							isLoginLoading.value ? "Logging in..." : "Login",
							" ",
							isLoginLoading.value ? /* @__PURE__ */ u(c, {
								size: 16,
								class: "animate-spin"
							}) : /* @__PURE__ */ u(n$1, {
								size: 16,
								class: "group-hover:text-white"
							})
						]
					}), mode.value !== "both" && /* @__PURE__ */ u("div", {
						class: "text-xs text-center",
						children: [
							/* @__PURE__ */ u("span", {
								class: "text-white/30",
								children: "or"
							}),
							" ",
							/* @__PURE__ */ u("a", {
								href: "#",
								class: "hover:text-white",
								onClick: (e$59) => {
									e$59.preventDefault();
									mode.value = "register";
								},
								children: "register"
							})
						]
					})]
				}),
				placement === "top" && loginErrorMessage.value && /* @__PURE__ */ u(Error$1, { message: loginErrorMessage.value })
			]
		}), (mode.value === "register" || mode.value === "both") && /* @__PURE__ */ u("form", {
			onSubmit: (e$59) => e$59.preventDefault(),
			class: "py-0 flex flex-col items-stretch justify-between gap-2 cursor-pointer",
			children: [
				placement === "bottom" && registerErrorMessage.value && /* @__PURE__ */ u(Error$1, { message: registerErrorMessage.value }),
				/* @__PURE__ */ u("input", {
					required: true,
					class: "w-full bg-white/5 py-1 px-2 outline-none",
					type: "text",
					placeholder: "Artist Name",
					autocomplete: "name",
					value: registerArtistName,
					onChange: (e$59) => registerArtistName.value = e$59.target.value
				}),
				/* @__PURE__ */ u("input", {
					required: true,
					class: "w-full bg-white/5 py-1 px-2 outline-none",
					type: "email",
					placeholder: "Email",
					autocomplete: "email",
					value: registerEmail,
					onChange: (e$59) => registerEmail.value = e$59.target.value
				}),
				/* @__PURE__ */ u("input", {
					required: true,
					class: "w-full bg-white/5 py-1 px-2 outline-none",
					type: "password",
					placeholder: "Password",
					autocomplete: "new-password",
					value: registerPassword,
					onChange: (e$59) => registerPassword.value = e$59.target.value
				}),
				/* @__PURE__ */ u("div", {
					class: "flex flex-row items-center justify-between",
					children: [/* @__PURE__ */ u(SidebarButton, {
						onClick: register$1,
						disabled: isRegisterLoading.value,
						class: mode.value === "both" ? "w-full" : "",
						children: [
							isRegisterLoading.value ? "Registering..." : "Register",
							" ",
							isRegisterLoading.value ? /* @__PURE__ */ u(c, {
								size: 16,
								class: "animate-spin"
							}) : /* @__PURE__ */ u(i, {
								size: 16,
								class: "group-hover:text-white"
							})
						]
					}), mode.value !== "both" && /* @__PURE__ */ u("div", {
						class: "text-xs text-center",
						children: [
							/* @__PURE__ */ u("span", {
								class: "text-white/30",
								children: "or"
							}),
							" ",
							/* @__PURE__ */ u("a", {
								href: "#",
								class: "hover:text-white",
								onClick: (e$59) => {
									e$59.preventDefault();
									mode.value = "login";
								},
								children: "login"
							})
						]
					})]
				}),
				placement === "top" && registerErrorMessage.value && /* @__PURE__ */ u(Error$1, { message: registerErrorMessage.value })
			]
		})]
	});
};
const Account = () => {
	if (session.value) return /* @__PURE__ */ u(Artist, { session: session.value });
	else return /* @__PURE__ */ u(AuthForm, {
		placement: "top",
		showBoth: true
	});
};
var models = [
	"gpt-5.2-chat-latest",
	"gpt-5-chat-latest",
	"codex-mini-latest",
	"gpt-5-nano",
	"gpt-5-mini",
	"gpt-5.1-mini"
];
const AI = () => {
	return /* @__PURE__ */ u(SidebarMain, { children: [
		/* @__PURE__ */ u("div", {
			class: "py-1 px-2 w-full text-sm flex flex-row items-center justify-between gap-2",
			children: [
				/* @__PURE__ */ u("div", {
					class: "whitespace-nowrap mr-1.5",
					children: "Temp"
				}),
				/* @__PURE__ */ u("input", {
					type: "range",
					min: "0",
					max: "2",
					step: .1,
					value: aiTemperature.value,
					onChange: (e$59) => {
						aiTemperature.value = Number(e$59.target.valueAsNumber.toFixed(1));
					},
					class: "w-full h-1 my-2",
					style: { accentColor: primaryColor.value }
				}),
				/* @__PURE__ */ u("div", {
					class: "w-[40px] text-right",
					children: aiTemperature.value.toFixed(1)
				})
			]
		}),
		/* @__PURE__ */ u("div", {
			class: "py-1 px-2 w-full text-sm flex flex-row items-center justify-between gap-2",
			children: [
				/* @__PURE__ */ u("div", {
					class: "whitespace-nowrap mr-1.5",
					children: "Top P"
				}),
				/* @__PURE__ */ u("input", {
					type: "range",
					min: "0",
					max: "1",
					step: .1,
					value: aiTopP.value,
					onChange: (e$59) => {
						aiTopP.value = Number(e$59.target.valueAsNumber.toFixed(1));
					},
					class: "w-full h-1 my-2",
					style: { accentColor: primaryColor.value }
				}),
				/* @__PURE__ */ u("div", {
					class: "w-[40px] text-right",
					children: aiTopP.value.toFixed(1)
				})
			]
		}),
		/* @__PURE__ */ u(SidebarButton, {
			onClick: () => {
				aiModel.value = models[(models.indexOf(aiModel.value) + 1) % models.length] || models[0];
			},
			children: aiModel
		}),
		/* @__PURE__ */ u("div", {
			class: "py-1 px-2 w-full text-sm flex flex-col gap-2",
			children: [/* @__PURE__ */ u(SidebarButton, {
				onClick: () => {
					api.generateAITrack(aiPromptNew.value, aiTemperature.value, aiTopP.value, aiModel.value).then((p$6) => {
						if (p$6) {
							const newProject = createProject({ name: p$6.title });
							newProject.doc.code = newProject.scratch.code = p$6.code;
							projects.value = [...projects.value, newProject];
						}
					}).catch((error$1) => {
						console.error(error$1);
					});
				},
				children: "Generate New Track"
			}), /* @__PURE__ */ u("textarea", {
				value: aiPromptNew.value,
				class: "bg-white/5 text-white outline-none px-2 py-1",
				rows: 3,
				onChange: (e$59) => {
					aiPromptNew.value = e$59.target.value;
				}
			})]
		})
	] });
};
const Browse = () => {
	return /* @__PURE__ */ u(SidebarMain, { children: [
		/* @__PURE__ */ u(SidebarLink, {
			to: "/browse/newest",
			children: [/* @__PURE__ */ u(c$1, {
				size: 16,
				class: "group-hover:text-white"
			}), /* @__PURE__ */ u("span", { children: "Newest" })]
		}),
		/* @__PURE__ */ u(SidebarLink, {
			to: "/browse/one-liners",
			children: [/* @__PURE__ */ u(e$1, {
				size: 16,
				class: "group-hover:text-white"
			}), /* @__PURE__ */ u("span", { children: "One-Liners" })]
		}),
		session.value && /* @__PURE__ */ u(SidebarLink, {
			to: "/browse/liked",
			children: [/* @__PURE__ */ u(o$13, {
				size: 16,
				class: "group-hover:text-white"
			}), /* @__PURE__ */ u("span", { children: "Liked" })]
		})
	] });
};
const Bytecode = () => {
	return /* @__PURE__ */ u("div", {
		class: "flex flex-col w-52 py-4 px-1.5 gap-0 text-neutral-400 text-xs font-mono whitespace-pre-wrap",
		children: bytecode.value.map((line) => /* @__PURE__ */ u("div", {
			class: "flex",
			children: [/* @__PURE__ */ u("span", {
				style: { color: primaryColor.value },
				children: [line.split(":")[0], ":\xA0"]
			}), line.split(": ")[1]]
		}))
	});
};
const Console = () => {
	return /* @__PURE__ */ u("div", {
		class: "flex flex-col w-52 py-4 px-1.5 gap-0 text-neutral-400 text-xs font-mono select-none",
		children: consoleDebug
	});
};
var ProjectButton = ({ project, onLoadA, onLoadB }) => {
	return /* @__PURE__ */ u("div", {
		class: "group px-2 hover:bg-white/5 flex flex-row items-center justify-between gap-2 outline-none focus:bg-white/5",
		children: [project.name, /* @__PURE__ */ u("div", {
			class: "text-xs flex flex-row gap-1",
			children: [/* @__PURE__ */ u("button", {
				onClick: onLoadA,
				class: "flex flex-row items-center justify-center p-1 pl-0.5 pr-1.5 hover:bg-white/5 hover:text-white",
				children: [/* @__PURE__ */ u(t, { size: 12 }), "A"]
			}), /* @__PURE__ */ u("button", {
				onClick: onLoadB,
				class: "flex flex-row items-center justify-center p-1 pl-1.5 pr-0.5 hover:bg-white/5 hover:text-white",
				children: ["B", /* @__PURE__ */ u(e$9, { size: 12 })]
			})]
		})]
	}, project.id);
};
const DJ = () => {
	return /* @__PURE__ */ u(SidebarMain, { children: projects.value.map((project) => /* @__PURE__ */ u(ProjectButton, {
		project,
		onLoadA: () => {
			n(() => {
				djDocA.value.code = project.scratch.code;
				djTitleA.value = project.name;
			});
		},
		onLoadB: () => {
			n(() => {
				djDocB.value.code = project.scratch.code;
				djTitleB.value = project.name;
			});
		}
	}, project.id)) });
};
var import_wav_encoder = /* @__PURE__ */ __toESM((/* @__PURE__ */ __commonJSMin(((exports, module) => {
	function encodeSync(audioData, opts) {
		opts = opts || {};
		audioData = toAudioData(audioData);
		if (audioData === null) throw new TypeError("Invalid AudioData");
		var floatingPoint = !!(opts.floatingPoint || opts.float);
		var bitDepth = floatingPoint ? 32 : opts.bitDepth | 0 || 16;
		var bytes = bitDepth >> 3;
		var length = audioData.length * audioData.numberOfChannels * bytes;
		var dataView = new DataView(new Uint8Array(44 + length).buffer);
		var writer = createWriter(dataView);
		var format = {
			formatId: floatingPoint ? 3 : 1,
			floatingPoint,
			numberOfChannels: audioData.numberOfChannels,
			sampleRate: audioData.sampleRate,
			bitDepth
		};
		writeHeader(writer, format, dataView.buffer.byteLength - 8);
		var err = writeData(writer, format, length, audioData, opts);
		if (err instanceof Error) throw err;
		return dataView.buffer;
	}
	function encode(audioData, opts) {
		return new Promise(function(resolve) {
			resolve(encodeSync(audioData, opts));
		});
	}
	function toAudioData(data) {
		var audioData = {};
		if (typeof data.sampleRate !== "number") return null;
		if (!Array.isArray(data.channelData)) return null;
		if (!(data.channelData[0] instanceof Float32Array)) return null;
		audioData.numberOfChannels = data.channelData.length;
		audioData.length = data.channelData[0].length | 0;
		audioData.sampleRate = data.sampleRate | 0;
		audioData.channelData = data.channelData;
		return audioData;
	}
	function writeHeader(writer, format, length) {
		var bytes = format.bitDepth >> 3;
		writer.string("RIFF");
		writer.uint32(length);
		writer.string("WAVE");
		writer.string("fmt ");
		writer.uint32(16);
		writer.uint16(format.floatingPoint ? 3 : 1);
		writer.uint16(format.numberOfChannels);
		writer.uint32(format.sampleRate);
		writer.uint32(format.sampleRate * format.numberOfChannels * bytes);
		writer.uint16(format.numberOfChannels * bytes);
		writer.uint16(format.bitDepth);
	}
	function writeData(writer, format, length, audioData, opts) {
		var bitDepth = format.bitDepth;
		var encoderOption = format.floatingPoint ? "f" : opts.symmetric ? "s" : "";
		var methodName = "pcm" + bitDepth + encoderOption;
		if (!writer[methodName]) return /* @__PURE__ */ new TypeError("Not supported bit depth: " + bitDepth);
		var write = writer[methodName].bind(writer);
		var numberOfChannels = format.numberOfChannels;
		var channelData = audioData.channelData;
		writer.string("data");
		writer.uint32(length);
		for (var i$6 = 0, imax = audioData.length; i$6 < imax; i$6++) for (var ch = 0; ch < numberOfChannels; ch++) write(channelData[ch][i$6]);
	}
	function createWriter(dataView) {
		var pos = 0;
		return {
			int16: function(value) {
				dataView.setInt16(pos, value, true);
				pos += 2;
			},
			uint16: function(value) {
				dataView.setUint16(pos, value, true);
				pos += 2;
			},
			uint32: function(value) {
				dataView.setUint32(pos, value, true);
				pos += 4;
			},
			string: function(value) {
				for (var i$6 = 0, imax = value.length; i$6 < imax; i$6++) dataView.setUint8(pos++, value.charCodeAt(i$6));
			},
			pcm8: function(value) {
				value = Math.max(-1, Math.min(value, 1));
				value = (value * .5 + .5) * 255;
				value = Math.round(value) | 0;
				dataView.setUint8(pos, value, true);
				pos += 1;
			},
			pcm8s: function(value) {
				value = Math.round(value * 128) + 128;
				value = Math.max(0, Math.min(value, 255));
				dataView.setUint8(pos, value, true);
				pos += 1;
			},
			pcm16: function(value) {
				value = Math.max(-1, Math.min(value, 1));
				value = value < 0 ? value * 32768 : value * 32767;
				value = Math.round(value) | 0;
				dataView.setInt16(pos, value, true);
				pos += 2;
			},
			pcm16s: function(value) {
				value = Math.round(value * 32768);
				value = Math.max(-32768, Math.min(value, 32767));
				dataView.setInt16(pos, value, true);
				pos += 2;
			},
			pcm24: function(value) {
				value = Math.max(-1, Math.min(value, 1));
				value = value < 0 ? 16777216 + value * 8388608 : value * 8388607;
				value = Math.round(value) | 0;
				var x0 = value >> 0 & 255;
				var x1 = value >> 8 & 255;
				var x2 = value >> 16 & 255;
				dataView.setUint8(pos + 0, x0);
				dataView.setUint8(pos + 1, x1);
				dataView.setUint8(pos + 2, x2);
				pos += 3;
			},
			pcm24s: function(value) {
				value = Math.round(value * 8388608);
				value = Math.max(-8388608, Math.min(value, 8388607));
				var x0 = value >> 0 & 255;
				var x1 = value >> 8 & 255;
				var x2 = value >> 16 & 255;
				dataView.setUint8(pos + 0, x0);
				dataView.setUint8(pos + 1, x1);
				dataView.setUint8(pos + 2, x2);
				pos += 3;
			},
			pcm32: function(value) {
				value = Math.max(-1, Math.min(value, 1));
				value = value < 0 ? value * 2147483648 : value * 2147483647;
				value = Math.round(value) | 0;
				dataView.setInt32(pos, value, true);
				pos += 4;
			},
			pcm32s: function(value) {
				value = Math.round(value * 2147483648);
				value = Math.max(-2147483648, Math.min(value, 2147483647));
				dataView.setInt32(pos, value, true);
				pos += 4;
			},
			pcm32f: function(value) {
				dataView.setFloat32(pos, value, true);
				pos += 4;
			}
		};
	}
	module.exports.encode = encode;
	module.exports.encode.sync = encodeSync;
})))(), 1);
function throttle(fn$1, delay) {
	let lastTime = 0;
	let timer = null;
	let pendingArgs = null;
	const throttled = function(...args) {
		const now = Date.now();
		const remaining = delay - (now - lastTime);
		if (remaining > 0) {
			pendingArgs = args;
			if (!timer) timer = setTimeout(() => {
				timer = null;
				lastTime = Date.now();
				if (pendingArgs) {
					fn$1.apply(this, pendingArgs);
					pendingArgs = null;
				}
			}, remaining);
			return;
		}
		lastTime = now;
		fn$1.apply(this, args);
	};
	return throttled;
}
const ExportAudio = () => {
	const barsInputValue = useSignal(3);
	const numberOfBars = useComputed(() => !barsInputValue.value ? 1 : 2 ** barsInputValue.value);
	const duration = useComputed(() => {
		const barLengthSeconds = 240 / bpm.value;
		return numberOfBars.value * barLengthSeconds;
	});
	const durationInMinutes = useComputed(() => {
		const durationInSeconds = duration.value;
		return `${Math.floor(durationInSeconds / 60)}:${(durationInSeconds % 60).toFixed(0).padStart(2, "0")}`;
	});
	const startedRendering = useSignal(false);
	const progress = useSignal(0);
	const floats = useSignal(null);
	const playing = useSignal(false);
	const position = useSignal(0);
	const scrubbing = useSignal(false);
	const scrubRatio = useSignal(0);
	const sourceRef = A(null);
	const gainRef = A(null);
	const seekTransitionRef = A(null);
	const stopTransitionRef = A(null);
	const pendingSeekRef = A(null);
	A(() => {});
	const startTimeRef = A(0);
	const playOffsetRef = A(0);
	const rafRef = A(0);
	const fadeOut = 16;
	const seekFade = .03;
	const seekThrottleMs = 80;
	const stopRendering = useSignal(false);
	const applyFadeOut = (left, right) => {
		const len = left.length;
		if (len >= fadeOut) for (let j$4 = 0; j$4 < fadeOut; j$4++) {
			const gain = 1 - j$4 / fadeOut;
			left[len - fadeOut + j$4] *= gain;
			right[len - fadeOut + j$4] *= gain;
		}
	};
	const wavBlob = useAsyncMemo(async () => {
		if (!audioContext.value) return;
		if (!floats.value) return;
		const wavBuffer = await import_wav_encoder.default.encode({
			sampleRate: audioContext.value.sampleRate,
			channelData: [floats.value.left, floats.value.right]
		});
		return new Blob([wavBuffer], { type: "audio/wav" });
	});
	const audioBuffer = useComputed(() => {
		const ac = audioContext.value;
		const f$5 = floats.value;
		if (!ac || !f$5) return null;
		const buf = ac.createBuffer(2, f$5.left.length, ac.sampleRate);
		buf.getChannelData(0).set(f$5.left);
		buf.getChannelData(1).set(f$5.right);
		return buf;
	});
	const bufferDuration = useComputed(() => audioBuffer.value?.duration ?? 0);
	y(() => {
		if (!playing.value || bufferDuration.value <= 0) return;
		const ac = audioContext.value;
		if (!ac) return;
		const tick = () => {
			if (!playing.value) return;
			position.value = (playOffsetRef.current + (ac.currentTime - startTimeRef.current)) % bufferDuration.value;
			rafRef.current = requestAnimationFrame(tick);
		};
		rafRef.current = requestAnimationFrame(tick);
		return () => cancelAnimationFrame(rafRef.current);
	}, [playing.value, bufferDuration.value]);
	y(() => {
		return () => {
			if (seekTransitionRef.current) clearTimeout(seekTransitionRef.current);
			if (stopTransitionRef.current) clearTimeout(stopTransitionRef.current);
			cancelAnimationFrame(rafRef.current);
			sourceRef.current?.stop();
			sourceRef.current = null;
		};
	}, []);
	const startSource = (offsetSeconds, fadeIn) => {
		const ac = audioContext.value;
		const buf = audioBuffer.value;
		if (!ac || !buf) return;
		const source = ac.createBufferSource();
		source.buffer = buf;
		source.loop = true;
		const gain = ac.createGain();
		gain.connect(ac.destination);
		source.connect(gain);
		gainRef.current = gain;
		if (fadeIn) {
			gain.gain.setValueAtTime(0, ac.currentTime);
			gain.gain.linearRampToValueAtTime(1, ac.currentTime + seekFade);
		} else gain.gain.setValueAtTime(1, ac.currentTime);
		source.start(0, offsetSeconds);
		sourceRef.current = source;
		playOffsetRef.current = offsetSeconds;
		startTimeRef.current = ac.currentTime;
		source.onended = () => {
			if (sourceRef.current === source) {
				sourceRef.current = null;
				gainRef.current = null;
				playing.value = false;
			}
		};
	};
	const doSeekTransition = () => {
		const dur = bufferDuration.value;
		if (dur <= 0) return;
		const target = Math.max(0, Math.min(position.value, dur));
		const ac = audioContext.value;
		const source = sourceRef.current;
		const gain = gainRef.current;
		if (seekTransitionRef.current) {
			pendingSeekRef.current = target;
			return;
		}
		if (!ac) return;
		if (!source || !gain) {
			startSource(target, false);
			return;
		}
		gain.gain.setValueAtTime(gain.gain.value, ac.currentTime);
		gain.gain.linearRampToValueAtTime(0, ac.currentTime + seekFade);
		const t$12 = seekFade * 1e3 + 5;
		seekTransitionRef.current = setTimeout(() => {
			seekTransitionRef.current = null;
			const startAt = pendingSeekRef.current ?? target;
			pendingSeekRef.current = null;
			source.stop();
			sourceRef.current = null;
			gainRef.current = null;
			startSource(startAt, true);
		}, t$12);
	};
	const throttledSeek = throttle(doSeekTransition, seekThrottleMs);
	const handleSeek = (seconds) => {
		const dur = bufferDuration.value;
		if (dur <= 0) return;
		position.value = Math.max(0, Math.min(seconds, dur));
		if (!playing.value) return;
		throttledSeek();
	};
	const sliderRatio = useComputed(() => {
		const dur = bufferDuration.value;
		if (dur <= 0) return 0;
		return scrubbing.value ? scrubRatio.value : position.value / dur;
	});
	const onScrubStart = () => {
		scrubbing.value = true;
		scrubRatio.value = bufferDuration.value > 0 ? position.value / bufferDuration.value : 0;
	};
	const onScrubInput = (e$59) => {
		scrubRatio.value = parseFloat(e$59.target.value);
		handleSeek(scrubRatio.value * bufferDuration.value);
	};
	const onScrubEnd = () => {
		scrubbing.value = false;
		handleSeek(scrubRatio.value * bufferDuration.value);
	};
	const handlePlayStop = () => {
		const ac = audioContext.value;
		const buf = audioBuffer.value;
		if (!ac || !buf) return;
		if (playing.value) {
			const dur = buf.duration;
			position.value = (playOffsetRef.current + (ac.currentTime - startTimeRef.current)) % dur;
			if (seekTransitionRef.current) {
				clearTimeout(seekTransitionRef.current);
				seekTransitionRef.current = null;
			}
			pendingSeekRef.current = null;
			const source = sourceRef.current;
			const gain = gainRef.current;
			if (!source || !gain) {
				sourceRef.current = null;
				gainRef.current = null;
				playing.value = false;
				return;
			}
			if (stopTransitionRef.current) {
				clearTimeout(stopTransitionRef.current);
				stopTransitionRef.current = null;
			}
			gain.gain.setValueAtTime(gain.gain.value, ac.currentTime);
			gain.gain.linearRampToValueAtTime(0, ac.currentTime + seekFade);
			const t$12 = seekFade * 1e3 + 5;
			stopTransitionRef.current = setTimeout(() => {
				stopTransitionRef.current = null;
				source.stop();
				sourceRef.current = null;
				gainRef.current = null;
				playing.value = false;
			}, t$12);
			return;
		}
		ac.resume();
		playing.value = true;
		startSource(position.value, position.value > 0);
	};
	const handleDownload = () => {
		if (!wavBlob.value) return;
		const sanitize = (s$4) => s$4.replace(/\s+/g, " ").replace(/[/\\:*?"<>|]/g, "");
		const artist = session.value?.artistName ? sanitize(session.value.artistName) : "";
		const title$1 = sanitize((currentProject.value?.name ?? "export").trim() || "export");
		const base = artist ? `${artist} - ${title$1}` : title$1;
		const url = URL.createObjectURL(wavBlob.value);
		const a$36 = document.createElement("a");
		a$36.href = url;
		a$36.download = `${base}.wav`;
		a$36.click();
		URL.revokeObjectURL(url);
	};
	const handleRender = async () => {
		if (!ctx.value || !currentProgramContext.value) return;
		if (playing.value) {
			if (seekTransitionRef.current) {
				clearTimeout(seekTransitionRef.current);
				seekTransitionRef.current = null;
			}
			if (stopTransitionRef.current) {
				clearTimeout(stopTransitionRef.current);
				stopTransitionRef.current = null;
			}
			pendingSeekRef.current = null;
			sourceRef.current?.stop();
			sourceRef.current = null;
			gainRef.current = null;
			playing.value = false;
		}
		startedRendering.value = true;
		await new Promise((resolve) => requestAnimationFrame(resolve));
		const { dsp } = ctx.value;
		const doc = currentProgramContext.value.doc;
		const gen = dsp.core.preview.renderToAudio(doc.code, numberOfBars.value, 4);
		let step;
		try {
			while (!(step = gen.next()).done) {
				if (stopRendering.value) throw new Error("Rendering stopped");
				progress.value = step.value;
				await new Promise((resolve) => requestAnimationFrame(resolve));
			}
			const left = step.value.left.slice();
			const right = step.value.right.slice();
			applyFadeOut(left, right);
			floats.value = {
				left,
				right
			};
		} catch (error$1) {
			console.error(error$1);
		} finally {
			position.value = 0;
			progress.value = 0;
			startedRendering.value = false;
			stopRendering.value = false;
		}
	};
	const handleStopRendering = () => {
		stopRendering.value = true;
	};
	const hasAudio = !!floats.value && !startedRendering.value;
	return /* @__PURE__ */ u("div", {
		class: "flex flex-col h-full w-52 py-2.5 text-neutral-400 text-sm select-none",
		children: [
			/* @__PURE__ */ u("div", {
				class: "relative flex flex-col",
				children: [
					/* @__PURE__ */ u("div", {
						class: "py-1 px-2 w-full text-sm flex flex-row items-center justify-between gap-2",
						children: [
							/* @__PURE__ */ u("div", {
								class: "whitespace-nowrap mr-1.5",
								children: "Bars"
							}),
							/* @__PURE__ */ u("input", {
								type: "range",
								min: "0",
								max: "9",
								value: barsInputValue,
								onChange: (e$59) => barsInputValue.value = Number(e$59.target.value),
								class: "w-full h-1 my-2",
								style: { accentColor: primaryColor.value }
							}),
							/* @__PURE__ */ u("div", {
								class: "w-[40px] text-right",
								children: numberOfBars
							})
						]
					}),
					/* @__PURE__ */ u("div", {
						class: "py-1 px-2 w-full flex flex-row items-center justify-between gap-2",
						children: [/* @__PURE__ */ u("div", { children: "Duration:" }), /* @__PURE__ */ u("div", { children: durationInMinutes })]
					}),
					startedRendering.value && /* @__PURE__ */ u("div", { class: `absolute top-0 left-0 w-full h-full flex items-center justify-center cursor-wait bg-[${backgroundColor.value}] bg-opacity-50` })
				]
			}),
			/* @__PURE__ */ u(SidebarButton, {
				onClick: handleRender,
				disabled: startedRendering.value,
				children: [startedRendering.value ? /* @__PURE__ */ u(c, {
					size: 16,
					class: "animate-spin"
				}) : /* @__PURE__ */ u(e$6, {
					size: 16,
					class: "group-hover:text-white"
				}), startedRendering.value ? /* @__PURE__ */ u("span", { children: "Rendering..." }) : /* @__PURE__ */ u("span", { children: "Render" })]
			}),
			!hasAudio && /* @__PURE__ */ u("div", {
				class: "mx-2 my-3 mb-[13.5px]",
				children: /* @__PURE__ */ u("div", {
					class: `h-0.5 bg-[${primaryColor.value}]`,
					style: { width: `${progress.value * 100}%` }
				})
			}),
			!hasAudio && startedRendering.value && /* @__PURE__ */ u(SidebarButton, {
				onClick: handleStopRendering,
				children: [/* @__PURE__ */ u(e$13, { size: 16 }), /* @__PURE__ */ u("span", { children: "Stop" })]
			}),
			hasAudio && /* @__PURE__ */ u(k, { children: [/* @__PURE__ */ u("div", {
				class: "px-2 my-1 mb-1 flex flex-row gap-0.5 items-center",
				children: [/* @__PURE__ */ u("button", {
					onClick: handlePlayStop,
					class: "pr-1",
					children: playing.value ? /* @__PURE__ */ u(PauseGradientIcon, { size: 16 }) : /* @__PURE__ */ u(PlayGradientIcon, { size: 16 })
				}), /* @__PURE__ */ u("input", {
					type: "range",
					min: 0,
					max: 1,
					step: .001,
					value: sliderRatio.value,
					onMouseDown: onScrubStart,
					onTouchStart: onScrubStart,
					onInput: onScrubInput,
					onMouseUp: onScrubEnd,
					onMouseLeave: (e$59) => e$59.buttons === 1 ? onScrubEnd() : null,
					onTouchEnd: onScrubEnd,
					class: "w-full h-[3.5px] my-2",
					style: { accentColor: primaryColor.value }
				})]
			}), /* @__PURE__ */ u(SidebarButton, {
				onClick: handleDownload,
				disabled: !wavBlob.value,
				children: [/* @__PURE__ */ u(e$12, {
					size: 16,
					class: "group-hover:text-white"
				}), /* @__PURE__ */ u("span", { children: "Download" })]
			})] })
		]
	});
};
var ProjectEditingItem = ({ project, onSave, onCancel }) => {
	const inputRef = A(null);
	const didSave = useSignal(null);
	const localIsPublic = useSignal(project.isPublic);
	const handleAccept = () => {
		didSave.value = true;
		const name = (inputRef.current?.value ?? "").trim() || getNextUntitledName();
		const isPublic = localIsPublic.value;
		onSave({
			name,
			isPublic
		});
	};
	const handleCancel = () => {
		if (didSave.value === null) {
			didSave.value = false;
			onCancel();
		}
	};
	const handleKeyDown = (e$59) => {
		if (e$59.key === "Enter") handleAccept();
		if (e$59.key === "Escape") handleCancel();
	};
	const handleBlur = () => {
		handleCancel();
	};
	y(() => {
		if (inputRef.current) inputRef.current.focus();
	}, [inputRef]);
	const isCurrentProject = currentProject.value?.id === project.id;
	return /* @__PURE__ */ u("li", {
		class: cn("flex flex-row items-center justify-between gap-0.5 pr-1 h-7", { "bg-white/5 text-white": isCurrentProject }),
		children: [
			/* @__PURE__ */ u("input", {
				ref: inputRef,
				class: "w-full bg-transparent py-0 ml-2 text-white outline-none",
				type: "text",
				value: project.name,
				onKeyDown: handleKeyDown,
				onBlur: handleBlur
			}),
			/* @__PURE__ */ u("button", {
				title: "Delete project",
				class: "p-1 text-neutral-600 hover:text-white",
				onMouseDown: (e$59) => {
					e$59.stopPropagation();
					if (confirm("Are you sure you want to delete this project?")) deleteProject(project);
				},
				children: /* @__PURE__ */ u(r$1, { size: 16 })
			}),
			/* @__PURE__ */ u("button", {
				title: "Accept changes",
				class: "p-1 text-neutral-600 hover:text-white",
				onMouseDown: handleAccept,
				children: /* @__PURE__ */ u(o$9, { size: 16 })
			}),
			/* @__PURE__ */ u("button", {
				title: localIsPublic.value ? "Make project private" : "Make project public",
				class: "p-1 text-neutral-600 hover:text-white",
				onMouseDown: (e$59) => {
					e$59.preventDefault();
					e$59.stopPropagation();
					localIsPublic.value = !localIsPublic.value;
				},
				children: localIsPublic.value ? /* @__PURE__ */ u(o$10, { size: 16 }) : /* @__PURE__ */ u(o$11, { size: 16 })
			})
		]
	});
};
var ProjectItem = ({ project }) => {
	const isEditing = useSignal(false);
	const isPlayingProject = playingProject.value?.id === project.id;
	const isCurrentProject = currentProject.value?.id === project.id;
	if (isEditing.value) return /* @__PURE__ */ u(ProjectEditingItem, {
		project,
		onSave: ({ name, isPublic }) => {
			if (project.isSaved) saveProject(project, {
				name,
				isPublic
			}).then(() => {
				isEditing.value = false;
			});
			else n(() => {
				project.name = name;
				project.isPublic = isPublic;
				isEditing.value = false;
			});
		},
		onCancel: () => {
			isEditing.value = false;
		}
	});
	return /* @__PURE__ */ u("li", {
		class: cn("group flex flex-row items-center justify-between gap-2 pl-0.5 py-0.5 cursor-pointer hover:bg-white/5", { "bg-white/5 text-white": isCurrentProject }),
		onMouseDown: (e$59) => {
			currentProjectId.value = project.id;
			if (e$59.ctrlKey || e$59.metaKey || e$59.button === MouseButton.Right) transport.restart();
		},
		children: [
			/* @__PURE__ */ u("button", {
				class: "group relative text-neutral-700 p-1 pr-0.5",
				onMouseDown: (e$59) => {
					if (playingProject.value?.id === project.id) if (e$59.ctrlKey || e$59.metaKey || e$59.button === MouseButton.Right) transport.restart();
					else transport.pause();
					else {
						currentProjectId.value = project.id;
						if (e$59.ctrlKey || e$59.metaKey || e$59.button === MouseButton.Right) transport.restart();
						else transport.start();
					}
				},
				children: isPlayingProject && isPlaying.value ? /* @__PURE__ */ u(k, { children: [/* @__PURE__ */ u("span", {
					class: "group-hover:opacity-0",
					children: /* @__PURE__ */ u(PlayGradientIcon, { size: 16 })
				}), /* @__PURE__ */ u("span", {
					class: "opacity-0 absolute top-1 left-1 group-hover:opacity-100",
					children: /* @__PURE__ */ u(PauseGradientIcon, { size: 16 })
				})] }) : /* @__PURE__ */ u(k, { children: [/* @__PURE__ */ u("span", {
					class: "group-hover:opacity-0",
					children: /* @__PURE__ */ u(a$2, {
						weight: "fill",
						size: 16
					})
				}), /* @__PURE__ */ u("span", {
					class: "opacity-0 absolute top-1 left-1 group-hover:opacity-100",
					children: /* @__PURE__ */ u(PlayGradientIcon, { size: 16 })
				})] })
			}),
			/* @__PURE__ */ u("div", {
				class: "flex flex-row items-start relative min-w-0 flex-1",
				children: /* @__PURE__ */ u("span", {
					className: cn("min-w-0 whitespace-nowrap overflow-hidden text-ellipsis", { "": !project.isDirty }),
					children: project.name
				})
			}),
			/* @__PURE__ */ u("div", {
				class: "flex flex-row items-center gap-0.5 pr-1 shrink-0",
				children: [
					project.isDirty && /* @__PURE__ */ u("button", {
						title: "Save project",
						class: "p-1 text-neutral-600 hover:text-white opacity-0 absolute group-hover:opacity-100 group-hover:static",
						onMouseDown: (e$59) => {
							e$59.stopPropagation();
							saveProject(project);
						},
						children: /* @__PURE__ */ u(a$1, { size: 16 })
					}),
					/* @__PURE__ */ u("button", {
						class: "p-1 text-neutral-600 hover:text-white opacity-0 absolute group-hover:opacity-100 group-hover:static",
						onMouseDown: (e$59) => {
							e$59.stopPropagation();
							isEditing.value = true;
						},
						children: /* @__PURE__ */ u(o$12, { size: 16 })
					}),
					!project.isPublic && /* @__PURE__ */ u("button", {
						class: "p-1 text-neutral-600 pointer-events-none group-hover:opacity-0 group-hover:absolute",
						onMouseDown: (e$59) => {
							e$59.stopPropagation();
							project.isPublic = !project.isPublic;
						},
						children: /* @__PURE__ */ u(o$11, { size: 16 })
					}),
					project.isDirty && /* @__PURE__ */ u("div", {
						class: "relative h-6",
						children: [/* @__PURE__ */ u("button", {
							title: "Discard changes",
							class: "p-1 text-neutral-600 hover:text-white opacity-0 group-hover:opacity-100 shrink-0",
							onMouseDown: (e$59) => {
								e$59.stopPropagation();
								if (confirm("Are you sure you want to discard changes to this project?")) discardChanges(project);
							},
							children: /* @__PURE__ */ u(e$11, {
								weight: "bold",
								size: 16
							})
						}), /* @__PURE__ */ u("div", { class: "absolute pointer-events-none top-[9px] left-[9px] w-1.5 h-1.5 rounded-full bg-neutral-600 group-hover:opacity-0" })]
					})
				]
			})
		]
	});
};
const Projects = () => {
	return /* @__PURE__ */ u(SidebarMain, {
		class: "h-[calc(100dvh-50px)] overflow-x-hidden",
		children: [
			/* @__PURE__ */ u("div", {
				class: "relative flex flex-col justify-start",
				children: [
					/* @__PURE__ */ u(SidebarButton, {
						onClick: createNewProject,
						children: [/* @__PURE__ */ u(e$10, {
							size: 16,
							class: "group-hover:text-white"
						}), "New"]
					}),
					/* @__PURE__ */ u("ul", {
						class: "",
						children: projects.value.map((project) => /* @__PURE__ */ u(ProjectItem, { project }, project.id))
					}),
					projectsLoading.value && /* @__PURE__ */ u("div", {
						class: `cursor-wait absolute top-0 left-0 w-full h-full flex items-center justify-center bg-opacity-70 bg-[${backgroundColor.value}]`,
						children: /* @__PURE__ */ u(SpinnerSmall, {})
					})
				]
			}),
			/* @__PURE__ */ u("div", { class: "flex-1" }),
			!session.value && /* @__PURE__ */ u("div", {
				class: "mt-4",
				children: /* @__PURE__ */ u(AuthForm, { placement: "bottom" })
			})
		]
	});
};
function memoizeByRef(fn$1, map = /* @__PURE__ */ new Map()) {
	function wrapped(arg, ...args) {
		if (map.has(arg)) return map.get(arg);
		let res;
		map.set(arg, res = fn$1.call(this, arg, ...args));
		return res;
	}
	return wrapped;
}
var { getPrototypeOf, getOwnPropertyDescriptor, getOwnPropertyDescriptors } = Object;
function entries(obj) {
	return Object.entries(obj);
}
var emptyObject = { __proto__: null };
function getAllPropertyDescriptors(object) {
	if (object === Object.prototype) return emptyObject;
	else return Object.assign({ __proto__: null }, getAllPropertyDescriptorsMemoized(getPrototypeOf(object)), getOwnPropertyDescriptors(object));
}
const getAllPropertyDescriptorsMemoized = memoizeByRef(getAllPropertyDescriptors);
function Switch({ checked, onChange, disabled = false, className = "" }) {
	const [internal, setInternal] = d(checked ?? false);
	const buttonRef = A(null);
	const [didMount, setDidMount] = d(false);
	y(() => {
		if (checked !== void 0) setInternal(checked);
	}, [checked]);
	const isOn = checked === void 0 ? internal : checked;
	function toggle(e$59) {
		e$59.stopPropagation();
		if (disabled) return;
		const next = !isOn;
		if (checked === void 0) setInternal(next);
		onChange?.(next);
	}
	y(() => {
		if (buttonRef.current && !didMount) setTimeout(() => {
			setDidMount(true);
		}, 500);
	}, [buttonRef]);
	return /* @__PURE__ */ u("button", {
		ref: buttonRef,
		type: "button",
		role: "switch",
		"aria-checked": isOn,
		onPointerDown: toggle,
		disabled,
		className: cn("inline-flex items-center w-6 h-4 p-1 rounded-sm border-2", className, {
			"transition-colors duration-200": didMount,
			"border-orange-600": isOn,
			"border-black": !isOn,
			"opacity-50 cursor-not-allowed": disabled
		}),
		style: {
			borderColor: isOn ? primaryColor.value : "transparent",
			backgroundImage: `linear-gradient(to bottom, ${theme.value.black} , #ffffff22)`
		},
		children: /* @__PURE__ */ u("span", {
			"aria-hidden": true,
			className: `block bg-neutral-500 group-hover:bg-white w-0.5 h-1.5 transform ${didMount ? "transition-transform duration-200" : ""} ${isOn ? "translate-x-2.5" : "translate-x-0"}`
		})
	});
}
var Switch_default = Switch;
var SettingsMap = {
	debug: {
		name: "Debug",
		shortcut: ""
	},
	showVisuals: {
		name: "Show Visuals",
		shortcut: "alt+i"
	},
	showKnobs: {
		name: "Show Knobs",
		shortcut: "alt+k"
	},
	showDocs: {
		name: "Show Docs",
		shortcut: "alt+o"
	},
	wordWrap: {
		name: "Word Wrap",
		shortcut: "alt+p"
	}
};
var SettingsButton = ({ onClick, children }) => /* @__PURE__ */ u(SidebarButton, {
	onClick,
	class: "justify-between",
	children
});
const Settings = () => {
	return /* @__PURE__ */ u(SidebarMain, { children: [
		/* @__PURE__ */ u("div", {
			class: "px-2 flex flex-row items-center justify-between",
			children: [/* @__PURE__ */ u("span", { children: "Audio Latency" }), /* @__PURE__ */ u("div", {
				class: "flex flex-row items-center gap-1",
				children: [
					/* @__PURE__ */ u("button", {
						class: "hover:bg-white/5 py-1 px-1",
						onMouseDown: () => {
							const dec = () => settings.audioLatency = Math.max(.005, settings.audioLatency - .005);
							let iv = null;
							let timeout = setTimeout(() => {
								iv = setInterval(dec, 5);
							}, 300);
							dec();
							window.addEventListener("mouseup", () => {
								if (iv) clearInterval(iv);
								if (timeout) clearTimeout(timeout);
							}, { once: true });
						},
						children: /* @__PURE__ */ u(t, {})
					}),
					/* @__PURE__ */ u("span", {
						class: "font-[Liga_Space_Mono] text-xs",
						children: settings.audioLatency.toFixed(3)
					}),
					/* @__PURE__ */ u("button", {
						class: "hover:bg-white/5 py-1 px-1",
						onMouseDown: () => {
							const inc = () => settings.audioLatency = Math.min(1, settings.audioLatency + .005);
							let iv = null;
							let timeout = setTimeout(() => {
								iv = setInterval(inc, 5);
							}, 300);
							inc();
							window.addEventListener("mouseup", () => {
								if (iv) clearInterval(iv);
								if (timeout) clearTimeout(timeout);
							}, { once: true });
						},
						children: /* @__PURE__ */ u(e$9, {})
					})
				]
			})]
		}),
		/* @__PURE__ */ u("div", {
			class: "flex flex-col",
			children: entries(SettingsMap).filter(([key]) => session.value?.isAdmin || key !== "debug").map(([key, value]) => /* @__PURE__ */ u("div", {
				class: "px-2 py-1 group hover:bg-white/5 flex flex-row items-center justify-between gap-2 cursor-pointer",
				onPointerDown: () => settings[key] = !settings[key],
				children: [/* @__PURE__ */ u("span", { children: value.name }), /* @__PURE__ */ u("div", {
					class: "flex flex-row items-center gap-2",
					children: [/* @__PURE__ */ u("div", {
						class: "text-neutral-500 text-xs",
						children: /* @__PURE__ */ u("kbd", {
							class: "font-[Outfit]",
							children: value.shortcut
						})
					}), /* @__PURE__ */ u(Switch_default, {
						checked: settings[key],
						onChange: (v$4) => settings[key] = v$4
					})]
				})]
			}, key))
		}),
		/* @__PURE__ */ u(SettingsButton, {
			onClick: toggleAnalyserType,
			children: [/* @__PURE__ */ u("span", {
				class: "whitespace-nowrap",
				children: "Analyser"
			}), /* @__PURE__ */ u("div", {
				class: "flex flex-row items-center gap-2",
				children: [/* @__PURE__ */ u("div", {
					class: "text-neutral-500 text-xs",
					children: /* @__PURE__ */ u("kbd", {
						class: "font-[Outfit]",
						children: "alt+l"
					})
				}), /* @__PURE__ */ u("span", {
					class: "group-hover:text-white",
					children: settings.analyserType
				})]
			})]
		}),
		/* @__PURE__ */ u(SettingsButton, {
			onClick: () => sidebarTab.value = "themes",
			children: [/* @__PURE__ */ u("span", { children: "Theme" }), /* @__PURE__ */ u("span", {
				class: "group-hover:text-white",
				children: themeName
			})]
		})
	] });
};
var SocialButton = ({ platform, url, label }) => {
	return /* @__PURE__ */ u(SidebarButton, {
		onClick: () => window.open(url, "_blank"),
		children: [/* @__PURE__ */ u(SocialIcon, {
			as: "span",
			network: platform,
			style: {
				width: 20,
				height: 20
			},
			className: "grayscale hover:grayscale-0 group-hover:grayscale-0"
		}), /* @__PURE__ */ u("span", { children: label })]
	});
};
const ShareProject = () => {
	const trackUrl = location.origin + "/p/" + currentProject.value?.id;
	const shareText = `Listen to ${`${session.value?.artistName} - ${currentProject.value?.name}`} by ${session.value?.artistName || "Unknown"} on loopmaster`;
	const getSocialShareUrl = (platform) => {
		switch (platform) {
			case "twitter": return `https://twitter.com/intent/tweet?text=${encodeURIComponent(shareText)}&url=${encodeURIComponent(trackUrl)}`;
			case "facebook": return `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(trackUrl)}`;
			case "reddit": return `https://reddit.com/submit?url=${encodeURIComponent(trackUrl)}&title=${encodeURIComponent(shareText)}`;
			case "whatsapp": return `https://api.whatsapp.com/send?text=${encodeURIComponent(shareText + " " + trackUrl)}`;
			case "telegram": return `https://t.me/share/url?url=${encodeURIComponent(trackUrl)}&text=${encodeURIComponent(shareText)}`;
			default: return "";
		}
	};
	return currentProject.value?.isSaved && currentProject.value?.isPublic ? /* @__PURE__ */ u("div", {
		class: "flex flex-col h-full w-52 py-2.5 gap-0 text-neutral-400 text-sm select-none",
		children: [
			/* @__PURE__ */ u(SocialButton, {
				label: "Share on X",
				platform: "x",
				url: getSocialShareUrl("twitter")
			}),
			/* @__PURE__ */ u(SocialButton, {
				label: "Share on Mastodon",
				platform: "mastodon",
				url: getSocialShareUrl("mastodon")
			}),
			/* @__PURE__ */ u(SocialButton, {
				label: "Share on Facebook",
				platform: "facebook",
				url: getSocialShareUrl("facebook")
			}),
			/* @__PURE__ */ u(SocialButton, {
				label: "Share on Reddit",
				platform: "reddit",
				url: getSocialShareUrl("reddit")
			}),
			/* @__PURE__ */ u(SocialButton, {
				label: "Share on WhatsApp",
				platform: "whatsapp",
				url: getSocialShareUrl("whatsapp")
			}),
			/* @__PURE__ */ u(SocialButton, {
				label: "Share on Telegram",
				platform: "telegram",
				url: getSocialShareUrl("telegram")
			})
		]
	}) : /* @__PURE__ */ u("div", {
		class: "flex flex-col h-full w-52 py-2.5 px-2 gap-0 text-neutral-400 text-sm select-none",
		children: "Save the project and/or make it public before sharing."
	});
};
var ABC = ({ hidden = false }) => /* @__PURE__ */ u("div", {
	class: cn("text-xs pl-2 flex flex-row flex-nowrap text-neutral-500 opacity-0", { "opacity-100": !hidden }),
	children: [
		/* @__PURE__ */ u("button", {
			class: cn("w-4 h-4 border border-neutral-500", { "bg-white/5 text-white": themeVariation.value === "A" }),
			onClick: (e$59) => {
				e$59.stopPropagation();
				themeVariation.value = "A";
			},
			children: "A"
		}),
		/* @__PURE__ */ u("button", {
			class: cn("w-4 h-4 border border-neutral-500", { "bg-white/5 text-white": themeVariation.value === "B" }),
			onClick: (e$59) => {
				e$59.stopPropagation();
				themeVariation.value = "B";
			},
			children: "B"
		}),
		/* @__PURE__ */ u("button", {
			class: cn("w-4 h-4 border border-neutral-500", { "bg-white/5 text-white": themeVariation.value === "C" }),
			onClick: (e$59) => {
				e$59.stopPropagation();
				themeVariation.value = "C";
			},
			children: "C"
		})
	]
});
const Themes = () => {
	const randomHistory = useSignal([{
		name: themeName.value,
		variation: themeVariation.value
	}]);
	const randomHistoryIndex = useSignal(0);
	return /* @__PURE__ */ u("div", {
		class: "flex flex-col w-52 text-neutral-400 text-sm select-none overflow-x-hidden",
		children: [
			/* @__PURE__ */ u("div", {
				class: "px-2 py-3.5 flex flex-col",
				children: /* @__PURE__ */ u("div", {
					class: "flex flex-row items-center justify-between",
					children: [/* @__PURE__ */ u("span", { children: themeName.value }), /* @__PURE__ */ u(ABC, {})]
				})
			}),
			/* @__PURE__ */ u("div", {
				class: "flex flex-row ml-2 items-center justify-between border-t border-b border-white/5",
				children: ["Random", /* @__PURE__ */ u("div", {
					class: "flex flex-row items-center justify-between",
					children: [/* @__PURE__ */ u(SidebarButton, {
						class: `h-8 ${randomHistoryIndex.value === 0 ? "opacity-50 cursor-default" : ""}`,
						onClick: () => {
							if (randomHistoryIndex.value === 0) return;
							else {
								randomHistoryIndex.value--;
								const { name, variation } = randomHistory.value[randomHistoryIndex.value];
								themeName.value = name;
								themeVariation.value = variation;
							}
						},
						children: /* @__PURE__ */ u(t, { size: 16 })
					}), /* @__PURE__ */ u(SidebarButton, {
						class: "h-8",
						onClick: () => {
							if (randomHistoryIndex.value === randomHistory.value.length - 1) {
								const theme$1 = _all_default[Math.floor(Math.random() * _all_default.length)];
								themeName.value = theme$1.name;
								themeVariation.value = [
									"A",
									"B",
									"C"
								][Math.floor(Math.random() * 3)];
								randomHistory.value.push({
									name: theme$1.name,
									variation: themeVariation.value
								});
								randomHistoryIndex.value++;
							} else {
								const { name, variation } = randomHistory.value[++randomHistoryIndex.value];
								themeName.value = name;
								themeVariation.value = variation;
							}
						},
						children: /* @__PURE__ */ u(e$9, { size: 16 })
					})]
				})]
			}),
			/* @__PURE__ */ u("ul", {
				class: "py-2.5",
				children: _all_default.map((theme$1) => /* @__PURE__ */ u("li", {
					class: cn(["px-2 py-1 flex items-center justify-between cursor-pointer hover:bg-white/5", { "bg-white/5 text-white": themeName.value === theme$1.name }]),
					onClick: () => {
						themeName.value = theme$1.name;
					},
					children: [/* @__PURE__ */ u("span", {
						class: "text-sm break-all",
						children: theme$1.name
					}), /* @__PURE__ */ u(ABC, { hidden: themeName.value !== theme$1.name })]
				}, theme$1.name))
			})
		]
	});
};
var import_jszip_min = /* @__PURE__ */ __toESM((/* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function(e$59) {
		if ("object" == typeof exports && "undefined" != typeof module) module.exports = e$59();
		else if ("function" == typeof define && define.amd) define([], e$59);
		else ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).JSZip = e$59();
	})(function() {
		return function s$4(a$36, o$34, h$5) {
			function u$5(r$11, e$60) {
				if (!o$34[r$11]) {
					if (!a$36[r$11]) {
						var t$12 = "function" == typeof __require && __require;
						if (!e$60 && t$12) return t$12(r$11, !0);
						if (l$10) return l$10(r$11, !0);
						var n$4 = /* @__PURE__ */ new Error("Cannot find module '" + r$11 + "'");
						throw n$4.code = "MODULE_NOT_FOUND", n$4;
					}
					var i$6 = o$34[r$11] = { exports: {} };
					a$36[r$11][0].call(i$6.exports, function(e$61) {
						var t$13 = a$36[r$11][1][e$61];
						return u$5(t$13 || e$61);
					}, i$6, i$6.exports, s$4, a$36, o$34, h$5);
				}
				return o$34[r$11].exports;
			}
			for (var l$10 = "function" == typeof __require && __require, e$59 = 0; e$59 < h$5.length; e$59++) u$5(h$5[e$59]);
			return u$5;
		}({
			1: [function(e$59, t$12, r$11) {
				"use strict";
				var d$5 = e$59("./utils"), c$7 = e$59("./support"), p$6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
				r$11.encode = function(e$60) {
					for (var t$13, r$12, n$4, i$6, s$4, a$36, o$34, h$5 = [], u$5 = 0, l$10 = e$60.length, f$5 = l$10, c$8 = "string" !== d$5.getTypeOf(e$60); u$5 < e$60.length;) f$5 = l$10 - u$5, n$4 = c$8 ? (t$13 = e$60[u$5++], r$12 = u$5 < l$10 ? e$60[u$5++] : 0, u$5 < l$10 ? e$60[u$5++] : 0) : (t$13 = e$60.charCodeAt(u$5++), r$12 = u$5 < l$10 ? e$60.charCodeAt(u$5++) : 0, u$5 < l$10 ? e$60.charCodeAt(u$5++) : 0), i$6 = t$13 >> 2, s$4 = (3 & t$13) << 4 | r$12 >> 4, a$36 = 1 < f$5 ? (15 & r$12) << 2 | n$4 >> 6 : 64, o$34 = 2 < f$5 ? 63 & n$4 : 64, h$5.push(p$6.charAt(i$6) + p$6.charAt(s$4) + p$6.charAt(a$36) + p$6.charAt(o$34));
					return h$5.join("");
				}, r$11.decode = function(e$60) {
					var t$13, r$12, n$4, i$6, s$4, a$36, o$34 = 0, h$5 = 0, u$5 = "data:";
					if (e$60.substr(0, u$5.length) === u$5) throw new Error("Invalid base64 input, it looks like a data url.");
					var l$10, f$5 = 3 * (e$60 = e$60.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
					if (e$60.charAt(e$60.length - 1) === p$6.charAt(64) && f$5--, e$60.charAt(e$60.length - 2) === p$6.charAt(64) && f$5--, f$5 % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
					for (l$10 = c$7.uint8array ? new Uint8Array(0 | f$5) : new Array(0 | f$5); o$34 < e$60.length;) t$13 = p$6.indexOf(e$60.charAt(o$34++)) << 2 | (i$6 = p$6.indexOf(e$60.charAt(o$34++))) >> 4, r$12 = (15 & i$6) << 4 | (s$4 = p$6.indexOf(e$60.charAt(o$34++))) >> 2, n$4 = (3 & s$4) << 6 | (a$36 = p$6.indexOf(e$60.charAt(o$34++))), l$10[h$5++] = t$13, 64 !== s$4 && (l$10[h$5++] = r$12), 64 !== a$36 && (l$10[h$5++] = n$4);
					return l$10;
				};
			}, {
				"./support": 30,
				"./utils": 32
			}],
			2: [function(e$59, t$12, r$11) {
				"use strict";
				var n$4 = e$59("./external"), i$6 = e$59("./stream/DataWorker"), s$4 = e$59("./stream/Crc32Probe"), a$36 = e$59("./stream/DataLengthProbe");
				function o$34(e$60, t$13, r$12, n$5, i$7) {
					this.compressedSize = e$60, this.uncompressedSize = t$13, this.crc32 = r$12, this.compression = n$5, this.compressedContent = i$7;
				}
				o$34.prototype = {
					getContentWorker: function() {
						var e$60 = new i$6(n$4.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a$36("data_length")), t$13 = this;
						return e$60.on("end", function() {
							if (this.streamInfo.data_length !== t$13.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
						}), e$60;
					},
					getCompressedWorker: function() {
						return new i$6(n$4.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
					}
				}, o$34.createWorkerFrom = function(e$60, t$13, r$12) {
					return e$60.pipe(new s$4()).pipe(new a$36("uncompressedSize")).pipe(t$13.compressWorker(r$12)).pipe(new a$36("compressedSize")).withStreamInfo("compression", t$13);
				}, t$12.exports = o$34;
			}, {
				"./external": 6,
				"./stream/Crc32Probe": 25,
				"./stream/DataLengthProbe": 26,
				"./stream/DataWorker": 27
			}],
			3: [function(e$59, t$12, r$11) {
				"use strict";
				var n$4 = e$59("./stream/GenericWorker");
				r$11.STORE = {
					magic: "\0\0",
					compressWorker: function() {
						return new n$4("STORE compression");
					},
					uncompressWorker: function() {
						return new n$4("STORE decompression");
					}
				}, r$11.DEFLATE = e$59("./flate");
			}, {
				"./flate": 7,
				"./stream/GenericWorker": 28
			}],
			4: [function(e$59, t$12, r$11) {
				"use strict";
				var n$4 = e$59("./utils");
				var o$34 = function() {
					for (var e$60, t$13 = [], r$12 = 0; r$12 < 256; r$12++) {
						e$60 = r$12;
						for (var n$5 = 0; n$5 < 8; n$5++) e$60 = 1 & e$60 ? 3988292384 ^ e$60 >>> 1 : e$60 >>> 1;
						t$13[r$12] = e$60;
					}
					return t$13;
				}();
				t$12.exports = function(e$60, t$13) {
					return void 0 !== e$60 && e$60.length ? "string" !== n$4.getTypeOf(e$60) ? function(e$61, t$14, r$12, n$5) {
						var i$6 = o$34, s$4 = n$5 + r$12;
						e$61 ^= -1;
						for (var a$36 = n$5; a$36 < s$4; a$36++) e$61 = e$61 >>> 8 ^ i$6[255 & (e$61 ^ t$14[a$36])];
						return -1 ^ e$61;
					}(0 | t$13, e$60, e$60.length, 0) : function(e$61, t$14, r$12, n$5) {
						var i$6 = o$34, s$4 = n$5 + r$12;
						e$61 ^= -1;
						for (var a$36 = n$5; a$36 < s$4; a$36++) e$61 = e$61 >>> 8 ^ i$6[255 & (e$61 ^ t$14.charCodeAt(a$36))];
						return -1 ^ e$61;
					}(0 | t$13, e$60, e$60.length, 0) : 0;
				};
			}, { "./utils": 32 }],
			5: [function(e$59, t$12, r$11) {
				"use strict";
				r$11.base64 = !1, r$11.binary = !1, r$11.dir = !1, r$11.createFolders = !0, r$11.date = null, r$11.compression = null, r$11.compressionOptions = null, r$11.comment = null, r$11.unixPermissions = null, r$11.dosPermissions = null;
			}, {}],
			6: [function(e$59, t$12, r$11) {
				"use strict";
				var n$4 = null;
				n$4 = "undefined" != typeof Promise ? Promise : e$59("lie"), t$12.exports = { Promise: n$4 };
			}, { lie: 37 }],
			7: [function(e$59, t$12, r$11) {
				"use strict";
				var n$4 = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i$6 = e$59("pako"), s$4 = e$59("./utils"), a$36 = e$59("./stream/GenericWorker"), o$34 = n$4 ? "uint8array" : "array";
				function h$5(e$60, t$13) {
					a$36.call(this, "FlateWorker/" + e$60), this._pako = null, this._pakoAction = e$60, this._pakoOptions = t$13, this.meta = {};
				}
				r$11.magic = "\b\0", s$4.inherits(h$5, a$36), h$5.prototype.processChunk = function(e$60) {
					this.meta = e$60.meta, null === this._pako && this._createPako(), this._pako.push(s$4.transformTo(o$34, e$60.data), !1);
				}, h$5.prototype.flush = function() {
					a$36.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], !0);
				}, h$5.prototype.cleanUp = function() {
					a$36.prototype.cleanUp.call(this), this._pako = null;
				}, h$5.prototype._createPako = function() {
					this._pako = new i$6[this._pakoAction]({
						raw: !0,
						level: this._pakoOptions.level || -1
					});
					var t$13 = this;
					this._pako.onData = function(e$60) {
						t$13.push({
							data: e$60,
							meta: t$13.meta
						});
					};
				}, r$11.compressWorker = function(e$60) {
					return new h$5("Deflate", e$60);
				}, r$11.uncompressWorker = function() {
					return new h$5("Inflate", {});
				};
			}, {
				"./stream/GenericWorker": 28,
				"./utils": 32,
				pako: 38
			}],
			8: [function(e$59, t$12, r$11) {
				"use strict";
				function A$3(e$60, t$13) {
					var r$12, n$5 = "";
					for (r$12 = 0; r$12 < t$13; r$12++) n$5 += String.fromCharCode(255 & e$60), e$60 >>>= 8;
					return n$5;
				}
				function n$4(e$60, t$13, r$12, n$5, i$7, s$5) {
					var a$36, o$34, h$5 = e$60.file, u$5 = e$60.compression, l$10 = s$5 !== O$3.utf8encode, f$5 = I$2.transformTo("string", s$5(h$5.name)), c$7 = I$2.transformTo("string", O$3.utf8encode(h$5.name)), d$5 = h$5.comment, p$6 = I$2.transformTo("string", s$5(d$5)), m$5 = I$2.transformTo("string", O$3.utf8encode(d$5)), _$5 = c$7.length !== h$5.name.length, g$5 = m$5.length !== d$5.length, b$4 = "", v$4 = "", y$5 = "", w$5 = h$5.dir, k$4 = h$5.date, x$4 = {
						crc32: 0,
						compressedSize: 0,
						uncompressedSize: 0
					};
					t$13 && !r$12 || (x$4.crc32 = e$60.crc32, x$4.compressedSize = e$60.compressedSize, x$4.uncompressedSize = e$60.uncompressedSize);
					var S$3 = 0;
					t$13 && (S$3 |= 8), l$10 || !_$5 && !g$5 || (S$3 |= 2048);
					var z$3 = 0, C$4 = 0;
					w$5 && (z$3 |= 16), "UNIX" === i$7 ? (C$4 = 798, z$3 |= function(e$61, t$14) {
						var r$13 = e$61;
						return e$61 || (r$13 = t$14 ? 16893 : 33204), (65535 & r$13) << 16;
					}(h$5.unixPermissions, w$5)) : (C$4 = 20, z$3 |= function(e$61) {
						return 63 & (e$61 || 0);
					}(h$5.dosPermissions)), a$36 = k$4.getUTCHours(), a$36 <<= 6, a$36 |= k$4.getUTCMinutes(), a$36 <<= 5, a$36 |= k$4.getUTCSeconds() / 2, o$34 = k$4.getUTCFullYear() - 1980, o$34 <<= 4, o$34 |= k$4.getUTCMonth() + 1, o$34 <<= 5, o$34 |= k$4.getUTCDate(), _$5 && (v$4 = A$3(1, 1) + A$3(B$4(f$5), 4) + c$7, b$4 += "up" + A$3(v$4.length, 2) + v$4), g$5 && (y$5 = A$3(1, 1) + A$3(B$4(p$6), 4) + m$5, b$4 += "uc" + A$3(y$5.length, 2) + y$5);
					var E$4 = "";
					return E$4 += "\n\0", E$4 += A$3(S$3, 2), E$4 += u$5.magic, E$4 += A$3(a$36, 2), E$4 += A$3(o$34, 2), E$4 += A$3(x$4.crc32, 4), E$4 += A$3(x$4.compressedSize, 4), E$4 += A$3(x$4.uncompressedSize, 4), E$4 += A$3(f$5.length, 2), E$4 += A$3(b$4.length, 2), {
						fileRecord: R$2.LOCAL_FILE_HEADER + E$4 + f$5 + b$4,
						dirRecord: R$2.CENTRAL_FILE_HEADER + A$3(C$4, 2) + E$4 + A$3(p$6.length, 2) + "\0\0\0\0" + A$3(z$3, 4) + A$3(n$5, 4) + f$5 + b$4 + p$6
					};
				}
				var I$2 = e$59("../utils"), i$6 = e$59("../stream/GenericWorker"), O$3 = e$59("../utf8"), B$4 = e$59("../crc32"), R$2 = e$59("../signature");
				function s$4(e$60, t$13, r$12, n$5) {
					i$6.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t$13, this.zipPlatform = r$12, this.encodeFileName = n$5, this.streamFiles = e$60, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
				}
				I$2.inherits(s$4, i$6), s$4.prototype.push = function(e$60) {
					var t$13 = e$60.meta.percent || 0, r$12 = this.entriesCount, n$5 = this._sources.length;
					this.accumulate ? this.contentBuffer.push(e$60) : (this.bytesWritten += e$60.data.length, i$6.prototype.push.call(this, {
						data: e$60.data,
						meta: {
							currentFile: this.currentFile,
							percent: r$12 ? (t$13 + 100 * (r$12 - n$5 - 1)) / r$12 : 100
						}
					}));
				}, s$4.prototype.openedSource = function(e$60) {
					this.currentSourceOffset = this.bytesWritten, this.currentFile = e$60.file.name;
					var t$13 = this.streamFiles && !e$60.file.dir;
					if (t$13) {
						var r$12 = n$4(e$60, t$13, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
						this.push({
							data: r$12.fileRecord,
							meta: { percent: 0 }
						});
					} else this.accumulate = !0;
				}, s$4.prototype.closedSource = function(e$60) {
					this.accumulate = !1;
					var t$13 = this.streamFiles && !e$60.file.dir, r$12 = n$4(e$60, t$13, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
					if (this.dirRecords.push(r$12.dirRecord), t$13) this.push({
						data: function(e$61) {
							return R$2.DATA_DESCRIPTOR + A$3(e$61.crc32, 4) + A$3(e$61.compressedSize, 4) + A$3(e$61.uncompressedSize, 4);
						}(e$60),
						meta: { percent: 100 }
					});
					else for (this.push({
						data: r$12.fileRecord,
						meta: { percent: 0 }
					}); this.contentBuffer.length;) this.push(this.contentBuffer.shift());
					this.currentFile = null;
				}, s$4.prototype.flush = function() {
					for (var e$60 = this.bytesWritten, t$13 = 0; t$13 < this.dirRecords.length; t$13++) this.push({
						data: this.dirRecords[t$13],
						meta: { percent: 100 }
					});
					var r$12 = this.bytesWritten - e$60, n$5 = function(e$61, t$14, r$13, n$6, i$7) {
						var s$5 = I$2.transformTo("string", i$7(n$6));
						return R$2.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A$3(e$61, 2) + A$3(e$61, 2) + A$3(t$14, 4) + A$3(r$13, 4) + A$3(s$5.length, 2) + s$5;
					}(this.dirRecords.length, r$12, e$60, this.zipComment, this.encodeFileName);
					this.push({
						data: n$5,
						meta: { percent: 100 }
					});
				}, s$4.prototype.prepareNextSource = function() {
					this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
				}, s$4.prototype.registerPrevious = function(e$60) {
					this._sources.push(e$60);
					var t$13 = this;
					return e$60.on("data", function(e$61) {
						t$13.processChunk(e$61);
					}), e$60.on("end", function() {
						t$13.closedSource(t$13.previous.streamInfo), t$13._sources.length ? t$13.prepareNextSource() : t$13.end();
					}), e$60.on("error", function(e$61) {
						t$13.error(e$61);
					}), this;
				}, s$4.prototype.resume = function() {
					return !!i$6.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
				}, s$4.prototype.error = function(e$60) {
					var t$13 = this._sources;
					if (!i$6.prototype.error.call(this, e$60)) return !1;
					for (var r$12 = 0; r$12 < t$13.length; r$12++) try {
						t$13[r$12].error(e$60);
					} catch (e$61) {}
					return !0;
				}, s$4.prototype.lock = function() {
					i$6.prototype.lock.call(this);
					for (var e$60 = this._sources, t$13 = 0; t$13 < e$60.length; t$13++) e$60[t$13].lock();
				}, t$12.exports = s$4;
			}, {
				"../crc32": 4,
				"../signature": 23,
				"../stream/GenericWorker": 28,
				"../utf8": 31,
				"../utils": 32
			}],
			9: [function(e$59, t$12, r$11) {
				"use strict";
				var u$5 = e$59("../compressions"), n$4 = e$59("./ZipFileWorker");
				r$11.generateWorker = function(e$60, a$36, t$13) {
					var o$34 = new n$4(a$36.streamFiles, t$13, a$36.platform, a$36.encodeFileName), h$5 = 0;
					try {
						e$60.forEach(function(e$61, t$14) {
							h$5++;
							var r$12 = function(e$62, t$15) {
								var r$13 = e$62 || t$15, n$6 = u$5[r$13];
								if (!n$6) throw new Error(r$13 + " is not a valid compression method !");
								return n$6;
							}(t$14.options.compression, a$36.compression), n$5 = t$14.options.compressionOptions || a$36.compressionOptions || {}, i$6 = t$14.dir, s$4 = t$14.date;
							t$14._compressWorker(r$12, n$5).withStreamInfo("file", {
								name: e$61,
								dir: i$6,
								date: s$4,
								comment: t$14.comment || "",
								unixPermissions: t$14.unixPermissions,
								dosPermissions: t$14.dosPermissions
							}).pipe(o$34);
						}), o$34.entriesCount = h$5;
					} catch (e$61) {
						o$34.error(e$61);
					}
					return o$34;
				};
			}, {
				"../compressions": 3,
				"./ZipFileWorker": 8
			}],
			10: [function(e$59, t$12, r$11) {
				"use strict";
				function n$4() {
					if (!(this instanceof n$4)) return new n$4();
					if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
					this.files = Object.create(null), this.comment = null, this.root = "", this.clone = function() {
						var e$60 = new n$4();
						for (var t$13 in this) "function" != typeof this[t$13] && (e$60[t$13] = this[t$13]);
						return e$60;
					};
				}
				(n$4.prototype = e$59("./object")).loadAsync = e$59("./load"), n$4.support = e$59("./support"), n$4.defaults = e$59("./defaults"), n$4.version = "3.10.1", n$4.loadAsync = function(e$60, t$13) {
					return new n$4().loadAsync(e$60, t$13);
				}, n$4.external = e$59("./external"), t$12.exports = n$4;
			}, {
				"./defaults": 5,
				"./external": 6,
				"./load": 11,
				"./object": 15,
				"./support": 30
			}],
			11: [function(e$59, t$12, r$11) {
				"use strict";
				var u$5 = e$59("./utils"), i$6 = e$59("./external"), n$4 = e$59("./utf8"), s$4 = e$59("./zipEntries"), a$36 = e$59("./stream/Crc32Probe"), l$10 = e$59("./nodejsUtils");
				function f$5(n$5) {
					return new i$6.Promise(function(e$60, t$13) {
						var r$12 = n$5.decompressed.getContentWorker().pipe(new a$36());
						r$12.on("error", function(e$61) {
							t$13(e$61);
						}).on("end", function() {
							r$12.streamInfo.crc32 !== n$5.decompressed.crc32 ? t$13(/* @__PURE__ */ new Error("Corrupted zip : CRC32 mismatch")) : e$60();
						}).resume();
					});
				}
				t$12.exports = function(e$60, o$34) {
					var h$5 = this;
					return o$34 = u$5.extend(o$34 || {}, {
						base64: !1,
						checkCRC32: !1,
						optimizedBinaryString: !1,
						createFolders: !1,
						decodeFileName: n$4.utf8decode
					}), l$10.isNode && l$10.isStream(e$60) ? i$6.Promise.reject(/* @__PURE__ */ new Error("JSZip can't accept a stream when loading a zip file.")) : u$5.prepareContent("the loaded zip file", e$60, !0, o$34.optimizedBinaryString, o$34.base64).then(function(e$61) {
						var t$13 = new s$4(o$34);
						return t$13.load(e$61), t$13;
					}).then(function(e$61) {
						var t$13 = [i$6.Promise.resolve(e$61)], r$12 = e$61.files;
						if (o$34.checkCRC32) for (var n$5 = 0; n$5 < r$12.length; n$5++) t$13.push(f$5(r$12[n$5]));
						return i$6.Promise.all(t$13);
					}).then(function(e$61) {
						for (var t$13 = e$61.shift(), r$12 = t$13.files, n$5 = 0; n$5 < r$12.length; n$5++) {
							var i$7 = r$12[n$5], s$5 = i$7.fileNameStr, a$37 = u$5.resolve(i$7.fileNameStr);
							h$5.file(a$37, i$7.decompressed, {
								binary: !0,
								optimizedBinaryString: !0,
								date: i$7.date,
								dir: i$7.dir,
								comment: i$7.fileCommentStr.length ? i$7.fileCommentStr : null,
								unixPermissions: i$7.unixPermissions,
								dosPermissions: i$7.dosPermissions,
								createFolders: o$34.createFolders
							}), i$7.dir || (h$5.file(a$37).unsafeOriginalName = s$5);
						}
						return t$13.zipComment.length && (h$5.comment = t$13.zipComment), h$5;
					});
				};
			}, {
				"./external": 6,
				"./nodejsUtils": 14,
				"./stream/Crc32Probe": 25,
				"./utf8": 31,
				"./utils": 32,
				"./zipEntries": 33
			}],
			12: [function(e$59, t$12, r$11) {
				"use strict";
				var n$4 = e$59("../utils"), i$6 = e$59("../stream/GenericWorker");
				function s$4(e$60, t$13) {
					i$6.call(this, "Nodejs stream input adapter for " + e$60), this._upstreamEnded = !1, this._bindStream(t$13);
				}
				n$4.inherits(s$4, i$6), s$4.prototype._bindStream = function(e$60) {
					var t$13 = this;
					(this._stream = e$60).pause(), e$60.on("data", function(e$61) {
						t$13.push({
							data: e$61,
							meta: { percent: 0 }
						});
					}).on("error", function(e$61) {
						t$13.isPaused ? this.generatedError = e$61 : t$13.error(e$61);
					}).on("end", function() {
						t$13.isPaused ? t$13._upstreamEnded = !0 : t$13.end();
					});
				}, s$4.prototype.pause = function() {
					return !!i$6.prototype.pause.call(this) && (this._stream.pause(), !0);
				}, s$4.prototype.resume = function() {
					return !!i$6.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
				}, t$12.exports = s$4;
			}, {
				"../stream/GenericWorker": 28,
				"../utils": 32
			}],
			13: [function(e$59, t$12, r$11) {
				"use strict";
				var i$6 = e$59("readable-stream").Readable;
				function n$4(e$60, t$13, r$12) {
					i$6.call(this, t$13), this._helper = e$60;
					var n$5 = this;
					e$60.on("data", function(e$61, t$14) {
						n$5.push(e$61) || n$5._helper.pause(), r$12 && r$12(t$14);
					}).on("error", function(e$61) {
						n$5.emit("error", e$61);
					}).on("end", function() {
						n$5.push(null);
					});
				}
				e$59("../utils").inherits(n$4, i$6), n$4.prototype._read = function() {
					this._helper.resume();
				}, t$12.exports = n$4;
			}, {
				"../utils": 32,
				"readable-stream": 16
			}],
			14: [function(e$59, t$12, r$11) {
				"use strict";
				t$12.exports = {
					isNode: "undefined" != typeof Buffer,
					newBufferFrom: function(e$60, t$13) {
						if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(e$60, t$13);
						if ("number" == typeof e$60) throw new Error("The \"data\" argument must not be a number");
						return new Buffer(e$60, t$13);
					},
					allocBuffer: function(e$60) {
						if (Buffer.alloc) return Buffer.alloc(e$60);
						var t$13 = new Buffer(e$60);
						return t$13.fill(0), t$13;
					},
					isBuffer: function(e$60) {
						return Buffer.isBuffer(e$60);
					},
					isStream: function(e$60) {
						return e$60 && "function" == typeof e$60.on && "function" == typeof e$60.pause && "function" == typeof e$60.resume;
					}
				};
			}, {}],
			15: [function(e$59, t$12, r$11) {
				"use strict";
				function s$4(e$60, t$13, r$12) {
					var n$4, i$7 = u$5.getTypeOf(t$13), s$5 = u$5.extend(r$12 || {}, f$5);
					s$5.date = s$5.date || /* @__PURE__ */ new Date(), null !== s$5.compression && (s$5.compression = s$5.compression.toUpperCase()), "string" == typeof s$5.unixPermissions && (s$5.unixPermissions = parseInt(s$5.unixPermissions, 8)), s$5.unixPermissions && 16384 & s$5.unixPermissions && (s$5.dir = !0), s$5.dosPermissions && 16 & s$5.dosPermissions && (s$5.dir = !0), s$5.dir && (e$60 = g$5(e$60)), s$5.createFolders && (n$4 = _$5(e$60)) && b$4.call(this, n$4, !0);
					var a$37 = "string" === i$7 && !1 === s$5.binary && !1 === s$5.base64;
					r$12 && void 0 !== r$12.binary || (s$5.binary = !a$37), (t$13 instanceof c$7 && 0 === t$13.uncompressedSize || s$5.dir || !t$13 || 0 === t$13.length) && (s$5.base64 = !1, s$5.binary = !0, t$13 = "", s$5.compression = "STORE", i$7 = "string");
					var o$35 = null;
					o$35 = t$13 instanceof c$7 || t$13 instanceof l$10 ? t$13 : p$6.isNode && p$6.isStream(t$13) ? new m$5(e$60, t$13) : u$5.prepareContent(e$60, t$13, s$5.binary, s$5.optimizedBinaryString, s$5.base64);
					var h$6 = new d$5(e$60, o$35, s$5);
					this.files[e$60] = h$6;
				}
				var i$6 = e$59("./utf8"), u$5 = e$59("./utils"), l$10 = e$59("./stream/GenericWorker"), a$36 = e$59("./stream/StreamHelper"), f$5 = e$59("./defaults"), c$7 = e$59("./compressedObject"), d$5 = e$59("./zipObject"), o$34 = e$59("./generate"), p$6 = e$59("./nodejsUtils"), m$5 = e$59("./nodejs/NodejsStreamInputAdapter"), _$5 = function(e$60) {
					"/" === e$60.slice(-1) && (e$60 = e$60.substring(0, e$60.length - 1));
					var t$13 = e$60.lastIndexOf("/");
					return 0 < t$13 ? e$60.substring(0, t$13) : "";
				}, g$5 = function(e$60) {
					return "/" !== e$60.slice(-1) && (e$60 += "/"), e$60;
				}, b$4 = function(e$60, t$13) {
					return t$13 = void 0 !== t$13 ? t$13 : f$5.createFolders, e$60 = g$5(e$60), this.files[e$60] || s$4.call(this, e$60, null, {
						dir: !0,
						createFolders: t$13
					}), this.files[e$60];
				};
				function h$5(e$60) {
					return "[object RegExp]" === Object.prototype.toString.call(e$60);
				}
				t$12.exports = {
					load: function() {
						throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
					},
					forEach: function(e$60) {
						var t$13, r$12, n$4;
						for (t$13 in this.files) n$4 = this.files[t$13], (r$12 = t$13.slice(this.root.length, t$13.length)) && t$13.slice(0, this.root.length) === this.root && e$60(r$12, n$4);
					},
					filter: function(r$12) {
						var n$4 = [];
						return this.forEach(function(e$60, t$13) {
							r$12(e$60, t$13) && n$4.push(t$13);
						}), n$4;
					},
					file: function(e$60, t$13, r$12) {
						if (1 !== arguments.length) return e$60 = this.root + e$60, s$4.call(this, e$60, t$13, r$12), this;
						if (h$5(e$60)) {
							var n$4 = e$60;
							return this.filter(function(e$61, t$14) {
								return !t$14.dir && n$4.test(e$61);
							});
						}
						var i$7 = this.files[this.root + e$60];
						return i$7 && !i$7.dir ? i$7 : null;
					},
					folder: function(r$12) {
						if (!r$12) return this;
						if (h$5(r$12)) return this.filter(function(e$61, t$14) {
							return t$14.dir && r$12.test(e$61);
						});
						var e$60 = this.root + r$12, t$13 = b$4.call(this, e$60), n$4 = this.clone();
						return n$4.root = t$13.name, n$4;
					},
					remove: function(r$12) {
						r$12 = this.root + r$12;
						var e$60 = this.files[r$12];
						if (e$60 || ("/" !== r$12.slice(-1) && (r$12 += "/"), e$60 = this.files[r$12]), e$60 && !e$60.dir) delete this.files[r$12];
						else for (var t$13 = this.filter(function(e$61, t$14) {
							return t$14.name.slice(0, r$12.length) === r$12;
						}), n$4 = 0; n$4 < t$13.length; n$4++) delete this.files[t$13[n$4].name];
						return this;
					},
					generate: function() {
						throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
					},
					generateInternalStream: function(e$60) {
						var t$13, r$12 = {};
						try {
							if ((r$12 = u$5.extend(e$60 || {}, {
								streamFiles: !1,
								compression: "STORE",
								compressionOptions: null,
								type: "",
								platform: "DOS",
								comment: null,
								mimeType: "application/zip",
								encodeFileName: i$6.utf8encode
							})).type = r$12.type.toLowerCase(), r$12.compression = r$12.compression.toUpperCase(), "binarystring" === r$12.type && (r$12.type = "string"), !r$12.type) throw new Error("No output type specified.");
							u$5.checkSupport(r$12.type), "darwin" !== r$12.platform && "freebsd" !== r$12.platform && "linux" !== r$12.platform && "sunos" !== r$12.platform || (r$12.platform = "UNIX"), "win32" === r$12.platform && (r$12.platform = "DOS");
							var n$4 = r$12.comment || this.comment || "";
							t$13 = o$34.generateWorker(this, r$12, n$4);
						} catch (e$61) {
							(t$13 = new l$10("error")).error(e$61);
						}
						return new a$36(t$13, r$12.type || "string", r$12.mimeType);
					},
					generateAsync: function(e$60, t$13) {
						return this.generateInternalStream(e$60).accumulate(t$13);
					},
					generateNodeStream: function(e$60, t$13) {
						return (e$60 = e$60 || {}).type || (e$60.type = "nodebuffer"), this.generateInternalStream(e$60).toNodejsStream(t$13);
					}
				};
			}, {
				"./compressedObject": 2,
				"./defaults": 5,
				"./generate": 9,
				"./nodejs/NodejsStreamInputAdapter": 12,
				"./nodejsUtils": 14,
				"./stream/GenericWorker": 28,
				"./stream/StreamHelper": 29,
				"./utf8": 31,
				"./utils": 32,
				"./zipObject": 35
			}],
			16: [function(e$59, t$12, r$11) {
				"use strict";
				t$12.exports = e$59("stream");
			}, { stream: void 0 }],
			17: [function(e$59, t$12, r$11) {
				"use strict";
				var n$4 = e$59("./DataReader");
				function i$6(e$60) {
					n$4.call(this, e$60);
					for (var t$13 = 0; t$13 < this.data.length; t$13++) e$60[t$13] = 255 & e$60[t$13];
				}
				e$59("../utils").inherits(i$6, n$4), i$6.prototype.byteAt = function(e$60) {
					return this.data[this.zero + e$60];
				}, i$6.prototype.lastIndexOfSignature = function(e$60) {
					for (var t$13 = e$60.charCodeAt(0), r$12 = e$60.charCodeAt(1), n$5 = e$60.charCodeAt(2), i$7 = e$60.charCodeAt(3), s$4 = this.length - 4; 0 <= s$4; --s$4) if (this.data[s$4] === t$13 && this.data[s$4 + 1] === r$12 && this.data[s$4 + 2] === n$5 && this.data[s$4 + 3] === i$7) return s$4 - this.zero;
					return -1;
				}, i$6.prototype.readAndCheckSignature = function(e$60) {
					var t$13 = e$60.charCodeAt(0), r$12 = e$60.charCodeAt(1), n$5 = e$60.charCodeAt(2), i$7 = e$60.charCodeAt(3), s$4 = this.readData(4);
					return t$13 === s$4[0] && r$12 === s$4[1] && n$5 === s$4[2] && i$7 === s$4[3];
				}, i$6.prototype.readData = function(e$60) {
					if (this.checkOffset(e$60), 0 === e$60) return [];
					var t$13 = this.data.slice(this.zero + this.index, this.zero + this.index + e$60);
					return this.index += e$60, t$13;
				}, t$12.exports = i$6;
			}, {
				"../utils": 32,
				"./DataReader": 18
			}],
			18: [function(e$59, t$12, r$11) {
				"use strict";
				var n$4 = e$59("../utils");
				function i$6(e$60) {
					this.data = e$60, this.length = e$60.length, this.index = 0, this.zero = 0;
				}
				i$6.prototype = {
					checkOffset: function(e$60) {
						this.checkIndex(this.index + e$60);
					},
					checkIndex: function(e$60) {
						if (this.length < this.zero + e$60 || e$60 < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e$60 + "). Corrupted zip ?");
					},
					setIndex: function(e$60) {
						this.checkIndex(e$60), this.index = e$60;
					},
					skip: function(e$60) {
						this.setIndex(this.index + e$60);
					},
					byteAt: function() {},
					readInt: function(e$60) {
						var t$13, r$12 = 0;
						for (this.checkOffset(e$60), t$13 = this.index + e$60 - 1; t$13 >= this.index; t$13--) r$12 = (r$12 << 8) + this.byteAt(t$13);
						return this.index += e$60, r$12;
					},
					readString: function(e$60) {
						return n$4.transformTo("string", this.readData(e$60));
					},
					readData: function() {},
					lastIndexOfSignature: function() {},
					readAndCheckSignature: function() {},
					readDate: function() {
						var e$60 = this.readInt(4);
						return new Date(Date.UTC(1980 + (e$60 >> 25 & 127), (e$60 >> 21 & 15) - 1, e$60 >> 16 & 31, e$60 >> 11 & 31, e$60 >> 5 & 63, (31 & e$60) << 1));
					}
				}, t$12.exports = i$6;
			}, { "../utils": 32 }],
			19: [function(e$59, t$12, r$11) {
				"use strict";
				var n$4 = e$59("./Uint8ArrayReader");
				function i$6(e$60) {
					n$4.call(this, e$60);
				}
				e$59("../utils").inherits(i$6, n$4), i$6.prototype.readData = function(e$60) {
					this.checkOffset(e$60);
					var t$13 = this.data.slice(this.zero + this.index, this.zero + this.index + e$60);
					return this.index += e$60, t$13;
				}, t$12.exports = i$6;
			}, {
				"../utils": 32,
				"./Uint8ArrayReader": 21
			}],
			20: [function(e$59, t$12, r$11) {
				"use strict";
				var n$4 = e$59("./DataReader");
				function i$6(e$60) {
					n$4.call(this, e$60);
				}
				e$59("../utils").inherits(i$6, n$4), i$6.prototype.byteAt = function(e$60) {
					return this.data.charCodeAt(this.zero + e$60);
				}, i$6.prototype.lastIndexOfSignature = function(e$60) {
					return this.data.lastIndexOf(e$60) - this.zero;
				}, i$6.prototype.readAndCheckSignature = function(e$60) {
					return e$60 === this.readData(4);
				}, i$6.prototype.readData = function(e$60) {
					this.checkOffset(e$60);
					var t$13 = this.data.slice(this.zero + this.index, this.zero + this.index + e$60);
					return this.index += e$60, t$13;
				}, t$12.exports = i$6;
			}, {
				"../utils": 32,
				"./DataReader": 18
			}],
			21: [function(e$59, t$12, r$11) {
				"use strict";
				var n$4 = e$59("./ArrayReader");
				function i$6(e$60) {
					n$4.call(this, e$60);
				}
				e$59("../utils").inherits(i$6, n$4), i$6.prototype.readData = function(e$60) {
					if (this.checkOffset(e$60), 0 === e$60) return new Uint8Array(0);
					var t$13 = this.data.subarray(this.zero + this.index, this.zero + this.index + e$60);
					return this.index += e$60, t$13;
				}, t$12.exports = i$6;
			}, {
				"../utils": 32,
				"./ArrayReader": 17
			}],
			22: [function(e$59, t$12, r$11) {
				"use strict";
				var n$4 = e$59("../utils"), i$6 = e$59("../support"), s$4 = e$59("./ArrayReader"), a$36 = e$59("./StringReader"), o$34 = e$59("./NodeBufferReader"), h$5 = e$59("./Uint8ArrayReader");
				t$12.exports = function(e$60) {
					var t$13 = n$4.getTypeOf(e$60);
					return n$4.checkSupport(t$13), "string" !== t$13 || i$6.uint8array ? "nodebuffer" === t$13 ? new o$34(e$60) : i$6.uint8array ? new h$5(n$4.transformTo("uint8array", e$60)) : new s$4(n$4.transformTo("array", e$60)) : new a$36(e$60);
				};
			}, {
				"../support": 30,
				"../utils": 32,
				"./ArrayReader": 17,
				"./NodeBufferReader": 19,
				"./StringReader": 20,
				"./Uint8ArrayReader": 21
			}],
			23: [function(e$59, t$12, r$11) {
				"use strict";
				r$11.LOCAL_FILE_HEADER = "PK", r$11.CENTRAL_FILE_HEADER = "PK", r$11.CENTRAL_DIRECTORY_END = "PK", r$11.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r$11.ZIP64_CENTRAL_DIRECTORY_END = "PK", r$11.DATA_DESCRIPTOR = "PK\x07\b";
			}, {}],
			24: [function(e$59, t$12, r$11) {
				"use strict";
				var n$4 = e$59("./GenericWorker"), i$6 = e$59("../utils");
				function s$4(e$60) {
					n$4.call(this, "ConvertWorker to " + e$60), this.destType = e$60;
				}
				i$6.inherits(s$4, n$4), s$4.prototype.processChunk = function(e$60) {
					this.push({
						data: i$6.transformTo(this.destType, e$60.data),
						meta: e$60.meta
					});
				}, t$12.exports = s$4;
			}, {
				"../utils": 32,
				"./GenericWorker": 28
			}],
			25: [function(e$59, t$12, r$11) {
				"use strict";
				var n$4 = e$59("./GenericWorker"), i$6 = e$59("../crc32");
				function s$4() {
					n$4.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
				}
				e$59("../utils").inherits(s$4, n$4), s$4.prototype.processChunk = function(e$60) {
					this.streamInfo.crc32 = i$6(e$60.data, this.streamInfo.crc32 || 0), this.push(e$60);
				}, t$12.exports = s$4;
			}, {
				"../crc32": 4,
				"../utils": 32,
				"./GenericWorker": 28
			}],
			26: [function(e$59, t$12, r$11) {
				"use strict";
				var n$4 = e$59("../utils"), i$6 = e$59("./GenericWorker");
				function s$4(e$60) {
					i$6.call(this, "DataLengthProbe for " + e$60), this.propName = e$60, this.withStreamInfo(e$60, 0);
				}
				n$4.inherits(s$4, i$6), s$4.prototype.processChunk = function(e$60) {
					if (e$60) {
						var t$13 = this.streamInfo[this.propName] || 0;
						this.streamInfo[this.propName] = t$13 + e$60.data.length;
					}
					i$6.prototype.processChunk.call(this, e$60);
				}, t$12.exports = s$4;
			}, {
				"../utils": 32,
				"./GenericWorker": 28
			}],
			27: [function(e$59, t$12, r$11) {
				"use strict";
				var n$4 = e$59("../utils"), i$6 = e$59("./GenericWorker");
				function s$4(e$60) {
					i$6.call(this, "DataWorker");
					var t$13 = this;
					this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, e$60.then(function(e$61) {
						t$13.dataIsReady = !0, t$13.data = e$61, t$13.max = e$61 && e$61.length || 0, t$13.type = n$4.getTypeOf(e$61), t$13.isPaused || t$13._tickAndRepeat();
					}, function(e$61) {
						t$13.error(e$61);
					});
				}
				n$4.inherits(s$4, i$6), s$4.prototype.cleanUp = function() {
					i$6.prototype.cleanUp.call(this), this.data = null;
				}, s$4.prototype.resume = function() {
					return !!i$6.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, n$4.delay(this._tickAndRepeat, [], this)), !0);
				}, s$4.prototype._tickAndRepeat = function() {
					this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n$4.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
				}, s$4.prototype._tick = function() {
					if (this.isPaused || this.isFinished) return !1;
					var e$60 = null, t$13 = Math.min(this.max, this.index + 16384);
					if (this.index >= this.max) return this.end();
					switch (this.type) {
						case "string":
							e$60 = this.data.substring(this.index, t$13);
							break;
						case "uint8array":
							e$60 = this.data.subarray(this.index, t$13);
							break;
						case "array":
						case "nodebuffer": e$60 = this.data.slice(this.index, t$13);
					}
					return this.index = t$13, this.push({
						data: e$60,
						meta: { percent: this.max ? this.index / this.max * 100 : 0 }
					});
				}, t$12.exports = s$4;
			}, {
				"../utils": 32,
				"./GenericWorker": 28
			}],
			28: [function(e$59, t$12, r$11) {
				"use strict";
				function n$4(e$60) {
					this.name = e$60 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = {
						data: [],
						end: [],
						error: []
					}, this.previous = null;
				}
				n$4.prototype = {
					push: function(e$60) {
						this.emit("data", e$60);
					},
					end: function() {
						if (this.isFinished) return !1;
						this.flush();
						try {
							this.emit("end"), this.cleanUp(), this.isFinished = !0;
						} catch (e$60) {
							this.emit("error", e$60);
						}
						return !0;
					},
					error: function(e$60) {
						return !this.isFinished && (this.isPaused ? this.generatedError = e$60 : (this.isFinished = !0, this.emit("error", e$60), this.previous && this.previous.error(e$60), this.cleanUp()), !0);
					},
					on: function(e$60, t$13) {
						return this._listeners[e$60].push(t$13), this;
					},
					cleanUp: function() {
						this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
					},
					emit: function(e$60, t$13) {
						if (this._listeners[e$60]) for (var r$12 = 0; r$12 < this._listeners[e$60].length; r$12++) this._listeners[e$60][r$12].call(this, t$13);
					},
					pipe: function(e$60) {
						return e$60.registerPrevious(this);
					},
					registerPrevious: function(e$60) {
						if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
						this.streamInfo = e$60.streamInfo, this.mergeStreamInfo(), this.previous = e$60;
						var t$13 = this;
						return e$60.on("data", function(e$61) {
							t$13.processChunk(e$61);
						}), e$60.on("end", function() {
							t$13.end();
						}), e$60.on("error", function(e$61) {
							t$13.error(e$61);
						}), this;
					},
					pause: function() {
						return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
					},
					resume: function() {
						if (!this.isPaused || this.isFinished) return !1;
						var e$60 = this.isPaused = !1;
						return this.generatedError && (this.error(this.generatedError), e$60 = !0), this.previous && this.previous.resume(), !e$60;
					},
					flush: function() {},
					processChunk: function(e$60) {
						this.push(e$60);
					},
					withStreamInfo: function(e$60, t$13) {
						return this.extraStreamInfo[e$60] = t$13, this.mergeStreamInfo(), this;
					},
					mergeStreamInfo: function() {
						for (var e$60 in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e$60) && (this.streamInfo[e$60] = this.extraStreamInfo[e$60]);
					},
					lock: function() {
						if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
						this.isLocked = !0, this.previous && this.previous.lock();
					},
					toString: function() {
						var e$60 = "Worker " + this.name;
						return this.previous ? this.previous + " -> " + e$60 : e$60;
					}
				}, t$12.exports = n$4;
			}, {}],
			29: [function(e$59, t$12, r$11) {
				"use strict";
				var h$5 = e$59("../utils"), i$6 = e$59("./ConvertWorker"), s$4 = e$59("./GenericWorker"), u$5 = e$59("../base64"), n$4 = e$59("../support"), a$36 = e$59("../external"), o$34 = null;
				if (n$4.nodestream) try {
					o$34 = e$59("../nodejs/NodejsStreamOutputAdapter");
				} catch (e$60) {}
				function l$10(e$60, o$35) {
					return new a$36.Promise(function(t$13, r$12) {
						var n$5 = [], i$7 = e$60._internalType, s$5 = e$60._outputType, a$37 = e$60._mimeType;
						e$60.on("data", function(e$61, t$14) {
							n$5.push(e$61), o$35 && o$35(t$14);
						}).on("error", function(e$61) {
							n$5 = [], r$12(e$61);
						}).on("end", function() {
							try {
								t$13(function(e$61, t$14, r$13) {
									switch (e$61) {
										case "blob": return h$5.newBlob(h$5.transformTo("arraybuffer", t$14), r$13);
										case "base64": return u$5.encode(t$14);
										default: return h$5.transformTo(e$61, t$14);
									}
								}(s$5, function(e$61, t$14) {
									var r$13, n$6 = 0, i$8 = null, s$6 = 0;
									for (r$13 = 0; r$13 < t$14.length; r$13++) s$6 += t$14[r$13].length;
									switch (e$61) {
										case "string": return t$14.join("");
										case "array": return Array.prototype.concat.apply([], t$14);
										case "uint8array":
											for (i$8 = new Uint8Array(s$6), r$13 = 0; r$13 < t$14.length; r$13++) i$8.set(t$14[r$13], n$6), n$6 += t$14[r$13].length;
											return i$8;
										case "nodebuffer": return Buffer.concat(t$14);
										default: throw new Error("concat : unsupported type '" + e$61 + "'");
									}
								}(i$7, n$5), a$37));
							} catch (e$61) {
								r$12(e$61);
							}
							n$5 = [];
						}).resume();
					});
				}
				function f$5(e$60, t$13, r$12) {
					var n$5 = t$13;
					switch (t$13) {
						case "blob":
						case "arraybuffer":
							n$5 = "uint8array";
							break;
						case "base64": n$5 = "string";
					}
					try {
						this._internalType = n$5, this._outputType = t$13, this._mimeType = r$12, h$5.checkSupport(n$5), this._worker = e$60.pipe(new i$6(n$5)), e$60.lock();
					} catch (e$61) {
						this._worker = new s$4("error"), this._worker.error(e$61);
					}
				}
				f$5.prototype = {
					accumulate: function(e$60) {
						return l$10(this, e$60);
					},
					on: function(e$60, t$13) {
						var r$12 = this;
						return "data" === e$60 ? this._worker.on(e$60, function(e$61) {
							t$13.call(r$12, e$61.data, e$61.meta);
						}) : this._worker.on(e$60, function() {
							h$5.delay(t$13, arguments, r$12);
						}), this;
					},
					resume: function() {
						return h$5.delay(this._worker.resume, [], this._worker), this;
					},
					pause: function() {
						return this._worker.pause(), this;
					},
					toNodejsStream: function(e$60) {
						if (h$5.checkSupport("nodestream"), "nodebuffer" !== this._outputType) throw new Error(this._outputType + " is not supported by this method");
						return new o$34(this, { objectMode: "nodebuffer" !== this._outputType }, e$60);
					}
				}, t$12.exports = f$5;
			}, {
				"../base64": 1,
				"../external": 6,
				"../nodejs/NodejsStreamOutputAdapter": 13,
				"../support": 30,
				"../utils": 32,
				"./ConvertWorker": 24,
				"./GenericWorker": 28
			}],
			30: [function(e$59, t$12, r$11) {
				"use strict";
				if (r$11.base64 = !0, r$11.array = !0, r$11.string = !0, r$11.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r$11.nodebuffer = "undefined" != typeof Buffer, r$11.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer) r$11.blob = !1;
				else {
					var n$4 = /* @__PURE__ */ new ArrayBuffer(0);
					try {
						r$11.blob = 0 === new Blob([n$4], { type: "application/zip" }).size;
					} catch (e$60) {
						try {
							var i$6 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
							i$6.append(n$4), r$11.blob = 0 === i$6.getBlob("application/zip").size;
						} catch (e$61) {
							r$11.blob = !1;
						}
					}
				}
				try {
					r$11.nodestream = !!e$59("readable-stream").Readable;
				} catch (e$60) {
					r$11.nodestream = !1;
				}
			}, { "readable-stream": 16 }],
			31: [function(e$59, t$12, s$4) {
				"use strict";
				for (var o$34 = e$59("./utils"), h$5 = e$59("./support"), r$11 = e$59("./nodejsUtils"), n$4 = e$59("./stream/GenericWorker"), u$5 = new Array(256), i$6 = 0; i$6 < 256; i$6++) u$5[i$6] = 252 <= i$6 ? 6 : 248 <= i$6 ? 5 : 240 <= i$6 ? 4 : 224 <= i$6 ? 3 : 192 <= i$6 ? 2 : 1;
				u$5[254] = u$5[254] = 1;
				function a$36() {
					n$4.call(this, "utf-8 decode"), this.leftOver = null;
				}
				function l$10() {
					n$4.call(this, "utf-8 encode");
				}
				s$4.utf8encode = function(e$60) {
					return h$5.nodebuffer ? r$11.newBufferFrom(e$60, "utf-8") : function(e$61) {
						var t$13, r$12, n$5, i$7, s$5, a$37 = e$61.length, o$35 = 0;
						for (i$7 = 0; i$7 < a$37; i$7++) 55296 == (64512 & (r$12 = e$61.charCodeAt(i$7))) && i$7 + 1 < a$37 && 56320 == (64512 & (n$5 = e$61.charCodeAt(i$7 + 1))) && (r$12 = 65536 + (r$12 - 55296 << 10) + (n$5 - 56320), i$7++), o$35 += r$12 < 128 ? 1 : r$12 < 2048 ? 2 : r$12 < 65536 ? 3 : 4;
						for (t$13 = h$5.uint8array ? new Uint8Array(o$35) : new Array(o$35), i$7 = s$5 = 0; s$5 < o$35; i$7++) 55296 == (64512 & (r$12 = e$61.charCodeAt(i$7))) && i$7 + 1 < a$37 && 56320 == (64512 & (n$5 = e$61.charCodeAt(i$7 + 1))) && (r$12 = 65536 + (r$12 - 55296 << 10) + (n$5 - 56320), i$7++), r$12 < 128 ? t$13[s$5++] = r$12 : (r$12 < 2048 ? t$13[s$5++] = 192 | r$12 >>> 6 : (r$12 < 65536 ? t$13[s$5++] = 224 | r$12 >>> 12 : (t$13[s$5++] = 240 | r$12 >>> 18, t$13[s$5++] = 128 | r$12 >>> 12 & 63), t$13[s$5++] = 128 | r$12 >>> 6 & 63), t$13[s$5++] = 128 | 63 & r$12);
						return t$13;
					}(e$60);
				}, s$4.utf8decode = function(e$60) {
					return h$5.nodebuffer ? o$34.transformTo("nodebuffer", e$60).toString("utf-8") : function(e$61) {
						var t$13, r$12, n$5, i$7, s$5 = e$61.length, a$37 = new Array(2 * s$5);
						for (t$13 = r$12 = 0; t$13 < s$5;) if ((n$5 = e$61[t$13++]) < 128) a$37[r$12++] = n$5;
						else if (4 < (i$7 = u$5[n$5])) a$37[r$12++] = 65533, t$13 += i$7 - 1;
						else {
							for (n$5 &= 2 === i$7 ? 31 : 3 === i$7 ? 15 : 7; 1 < i$7 && t$13 < s$5;) n$5 = n$5 << 6 | 63 & e$61[t$13++], i$7--;
							1 < i$7 ? a$37[r$12++] = 65533 : n$5 < 65536 ? a$37[r$12++] = n$5 : (n$5 -= 65536, a$37[r$12++] = 55296 | n$5 >> 10 & 1023, a$37[r$12++] = 56320 | 1023 & n$5);
						}
						return a$37.length !== r$12 && (a$37.subarray ? a$37 = a$37.subarray(0, r$12) : a$37.length = r$12), o$34.applyFromCharCode(a$37);
					}(e$60 = o$34.transformTo(h$5.uint8array ? "uint8array" : "array", e$60));
				}, o$34.inherits(a$36, n$4), a$36.prototype.processChunk = function(e$60) {
					var t$13 = o$34.transformTo(h$5.uint8array ? "uint8array" : "array", e$60.data);
					if (this.leftOver && this.leftOver.length) {
						if (h$5.uint8array) {
							var r$12 = t$13;
							(t$13 = new Uint8Array(r$12.length + this.leftOver.length)).set(this.leftOver, 0), t$13.set(r$12, this.leftOver.length);
						} else t$13 = this.leftOver.concat(t$13);
						this.leftOver = null;
					}
					var n$5 = function(e$61, t$14) {
						var r$13;
						for ((t$14 = t$14 || e$61.length) > e$61.length && (t$14 = e$61.length), r$13 = t$14 - 1; 0 <= r$13 && 128 == (192 & e$61[r$13]);) r$13--;
						return r$13 < 0 ? t$14 : 0 === r$13 ? t$14 : r$13 + u$5[e$61[r$13]] > t$14 ? r$13 : t$14;
					}(t$13), i$7 = t$13;
					n$5 !== t$13.length && (h$5.uint8array ? (i$7 = t$13.subarray(0, n$5), this.leftOver = t$13.subarray(n$5, t$13.length)) : (i$7 = t$13.slice(0, n$5), this.leftOver = t$13.slice(n$5, t$13.length))), this.push({
						data: s$4.utf8decode(i$7),
						meta: e$60.meta
					});
				}, a$36.prototype.flush = function() {
					this.leftOver && this.leftOver.length && (this.push({
						data: s$4.utf8decode(this.leftOver),
						meta: {}
					}), this.leftOver = null);
				}, s$4.Utf8DecodeWorker = a$36, o$34.inherits(l$10, n$4), l$10.prototype.processChunk = function(e$60) {
					this.push({
						data: s$4.utf8encode(e$60.data),
						meta: e$60.meta
					});
				}, s$4.Utf8EncodeWorker = l$10;
			}, {
				"./nodejsUtils": 14,
				"./stream/GenericWorker": 28,
				"./support": 30,
				"./utils": 32
			}],
			32: [function(e$59, t$12, a$36) {
				"use strict";
				var o$34 = e$59("./support"), h$5 = e$59("./base64"), r$11 = e$59("./nodejsUtils"), u$5 = e$59("./external");
				function n$4(e$60) {
					return e$60;
				}
				function l$10(e$60, t$13) {
					for (var r$12 = 0; r$12 < e$60.length; ++r$12) t$13[r$12] = 255 & e$60.charCodeAt(r$12);
					return t$13;
				}
				e$59("setimmediate"), a$36.newBlob = function(t$13, r$12) {
					a$36.checkSupport("blob");
					try {
						return new Blob([t$13], { type: r$12 });
					} catch (e$60) {
						try {
							var n$5 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
							return n$5.append(t$13), n$5.getBlob(r$12);
						} catch (e$61) {
							throw new Error("Bug : can't construct the Blob.");
						}
					}
				};
				var i$6 = {
					stringifyByChunk: function(e$60, t$13, r$12) {
						var n$5 = [], i$7 = 0, s$5 = e$60.length;
						if (s$5 <= r$12) return String.fromCharCode.apply(null, e$60);
						for (; i$7 < s$5;) "array" === t$13 || "nodebuffer" === t$13 ? n$5.push(String.fromCharCode.apply(null, e$60.slice(i$7, Math.min(i$7 + r$12, s$5)))) : n$5.push(String.fromCharCode.apply(null, e$60.subarray(i$7, Math.min(i$7 + r$12, s$5)))), i$7 += r$12;
						return n$5.join("");
					},
					stringifyByChar: function(e$60) {
						for (var t$13 = "", r$12 = 0; r$12 < e$60.length; r$12++) t$13 += String.fromCharCode(e$60[r$12]);
						return t$13;
					},
					applyCanBeUsed: {
						uint8array: function() {
							try {
								return o$34.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
							} catch (e$60) {
								return !1;
							}
						}(),
						nodebuffer: function() {
							try {
								return o$34.nodebuffer && 1 === String.fromCharCode.apply(null, r$11.allocBuffer(1)).length;
							} catch (e$60) {
								return !1;
							}
						}()
					}
				};
				function s$4(e$60) {
					var t$13 = 65536, r$12 = a$36.getTypeOf(e$60), n$5 = !0;
					if ("uint8array" === r$12 ? n$5 = i$6.applyCanBeUsed.uint8array : "nodebuffer" === r$12 && (n$5 = i$6.applyCanBeUsed.nodebuffer), n$5) for (; 1 < t$13;) try {
						return i$6.stringifyByChunk(e$60, r$12, t$13);
					} catch (e$61) {
						t$13 = Math.floor(t$13 / 2);
					}
					return i$6.stringifyByChar(e$60);
				}
				function f$5(e$60, t$13) {
					for (var r$12 = 0; r$12 < e$60.length; r$12++) t$13[r$12] = e$60[r$12];
					return t$13;
				}
				a$36.applyFromCharCode = s$4;
				var c$7 = {};
				c$7.string = {
					string: n$4,
					array: function(e$60) {
						return l$10(e$60, new Array(e$60.length));
					},
					arraybuffer: function(e$60) {
						return c$7.string.uint8array(e$60).buffer;
					},
					uint8array: function(e$60) {
						return l$10(e$60, new Uint8Array(e$60.length));
					},
					nodebuffer: function(e$60) {
						return l$10(e$60, r$11.allocBuffer(e$60.length));
					}
				}, c$7.array = {
					string: s$4,
					array: n$4,
					arraybuffer: function(e$60) {
						return new Uint8Array(e$60).buffer;
					},
					uint8array: function(e$60) {
						return new Uint8Array(e$60);
					},
					nodebuffer: function(e$60) {
						return r$11.newBufferFrom(e$60);
					}
				}, c$7.arraybuffer = {
					string: function(e$60) {
						return s$4(new Uint8Array(e$60));
					},
					array: function(e$60) {
						return f$5(new Uint8Array(e$60), new Array(e$60.byteLength));
					},
					arraybuffer: n$4,
					uint8array: function(e$60) {
						return new Uint8Array(e$60);
					},
					nodebuffer: function(e$60) {
						return r$11.newBufferFrom(new Uint8Array(e$60));
					}
				}, c$7.uint8array = {
					string: s$4,
					array: function(e$60) {
						return f$5(e$60, new Array(e$60.length));
					},
					arraybuffer: function(e$60) {
						return e$60.buffer;
					},
					uint8array: n$4,
					nodebuffer: function(e$60) {
						return r$11.newBufferFrom(e$60);
					}
				}, c$7.nodebuffer = {
					string: s$4,
					array: function(e$60) {
						return f$5(e$60, new Array(e$60.length));
					},
					arraybuffer: function(e$60) {
						return c$7.nodebuffer.uint8array(e$60).buffer;
					},
					uint8array: function(e$60) {
						return f$5(e$60, new Uint8Array(e$60.length));
					},
					nodebuffer: n$4
				}, a$36.transformTo = function(e$60, t$13) {
					if (t$13 = t$13 || "", !e$60) return t$13;
					a$36.checkSupport(e$60);
					return c$7[a$36.getTypeOf(t$13)][e$60](t$13);
				}, a$36.resolve = function(e$60) {
					for (var t$13 = e$60.split("/"), r$12 = [], n$5 = 0; n$5 < t$13.length; n$5++) {
						var i$7 = t$13[n$5];
						"." === i$7 || "" === i$7 && 0 !== n$5 && n$5 !== t$13.length - 1 || (".." === i$7 ? r$12.pop() : r$12.push(i$7));
					}
					return r$12.join("/");
				}, a$36.getTypeOf = function(e$60) {
					return "string" == typeof e$60 ? "string" : "[object Array]" === Object.prototype.toString.call(e$60) ? "array" : o$34.nodebuffer && r$11.isBuffer(e$60) ? "nodebuffer" : o$34.uint8array && e$60 instanceof Uint8Array ? "uint8array" : o$34.arraybuffer && e$60 instanceof ArrayBuffer ? "arraybuffer" : void 0;
				}, a$36.checkSupport = function(e$60) {
					if (!o$34[e$60.toLowerCase()]) throw new Error(e$60 + " is not supported by this platform");
				}, a$36.MAX_VALUE_16BITS = 65535, a$36.MAX_VALUE_32BITS = -1, a$36.pretty = function(e$60) {
					var t$13, r$12, n$5 = "";
					for (r$12 = 0; r$12 < (e$60 || "").length; r$12++) n$5 += "\\x" + ((t$13 = e$60.charCodeAt(r$12)) < 16 ? "0" : "") + t$13.toString(16).toUpperCase();
					return n$5;
				}, a$36.delay = function(e$60, t$13, r$12) {
					setImmediate(function() {
						e$60.apply(r$12 || null, t$13 || []);
					});
				}, a$36.inherits = function(e$60, t$13) {
					function r$12() {}
					r$12.prototype = t$13.prototype, e$60.prototype = new r$12();
				}, a$36.extend = function() {
					var e$60, t$13, r$12 = {};
					for (e$60 = 0; e$60 < arguments.length; e$60++) for (t$13 in arguments[e$60]) Object.prototype.hasOwnProperty.call(arguments[e$60], t$13) && void 0 === r$12[t$13] && (r$12[t$13] = arguments[e$60][t$13]);
					return r$12;
				}, a$36.prepareContent = function(r$12, e$60, n$5, i$7, s$5) {
					return u$5.Promise.resolve(e$60).then(function(n$6) {
						return o$34.blob && (n$6 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n$6))) && "undefined" != typeof FileReader ? new u$5.Promise(function(t$13, r$13) {
							var e$61 = new FileReader();
							e$61.onload = function(e$62) {
								t$13(e$62.target.result);
							}, e$61.onerror = function(e$62) {
								r$13(e$62.target.error);
							}, e$61.readAsArrayBuffer(n$6);
						}) : n$6;
					}).then(function(e$61) {
						var t$13 = a$36.getTypeOf(e$61);
						return t$13 ? ("arraybuffer" === t$13 ? e$61 = a$36.transformTo("uint8array", e$61) : "string" === t$13 && (s$5 ? e$61 = h$5.decode(e$61) : n$5 && !0 !== i$7 && (e$61 = function(e$62) {
							return l$10(e$62, o$34.uint8array ? new Uint8Array(e$62.length) : new Array(e$62.length));
						}(e$61))), e$61) : u$5.Promise.reject(/* @__PURE__ */ new Error("Can't read the data of '" + r$12 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
					});
				};
			}, {
				"./base64": 1,
				"./external": 6,
				"./nodejsUtils": 14,
				"./support": 30,
				setimmediate: 54
			}],
			33: [function(e$59, t$12, r$11) {
				"use strict";
				var n$4 = e$59("./reader/readerFor"), i$6 = e$59("./utils"), s$4 = e$59("./signature"), a$36 = e$59("./zipEntry"), o$34 = e$59("./support");
				function h$5(e$60) {
					this.files = [], this.loadOptions = e$60;
				}
				h$5.prototype = {
					checkSignature: function(e$60) {
						if (!this.reader.readAndCheckSignature(e$60)) {
							this.reader.index -= 4;
							var t$13 = this.reader.readString(4);
							throw new Error("Corrupted zip or bug: unexpected signature (" + i$6.pretty(t$13) + ", expected " + i$6.pretty(e$60) + ")");
						}
					},
					isSignature: function(e$60, t$13) {
						var r$12 = this.reader.index;
						this.reader.setIndex(e$60);
						var n$5 = this.reader.readString(4) === t$13;
						return this.reader.setIndex(r$12), n$5;
					},
					readBlockEndOfCentral: function() {
						this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
						var e$60 = this.reader.readData(this.zipCommentLength), t$13 = o$34.uint8array ? "uint8array" : "array", r$12 = i$6.transformTo(t$13, e$60);
						this.zipComment = this.loadOptions.decodeFileName(r$12);
					},
					readBlockZip64EndOfCentral: function() {
						this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
						for (var e$60, t$13, r$12, n$5 = this.zip64EndOfCentralSize - 44; 0 < n$5;) e$60 = this.reader.readInt(2), t$13 = this.reader.readInt(4), r$12 = this.reader.readData(t$13), this.zip64ExtensibleData[e$60] = {
							id: e$60,
							length: t$13,
							value: r$12
						};
					},
					readBlockZip64EndOfCentralLocator: function() {
						if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
					},
					readLocalFiles: function() {
						var e$60, t$13;
						for (e$60 = 0; e$60 < this.files.length; e$60++) t$13 = this.files[e$60], this.reader.setIndex(t$13.localHeaderOffset), this.checkSignature(s$4.LOCAL_FILE_HEADER), t$13.readLocalPart(this.reader), t$13.handleUTF8(), t$13.processAttributes();
					},
					readCentralDir: function() {
						var e$60;
						for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s$4.CENTRAL_FILE_HEADER);) (e$60 = new a$36({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e$60);
						if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
					},
					readEndOfCentral: function() {
						var e$60 = this.reader.lastIndexOfSignature(s$4.CENTRAL_DIRECTORY_END);
						if (e$60 < 0) throw !this.isSignature(0, s$4.LOCAL_FILE_HEADER) ? /* @__PURE__ */ new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : /* @__PURE__ */ new Error("Corrupted zip: can't find end of central directory");
						this.reader.setIndex(e$60);
						var t$13 = e$60;
						if (this.checkSignature(s$4.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i$6.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i$6.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i$6.MAX_VALUE_16BITS || this.centralDirRecords === i$6.MAX_VALUE_16BITS || this.centralDirSize === i$6.MAX_VALUE_32BITS || this.centralDirOffset === i$6.MAX_VALUE_32BITS) {
							if (this.zip64 = !0, (e$60 = this.reader.lastIndexOfSignature(s$4.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
							if (this.reader.setIndex(e$60), this.checkSignature(s$4.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s$4.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s$4.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
							this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s$4.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
						}
						var r$12 = this.centralDirOffset + this.centralDirSize;
						this.zip64 && (r$12 += 20, r$12 += 12 + this.zip64EndOfCentralSize);
						var n$5 = t$13 - r$12;
						if (0 < n$5) this.isSignature(t$13, s$4.CENTRAL_FILE_HEADER) || (this.reader.zero = n$5);
						else if (n$5 < 0) throw new Error("Corrupted zip: missing " + Math.abs(n$5) + " bytes.");
					},
					prepareReader: function(e$60) {
						this.reader = n$4(e$60);
					},
					load: function(e$60) {
						this.prepareReader(e$60), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
					}
				}, t$12.exports = h$5;
			}, {
				"./reader/readerFor": 22,
				"./signature": 23,
				"./support": 30,
				"./utils": 32,
				"./zipEntry": 34
			}],
			34: [function(e$59, t$12, r$11) {
				"use strict";
				var n$4 = e$59("./reader/readerFor"), s$4 = e$59("./utils"), i$6 = e$59("./compressedObject"), a$36 = e$59("./crc32"), o$34 = e$59("./utf8"), h$5 = e$59("./compressions"), u$5 = e$59("./support");
				function l$10(e$60, t$13) {
					this.options = e$60, this.loadOptions = t$13;
				}
				l$10.prototype = {
					isEncrypted: function() {
						return 1 == (1 & this.bitFlag);
					},
					useUTF8: function() {
						return 2048 == (2048 & this.bitFlag);
					},
					readLocalPart: function(e$60) {
						var t$13, r$12;
						if (e$60.skip(22), this.fileNameLength = e$60.readInt(2), r$12 = e$60.readInt(2), this.fileName = e$60.readData(this.fileNameLength), e$60.skip(r$12), -1 === this.compressedSize || -1 === this.uncompressedSize) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
						if (null === (t$13 = function(e$61) {
							for (var t$14 in h$5) if (Object.prototype.hasOwnProperty.call(h$5, t$14) && h$5[t$14].magic === e$61) return h$5[t$14];
							return null;
						}(this.compressionMethod))) throw new Error("Corrupted zip : compression " + s$4.pretty(this.compressionMethod) + " unknown (inner file : " + s$4.transformTo("string", this.fileName) + ")");
						this.decompressed = new i$6(this.compressedSize, this.uncompressedSize, this.crc32, t$13, e$60.readData(this.compressedSize));
					},
					readCentralPart: function(e$60) {
						this.versionMadeBy = e$60.readInt(2), e$60.skip(2), this.bitFlag = e$60.readInt(2), this.compressionMethod = e$60.readString(2), this.date = e$60.readDate(), this.crc32 = e$60.readInt(4), this.compressedSize = e$60.readInt(4), this.uncompressedSize = e$60.readInt(4);
						var t$13 = e$60.readInt(2);
						if (this.extraFieldsLength = e$60.readInt(2), this.fileCommentLength = e$60.readInt(2), this.diskNumberStart = e$60.readInt(2), this.internalFileAttributes = e$60.readInt(2), this.externalFileAttributes = e$60.readInt(4), this.localHeaderOffset = e$60.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
						e$60.skip(t$13), this.readExtraFields(e$60), this.parseZIP64ExtraField(e$60), this.fileComment = e$60.readData(this.fileCommentLength);
					},
					processAttributes: function() {
						this.unixPermissions = null, this.dosPermissions = null;
						var e$60 = this.versionMadeBy >> 8;
						this.dir = !!(16 & this.externalFileAttributes), 0 == e$60 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e$60 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = !0);
					},
					parseZIP64ExtraField: function() {
						if (this.extraFields[1]) {
							var e$60 = n$4(this.extraFields[1].value);
							this.uncompressedSize === s$4.MAX_VALUE_32BITS && (this.uncompressedSize = e$60.readInt(8)), this.compressedSize === s$4.MAX_VALUE_32BITS && (this.compressedSize = e$60.readInt(8)), this.localHeaderOffset === s$4.MAX_VALUE_32BITS && (this.localHeaderOffset = e$60.readInt(8)), this.diskNumberStart === s$4.MAX_VALUE_32BITS && (this.diskNumberStart = e$60.readInt(4));
						}
					},
					readExtraFields: function(e$60) {
						var t$13, r$12, n$5, i$7 = e$60.index + this.extraFieldsLength;
						for (this.extraFields || (this.extraFields = {}); e$60.index + 4 < i$7;) t$13 = e$60.readInt(2), r$12 = e$60.readInt(2), n$5 = e$60.readData(r$12), this.extraFields[t$13] = {
							id: t$13,
							length: r$12,
							value: n$5
						};
						e$60.setIndex(i$7);
					},
					handleUTF8: function() {
						var e$60 = u$5.uint8array ? "uint8array" : "array";
						if (this.useUTF8()) this.fileNameStr = o$34.utf8decode(this.fileName), this.fileCommentStr = o$34.utf8decode(this.fileComment);
						else {
							var t$13 = this.findExtraFieldUnicodePath();
							if (null !== t$13) this.fileNameStr = t$13;
							else {
								var r$12 = s$4.transformTo(e$60, this.fileName);
								this.fileNameStr = this.loadOptions.decodeFileName(r$12);
							}
							var n$5 = this.findExtraFieldUnicodeComment();
							if (null !== n$5) this.fileCommentStr = n$5;
							else {
								var i$7 = s$4.transformTo(e$60, this.fileComment);
								this.fileCommentStr = this.loadOptions.decodeFileName(i$7);
							}
						}
					},
					findExtraFieldUnicodePath: function() {
						var e$60 = this.extraFields[28789];
						if (e$60) {
							var t$13 = n$4(e$60.value);
							return 1 !== t$13.readInt(1) ? null : a$36(this.fileName) !== t$13.readInt(4) ? null : o$34.utf8decode(t$13.readData(e$60.length - 5));
						}
						return null;
					},
					findExtraFieldUnicodeComment: function() {
						var e$60 = this.extraFields[25461];
						if (e$60) {
							var t$13 = n$4(e$60.value);
							return 1 !== t$13.readInt(1) ? null : a$36(this.fileComment) !== t$13.readInt(4) ? null : o$34.utf8decode(t$13.readData(e$60.length - 5));
						}
						return null;
					}
				}, t$12.exports = l$10;
			}, {
				"./compressedObject": 2,
				"./compressions": 3,
				"./crc32": 4,
				"./reader/readerFor": 22,
				"./support": 30,
				"./utf8": 31,
				"./utils": 32
			}],
			35: [function(e$59, t$12, r$11) {
				"use strict";
				function n$4(e$60, t$13, r$12) {
					this.name = e$60, this.dir = r$12.dir, this.date = r$12.date, this.comment = r$12.comment, this.unixPermissions = r$12.unixPermissions, this.dosPermissions = r$12.dosPermissions, this._data = t$13, this._dataBinary = r$12.binary, this.options = {
						compression: r$12.compression,
						compressionOptions: r$12.compressionOptions
					};
				}
				var s$4 = e$59("./stream/StreamHelper"), i$6 = e$59("./stream/DataWorker"), a$36 = e$59("./utf8"), o$34 = e$59("./compressedObject"), h$5 = e$59("./stream/GenericWorker");
				n$4.prototype = {
					internalStream: function(e$60) {
						var t$13 = null, r$12 = "string";
						try {
							if (!e$60) throw new Error("No output type specified.");
							var n$5 = "string" === (r$12 = e$60.toLowerCase()) || "text" === r$12;
							"binarystring" !== r$12 && "text" !== r$12 || (r$12 = "string"), t$13 = this._decompressWorker();
							var i$7 = !this._dataBinary;
							i$7 && !n$5 && (t$13 = t$13.pipe(new a$36.Utf8EncodeWorker())), !i$7 && n$5 && (t$13 = t$13.pipe(new a$36.Utf8DecodeWorker()));
						} catch (e$61) {
							(t$13 = new h$5("error")).error(e$61);
						}
						return new s$4(t$13, r$12, "");
					},
					async: function(e$60, t$13) {
						return this.internalStream(e$60).accumulate(t$13);
					},
					nodeStream: function(e$60, t$13) {
						return this.internalStream(e$60 || "nodebuffer").toNodejsStream(t$13);
					},
					_compressWorker: function(e$60, t$13) {
						if (this._data instanceof o$34 && this._data.compression.magic === e$60.magic) return this._data.getCompressedWorker();
						var r$12 = this._decompressWorker();
						return this._dataBinary || (r$12 = r$12.pipe(new a$36.Utf8EncodeWorker())), o$34.createWorkerFrom(r$12, e$60, t$13);
					},
					_decompressWorker: function() {
						return this._data instanceof o$34 ? this._data.getContentWorker() : this._data instanceof h$5 ? this._data : new i$6(this._data);
					}
				};
				for (var u$5 = [
					"asText",
					"asBinary",
					"asNodeBuffer",
					"asUint8Array",
					"asArrayBuffer"
				], l$10 = function() {
					throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
				}, f$5 = 0; f$5 < u$5.length; f$5++) n$4.prototype[u$5[f$5]] = l$10;
				t$12.exports = n$4;
			}, {
				"./compressedObject": 2,
				"./stream/DataWorker": 27,
				"./stream/GenericWorker": 28,
				"./stream/StreamHelper": 29,
				"./utf8": 31
			}],
			36: [function(e$59, l$10, t$12) {
				(function(t$13) {
					"use strict";
					var r$11, n$4, e$60 = t$13.MutationObserver || t$13.WebKitMutationObserver;
					if (e$60) {
						var i$6 = 0, s$4 = new e$60(u$5), a$36 = t$13.document.createTextNode("");
						s$4.observe(a$36, { characterData: !0 }), r$11 = function() {
							a$36.data = i$6 = ++i$6 % 2;
						};
					} else if (t$13.setImmediate || void 0 === t$13.MessageChannel) r$11 = "document" in t$13 && "onreadystatechange" in t$13.document.createElement("script") ? function() {
						var e$61 = t$13.document.createElement("script");
						e$61.onreadystatechange = function() {
							u$5(), e$61.onreadystatechange = null, e$61.parentNode.removeChild(e$61), e$61 = null;
						}, t$13.document.documentElement.appendChild(e$61);
					} : function() {
						setTimeout(u$5, 0);
					};
					else {
						var o$34 = new t$13.MessageChannel();
						o$34.port1.onmessage = u$5, r$11 = function() {
							o$34.port2.postMessage(0);
						};
					}
					var h$5 = [];
					function u$5() {
						var e$61, t$14;
						n$4 = !0;
						for (var r$12 = h$5.length; r$12;) {
							for (t$14 = h$5, h$5 = [], e$61 = -1; ++e$61 < r$12;) t$14[e$61]();
							r$12 = h$5.length;
						}
						n$4 = !1;
					}
					l$10.exports = function(e$61) {
						1 !== h$5.push(e$61) || n$4 || r$11();
					};
				}).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
			}, {}],
			37: [function(e$59, t$12, r$11) {
				"use strict";
				var i$6 = e$59("immediate");
				function u$5() {}
				var l$10 = {}, s$4 = ["REJECTED"], a$36 = ["FULFILLED"], n$4 = ["PENDING"];
				function o$34(e$60) {
					if ("function" != typeof e$60) throw new TypeError("resolver must be a function");
					this.state = n$4, this.queue = [], this.outcome = void 0, e$60 !== u$5 && d$5(this, e$60);
				}
				function h$5(e$60, t$13, r$12) {
					this.promise = e$60, "function" == typeof t$13 && (this.onFulfilled = t$13, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r$12 && (this.onRejected = r$12, this.callRejected = this.otherCallRejected);
				}
				function f$5(t$13, r$12, n$5) {
					i$6(function() {
						var e$60;
						try {
							e$60 = r$12(n$5);
						} catch (e$61) {
							return l$10.reject(t$13, e$61);
						}
						e$60 === t$13 ? l$10.reject(t$13, /* @__PURE__ */ new TypeError("Cannot resolve promise with itself")) : l$10.resolve(t$13, e$60);
					});
				}
				function c$7(e$60) {
					var t$13 = e$60 && e$60.then;
					if (e$60 && ("object" == typeof e$60 || "function" == typeof e$60) && "function" == typeof t$13) return function() {
						t$13.apply(e$60, arguments);
					};
				}
				function d$5(t$13, e$60) {
					var r$12 = !1;
					function n$5(e$61) {
						r$12 || (r$12 = !0, l$10.reject(t$13, e$61));
					}
					function i$7(e$61) {
						r$12 || (r$12 = !0, l$10.resolve(t$13, e$61));
					}
					var s$5 = p$6(function() {
						e$60(i$7, n$5);
					});
					"error" === s$5.status && n$5(s$5.value);
				}
				function p$6(e$60, t$13) {
					var r$12 = {};
					try {
						r$12.value = e$60(t$13), r$12.status = "success";
					} catch (e$61) {
						r$12.status = "error", r$12.value = e$61;
					}
					return r$12;
				}
				(t$12.exports = o$34).prototype.finally = function(t$13) {
					if ("function" != typeof t$13) return this;
					var r$12 = this.constructor;
					return this.then(function(e$60) {
						return r$12.resolve(t$13()).then(function() {
							return e$60;
						});
					}, function(e$60) {
						return r$12.resolve(t$13()).then(function() {
							throw e$60;
						});
					});
				}, o$34.prototype.catch = function(e$60) {
					return this.then(null, e$60);
				}, o$34.prototype.then = function(e$60, t$13) {
					if ("function" != typeof e$60 && this.state === a$36 || "function" != typeof t$13 && this.state === s$4) return this;
					var r$12 = new this.constructor(u$5);
					this.state !== n$4 ? f$5(r$12, this.state === a$36 ? e$60 : t$13, this.outcome) : this.queue.push(new h$5(r$12, e$60, t$13));
					return r$12;
				}, h$5.prototype.callFulfilled = function(e$60) {
					l$10.resolve(this.promise, e$60);
				}, h$5.prototype.otherCallFulfilled = function(e$60) {
					f$5(this.promise, this.onFulfilled, e$60);
				}, h$5.prototype.callRejected = function(e$60) {
					l$10.reject(this.promise, e$60);
				}, h$5.prototype.otherCallRejected = function(e$60) {
					f$5(this.promise, this.onRejected, e$60);
				}, l$10.resolve = function(e$60, t$13) {
					var r$12 = p$6(c$7, t$13);
					if ("error" === r$12.status) return l$10.reject(e$60, r$12.value);
					var n$5 = r$12.value;
					if (n$5) d$5(e$60, n$5);
					else {
						e$60.state = a$36, e$60.outcome = t$13;
						for (var i$7 = -1, s$5 = e$60.queue.length; ++i$7 < s$5;) e$60.queue[i$7].callFulfilled(t$13);
					}
					return e$60;
				}, l$10.reject = function(e$60, t$13) {
					e$60.state = s$4, e$60.outcome = t$13;
					for (var r$12 = -1, n$5 = e$60.queue.length; ++r$12 < n$5;) e$60.queue[r$12].callRejected(t$13);
					return e$60;
				}, o$34.resolve = function(e$60) {
					if (e$60 instanceof this) return e$60;
					return l$10.resolve(new this(u$5), e$60);
				}, o$34.reject = function(e$60) {
					var t$13 = new this(u$5);
					return l$10.reject(t$13, e$60);
				}, o$34.all = function(e$60) {
					var r$12 = this;
					if ("[object Array]" !== Object.prototype.toString.call(e$60)) return this.reject(/* @__PURE__ */ new TypeError("must be an array"));
					var n$5 = e$60.length, i$7 = !1;
					if (!n$5) return this.resolve([]);
					var s$5 = new Array(n$5), a$37 = 0, t$13 = -1, o$35 = new this(u$5);
					for (; ++t$13 < n$5;) h$6(e$60[t$13], t$13);
					return o$35;
					function h$6(e$61, t$14) {
						r$12.resolve(e$61).then(function(e$62) {
							s$5[t$14] = e$62, ++a$37 !== n$5 || i$7 || (i$7 = !0, l$10.resolve(o$35, s$5));
						}, function(e$62) {
							i$7 || (i$7 = !0, l$10.reject(o$35, e$62));
						});
					}
				}, o$34.race = function(e$60) {
					var t$13 = this;
					if ("[object Array]" !== Object.prototype.toString.call(e$60)) return this.reject(/* @__PURE__ */ new TypeError("must be an array"));
					var r$12 = e$60.length, n$5 = !1;
					if (!r$12) return this.resolve([]);
					var i$7 = -1, s$5 = new this(u$5);
					for (; ++i$7 < r$12;) a$37 = e$60[i$7], t$13.resolve(a$37).then(function(e$61) {
						n$5 || (n$5 = !0, l$10.resolve(s$5, e$61));
					}, function(e$61) {
						n$5 || (n$5 = !0, l$10.reject(s$5, e$61));
					});
					var a$37;
					return s$5;
				};
			}, { immediate: 36 }],
			38: [function(e$59, t$12, r$11) {
				"use strict";
				var n$4 = {};
				(0, e$59("./lib/utils/common").assign)(n$4, e$59("./lib/deflate"), e$59("./lib/inflate"), e$59("./lib/zlib/constants")), t$12.exports = n$4;
			}, {
				"./lib/deflate": 39,
				"./lib/inflate": 40,
				"./lib/utils/common": 41,
				"./lib/zlib/constants": 44
			}],
			39: [function(e$59, t$12, r$11) {
				"use strict";
				var a$36 = e$59("./zlib/deflate"), o$34 = e$59("./utils/common"), h$5 = e$59("./utils/strings"), i$6 = e$59("./zlib/messages"), s$4 = e$59("./zlib/zstream"), u$5 = Object.prototype.toString, l$10 = 0, f$5 = -1, c$7 = 0, d$5 = 8;
				function p$6(e$60) {
					if (!(this instanceof p$6)) return new p$6(e$60);
					this.options = o$34.assign({
						level: f$5,
						method: d$5,
						chunkSize: 16384,
						windowBits: 15,
						memLevel: 8,
						strategy: c$7,
						to: ""
					}, e$60 || {});
					var t$13 = this.options;
					t$13.raw && 0 < t$13.windowBits ? t$13.windowBits = -t$13.windowBits : t$13.gzip && 0 < t$13.windowBits && t$13.windowBits < 16 && (t$13.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new s$4(), this.strm.avail_out = 0;
					var r$12 = a$36.deflateInit2(this.strm, t$13.level, t$13.method, t$13.windowBits, t$13.memLevel, t$13.strategy);
					if (r$12 !== l$10) throw new Error(i$6[r$12]);
					if (t$13.header && a$36.deflateSetHeader(this.strm, t$13.header), t$13.dictionary) {
						var n$5;
						if (n$5 = "string" == typeof t$13.dictionary ? h$5.string2buf(t$13.dictionary) : "[object ArrayBuffer]" === u$5.call(t$13.dictionary) ? new Uint8Array(t$13.dictionary) : t$13.dictionary, (r$12 = a$36.deflateSetDictionary(this.strm, n$5)) !== l$10) throw new Error(i$6[r$12]);
						this._dict_set = !0;
					}
				}
				function n$4(e$60, t$13) {
					var r$12 = new p$6(t$13);
					if (r$12.push(e$60, !0), r$12.err) throw r$12.msg || i$6[r$12.err];
					return r$12.result;
				}
				p$6.prototype.push = function(e$60, t$13) {
					var r$12, n$5, i$7 = this.strm, s$5 = this.options.chunkSize;
					if (this.ended) return !1;
					n$5 = t$13 === ~~t$13 ? t$13 : !0 === t$13 ? 4 : 0, "string" == typeof e$60 ? i$7.input = h$5.string2buf(e$60) : "[object ArrayBuffer]" === u$5.call(e$60) ? i$7.input = new Uint8Array(e$60) : i$7.input = e$60, i$7.next_in = 0, i$7.avail_in = i$7.input.length;
					do {
						if (0 === i$7.avail_out && (i$7.output = new o$34.Buf8(s$5), i$7.next_out = 0, i$7.avail_out = s$5), 1 !== (r$12 = a$36.deflate(i$7, n$5)) && r$12 !== l$10) return this.onEnd(r$12), !(this.ended = !0);
						0 !== i$7.avail_out && (0 !== i$7.avail_in || 4 !== n$5 && 2 !== n$5) || ("string" === this.options.to ? this.onData(h$5.buf2binstring(o$34.shrinkBuf(i$7.output, i$7.next_out))) : this.onData(o$34.shrinkBuf(i$7.output, i$7.next_out)));
					} while ((0 < i$7.avail_in || 0 === i$7.avail_out) && 1 !== r$12);
					return 4 === n$5 ? (r$12 = a$36.deflateEnd(this.strm), this.onEnd(r$12), this.ended = !0, r$12 === l$10) : 2 !== n$5 || (this.onEnd(l$10), !(i$7.avail_out = 0));
				}, p$6.prototype.onData = function(e$60) {
					this.chunks.push(e$60);
				}, p$6.prototype.onEnd = function(e$60) {
					e$60 === l$10 && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o$34.flattenChunks(this.chunks)), this.chunks = [], this.err = e$60, this.msg = this.strm.msg;
				}, r$11.Deflate = p$6, r$11.deflate = n$4, r$11.deflateRaw = function(e$60, t$13) {
					return (t$13 = t$13 || {}).raw = !0, n$4(e$60, t$13);
				}, r$11.gzip = function(e$60, t$13) {
					return (t$13 = t$13 || {}).gzip = !0, n$4(e$60, t$13);
				};
			}, {
				"./utils/common": 41,
				"./utils/strings": 42,
				"./zlib/deflate": 46,
				"./zlib/messages": 51,
				"./zlib/zstream": 53
			}],
			40: [function(e$59, t$12, r$11) {
				"use strict";
				var c$7 = e$59("./zlib/inflate"), d$5 = e$59("./utils/common"), p$6 = e$59("./utils/strings"), m$5 = e$59("./zlib/constants"), n$4 = e$59("./zlib/messages"), i$6 = e$59("./zlib/zstream"), s$4 = e$59("./zlib/gzheader"), _$5 = Object.prototype.toString;
				function a$36(e$60) {
					if (!(this instanceof a$36)) return new a$36(e$60);
					this.options = d$5.assign({
						chunkSize: 16384,
						windowBits: 0,
						to: ""
					}, e$60 || {});
					var t$13 = this.options;
					t$13.raw && 0 <= t$13.windowBits && t$13.windowBits < 16 && (t$13.windowBits = -t$13.windowBits, 0 === t$13.windowBits && (t$13.windowBits = -15)), !(0 <= t$13.windowBits && t$13.windowBits < 16) || e$60 && e$60.windowBits || (t$13.windowBits += 32), 15 < t$13.windowBits && t$13.windowBits < 48 && 0 == (15 & t$13.windowBits) && (t$13.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new i$6(), this.strm.avail_out = 0;
					var r$12 = c$7.inflateInit2(this.strm, t$13.windowBits);
					if (r$12 !== m$5.Z_OK) throw new Error(n$4[r$12]);
					this.header = new s$4(), c$7.inflateGetHeader(this.strm, this.header);
				}
				function o$34(e$60, t$13) {
					var r$12 = new a$36(t$13);
					if (r$12.push(e$60, !0), r$12.err) throw r$12.msg || n$4[r$12.err];
					return r$12.result;
				}
				a$36.prototype.push = function(e$60, t$13) {
					var r$12, n$5, i$7, s$5, a$37, o$35, h$5 = this.strm, u$5 = this.options.chunkSize, l$10 = this.options.dictionary, f$5 = !1;
					if (this.ended) return !1;
					n$5 = t$13 === ~~t$13 ? t$13 : !0 === t$13 ? m$5.Z_FINISH : m$5.Z_NO_FLUSH, "string" == typeof e$60 ? h$5.input = p$6.binstring2buf(e$60) : "[object ArrayBuffer]" === _$5.call(e$60) ? h$5.input = new Uint8Array(e$60) : h$5.input = e$60, h$5.next_in = 0, h$5.avail_in = h$5.input.length;
					do {
						if (0 === h$5.avail_out && (h$5.output = new d$5.Buf8(u$5), h$5.next_out = 0, h$5.avail_out = u$5), (r$12 = c$7.inflate(h$5, m$5.Z_NO_FLUSH)) === m$5.Z_NEED_DICT && l$10 && (o$35 = "string" == typeof l$10 ? p$6.string2buf(l$10) : "[object ArrayBuffer]" === _$5.call(l$10) ? new Uint8Array(l$10) : l$10, r$12 = c$7.inflateSetDictionary(this.strm, o$35)), r$12 === m$5.Z_BUF_ERROR && !0 === f$5 && (r$12 = m$5.Z_OK, f$5 = !1), r$12 !== m$5.Z_STREAM_END && r$12 !== m$5.Z_OK) return this.onEnd(r$12), !(this.ended = !0);
						h$5.next_out && (0 !== h$5.avail_out && r$12 !== m$5.Z_STREAM_END && (0 !== h$5.avail_in || n$5 !== m$5.Z_FINISH && n$5 !== m$5.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i$7 = p$6.utf8border(h$5.output, h$5.next_out), s$5 = h$5.next_out - i$7, a$37 = p$6.buf2string(h$5.output, i$7), h$5.next_out = s$5, h$5.avail_out = u$5 - s$5, s$5 && d$5.arraySet(h$5.output, h$5.output, i$7, s$5, 0), this.onData(a$37)) : this.onData(d$5.shrinkBuf(h$5.output, h$5.next_out)))), 0 === h$5.avail_in && 0 === h$5.avail_out && (f$5 = !0);
					} while ((0 < h$5.avail_in || 0 === h$5.avail_out) && r$12 !== m$5.Z_STREAM_END);
					return r$12 === m$5.Z_STREAM_END && (n$5 = m$5.Z_FINISH), n$5 === m$5.Z_FINISH ? (r$12 = c$7.inflateEnd(this.strm), this.onEnd(r$12), this.ended = !0, r$12 === m$5.Z_OK) : n$5 !== m$5.Z_SYNC_FLUSH || (this.onEnd(m$5.Z_OK), !(h$5.avail_out = 0));
				}, a$36.prototype.onData = function(e$60) {
					this.chunks.push(e$60);
				}, a$36.prototype.onEnd = function(e$60) {
					e$60 === m$5.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d$5.flattenChunks(this.chunks)), this.chunks = [], this.err = e$60, this.msg = this.strm.msg;
				}, r$11.Inflate = a$36, r$11.inflate = o$34, r$11.inflateRaw = function(e$60, t$13) {
					return (t$13 = t$13 || {}).raw = !0, o$34(e$60, t$13);
				}, r$11.ungzip = o$34;
			}, {
				"./utils/common": 41,
				"./utils/strings": 42,
				"./zlib/constants": 44,
				"./zlib/gzheader": 47,
				"./zlib/inflate": 49,
				"./zlib/messages": 51,
				"./zlib/zstream": 53
			}],
			41: [function(e$59, t$12, r$11) {
				"use strict";
				var n$4 = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
				r$11.assign = function(e$60) {
					for (var t$13 = Array.prototype.slice.call(arguments, 1); t$13.length;) {
						var r$12 = t$13.shift();
						if (r$12) {
							if ("object" != typeof r$12) throw new TypeError(r$12 + "must be non-object");
							for (var n$5 in r$12) r$12.hasOwnProperty(n$5) && (e$60[n$5] = r$12[n$5]);
						}
					}
					return e$60;
				}, r$11.shrinkBuf = function(e$60, t$13) {
					return e$60.length === t$13 ? e$60 : e$60.subarray ? e$60.subarray(0, t$13) : (e$60.length = t$13, e$60);
				};
				var i$6 = {
					arraySet: function(e$60, t$13, r$12, n$5, i$7) {
						if (t$13.subarray && e$60.subarray) e$60.set(t$13.subarray(r$12, r$12 + n$5), i$7);
						else for (var s$5 = 0; s$5 < n$5; s$5++) e$60[i$7 + s$5] = t$13[r$12 + s$5];
					},
					flattenChunks: function(e$60) {
						var t$13, r$12, n$5, i$7, s$5, a$36;
						for (t$13 = n$5 = 0, r$12 = e$60.length; t$13 < r$12; t$13++) n$5 += e$60[t$13].length;
						for (a$36 = new Uint8Array(n$5), t$13 = i$7 = 0, r$12 = e$60.length; t$13 < r$12; t$13++) s$5 = e$60[t$13], a$36.set(s$5, i$7), i$7 += s$5.length;
						return a$36;
					}
				}, s$4 = {
					arraySet: function(e$60, t$13, r$12, n$5, i$7) {
						for (var s$5 = 0; s$5 < n$5; s$5++) e$60[i$7 + s$5] = t$13[r$12 + s$5];
					},
					flattenChunks: function(e$60) {
						return [].concat.apply([], e$60);
					}
				};
				r$11.setTyped = function(e$60) {
					e$60 ? (r$11.Buf8 = Uint8Array, r$11.Buf16 = Uint16Array, r$11.Buf32 = Int32Array, r$11.assign(r$11, i$6)) : (r$11.Buf8 = Array, r$11.Buf16 = Array, r$11.Buf32 = Array, r$11.assign(r$11, s$4));
				}, r$11.setTyped(n$4);
			}, {}],
			42: [function(e$59, t$12, r$11) {
				"use strict";
				var h$5 = e$59("./common"), i$6 = !0, s$4 = !0;
				try {
					String.fromCharCode.apply(null, [0]);
				} catch (e$60) {
					i$6 = !1;
				}
				try {
					String.fromCharCode.apply(null, new Uint8Array(1));
				} catch (e$60) {
					s$4 = !1;
				}
				for (var u$5 = new h$5.Buf8(256), n$4 = 0; n$4 < 256; n$4++) u$5[n$4] = 252 <= n$4 ? 6 : 248 <= n$4 ? 5 : 240 <= n$4 ? 4 : 224 <= n$4 ? 3 : 192 <= n$4 ? 2 : 1;
				function l$10(e$60, t$13) {
					if (t$13 < 65537 && (e$60.subarray && s$4 || !e$60.subarray && i$6)) return String.fromCharCode.apply(null, h$5.shrinkBuf(e$60, t$13));
					for (var r$12 = "", n$5 = 0; n$5 < t$13; n$5++) r$12 += String.fromCharCode(e$60[n$5]);
					return r$12;
				}
				u$5[254] = u$5[254] = 1, r$11.string2buf = function(e$60) {
					var t$13, r$12, n$5, i$7, s$5, a$36 = e$60.length, o$34 = 0;
					for (i$7 = 0; i$7 < a$36; i$7++) 55296 == (64512 & (r$12 = e$60.charCodeAt(i$7))) && i$7 + 1 < a$36 && 56320 == (64512 & (n$5 = e$60.charCodeAt(i$7 + 1))) && (r$12 = 65536 + (r$12 - 55296 << 10) + (n$5 - 56320), i$7++), o$34 += r$12 < 128 ? 1 : r$12 < 2048 ? 2 : r$12 < 65536 ? 3 : 4;
					for (t$13 = new h$5.Buf8(o$34), i$7 = s$5 = 0; s$5 < o$34; i$7++) 55296 == (64512 & (r$12 = e$60.charCodeAt(i$7))) && i$7 + 1 < a$36 && 56320 == (64512 & (n$5 = e$60.charCodeAt(i$7 + 1))) && (r$12 = 65536 + (r$12 - 55296 << 10) + (n$5 - 56320), i$7++), r$12 < 128 ? t$13[s$5++] = r$12 : (r$12 < 2048 ? t$13[s$5++] = 192 | r$12 >>> 6 : (r$12 < 65536 ? t$13[s$5++] = 224 | r$12 >>> 12 : (t$13[s$5++] = 240 | r$12 >>> 18, t$13[s$5++] = 128 | r$12 >>> 12 & 63), t$13[s$5++] = 128 | r$12 >>> 6 & 63), t$13[s$5++] = 128 | 63 & r$12);
					return t$13;
				}, r$11.buf2binstring = function(e$60) {
					return l$10(e$60, e$60.length);
				}, r$11.binstring2buf = function(e$60) {
					for (var t$13 = new h$5.Buf8(e$60.length), r$12 = 0, n$5 = t$13.length; r$12 < n$5; r$12++) t$13[r$12] = e$60.charCodeAt(r$12);
					return t$13;
				}, r$11.buf2string = function(e$60, t$13) {
					var r$12, n$5, i$7, s$5, a$36 = t$13 || e$60.length, o$34 = new Array(2 * a$36);
					for (r$12 = n$5 = 0; r$12 < a$36;) if ((i$7 = e$60[r$12++]) < 128) o$34[n$5++] = i$7;
					else if (4 < (s$5 = u$5[i$7])) o$34[n$5++] = 65533, r$12 += s$5 - 1;
					else {
						for (i$7 &= 2 === s$5 ? 31 : 3 === s$5 ? 15 : 7; 1 < s$5 && r$12 < a$36;) i$7 = i$7 << 6 | 63 & e$60[r$12++], s$5--;
						1 < s$5 ? o$34[n$5++] = 65533 : i$7 < 65536 ? o$34[n$5++] = i$7 : (i$7 -= 65536, o$34[n$5++] = 55296 | i$7 >> 10 & 1023, o$34[n$5++] = 56320 | 1023 & i$7);
					}
					return l$10(o$34, n$5);
				}, r$11.utf8border = function(e$60, t$13) {
					var r$12;
					for ((t$13 = t$13 || e$60.length) > e$60.length && (t$13 = e$60.length), r$12 = t$13 - 1; 0 <= r$12 && 128 == (192 & e$60[r$12]);) r$12--;
					return r$12 < 0 ? t$13 : 0 === r$12 ? t$13 : r$12 + u$5[e$60[r$12]] > t$13 ? r$12 : t$13;
				};
			}, { "./common": 41 }],
			43: [function(e$59, t$12, r$11) {
				"use strict";
				t$12.exports = function(e$60, t$13, r$12, n$4) {
					for (var i$6 = 65535 & e$60 | 0, s$4 = e$60 >>> 16 & 65535 | 0, a$36 = 0; 0 !== r$12;) {
						for (r$12 -= a$36 = 2e3 < r$12 ? 2e3 : r$12; s$4 = s$4 + (i$6 = i$6 + t$13[n$4++] | 0) | 0, --a$36;);
						i$6 %= 65521, s$4 %= 65521;
					}
					return i$6 | s$4 << 16 | 0;
				};
			}, {}],
			44: [function(e$59, t$12, r$11) {
				"use strict";
				t$12.exports = {
					Z_NO_FLUSH: 0,
					Z_PARTIAL_FLUSH: 1,
					Z_SYNC_FLUSH: 2,
					Z_FULL_FLUSH: 3,
					Z_FINISH: 4,
					Z_BLOCK: 5,
					Z_TREES: 6,
					Z_OK: 0,
					Z_STREAM_END: 1,
					Z_NEED_DICT: 2,
					Z_ERRNO: -1,
					Z_STREAM_ERROR: -2,
					Z_DATA_ERROR: -3,
					Z_BUF_ERROR: -5,
					Z_NO_COMPRESSION: 0,
					Z_BEST_SPEED: 1,
					Z_BEST_COMPRESSION: 9,
					Z_DEFAULT_COMPRESSION: -1,
					Z_FILTERED: 1,
					Z_HUFFMAN_ONLY: 2,
					Z_RLE: 3,
					Z_FIXED: 4,
					Z_DEFAULT_STRATEGY: 0,
					Z_BINARY: 0,
					Z_TEXT: 1,
					Z_UNKNOWN: 2,
					Z_DEFLATED: 8
				};
			}, {}],
			45: [function(e$59, t$12, r$11) {
				"use strict";
				var o$34 = function() {
					for (var e$60, t$13 = [], r$12 = 0; r$12 < 256; r$12++) {
						e$60 = r$12;
						for (var n$4 = 0; n$4 < 8; n$4++) e$60 = 1 & e$60 ? 3988292384 ^ e$60 >>> 1 : e$60 >>> 1;
						t$13[r$12] = e$60;
					}
					return t$13;
				}();
				t$12.exports = function(e$60, t$13, r$12, n$4) {
					var i$6 = o$34, s$4 = n$4 + r$12;
					e$60 ^= -1;
					for (var a$36 = n$4; a$36 < s$4; a$36++) e$60 = e$60 >>> 8 ^ i$6[255 & (e$60 ^ t$13[a$36])];
					return -1 ^ e$60;
				};
			}, {}],
			46: [function(e$59, t$12, r$11) {
				"use strict";
				var h$5, c$7 = e$59("../utils/common"), u$5 = e$59("./trees"), d$5 = e$59("./adler32"), p$6 = e$59("./crc32"), n$4 = e$59("./messages"), l$10 = 0, f$5 = 4, m$5 = 0, _$5 = -2, g$5 = -1, b$4 = 4, i$6 = 2, v$4 = 8, y$5 = 9, s$4 = 286, a$36 = 30, o$34 = 19, w$5 = 2 * s$4 + 1, k$4 = 15, x$4 = 3, S$3 = 258, z$3 = S$3 + x$4 + 1, C$4 = 42, E$4 = 113, A$3 = 1, I$2 = 2, O$3 = 3, B$4 = 4;
				function R$2(e$60, t$13) {
					return e$60.msg = n$4[t$13], t$13;
				}
				function T$4(e$60) {
					return (e$60 << 1) - (4 < e$60 ? 9 : 0);
				}
				function D$4(e$60) {
					for (var t$13 = e$60.length; 0 <= --t$13;) e$60[t$13] = 0;
				}
				function F$4(e$60) {
					var t$13 = e$60.state, r$12 = t$13.pending;
					r$12 > e$60.avail_out && (r$12 = e$60.avail_out), 0 !== r$12 && (c$7.arraySet(e$60.output, t$13.pending_buf, t$13.pending_out, r$12, e$60.next_out), e$60.next_out += r$12, t$13.pending_out += r$12, e$60.total_out += r$12, e$60.avail_out -= r$12, t$13.pending -= r$12, 0 === t$13.pending && (t$13.pending_out = 0));
				}
				function N$3(e$60, t$13) {
					u$5._tr_flush_block(e$60, 0 <= e$60.block_start ? e$60.block_start : -1, e$60.strstart - e$60.block_start, t$13), e$60.block_start = e$60.strstart, F$4(e$60.strm);
				}
				function U$2(e$60, t$13) {
					e$60.pending_buf[e$60.pending++] = t$13;
				}
				function P$3(e$60, t$13) {
					e$60.pending_buf[e$60.pending++] = t$13 >>> 8 & 255, e$60.pending_buf[e$60.pending++] = 255 & t$13;
				}
				function L$3(e$60, t$13) {
					var r$12, n$5, i$7 = e$60.max_chain_length, s$5 = e$60.strstart, a$37 = e$60.prev_length, o$35 = e$60.nice_match, h$6 = e$60.strstart > e$60.w_size - z$3 ? e$60.strstart - (e$60.w_size - z$3) : 0, u$6 = e$60.window, l$11 = e$60.w_mask, f$6 = e$60.prev, c$8 = e$60.strstart + S$3, d$6 = u$6[s$5 + a$37 - 1], p$7 = u$6[s$5 + a$37];
					e$60.prev_length >= e$60.good_match && (i$7 >>= 2), o$35 > e$60.lookahead && (o$35 = e$60.lookahead);
					do
						if (u$6[(r$12 = t$13) + a$37] === p$7 && u$6[r$12 + a$37 - 1] === d$6 && u$6[r$12] === u$6[s$5] && u$6[++r$12] === u$6[s$5 + 1]) {
							s$5 += 2, r$12++;
							do							;
while (u$6[++s$5] === u$6[++r$12] && u$6[++s$5] === u$6[++r$12] && u$6[++s$5] === u$6[++r$12] && u$6[++s$5] === u$6[++r$12] && u$6[++s$5] === u$6[++r$12] && u$6[++s$5] === u$6[++r$12] && u$6[++s$5] === u$6[++r$12] && u$6[++s$5] === u$6[++r$12] && s$5 < c$8);
							if (n$5 = S$3 - (c$8 - s$5), s$5 = c$8 - S$3, a$37 < n$5) {
								if (e$60.match_start = t$13, o$35 <= (a$37 = n$5)) break;
								d$6 = u$6[s$5 + a$37 - 1], p$7 = u$6[s$5 + a$37];
							}
						}
					while ((t$13 = f$6[t$13 & l$11]) > h$6 && 0 != --i$7);
					return a$37 <= e$60.lookahead ? a$37 : e$60.lookahead;
				}
				function j$4(e$60) {
					var t$13, r$12, n$5, i$7, s$5, a$37, o$35, h$6, u$6, l$11, f$6 = e$60.w_size;
					do {
						if (i$7 = e$60.window_size - e$60.lookahead - e$60.strstart, e$60.strstart >= f$6 + (f$6 - z$3)) {
							for (c$7.arraySet(e$60.window, e$60.window, f$6, f$6, 0), e$60.match_start -= f$6, e$60.strstart -= f$6, e$60.block_start -= f$6, t$13 = r$12 = e$60.hash_size; n$5 = e$60.head[--t$13], e$60.head[t$13] = f$6 <= n$5 ? n$5 - f$6 : 0, --r$12;);
							for (t$13 = r$12 = f$6; n$5 = e$60.prev[--t$13], e$60.prev[t$13] = f$6 <= n$5 ? n$5 - f$6 : 0, --r$12;);
							i$7 += f$6;
						}
						if (0 === e$60.strm.avail_in) break;
						if (a$37 = e$60.strm, o$35 = e$60.window, h$6 = e$60.strstart + e$60.lookahead, u$6 = i$7, l$11 = void 0, l$11 = a$37.avail_in, u$6 < l$11 && (l$11 = u$6), r$12 = 0 === l$11 ? 0 : (a$37.avail_in -= l$11, c$7.arraySet(o$35, a$37.input, a$37.next_in, l$11, h$6), 1 === a$37.state.wrap ? a$37.adler = d$5(a$37.adler, o$35, l$11, h$6) : 2 === a$37.state.wrap && (a$37.adler = p$6(a$37.adler, o$35, l$11, h$6)), a$37.next_in += l$11, a$37.total_in += l$11, l$11), e$60.lookahead += r$12, e$60.lookahead + e$60.insert >= x$4) for (s$5 = e$60.strstart - e$60.insert, e$60.ins_h = e$60.window[s$5], e$60.ins_h = (e$60.ins_h << e$60.hash_shift ^ e$60.window[s$5 + 1]) & e$60.hash_mask; e$60.insert && (e$60.ins_h = (e$60.ins_h << e$60.hash_shift ^ e$60.window[s$5 + x$4 - 1]) & e$60.hash_mask, e$60.prev[s$5 & e$60.w_mask] = e$60.head[e$60.ins_h], e$60.head[e$60.ins_h] = s$5, s$5++, e$60.insert--, !(e$60.lookahead + e$60.insert < x$4)););
					} while (e$60.lookahead < z$3 && 0 !== e$60.strm.avail_in);
				}
				function Z$1(e$60, t$13) {
					for (var r$12, n$5;;) {
						if (e$60.lookahead < z$3) {
							if (j$4(e$60), e$60.lookahead < z$3 && t$13 === l$10) return A$3;
							if (0 === e$60.lookahead) break;
						}
						if (r$12 = 0, e$60.lookahead >= x$4 && (e$60.ins_h = (e$60.ins_h << e$60.hash_shift ^ e$60.window[e$60.strstart + x$4 - 1]) & e$60.hash_mask, r$12 = e$60.prev[e$60.strstart & e$60.w_mask] = e$60.head[e$60.ins_h], e$60.head[e$60.ins_h] = e$60.strstart), 0 !== r$12 && e$60.strstart - r$12 <= e$60.w_size - z$3 && (e$60.match_length = L$3(e$60, r$12)), e$60.match_length >= x$4) if (n$5 = u$5._tr_tally(e$60, e$60.strstart - e$60.match_start, e$60.match_length - x$4), e$60.lookahead -= e$60.match_length, e$60.match_length <= e$60.max_lazy_match && e$60.lookahead >= x$4) {
							for (e$60.match_length--; e$60.strstart++, e$60.ins_h = (e$60.ins_h << e$60.hash_shift ^ e$60.window[e$60.strstart + x$4 - 1]) & e$60.hash_mask, r$12 = e$60.prev[e$60.strstart & e$60.w_mask] = e$60.head[e$60.ins_h], e$60.head[e$60.ins_h] = e$60.strstart, 0 != --e$60.match_length;);
							e$60.strstart++;
						} else e$60.strstart += e$60.match_length, e$60.match_length = 0, e$60.ins_h = e$60.window[e$60.strstart], e$60.ins_h = (e$60.ins_h << e$60.hash_shift ^ e$60.window[e$60.strstart + 1]) & e$60.hash_mask;
						else n$5 = u$5._tr_tally(e$60, 0, e$60.window[e$60.strstart]), e$60.lookahead--, e$60.strstart++;
						if (n$5 && (N$3(e$60, !1), 0 === e$60.strm.avail_out)) return A$3;
					}
					return e$60.insert = e$60.strstart < x$4 - 1 ? e$60.strstart : x$4 - 1, t$13 === f$5 ? (N$3(e$60, !0), 0 === e$60.strm.avail_out ? O$3 : B$4) : e$60.last_lit && (N$3(e$60, !1), 0 === e$60.strm.avail_out) ? A$3 : I$2;
				}
				function W$2(e$60, t$13) {
					for (var r$12, n$5, i$7;;) {
						if (e$60.lookahead < z$3) {
							if (j$4(e$60), e$60.lookahead < z$3 && t$13 === l$10) return A$3;
							if (0 === e$60.lookahead) break;
						}
						if (r$12 = 0, e$60.lookahead >= x$4 && (e$60.ins_h = (e$60.ins_h << e$60.hash_shift ^ e$60.window[e$60.strstart + x$4 - 1]) & e$60.hash_mask, r$12 = e$60.prev[e$60.strstart & e$60.w_mask] = e$60.head[e$60.ins_h], e$60.head[e$60.ins_h] = e$60.strstart), e$60.prev_length = e$60.match_length, e$60.prev_match = e$60.match_start, e$60.match_length = x$4 - 1, 0 !== r$12 && e$60.prev_length < e$60.max_lazy_match && e$60.strstart - r$12 <= e$60.w_size - z$3 && (e$60.match_length = L$3(e$60, r$12), e$60.match_length <= 5 && (1 === e$60.strategy || e$60.match_length === x$4 && 4096 < e$60.strstart - e$60.match_start) && (e$60.match_length = x$4 - 1)), e$60.prev_length >= x$4 && e$60.match_length <= e$60.prev_length) {
							for (i$7 = e$60.strstart + e$60.lookahead - x$4, n$5 = u$5._tr_tally(e$60, e$60.strstart - 1 - e$60.prev_match, e$60.prev_length - x$4), e$60.lookahead -= e$60.prev_length - 1, e$60.prev_length -= 2; ++e$60.strstart <= i$7 && (e$60.ins_h = (e$60.ins_h << e$60.hash_shift ^ e$60.window[e$60.strstart + x$4 - 1]) & e$60.hash_mask, r$12 = e$60.prev[e$60.strstart & e$60.w_mask] = e$60.head[e$60.ins_h], e$60.head[e$60.ins_h] = e$60.strstart), 0 != --e$60.prev_length;);
							if (e$60.match_available = 0, e$60.match_length = x$4 - 1, e$60.strstart++, n$5 && (N$3(e$60, !1), 0 === e$60.strm.avail_out)) return A$3;
						} else if (e$60.match_available) {
							if ((n$5 = u$5._tr_tally(e$60, 0, e$60.window[e$60.strstart - 1])) && N$3(e$60, !1), e$60.strstart++, e$60.lookahead--, 0 === e$60.strm.avail_out) return A$3;
						} else e$60.match_available = 1, e$60.strstart++, e$60.lookahead--;
					}
					return e$60.match_available && (n$5 = u$5._tr_tally(e$60, 0, e$60.window[e$60.strstart - 1]), e$60.match_available = 0), e$60.insert = e$60.strstart < x$4 - 1 ? e$60.strstart : x$4 - 1, t$13 === f$5 ? (N$3(e$60, !0), 0 === e$60.strm.avail_out ? O$3 : B$4) : e$60.last_lit && (N$3(e$60, !1), 0 === e$60.strm.avail_out) ? A$3 : I$2;
				}
				function M$2(e$60, t$13, r$12, n$5, i$7) {
					this.good_length = e$60, this.max_lazy = t$13, this.nice_length = r$12, this.max_chain = n$5, this.func = i$7;
				}
				function H$3() {
					this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v$4, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c$7.Buf16(2 * w$5), this.dyn_dtree = new c$7.Buf16(2 * (2 * a$36 + 1)), this.bl_tree = new c$7.Buf16(2 * (2 * o$34 + 1)), D$4(this.dyn_ltree), D$4(this.dyn_dtree), D$4(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c$7.Buf16(k$4 + 1), this.heap = new c$7.Buf16(2 * s$4 + 1), D$4(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c$7.Buf16(2 * s$4 + 1), D$4(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
				}
				function G$3(e$60) {
					var t$13;
					return e$60 && e$60.state ? (e$60.total_in = e$60.total_out = 0, e$60.data_type = i$6, (t$13 = e$60.state).pending = 0, t$13.pending_out = 0, t$13.wrap < 0 && (t$13.wrap = -t$13.wrap), t$13.status = t$13.wrap ? C$4 : E$4, e$60.adler = 2 === t$13.wrap ? 0 : 1, t$13.last_flush = l$10, u$5._tr_init(t$13), m$5) : R$2(e$60, _$5);
				}
				function K$3(e$60) {
					var t$13 = G$3(e$60);
					return t$13 === m$5 && function(e$61) {
						e$61.window_size = 2 * e$61.w_size, D$4(e$61.head), e$61.max_lazy_match = h$5[e$61.level].max_lazy, e$61.good_match = h$5[e$61.level].good_length, e$61.nice_match = h$5[e$61.level].nice_length, e$61.max_chain_length = h$5[e$61.level].max_chain, e$61.strstart = 0, e$61.block_start = 0, e$61.lookahead = 0, e$61.insert = 0, e$61.match_length = e$61.prev_length = x$4 - 1, e$61.match_available = 0, e$61.ins_h = 0;
					}(e$60.state), t$13;
				}
				function Y$1(e$60, t$13, r$12, n$5, i$7, s$5) {
					if (!e$60) return _$5;
					var a$37 = 1;
					if (t$13 === g$5 && (t$13 = 6), n$5 < 0 ? (a$37 = 0, n$5 = -n$5) : 15 < n$5 && (a$37 = 2, n$5 -= 16), i$7 < 1 || y$5 < i$7 || r$12 !== v$4 || n$5 < 8 || 15 < n$5 || t$13 < 0 || 9 < t$13 || s$5 < 0 || b$4 < s$5) return R$2(e$60, _$5);
					8 === n$5 && (n$5 = 9);
					var o$35 = new H$3();
					return (e$60.state = o$35).strm = e$60, o$35.wrap = a$37, o$35.gzhead = null, o$35.w_bits = n$5, o$35.w_size = 1 << o$35.w_bits, o$35.w_mask = o$35.w_size - 1, o$35.hash_bits = i$7 + 7, o$35.hash_size = 1 << o$35.hash_bits, o$35.hash_mask = o$35.hash_size - 1, o$35.hash_shift = ~~((o$35.hash_bits + x$4 - 1) / x$4), o$35.window = new c$7.Buf8(2 * o$35.w_size), o$35.head = new c$7.Buf16(o$35.hash_size), o$35.prev = new c$7.Buf16(o$35.w_size), o$35.lit_bufsize = 1 << i$7 + 6, o$35.pending_buf_size = 4 * o$35.lit_bufsize, o$35.pending_buf = new c$7.Buf8(o$35.pending_buf_size), o$35.d_buf = 1 * o$35.lit_bufsize, o$35.l_buf = 3 * o$35.lit_bufsize, o$35.level = t$13, o$35.strategy = s$5, o$35.method = r$12, K$3(e$60);
				}
				h$5 = [
					new M$2(0, 0, 0, 0, function(e$60, t$13) {
						var r$12 = 65535;
						for (r$12 > e$60.pending_buf_size - 5 && (r$12 = e$60.pending_buf_size - 5);;) {
							if (e$60.lookahead <= 1) {
								if (j$4(e$60), 0 === e$60.lookahead && t$13 === l$10) return A$3;
								if (0 === e$60.lookahead) break;
							}
							e$60.strstart += e$60.lookahead, e$60.lookahead = 0;
							var n$5 = e$60.block_start + r$12;
							if ((0 === e$60.strstart || e$60.strstart >= n$5) && (e$60.lookahead = e$60.strstart - n$5, e$60.strstart = n$5, N$3(e$60, !1), 0 === e$60.strm.avail_out)) return A$3;
							if (e$60.strstart - e$60.block_start >= e$60.w_size - z$3 && (N$3(e$60, !1), 0 === e$60.strm.avail_out)) return A$3;
						}
						return e$60.insert = 0, t$13 === f$5 ? (N$3(e$60, !0), 0 === e$60.strm.avail_out ? O$3 : B$4) : (e$60.strstart > e$60.block_start && (N$3(e$60, !1), e$60.strm.avail_out), A$3);
					}),
					new M$2(4, 4, 8, 4, Z$1),
					new M$2(4, 5, 16, 8, Z$1),
					new M$2(4, 6, 32, 32, Z$1),
					new M$2(4, 4, 16, 16, W$2),
					new M$2(8, 16, 32, 32, W$2),
					new M$2(8, 16, 128, 128, W$2),
					new M$2(8, 32, 128, 256, W$2),
					new M$2(32, 128, 258, 1024, W$2),
					new M$2(32, 258, 258, 4096, W$2)
				], r$11.deflateInit = function(e$60, t$13) {
					return Y$1(e$60, t$13, v$4, 15, 8, 0);
				}, r$11.deflateInit2 = Y$1, r$11.deflateReset = K$3, r$11.deflateResetKeep = G$3, r$11.deflateSetHeader = function(e$60, t$13) {
					return e$60 && e$60.state ? 2 !== e$60.state.wrap ? _$5 : (e$60.state.gzhead = t$13, m$5) : _$5;
				}, r$11.deflate = function(e$60, t$13) {
					var r$12, n$5, i$7, s$5;
					if (!e$60 || !e$60.state || 5 < t$13 || t$13 < 0) return e$60 ? R$2(e$60, _$5) : _$5;
					if (n$5 = e$60.state, !e$60.output || !e$60.input && 0 !== e$60.avail_in || 666 === n$5.status && t$13 !== f$5) return R$2(e$60, 0 === e$60.avail_out ? -5 : _$5);
					if (n$5.strm = e$60, r$12 = n$5.last_flush, n$5.last_flush = t$13, n$5.status === C$4) if (2 === n$5.wrap) e$60.adler = 0, U$2(n$5, 31), U$2(n$5, 139), U$2(n$5, 8), n$5.gzhead ? (U$2(n$5, (n$5.gzhead.text ? 1 : 0) + (n$5.gzhead.hcrc ? 2 : 0) + (n$5.gzhead.extra ? 4 : 0) + (n$5.gzhead.name ? 8 : 0) + (n$5.gzhead.comment ? 16 : 0)), U$2(n$5, 255 & n$5.gzhead.time), U$2(n$5, n$5.gzhead.time >> 8 & 255), U$2(n$5, n$5.gzhead.time >> 16 & 255), U$2(n$5, n$5.gzhead.time >> 24 & 255), U$2(n$5, 9 === n$5.level ? 2 : 2 <= n$5.strategy || n$5.level < 2 ? 4 : 0), U$2(n$5, 255 & n$5.gzhead.os), n$5.gzhead.extra && n$5.gzhead.extra.length && (U$2(n$5, 255 & n$5.gzhead.extra.length), U$2(n$5, n$5.gzhead.extra.length >> 8 & 255)), n$5.gzhead.hcrc && (e$60.adler = p$6(e$60.adler, n$5.pending_buf, n$5.pending, 0)), n$5.gzindex = 0, n$5.status = 69) : (U$2(n$5, 0), U$2(n$5, 0), U$2(n$5, 0), U$2(n$5, 0), U$2(n$5, 0), U$2(n$5, 9 === n$5.level ? 2 : 2 <= n$5.strategy || n$5.level < 2 ? 4 : 0), U$2(n$5, 3), n$5.status = E$4);
					else {
						var a$37 = v$4 + (n$5.w_bits - 8 << 4) << 8;
						a$37 |= (2 <= n$5.strategy || n$5.level < 2 ? 0 : n$5.level < 6 ? 1 : 6 === n$5.level ? 2 : 3) << 6, 0 !== n$5.strstart && (a$37 |= 32), a$37 += 31 - a$37 % 31, n$5.status = E$4, P$3(n$5, a$37), 0 !== n$5.strstart && (P$3(n$5, e$60.adler >>> 16), P$3(n$5, 65535 & e$60.adler)), e$60.adler = 1;
					}
					if (69 === n$5.status) if (n$5.gzhead.extra) {
						for (i$7 = n$5.pending; n$5.gzindex < (65535 & n$5.gzhead.extra.length) && (n$5.pending !== n$5.pending_buf_size || (n$5.gzhead.hcrc && n$5.pending > i$7 && (e$60.adler = p$6(e$60.adler, n$5.pending_buf, n$5.pending - i$7, i$7)), F$4(e$60), i$7 = n$5.pending, n$5.pending !== n$5.pending_buf_size));) U$2(n$5, 255 & n$5.gzhead.extra[n$5.gzindex]), n$5.gzindex++;
						n$5.gzhead.hcrc && n$5.pending > i$7 && (e$60.adler = p$6(e$60.adler, n$5.pending_buf, n$5.pending - i$7, i$7)), n$5.gzindex === n$5.gzhead.extra.length && (n$5.gzindex = 0, n$5.status = 73);
					} else n$5.status = 73;
					if (73 === n$5.status) if (n$5.gzhead.name) {
						i$7 = n$5.pending;
						do {
							if (n$5.pending === n$5.pending_buf_size && (n$5.gzhead.hcrc && n$5.pending > i$7 && (e$60.adler = p$6(e$60.adler, n$5.pending_buf, n$5.pending - i$7, i$7)), F$4(e$60), i$7 = n$5.pending, n$5.pending === n$5.pending_buf_size)) {
								s$5 = 1;
								break;
							}
							s$5 = n$5.gzindex < n$5.gzhead.name.length ? 255 & n$5.gzhead.name.charCodeAt(n$5.gzindex++) : 0, U$2(n$5, s$5);
						} while (0 !== s$5);
						n$5.gzhead.hcrc && n$5.pending > i$7 && (e$60.adler = p$6(e$60.adler, n$5.pending_buf, n$5.pending - i$7, i$7)), 0 === s$5 && (n$5.gzindex = 0, n$5.status = 91);
					} else n$5.status = 91;
					if (91 === n$5.status) if (n$5.gzhead.comment) {
						i$7 = n$5.pending;
						do {
							if (n$5.pending === n$5.pending_buf_size && (n$5.gzhead.hcrc && n$5.pending > i$7 && (e$60.adler = p$6(e$60.adler, n$5.pending_buf, n$5.pending - i$7, i$7)), F$4(e$60), i$7 = n$5.pending, n$5.pending === n$5.pending_buf_size)) {
								s$5 = 1;
								break;
							}
							s$5 = n$5.gzindex < n$5.gzhead.comment.length ? 255 & n$5.gzhead.comment.charCodeAt(n$5.gzindex++) : 0, U$2(n$5, s$5);
						} while (0 !== s$5);
						n$5.gzhead.hcrc && n$5.pending > i$7 && (e$60.adler = p$6(e$60.adler, n$5.pending_buf, n$5.pending - i$7, i$7)), 0 === s$5 && (n$5.status = 103);
					} else n$5.status = 103;
					if (103 === n$5.status && (n$5.gzhead.hcrc ? (n$5.pending + 2 > n$5.pending_buf_size && F$4(e$60), n$5.pending + 2 <= n$5.pending_buf_size && (U$2(n$5, 255 & e$60.adler), U$2(n$5, e$60.adler >> 8 & 255), e$60.adler = 0, n$5.status = E$4)) : n$5.status = E$4), 0 !== n$5.pending) {
						if (F$4(e$60), 0 === e$60.avail_out) return n$5.last_flush = -1, m$5;
					} else if (0 === e$60.avail_in && T$4(t$13) <= T$4(r$12) && t$13 !== f$5) return R$2(e$60, -5);
					if (666 === n$5.status && 0 !== e$60.avail_in) return R$2(e$60, -5);
					if (0 !== e$60.avail_in || 0 !== n$5.lookahead || t$13 !== l$10 && 666 !== n$5.status) {
						var o$35 = 2 === n$5.strategy ? function(e$61, t$14) {
							for (var r$13;;) {
								if (0 === e$61.lookahead && (j$4(e$61), 0 === e$61.lookahead)) {
									if (t$14 === l$10) return A$3;
									break;
								}
								if (e$61.match_length = 0, r$13 = u$5._tr_tally(e$61, 0, e$61.window[e$61.strstart]), e$61.lookahead--, e$61.strstart++, r$13 && (N$3(e$61, !1), 0 === e$61.strm.avail_out)) return A$3;
							}
							return e$61.insert = 0, t$14 === f$5 ? (N$3(e$61, !0), 0 === e$61.strm.avail_out ? O$3 : B$4) : e$61.last_lit && (N$3(e$61, !1), 0 === e$61.strm.avail_out) ? A$3 : I$2;
						}(n$5, t$13) : 3 === n$5.strategy ? function(e$61, t$14) {
							for (var r$13, n$6, i$8, s$6, a$38 = e$61.window;;) {
								if (e$61.lookahead <= S$3) {
									if (j$4(e$61), e$61.lookahead <= S$3 && t$14 === l$10) return A$3;
									if (0 === e$61.lookahead) break;
								}
								if (e$61.match_length = 0, e$61.lookahead >= x$4 && 0 < e$61.strstart && (n$6 = a$38[i$8 = e$61.strstart - 1]) === a$38[++i$8] && n$6 === a$38[++i$8] && n$6 === a$38[++i$8]) {
									s$6 = e$61.strstart + S$3;
									do									;
while (n$6 === a$38[++i$8] && n$6 === a$38[++i$8] && n$6 === a$38[++i$8] && n$6 === a$38[++i$8] && n$6 === a$38[++i$8] && n$6 === a$38[++i$8] && n$6 === a$38[++i$8] && n$6 === a$38[++i$8] && i$8 < s$6);
									e$61.match_length = S$3 - (s$6 - i$8), e$61.match_length > e$61.lookahead && (e$61.match_length = e$61.lookahead);
								}
								if (e$61.match_length >= x$4 ? (r$13 = u$5._tr_tally(e$61, 1, e$61.match_length - x$4), e$61.lookahead -= e$61.match_length, e$61.strstart += e$61.match_length, e$61.match_length = 0) : (r$13 = u$5._tr_tally(e$61, 0, e$61.window[e$61.strstart]), e$61.lookahead--, e$61.strstart++), r$13 && (N$3(e$61, !1), 0 === e$61.strm.avail_out)) return A$3;
							}
							return e$61.insert = 0, t$14 === f$5 ? (N$3(e$61, !0), 0 === e$61.strm.avail_out ? O$3 : B$4) : e$61.last_lit && (N$3(e$61, !1), 0 === e$61.strm.avail_out) ? A$3 : I$2;
						}(n$5, t$13) : h$5[n$5.level].func(n$5, t$13);
						if (o$35 !== O$3 && o$35 !== B$4 || (n$5.status = 666), o$35 === A$3 || o$35 === O$3) return 0 === e$60.avail_out && (n$5.last_flush = -1), m$5;
						if (o$35 === I$2 && (1 === t$13 ? u$5._tr_align(n$5) : 5 !== t$13 && (u$5._tr_stored_block(n$5, 0, 0, !1), 3 === t$13 && (D$4(n$5.head), 0 === n$5.lookahead && (n$5.strstart = 0, n$5.block_start = 0, n$5.insert = 0))), F$4(e$60), 0 === e$60.avail_out)) return n$5.last_flush = -1, m$5;
					}
					return t$13 !== f$5 ? m$5 : n$5.wrap <= 0 ? 1 : (2 === n$5.wrap ? (U$2(n$5, 255 & e$60.adler), U$2(n$5, e$60.adler >> 8 & 255), U$2(n$5, e$60.adler >> 16 & 255), U$2(n$5, e$60.adler >> 24 & 255), U$2(n$5, 255 & e$60.total_in), U$2(n$5, e$60.total_in >> 8 & 255), U$2(n$5, e$60.total_in >> 16 & 255), U$2(n$5, e$60.total_in >> 24 & 255)) : (P$3(n$5, e$60.adler >>> 16), P$3(n$5, 65535 & e$60.adler)), F$4(e$60), 0 < n$5.wrap && (n$5.wrap = -n$5.wrap), 0 !== n$5.pending ? m$5 : 1);
				}, r$11.deflateEnd = function(e$60) {
					var t$13;
					return e$60 && e$60.state ? (t$13 = e$60.state.status) !== C$4 && 69 !== t$13 && 73 !== t$13 && 91 !== t$13 && 103 !== t$13 && t$13 !== E$4 && 666 !== t$13 ? R$2(e$60, _$5) : (e$60.state = null, t$13 === E$4 ? R$2(e$60, -3) : m$5) : _$5;
				}, r$11.deflateSetDictionary = function(e$60, t$13) {
					var r$12, n$5, i$7, s$5, a$37, o$35, h$6, u$6, l$11 = t$13.length;
					if (!e$60 || !e$60.state) return _$5;
					if (2 === (s$5 = (r$12 = e$60.state).wrap) || 1 === s$5 && r$12.status !== C$4 || r$12.lookahead) return _$5;
					for (1 === s$5 && (e$60.adler = d$5(e$60.adler, t$13, l$11, 0)), r$12.wrap = 0, l$11 >= r$12.w_size && (0 === s$5 && (D$4(r$12.head), r$12.strstart = 0, r$12.block_start = 0, r$12.insert = 0), u$6 = new c$7.Buf8(r$12.w_size), c$7.arraySet(u$6, t$13, l$11 - r$12.w_size, r$12.w_size, 0), t$13 = u$6, l$11 = r$12.w_size), a$37 = e$60.avail_in, o$35 = e$60.next_in, h$6 = e$60.input, e$60.avail_in = l$11, e$60.next_in = 0, e$60.input = t$13, j$4(r$12); r$12.lookahead >= x$4;) {
						for (n$5 = r$12.strstart, i$7 = r$12.lookahead - (x$4 - 1); r$12.ins_h = (r$12.ins_h << r$12.hash_shift ^ r$12.window[n$5 + x$4 - 1]) & r$12.hash_mask, r$12.prev[n$5 & r$12.w_mask] = r$12.head[r$12.ins_h], r$12.head[r$12.ins_h] = n$5, n$5++, --i$7;);
						r$12.strstart = n$5, r$12.lookahead = x$4 - 1, j$4(r$12);
					}
					return r$12.strstart += r$12.lookahead, r$12.block_start = r$12.strstart, r$12.insert = r$12.lookahead, r$12.lookahead = 0, r$12.match_length = r$12.prev_length = x$4 - 1, r$12.match_available = 0, e$60.next_in = o$35, e$60.input = h$6, e$60.avail_in = a$37, r$12.wrap = s$5, m$5;
				}, r$11.deflateInfo = "pako deflate (from Nodeca project)";
			}, {
				"../utils/common": 41,
				"./adler32": 43,
				"./crc32": 45,
				"./messages": 51,
				"./trees": 52
			}],
			47: [function(e$59, t$12, r$11) {
				"use strict";
				t$12.exports = function() {
					this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
				};
			}, {}],
			48: [function(e$59, t$12, r$11) {
				"use strict";
				t$12.exports = function(e$60, t$13) {
					var r$12 = e$60.state, n$4 = e$60.next_in, i$6, s$4, a$36, o$34, h$5, u$5, l$10, f$5, c$7, d$5, p$6, m$5, _$5, g$5, b$4, v$4, y$5, w$5, k$4, x$4, S$3, z$3 = e$60.input, C$4;
					i$6 = n$4 + (e$60.avail_in - 5), s$4 = e$60.next_out, C$4 = e$60.output, a$36 = s$4 - (t$13 - e$60.avail_out), o$34 = s$4 + (e$60.avail_out - 257), h$5 = r$12.dmax, u$5 = r$12.wsize, l$10 = r$12.whave, f$5 = r$12.wnext, c$7 = r$12.window, d$5 = r$12.hold, p$6 = r$12.bits, m$5 = r$12.lencode, _$5 = r$12.distcode, g$5 = (1 << r$12.lenbits) - 1, b$4 = (1 << r$12.distbits) - 1;
					e: do {
						p$6 < 15 && (d$5 += z$3[n$4++] << p$6, p$6 += 8, d$5 += z$3[n$4++] << p$6, p$6 += 8), v$4 = m$5[d$5 & g$5];
						t: for (;;) {
							if (d$5 >>>= y$5 = v$4 >>> 24, p$6 -= y$5, 0 === (y$5 = v$4 >>> 16 & 255)) C$4[s$4++] = 65535 & v$4;
							else {
								if (!(16 & y$5)) {
									if (0 == (64 & y$5)) {
										v$4 = m$5[(65535 & v$4) + (d$5 & (1 << y$5) - 1)];
										continue t;
									}
									if (32 & y$5) {
										r$12.mode = 12;
										break e;
									}
									e$60.msg = "invalid literal/length code", r$12.mode = 30;
									break e;
								}
								w$5 = 65535 & v$4, (y$5 &= 15) && (p$6 < y$5 && (d$5 += z$3[n$4++] << p$6, p$6 += 8), w$5 += d$5 & (1 << y$5) - 1, d$5 >>>= y$5, p$6 -= y$5), p$6 < 15 && (d$5 += z$3[n$4++] << p$6, p$6 += 8, d$5 += z$3[n$4++] << p$6, p$6 += 8), v$4 = _$5[d$5 & b$4];
								r: for (;;) {
									if (d$5 >>>= y$5 = v$4 >>> 24, p$6 -= y$5, !(16 & (y$5 = v$4 >>> 16 & 255))) {
										if (0 == (64 & y$5)) {
											v$4 = _$5[(65535 & v$4) + (d$5 & (1 << y$5) - 1)];
											continue r;
										}
										e$60.msg = "invalid distance code", r$12.mode = 30;
										break e;
									}
									if (k$4 = 65535 & v$4, p$6 < (y$5 &= 15) && (d$5 += z$3[n$4++] << p$6, (p$6 += 8) < y$5 && (d$5 += z$3[n$4++] << p$6, p$6 += 8)), h$5 < (k$4 += d$5 & (1 << y$5) - 1)) {
										e$60.msg = "invalid distance too far back", r$12.mode = 30;
										break e;
									}
									if (d$5 >>>= y$5, p$6 -= y$5, (y$5 = s$4 - a$36) < k$4) {
										if (l$10 < (y$5 = k$4 - y$5) && r$12.sane) {
											e$60.msg = "invalid distance too far back", r$12.mode = 30;
											break e;
										}
										if (S$3 = c$7, (x$4 = 0) === f$5) {
											if (x$4 += u$5 - y$5, y$5 < w$5) {
												for (w$5 -= y$5; C$4[s$4++] = c$7[x$4++], --y$5;);
												x$4 = s$4 - k$4, S$3 = C$4;
											}
										} else if (f$5 < y$5) {
											if (x$4 += u$5 + f$5 - y$5, (y$5 -= f$5) < w$5) {
												for (w$5 -= y$5; C$4[s$4++] = c$7[x$4++], --y$5;);
												if (x$4 = 0, f$5 < w$5) {
													for (w$5 -= y$5 = f$5; C$4[s$4++] = c$7[x$4++], --y$5;);
													x$4 = s$4 - k$4, S$3 = C$4;
												}
											}
										} else if (x$4 += f$5 - y$5, y$5 < w$5) {
											for (w$5 -= y$5; C$4[s$4++] = c$7[x$4++], --y$5;);
											x$4 = s$4 - k$4, S$3 = C$4;
										}
										for (; 2 < w$5;) C$4[s$4++] = S$3[x$4++], C$4[s$4++] = S$3[x$4++], C$4[s$4++] = S$3[x$4++], w$5 -= 3;
										w$5 && (C$4[s$4++] = S$3[x$4++], 1 < w$5 && (C$4[s$4++] = S$3[x$4++]));
									} else {
										for (x$4 = s$4 - k$4; C$4[s$4++] = C$4[x$4++], C$4[s$4++] = C$4[x$4++], C$4[s$4++] = C$4[x$4++], 2 < (w$5 -= 3););
										w$5 && (C$4[s$4++] = C$4[x$4++], 1 < w$5 && (C$4[s$4++] = C$4[x$4++]));
									}
									break;
								}
							}
							break;
						}
					} while (n$4 < i$6 && s$4 < o$34);
					n$4 -= w$5 = p$6 >> 3, d$5 &= (1 << (p$6 -= w$5 << 3)) - 1, e$60.next_in = n$4, e$60.next_out = s$4, e$60.avail_in = n$4 < i$6 ? i$6 - n$4 + 5 : 5 - (n$4 - i$6), e$60.avail_out = s$4 < o$34 ? o$34 - s$4 + 257 : 257 - (s$4 - o$34), r$12.hold = d$5, r$12.bits = p$6;
				};
			}, {}],
			49: [function(e$59, t$12, r$11) {
				"use strict";
				var I$2 = e$59("../utils/common"), O$3 = e$59("./adler32"), B$4 = e$59("./crc32"), R$2 = e$59("./inffast"), T$4 = e$59("./inftrees"), D$4 = 1, F$4 = 2, N$3 = 0, U$2 = -2, P$3 = 1, n$4 = 852, i$6 = 592;
				function L$3(e$60) {
					return (e$60 >>> 24 & 255) + (e$60 >>> 8 & 65280) + ((65280 & e$60) << 8) + ((255 & e$60) << 24);
				}
				function s$4() {
					this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I$2.Buf16(320), this.work = new I$2.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
				}
				function a$36(e$60) {
					var t$13;
					return e$60 && e$60.state ? (t$13 = e$60.state, e$60.total_in = e$60.total_out = t$13.total = 0, e$60.msg = "", t$13.wrap && (e$60.adler = 1 & t$13.wrap), t$13.mode = P$3, t$13.last = 0, t$13.havedict = 0, t$13.dmax = 32768, t$13.head = null, t$13.hold = 0, t$13.bits = 0, t$13.lencode = t$13.lendyn = new I$2.Buf32(n$4), t$13.distcode = t$13.distdyn = new I$2.Buf32(i$6), t$13.sane = 1, t$13.back = -1, N$3) : U$2;
				}
				function o$34(e$60) {
					var t$13;
					return e$60 && e$60.state ? ((t$13 = e$60.state).wsize = 0, t$13.whave = 0, t$13.wnext = 0, a$36(e$60)) : U$2;
				}
				function h$5(e$60, t$13) {
					var r$12, n$5;
					return e$60 && e$60.state ? (n$5 = e$60.state, t$13 < 0 ? (r$12 = 0, t$13 = -t$13) : (r$12 = 1 + (t$13 >> 4), t$13 < 48 && (t$13 &= 15)), t$13 && (t$13 < 8 || 15 < t$13) ? U$2 : (null !== n$5.window && n$5.wbits !== t$13 && (n$5.window = null), n$5.wrap = r$12, n$5.wbits = t$13, o$34(e$60))) : U$2;
				}
				function u$5(e$60, t$13) {
					var r$12, n$5;
					return e$60 ? (n$5 = new s$4(), (e$60.state = n$5).window = null, (r$12 = h$5(e$60, t$13)) !== N$3 && (e$60.state = null), r$12) : U$2;
				}
				var l$10, f$5, c$7 = !0;
				function j$4(e$60) {
					if (c$7) {
						var t$13;
						for (l$10 = new I$2.Buf32(512), f$5 = new I$2.Buf32(32), t$13 = 0; t$13 < 144;) e$60.lens[t$13++] = 8;
						for (; t$13 < 256;) e$60.lens[t$13++] = 9;
						for (; t$13 < 280;) e$60.lens[t$13++] = 7;
						for (; t$13 < 288;) e$60.lens[t$13++] = 8;
						for (T$4(D$4, e$60.lens, 0, 288, l$10, 0, e$60.work, { bits: 9 }), t$13 = 0; t$13 < 32;) e$60.lens[t$13++] = 5;
						T$4(F$4, e$60.lens, 0, 32, f$5, 0, e$60.work, { bits: 5 }), c$7 = !1;
					}
					e$60.lencode = l$10, e$60.lenbits = 9, e$60.distcode = f$5, e$60.distbits = 5;
				}
				function Z$1(e$60, t$13, r$12, n$5) {
					var i$7, s$5 = e$60.state;
					return null === s$5.window && (s$5.wsize = 1 << s$5.wbits, s$5.wnext = 0, s$5.whave = 0, s$5.window = new I$2.Buf8(s$5.wsize)), n$5 >= s$5.wsize ? (I$2.arraySet(s$5.window, t$13, r$12 - s$5.wsize, s$5.wsize, 0), s$5.wnext = 0, s$5.whave = s$5.wsize) : (n$5 < (i$7 = s$5.wsize - s$5.wnext) && (i$7 = n$5), I$2.arraySet(s$5.window, t$13, r$12 - n$5, i$7, s$5.wnext), (n$5 -= i$7) ? (I$2.arraySet(s$5.window, t$13, r$12 - n$5, n$5, 0), s$5.wnext = n$5, s$5.whave = s$5.wsize) : (s$5.wnext += i$7, s$5.wnext === s$5.wsize && (s$5.wnext = 0), s$5.whave < s$5.wsize && (s$5.whave += i$7))), 0;
				}
				r$11.inflateReset = o$34, r$11.inflateReset2 = h$5, r$11.inflateResetKeep = a$36, r$11.inflateInit = function(e$60) {
					return u$5(e$60, 15);
				}, r$11.inflateInit2 = u$5, r$11.inflate = function(e$60, t$13) {
					var r$12, n$5, i$7, s$5, a$37, o$35, h$6, u$6, l$11, f$6, c$8, d$5, p$6, m$5, _$5, g$5, b$4, v$4, y$5, w$5, k$4, x$4, S$3, z$3, C$4 = 0, E$4 = new I$2.Buf8(4), A$3 = [
						16,
						17,
						18,
						0,
						8,
						7,
						9,
						6,
						10,
						5,
						11,
						4,
						12,
						3,
						13,
						2,
						14,
						1,
						15
					];
					if (!e$60 || !e$60.state || !e$60.output || !e$60.input && 0 !== e$60.avail_in) return U$2;
					12 === (r$12 = e$60.state).mode && (r$12.mode = 13), a$37 = e$60.next_out, i$7 = e$60.output, h$6 = e$60.avail_out, s$5 = e$60.next_in, n$5 = e$60.input, o$35 = e$60.avail_in, u$6 = r$12.hold, l$11 = r$12.bits, f$6 = o$35, c$8 = h$6, x$4 = N$3;
					e: for (;;) switch (r$12.mode) {
						case P$3:
							if (0 === r$12.wrap) {
								r$12.mode = 13;
								break;
							}
							for (; l$11 < 16;) {
								if (0 === o$35) break e;
								o$35--, u$6 += n$5[s$5++] << l$11, l$11 += 8;
							}
							if (2 & r$12.wrap && 35615 === u$6) {
								E$4[r$12.check = 0] = 255 & u$6, E$4[1] = u$6 >>> 8 & 255, r$12.check = B$4(r$12.check, E$4, 2, 0), l$11 = u$6 = 0, r$12.mode = 2;
								break;
							}
							if (r$12.flags = 0, r$12.head && (r$12.head.done = !1), !(1 & r$12.wrap) || (((255 & u$6) << 8) + (u$6 >> 8)) % 31) {
								e$60.msg = "incorrect header check", r$12.mode = 30;
								break;
							}
							if (8 != (15 & u$6)) {
								e$60.msg = "unknown compression method", r$12.mode = 30;
								break;
							}
							if (l$11 -= 4, k$4 = 8 + (15 & (u$6 >>>= 4)), 0 === r$12.wbits) r$12.wbits = k$4;
							else if (k$4 > r$12.wbits) {
								e$60.msg = "invalid window size", r$12.mode = 30;
								break;
							}
							r$12.dmax = 1 << k$4, e$60.adler = r$12.check = 1, r$12.mode = 512 & u$6 ? 10 : 12, l$11 = u$6 = 0;
							break;
						case 2:
							for (; l$11 < 16;) {
								if (0 === o$35) break e;
								o$35--, u$6 += n$5[s$5++] << l$11, l$11 += 8;
							}
							if (r$12.flags = u$6, 8 != (255 & r$12.flags)) {
								e$60.msg = "unknown compression method", r$12.mode = 30;
								break;
							}
							if (57344 & r$12.flags) {
								e$60.msg = "unknown header flags set", r$12.mode = 30;
								break;
							}
							r$12.head && (r$12.head.text = u$6 >> 8 & 1), 512 & r$12.flags && (E$4[0] = 255 & u$6, E$4[1] = u$6 >>> 8 & 255, r$12.check = B$4(r$12.check, E$4, 2, 0)), l$11 = u$6 = 0, r$12.mode = 3;
						case 3:
							for (; l$11 < 32;) {
								if (0 === o$35) break e;
								o$35--, u$6 += n$5[s$5++] << l$11, l$11 += 8;
							}
							r$12.head && (r$12.head.time = u$6), 512 & r$12.flags && (E$4[0] = 255 & u$6, E$4[1] = u$6 >>> 8 & 255, E$4[2] = u$6 >>> 16 & 255, E$4[3] = u$6 >>> 24 & 255, r$12.check = B$4(r$12.check, E$4, 4, 0)), l$11 = u$6 = 0, r$12.mode = 4;
						case 4:
							for (; l$11 < 16;) {
								if (0 === o$35) break e;
								o$35--, u$6 += n$5[s$5++] << l$11, l$11 += 8;
							}
							r$12.head && (r$12.head.xflags = 255 & u$6, r$12.head.os = u$6 >> 8), 512 & r$12.flags && (E$4[0] = 255 & u$6, E$4[1] = u$6 >>> 8 & 255, r$12.check = B$4(r$12.check, E$4, 2, 0)), l$11 = u$6 = 0, r$12.mode = 5;
						case 5:
							if (1024 & r$12.flags) {
								for (; l$11 < 16;) {
									if (0 === o$35) break e;
									o$35--, u$6 += n$5[s$5++] << l$11, l$11 += 8;
								}
								r$12.length = u$6, r$12.head && (r$12.head.extra_len = u$6), 512 & r$12.flags && (E$4[0] = 255 & u$6, E$4[1] = u$6 >>> 8 & 255, r$12.check = B$4(r$12.check, E$4, 2, 0)), l$11 = u$6 = 0;
							} else r$12.head && (r$12.head.extra = null);
							r$12.mode = 6;
						case 6:
							if (1024 & r$12.flags && (o$35 < (d$5 = r$12.length) && (d$5 = o$35), d$5 && (r$12.head && (k$4 = r$12.head.extra_len - r$12.length, r$12.head.extra || (r$12.head.extra = new Array(r$12.head.extra_len)), I$2.arraySet(r$12.head.extra, n$5, s$5, d$5, k$4)), 512 & r$12.flags && (r$12.check = B$4(r$12.check, n$5, d$5, s$5)), o$35 -= d$5, s$5 += d$5, r$12.length -= d$5), r$12.length)) break e;
							r$12.length = 0, r$12.mode = 7;
						case 7:
							if (2048 & r$12.flags) {
								if (0 === o$35) break e;
								for (d$5 = 0; k$4 = n$5[s$5 + d$5++], r$12.head && k$4 && r$12.length < 65536 && (r$12.head.name += String.fromCharCode(k$4)), k$4 && d$5 < o$35;);
								if (512 & r$12.flags && (r$12.check = B$4(r$12.check, n$5, d$5, s$5)), o$35 -= d$5, s$5 += d$5, k$4) break e;
							} else r$12.head && (r$12.head.name = null);
							r$12.length = 0, r$12.mode = 8;
						case 8:
							if (4096 & r$12.flags) {
								if (0 === o$35) break e;
								for (d$5 = 0; k$4 = n$5[s$5 + d$5++], r$12.head && k$4 && r$12.length < 65536 && (r$12.head.comment += String.fromCharCode(k$4)), k$4 && d$5 < o$35;);
								if (512 & r$12.flags && (r$12.check = B$4(r$12.check, n$5, d$5, s$5)), o$35 -= d$5, s$5 += d$5, k$4) break e;
							} else r$12.head && (r$12.head.comment = null);
							r$12.mode = 9;
						case 9:
							if (512 & r$12.flags) {
								for (; l$11 < 16;) {
									if (0 === o$35) break e;
									o$35--, u$6 += n$5[s$5++] << l$11, l$11 += 8;
								}
								if (u$6 !== (65535 & r$12.check)) {
									e$60.msg = "header crc mismatch", r$12.mode = 30;
									break;
								}
								l$11 = u$6 = 0;
							}
							r$12.head && (r$12.head.hcrc = r$12.flags >> 9 & 1, r$12.head.done = !0), e$60.adler = r$12.check = 0, r$12.mode = 12;
							break;
						case 10:
							for (; l$11 < 32;) {
								if (0 === o$35) break e;
								o$35--, u$6 += n$5[s$5++] << l$11, l$11 += 8;
							}
							e$60.adler = r$12.check = L$3(u$6), l$11 = u$6 = 0, r$12.mode = 11;
						case 11:
							if (0 === r$12.havedict) return e$60.next_out = a$37, e$60.avail_out = h$6, e$60.next_in = s$5, e$60.avail_in = o$35, r$12.hold = u$6, r$12.bits = l$11, 2;
							e$60.adler = r$12.check = 1, r$12.mode = 12;
						case 12: if (5 === t$13 || 6 === t$13) break e;
						case 13:
							if (r$12.last) {
								u$6 >>>= 7 & l$11, l$11 -= 7 & l$11, r$12.mode = 27;
								break;
							}
							for (; l$11 < 3;) {
								if (0 === o$35) break e;
								o$35--, u$6 += n$5[s$5++] << l$11, l$11 += 8;
							}
							switch (r$12.last = 1 & u$6, l$11 -= 1, 3 & (u$6 >>>= 1)) {
								case 0:
									r$12.mode = 14;
									break;
								case 1:
									if (j$4(r$12), r$12.mode = 20, 6 !== t$13) break;
									u$6 >>>= 2, l$11 -= 2;
									break e;
								case 2:
									r$12.mode = 17;
									break;
								case 3: e$60.msg = "invalid block type", r$12.mode = 30;
							}
							u$6 >>>= 2, l$11 -= 2;
							break;
						case 14:
							for (u$6 >>>= 7 & l$11, l$11 -= 7 & l$11; l$11 < 32;) {
								if (0 === o$35) break e;
								o$35--, u$6 += n$5[s$5++] << l$11, l$11 += 8;
							}
							if ((65535 & u$6) != (u$6 >>> 16 ^ 65535)) {
								e$60.msg = "invalid stored block lengths", r$12.mode = 30;
								break;
							}
							if (r$12.length = 65535 & u$6, l$11 = u$6 = 0, r$12.mode = 15, 6 === t$13) break e;
						case 15: r$12.mode = 16;
						case 16:
							if (d$5 = r$12.length) {
								if (o$35 < d$5 && (d$5 = o$35), h$6 < d$5 && (d$5 = h$6), 0 === d$5) break e;
								I$2.arraySet(i$7, n$5, s$5, d$5, a$37), o$35 -= d$5, s$5 += d$5, h$6 -= d$5, a$37 += d$5, r$12.length -= d$5;
								break;
							}
							r$12.mode = 12;
							break;
						case 17:
							for (; l$11 < 14;) {
								if (0 === o$35) break e;
								o$35--, u$6 += n$5[s$5++] << l$11, l$11 += 8;
							}
							if (r$12.nlen = 257 + (31 & u$6), u$6 >>>= 5, l$11 -= 5, r$12.ndist = 1 + (31 & u$6), u$6 >>>= 5, l$11 -= 5, r$12.ncode = 4 + (15 & u$6), u$6 >>>= 4, l$11 -= 4, 286 < r$12.nlen || 30 < r$12.ndist) {
								e$60.msg = "too many length or distance symbols", r$12.mode = 30;
								break;
							}
							r$12.have = 0, r$12.mode = 18;
						case 18:
							for (; r$12.have < r$12.ncode;) {
								for (; l$11 < 3;) {
									if (0 === o$35) break e;
									o$35--, u$6 += n$5[s$5++] << l$11, l$11 += 8;
								}
								r$12.lens[A$3[r$12.have++]] = 7 & u$6, u$6 >>>= 3, l$11 -= 3;
							}
							for (; r$12.have < 19;) r$12.lens[A$3[r$12.have++]] = 0;
							if (r$12.lencode = r$12.lendyn, r$12.lenbits = 7, S$3 = { bits: r$12.lenbits }, x$4 = T$4(0, r$12.lens, 0, 19, r$12.lencode, 0, r$12.work, S$3), r$12.lenbits = S$3.bits, x$4) {
								e$60.msg = "invalid code lengths set", r$12.mode = 30;
								break;
							}
							r$12.have = 0, r$12.mode = 19;
						case 19:
							for (; r$12.have < r$12.nlen + r$12.ndist;) {
								for (; g$5 = (C$4 = r$12.lencode[u$6 & (1 << r$12.lenbits) - 1]) >>> 16 & 255, b$4 = 65535 & C$4, !((_$5 = C$4 >>> 24) <= l$11);) {
									if (0 === o$35) break e;
									o$35--, u$6 += n$5[s$5++] << l$11, l$11 += 8;
								}
								if (b$4 < 16) u$6 >>>= _$5, l$11 -= _$5, r$12.lens[r$12.have++] = b$4;
								else {
									if (16 === b$4) {
										for (z$3 = _$5 + 2; l$11 < z$3;) {
											if (0 === o$35) break e;
											o$35--, u$6 += n$5[s$5++] << l$11, l$11 += 8;
										}
										if (u$6 >>>= _$5, l$11 -= _$5, 0 === r$12.have) {
											e$60.msg = "invalid bit length repeat", r$12.mode = 30;
											break;
										}
										k$4 = r$12.lens[r$12.have - 1], d$5 = 3 + (3 & u$6), u$6 >>>= 2, l$11 -= 2;
									} else if (17 === b$4) {
										for (z$3 = _$5 + 3; l$11 < z$3;) {
											if (0 === o$35) break e;
											o$35--, u$6 += n$5[s$5++] << l$11, l$11 += 8;
										}
										l$11 -= _$5, k$4 = 0, d$5 = 3 + (7 & (u$6 >>>= _$5)), u$6 >>>= 3, l$11 -= 3;
									} else {
										for (z$3 = _$5 + 7; l$11 < z$3;) {
											if (0 === o$35) break e;
											o$35--, u$6 += n$5[s$5++] << l$11, l$11 += 8;
										}
										l$11 -= _$5, k$4 = 0, d$5 = 11 + (127 & (u$6 >>>= _$5)), u$6 >>>= 7, l$11 -= 7;
									}
									if (r$12.have + d$5 > r$12.nlen + r$12.ndist) {
										e$60.msg = "invalid bit length repeat", r$12.mode = 30;
										break;
									}
									for (; d$5--;) r$12.lens[r$12.have++] = k$4;
								}
							}
							if (30 === r$12.mode) break;
							if (0 === r$12.lens[256]) {
								e$60.msg = "invalid code -- missing end-of-block", r$12.mode = 30;
								break;
							}
							if (r$12.lenbits = 9, S$3 = { bits: r$12.lenbits }, x$4 = T$4(D$4, r$12.lens, 0, r$12.nlen, r$12.lencode, 0, r$12.work, S$3), r$12.lenbits = S$3.bits, x$4) {
								e$60.msg = "invalid literal/lengths set", r$12.mode = 30;
								break;
							}
							if (r$12.distbits = 6, r$12.distcode = r$12.distdyn, S$3 = { bits: r$12.distbits }, x$4 = T$4(F$4, r$12.lens, r$12.nlen, r$12.ndist, r$12.distcode, 0, r$12.work, S$3), r$12.distbits = S$3.bits, x$4) {
								e$60.msg = "invalid distances set", r$12.mode = 30;
								break;
							}
							if (r$12.mode = 20, 6 === t$13) break e;
						case 20: r$12.mode = 21;
						case 21:
							if (6 <= o$35 && 258 <= h$6) {
								e$60.next_out = a$37, e$60.avail_out = h$6, e$60.next_in = s$5, e$60.avail_in = o$35, r$12.hold = u$6, r$12.bits = l$11, R$2(e$60, c$8), a$37 = e$60.next_out, i$7 = e$60.output, h$6 = e$60.avail_out, s$5 = e$60.next_in, n$5 = e$60.input, o$35 = e$60.avail_in, u$6 = r$12.hold, l$11 = r$12.bits, 12 === r$12.mode && (r$12.back = -1);
								break;
							}
							for (r$12.back = 0; g$5 = (C$4 = r$12.lencode[u$6 & (1 << r$12.lenbits) - 1]) >>> 16 & 255, b$4 = 65535 & C$4, !((_$5 = C$4 >>> 24) <= l$11);) {
								if (0 === o$35) break e;
								o$35--, u$6 += n$5[s$5++] << l$11, l$11 += 8;
							}
							if (g$5 && 0 == (240 & g$5)) {
								for (v$4 = _$5, y$5 = g$5, w$5 = b$4; g$5 = (C$4 = r$12.lencode[w$5 + ((u$6 & (1 << v$4 + y$5) - 1) >> v$4)]) >>> 16 & 255, b$4 = 65535 & C$4, !(v$4 + (_$5 = C$4 >>> 24) <= l$11);) {
									if (0 === o$35) break e;
									o$35--, u$6 += n$5[s$5++] << l$11, l$11 += 8;
								}
								u$6 >>>= v$4, l$11 -= v$4, r$12.back += v$4;
							}
							if (u$6 >>>= _$5, l$11 -= _$5, r$12.back += _$5, r$12.length = b$4, 0 === g$5) {
								r$12.mode = 26;
								break;
							}
							if (32 & g$5) {
								r$12.back = -1, r$12.mode = 12;
								break;
							}
							if (64 & g$5) {
								e$60.msg = "invalid literal/length code", r$12.mode = 30;
								break;
							}
							r$12.extra = 15 & g$5, r$12.mode = 22;
						case 22:
							if (r$12.extra) {
								for (z$3 = r$12.extra; l$11 < z$3;) {
									if (0 === o$35) break e;
									o$35--, u$6 += n$5[s$5++] << l$11, l$11 += 8;
								}
								r$12.length += u$6 & (1 << r$12.extra) - 1, u$6 >>>= r$12.extra, l$11 -= r$12.extra, r$12.back += r$12.extra;
							}
							r$12.was = r$12.length, r$12.mode = 23;
						case 23:
							for (; g$5 = (C$4 = r$12.distcode[u$6 & (1 << r$12.distbits) - 1]) >>> 16 & 255, b$4 = 65535 & C$4, !((_$5 = C$4 >>> 24) <= l$11);) {
								if (0 === o$35) break e;
								o$35--, u$6 += n$5[s$5++] << l$11, l$11 += 8;
							}
							if (0 == (240 & g$5)) {
								for (v$4 = _$5, y$5 = g$5, w$5 = b$4; g$5 = (C$4 = r$12.distcode[w$5 + ((u$6 & (1 << v$4 + y$5) - 1) >> v$4)]) >>> 16 & 255, b$4 = 65535 & C$4, !(v$4 + (_$5 = C$4 >>> 24) <= l$11);) {
									if (0 === o$35) break e;
									o$35--, u$6 += n$5[s$5++] << l$11, l$11 += 8;
								}
								u$6 >>>= v$4, l$11 -= v$4, r$12.back += v$4;
							}
							if (u$6 >>>= _$5, l$11 -= _$5, r$12.back += _$5, 64 & g$5) {
								e$60.msg = "invalid distance code", r$12.mode = 30;
								break;
							}
							r$12.offset = b$4, r$12.extra = 15 & g$5, r$12.mode = 24;
						case 24:
							if (r$12.extra) {
								for (z$3 = r$12.extra; l$11 < z$3;) {
									if (0 === o$35) break e;
									o$35--, u$6 += n$5[s$5++] << l$11, l$11 += 8;
								}
								r$12.offset += u$6 & (1 << r$12.extra) - 1, u$6 >>>= r$12.extra, l$11 -= r$12.extra, r$12.back += r$12.extra;
							}
							if (r$12.offset > r$12.dmax) {
								e$60.msg = "invalid distance too far back", r$12.mode = 30;
								break;
							}
							r$12.mode = 25;
						case 25:
							if (0 === h$6) break e;
							if (d$5 = c$8 - h$6, r$12.offset > d$5) {
								if ((d$5 = r$12.offset - d$5) > r$12.whave && r$12.sane) {
									e$60.msg = "invalid distance too far back", r$12.mode = 30;
									break;
								}
								p$6 = d$5 > r$12.wnext ? (d$5 -= r$12.wnext, r$12.wsize - d$5) : r$12.wnext - d$5, d$5 > r$12.length && (d$5 = r$12.length), m$5 = r$12.window;
							} else m$5 = i$7, p$6 = a$37 - r$12.offset, d$5 = r$12.length;
							for (h$6 < d$5 && (d$5 = h$6), h$6 -= d$5, r$12.length -= d$5; i$7[a$37++] = m$5[p$6++], --d$5;);
							0 === r$12.length && (r$12.mode = 21);
							break;
						case 26:
							if (0 === h$6) break e;
							i$7[a$37++] = r$12.length, h$6--, r$12.mode = 21;
							break;
						case 27:
							if (r$12.wrap) {
								for (; l$11 < 32;) {
									if (0 === o$35) break e;
									o$35--, u$6 |= n$5[s$5++] << l$11, l$11 += 8;
								}
								if (c$8 -= h$6, e$60.total_out += c$8, r$12.total += c$8, c$8 && (e$60.adler = r$12.check = r$12.flags ? B$4(r$12.check, i$7, c$8, a$37 - c$8) : O$3(r$12.check, i$7, c$8, a$37 - c$8)), c$8 = h$6, (r$12.flags ? u$6 : L$3(u$6)) !== r$12.check) {
									e$60.msg = "incorrect data check", r$12.mode = 30;
									break;
								}
								l$11 = u$6 = 0;
							}
							r$12.mode = 28;
						case 28:
							if (r$12.wrap && r$12.flags) {
								for (; l$11 < 32;) {
									if (0 === o$35) break e;
									o$35--, u$6 += n$5[s$5++] << l$11, l$11 += 8;
								}
								if (u$6 !== (4294967295 & r$12.total)) {
									e$60.msg = "incorrect length check", r$12.mode = 30;
									break;
								}
								l$11 = u$6 = 0;
							}
							r$12.mode = 29;
						case 29:
							x$4 = 1;
							break e;
						case 30:
							x$4 = -3;
							break e;
						case 31: return -4;
						case 32:
						default: return U$2;
					}
					return e$60.next_out = a$37, e$60.avail_out = h$6, e$60.next_in = s$5, e$60.avail_in = o$35, r$12.hold = u$6, r$12.bits = l$11, (r$12.wsize || c$8 !== e$60.avail_out && r$12.mode < 30 && (r$12.mode < 27 || 4 !== t$13)) && Z$1(e$60, e$60.output, e$60.next_out, c$8 - e$60.avail_out) ? (r$12.mode = 31, -4) : (f$6 -= e$60.avail_in, c$8 -= e$60.avail_out, e$60.total_in += f$6, e$60.total_out += c$8, r$12.total += c$8, r$12.wrap && c$8 && (e$60.adler = r$12.check = r$12.flags ? B$4(r$12.check, i$7, c$8, e$60.next_out - c$8) : O$3(r$12.check, i$7, c$8, e$60.next_out - c$8)), e$60.data_type = r$12.bits + (r$12.last ? 64 : 0) + (12 === r$12.mode ? 128 : 0) + (20 === r$12.mode || 15 === r$12.mode ? 256 : 0), (0 == f$6 && 0 === c$8 || 4 === t$13) && x$4 === N$3 && (x$4 = -5), x$4);
				}, r$11.inflateEnd = function(e$60) {
					if (!e$60 || !e$60.state) return U$2;
					var t$13 = e$60.state;
					return t$13.window && (t$13.window = null), e$60.state = null, N$3;
				}, r$11.inflateGetHeader = function(e$60, t$13) {
					var r$12;
					return e$60 && e$60.state ? 0 == (2 & (r$12 = e$60.state).wrap) ? U$2 : ((r$12.head = t$13).done = !1, N$3) : U$2;
				}, r$11.inflateSetDictionary = function(e$60, t$13) {
					var r$12, n$5 = t$13.length;
					return e$60 && e$60.state ? 0 !== (r$12 = e$60.state).wrap && 11 !== r$12.mode ? U$2 : 11 === r$12.mode && O$3(1, t$13, n$5, 0) !== r$12.check ? -3 : Z$1(e$60, t$13, n$5, n$5) ? (r$12.mode = 31, -4) : (r$12.havedict = 1, N$3) : U$2;
				}, r$11.inflateInfo = "pako inflate (from Nodeca project)";
			}, {
				"../utils/common": 41,
				"./adler32": 43,
				"./crc32": 45,
				"./inffast": 48,
				"./inftrees": 50
			}],
			50: [function(e$59, t$12, r$11) {
				"use strict";
				var D$4 = e$59("../utils/common"), F$4 = [
					3,
					4,
					5,
					6,
					7,
					8,
					9,
					10,
					11,
					13,
					15,
					17,
					19,
					23,
					27,
					31,
					35,
					43,
					51,
					59,
					67,
					83,
					99,
					115,
					131,
					163,
					195,
					227,
					258,
					0,
					0
				], N$3 = [
					16,
					16,
					16,
					16,
					16,
					16,
					16,
					16,
					17,
					17,
					17,
					17,
					18,
					18,
					18,
					18,
					19,
					19,
					19,
					19,
					20,
					20,
					20,
					20,
					21,
					21,
					21,
					21,
					16,
					72,
					78
				], U$2 = [
					1,
					2,
					3,
					4,
					5,
					7,
					9,
					13,
					17,
					25,
					33,
					49,
					65,
					97,
					129,
					193,
					257,
					385,
					513,
					769,
					1025,
					1537,
					2049,
					3073,
					4097,
					6145,
					8193,
					12289,
					16385,
					24577,
					0,
					0
				], P$3 = [
					16,
					16,
					16,
					16,
					17,
					17,
					18,
					18,
					19,
					19,
					20,
					20,
					21,
					21,
					22,
					22,
					23,
					23,
					24,
					24,
					25,
					25,
					26,
					26,
					27,
					27,
					28,
					28,
					29,
					29,
					64,
					64
				];
				t$12.exports = function(e$60, t$13, r$12, n$4, i$6, s$4, a$36, o$34) {
					var h$5, u$5, l$10, f$5, c$7, d$5, p$6, m$5, _$5, g$5 = o$34.bits, b$4 = 0, v$4 = 0, y$5 = 0, w$5 = 0, k$4 = 0, x$4 = 0, S$3 = 0, z$3 = 0, C$4 = 0, E$4 = 0, A$3 = null, I$2 = 0, O$3 = new D$4.Buf16(16), B$4 = new D$4.Buf16(16), R$2 = null, T$4 = 0;
					for (b$4 = 0; b$4 <= 15; b$4++) O$3[b$4] = 0;
					for (v$4 = 0; v$4 < n$4; v$4++) O$3[t$13[r$12 + v$4]]++;
					for (k$4 = g$5, w$5 = 15; 1 <= w$5 && 0 === O$3[w$5]; w$5--);
					if (w$5 < k$4 && (k$4 = w$5), 0 === w$5) return i$6[s$4++] = 20971520, i$6[s$4++] = 20971520, o$34.bits = 1, 0;
					for (y$5 = 1; y$5 < w$5 && 0 === O$3[y$5]; y$5++);
					for (k$4 < y$5 && (k$4 = y$5), b$4 = z$3 = 1; b$4 <= 15; b$4++) if (z$3 <<= 1, (z$3 -= O$3[b$4]) < 0) return -1;
					if (0 < z$3 && (0 === e$60 || 1 !== w$5)) return -1;
					for (B$4[1] = 0, b$4 = 1; b$4 < 15; b$4++) B$4[b$4 + 1] = B$4[b$4] + O$3[b$4];
					for (v$4 = 0; v$4 < n$4; v$4++) 0 !== t$13[r$12 + v$4] && (a$36[B$4[t$13[r$12 + v$4]]++] = v$4);
					if (d$5 = 0 === e$60 ? (A$3 = R$2 = a$36, 19) : 1 === e$60 ? (A$3 = F$4, I$2 -= 257, R$2 = N$3, T$4 -= 257, 256) : (A$3 = U$2, R$2 = P$3, -1), b$4 = y$5, c$7 = s$4, S$3 = v$4 = E$4 = 0, l$10 = -1, f$5 = (C$4 = 1 << (x$4 = k$4)) - 1, 1 === e$60 && 852 < C$4 || 2 === e$60 && 592 < C$4) return 1;
					for (;;) {
						for (p$6 = b$4 - S$3, _$5 = a$36[v$4] < d$5 ? (m$5 = 0, a$36[v$4]) : a$36[v$4] > d$5 ? (m$5 = R$2[T$4 + a$36[v$4]], A$3[I$2 + a$36[v$4]]) : (m$5 = 96, 0), h$5 = 1 << b$4 - S$3, y$5 = u$5 = 1 << x$4; i$6[c$7 + (E$4 >> S$3) + (u$5 -= h$5)] = p$6 << 24 | m$5 << 16 | _$5 | 0, 0 !== u$5;);
						for (h$5 = 1 << b$4 - 1; E$4 & h$5;) h$5 >>= 1;
						if (0 !== h$5 ? (E$4 &= h$5 - 1, E$4 += h$5) : E$4 = 0, v$4++, 0 == --O$3[b$4]) {
							if (b$4 === w$5) break;
							b$4 = t$13[r$12 + a$36[v$4]];
						}
						if (k$4 < b$4 && (E$4 & f$5) !== l$10) {
							for (0 === S$3 && (S$3 = k$4), c$7 += y$5, z$3 = 1 << (x$4 = b$4 - S$3); x$4 + S$3 < w$5 && !((z$3 -= O$3[x$4 + S$3]) <= 0);) x$4++, z$3 <<= 1;
							if (C$4 += 1 << x$4, 1 === e$60 && 852 < C$4 || 2 === e$60 && 592 < C$4) return 1;
							i$6[l$10 = E$4 & f$5] = k$4 << 24 | x$4 << 16 | c$7 - s$4 | 0;
						}
					}
					return 0 !== E$4 && (i$6[c$7 + E$4] = b$4 - S$3 << 24 | 4194304), o$34.bits = k$4, 0;
				};
			}, { "../utils/common": 41 }],
			51: [function(e$59, t$12, r$11) {
				"use strict";
				t$12.exports = {
					2: "need dictionary",
					1: "stream end",
					0: "",
					"-1": "file error",
					"-2": "stream error",
					"-3": "data error",
					"-4": "insufficient memory",
					"-5": "buffer error",
					"-6": "incompatible version"
				};
			}, {}],
			52: [function(e$59, t$12, r$11) {
				"use strict";
				var i$6 = e$59("../utils/common"), o$34 = 0, h$5 = 1;
				function n$4(e$60) {
					for (var t$13 = e$60.length; 0 <= --t$13;) e$60[t$13] = 0;
				}
				var s$4 = 0, a$36 = 29, u$5 = 256, l$10 = u$5 + 1 + a$36, f$5 = 30, c$7 = 19, _$5 = 2 * l$10 + 1, g$5 = 15, d$5 = 16, p$6 = 7, m$5 = 256, b$4 = 16, v$4 = 17, y$5 = 18, w$5 = [
					0,
					0,
					0,
					0,
					0,
					0,
					0,
					0,
					1,
					1,
					1,
					1,
					2,
					2,
					2,
					2,
					3,
					3,
					3,
					3,
					4,
					4,
					4,
					4,
					5,
					5,
					5,
					5,
					0
				], k$4 = [
					0,
					0,
					0,
					0,
					1,
					1,
					2,
					2,
					3,
					3,
					4,
					4,
					5,
					5,
					6,
					6,
					7,
					7,
					8,
					8,
					9,
					9,
					10,
					10,
					11,
					11,
					12,
					12,
					13,
					13
				], x$4 = [
					0,
					0,
					0,
					0,
					0,
					0,
					0,
					0,
					0,
					0,
					0,
					0,
					0,
					0,
					0,
					0,
					2,
					3,
					7
				], S$3 = [
					16,
					17,
					18,
					0,
					8,
					7,
					9,
					6,
					10,
					5,
					11,
					4,
					12,
					3,
					13,
					2,
					14,
					1,
					15
				], z$3 = new Array(2 * (l$10 + 2));
				n$4(z$3);
				var C$4 = new Array(2 * f$5);
				n$4(C$4);
				var E$4 = new Array(512);
				n$4(E$4);
				var A$3 = new Array(256);
				n$4(A$3);
				var I$2 = new Array(a$36);
				n$4(I$2);
				var O$3, B$4, R$2, T$4 = new Array(f$5);
				function D$4(e$60, t$13, r$12, n$5, i$7) {
					this.static_tree = e$60, this.extra_bits = t$13, this.extra_base = r$12, this.elems = n$5, this.max_length = i$7, this.has_stree = e$60 && e$60.length;
				}
				function F$4(e$60, t$13) {
					this.dyn_tree = e$60, this.max_code = 0, this.stat_desc = t$13;
				}
				function N$3(e$60) {
					return e$60 < 256 ? E$4[e$60] : E$4[256 + (e$60 >>> 7)];
				}
				function U$2(e$60, t$13) {
					e$60.pending_buf[e$60.pending++] = 255 & t$13, e$60.pending_buf[e$60.pending++] = t$13 >>> 8 & 255;
				}
				function P$3(e$60, t$13, r$12) {
					e$60.bi_valid > d$5 - r$12 ? (e$60.bi_buf |= t$13 << e$60.bi_valid & 65535, U$2(e$60, e$60.bi_buf), e$60.bi_buf = t$13 >> d$5 - e$60.bi_valid, e$60.bi_valid += r$12 - d$5) : (e$60.bi_buf |= t$13 << e$60.bi_valid & 65535, e$60.bi_valid += r$12);
				}
				function L$3(e$60, t$13, r$12) {
					P$3(e$60, r$12[2 * t$13], r$12[2 * t$13 + 1]);
				}
				function j$4(e$60, t$13) {
					for (var r$12 = 0; r$12 |= 1 & e$60, e$60 >>>= 1, r$12 <<= 1, 0 < --t$13;);
					return r$12 >>> 1;
				}
				function Z$1(e$60, t$13, r$12) {
					var n$5, i$7, s$5 = new Array(g$5 + 1), a$37 = 0;
					for (n$5 = 1; n$5 <= g$5; n$5++) s$5[n$5] = a$37 = a$37 + r$12[n$5 - 1] << 1;
					for (i$7 = 0; i$7 <= t$13; i$7++) {
						var o$35 = e$60[2 * i$7 + 1];
						0 !== o$35 && (e$60[2 * i$7] = j$4(s$5[o$35]++, o$35));
					}
				}
				function W$2(e$60) {
					var t$13;
					for (t$13 = 0; t$13 < l$10; t$13++) e$60.dyn_ltree[2 * t$13] = 0;
					for (t$13 = 0; t$13 < f$5; t$13++) e$60.dyn_dtree[2 * t$13] = 0;
					for (t$13 = 0; t$13 < c$7; t$13++) e$60.bl_tree[2 * t$13] = 0;
					e$60.dyn_ltree[2 * m$5] = 1, e$60.opt_len = e$60.static_len = 0, e$60.last_lit = e$60.matches = 0;
				}
				function M$2(e$60) {
					8 < e$60.bi_valid ? U$2(e$60, e$60.bi_buf) : 0 < e$60.bi_valid && (e$60.pending_buf[e$60.pending++] = e$60.bi_buf), e$60.bi_buf = 0, e$60.bi_valid = 0;
				}
				function H$3(e$60, t$13, r$12, n$5) {
					var i$7 = 2 * t$13, s$5 = 2 * r$12;
					return e$60[i$7] < e$60[s$5] || e$60[i$7] === e$60[s$5] && n$5[t$13] <= n$5[r$12];
				}
				function G$3(e$60, t$13, r$12) {
					for (var n$5 = e$60.heap[r$12], i$7 = r$12 << 1; i$7 <= e$60.heap_len && (i$7 < e$60.heap_len && H$3(t$13, e$60.heap[i$7 + 1], e$60.heap[i$7], e$60.depth) && i$7++, !H$3(t$13, n$5, e$60.heap[i$7], e$60.depth));) e$60.heap[r$12] = e$60.heap[i$7], r$12 = i$7, i$7 <<= 1;
					e$60.heap[r$12] = n$5;
				}
				function K$3(e$60, t$13, r$12) {
					var n$5, i$7, s$5, a$37, o$35 = 0;
					if (0 !== e$60.last_lit) for (; n$5 = e$60.pending_buf[e$60.d_buf + 2 * o$35] << 8 | e$60.pending_buf[e$60.d_buf + 2 * o$35 + 1], i$7 = e$60.pending_buf[e$60.l_buf + o$35], o$35++, 0 === n$5 ? L$3(e$60, i$7, t$13) : (L$3(e$60, (s$5 = A$3[i$7]) + u$5 + 1, t$13), 0 !== (a$37 = w$5[s$5]) && P$3(e$60, i$7 -= I$2[s$5], a$37), L$3(e$60, s$5 = N$3(--n$5), r$12), 0 !== (a$37 = k$4[s$5]) && P$3(e$60, n$5 -= T$4[s$5], a$37)), o$35 < e$60.last_lit;);
					L$3(e$60, m$5, t$13);
				}
				function Y$1(e$60, t$13) {
					var r$12, n$5, i$7, s$5 = t$13.dyn_tree, a$37 = t$13.stat_desc.static_tree, o$35 = t$13.stat_desc.has_stree, h$6 = t$13.stat_desc.elems, u$6 = -1;
					for (e$60.heap_len = 0, e$60.heap_max = _$5, r$12 = 0; r$12 < h$6; r$12++) 0 !== s$5[2 * r$12] ? (e$60.heap[++e$60.heap_len] = u$6 = r$12, e$60.depth[r$12] = 0) : s$5[2 * r$12 + 1] = 0;
					for (; e$60.heap_len < 2;) s$5[2 * (i$7 = e$60.heap[++e$60.heap_len] = u$6 < 2 ? ++u$6 : 0)] = 1, e$60.depth[i$7] = 0, e$60.opt_len--, o$35 && (e$60.static_len -= a$37[2 * i$7 + 1]);
					for (t$13.max_code = u$6, r$12 = e$60.heap_len >> 1; 1 <= r$12; r$12--) G$3(e$60, s$5, r$12);
					for (i$7 = h$6; r$12 = e$60.heap[1], e$60.heap[1] = e$60.heap[e$60.heap_len--], G$3(e$60, s$5, 1), n$5 = e$60.heap[1], e$60.heap[--e$60.heap_max] = r$12, e$60.heap[--e$60.heap_max] = n$5, s$5[2 * i$7] = s$5[2 * r$12] + s$5[2 * n$5], e$60.depth[i$7] = (e$60.depth[r$12] >= e$60.depth[n$5] ? e$60.depth[r$12] : e$60.depth[n$5]) + 1, s$5[2 * r$12 + 1] = s$5[2 * n$5 + 1] = i$7, e$60.heap[1] = i$7++, G$3(e$60, s$5, 1), 2 <= e$60.heap_len;);
					e$60.heap[--e$60.heap_max] = e$60.heap[1], function(e$61, t$14) {
						var r$13, n$6, i$8, s$6, a$38, o$36, h$7 = t$14.dyn_tree, u$7 = t$14.max_code, l$11 = t$14.stat_desc.static_tree, f$6 = t$14.stat_desc.has_stree, c$8 = t$14.stat_desc.extra_bits, d$6 = t$14.stat_desc.extra_base, p$7 = t$14.stat_desc.max_length, m$6 = 0;
						for (s$6 = 0; s$6 <= g$5; s$6++) e$61.bl_count[s$6] = 0;
						for (h$7[2 * e$61.heap[e$61.heap_max] + 1] = 0, r$13 = e$61.heap_max + 1; r$13 < _$5; r$13++) p$7 < (s$6 = h$7[2 * h$7[2 * (n$6 = e$61.heap[r$13]) + 1] + 1] + 1) && (s$6 = p$7, m$6++), h$7[2 * n$6 + 1] = s$6, u$7 < n$6 || (e$61.bl_count[s$6]++, a$38 = 0, d$6 <= n$6 && (a$38 = c$8[n$6 - d$6]), o$36 = h$7[2 * n$6], e$61.opt_len += o$36 * (s$6 + a$38), f$6 && (e$61.static_len += o$36 * (l$11[2 * n$6 + 1] + a$38)));
						if (0 !== m$6) {
							do {
								for (s$6 = p$7 - 1; 0 === e$61.bl_count[s$6];) s$6--;
								e$61.bl_count[s$6]--, e$61.bl_count[s$6 + 1] += 2, e$61.bl_count[p$7]--, m$6 -= 2;
							} while (0 < m$6);
							for (s$6 = p$7; 0 !== s$6; s$6--) for (n$6 = e$61.bl_count[s$6]; 0 !== n$6;) u$7 < (i$8 = e$61.heap[--r$13]) || (h$7[2 * i$8 + 1] !== s$6 && (e$61.opt_len += (s$6 - h$7[2 * i$8 + 1]) * h$7[2 * i$8], h$7[2 * i$8 + 1] = s$6), n$6--);
						}
					}(e$60, t$13), Z$1(s$5, u$6, e$60.bl_count);
				}
				function X$2(e$60, t$13, r$12) {
					var n$5, i$7, s$5 = -1, a$37 = t$13[1], o$35 = 0, h$6 = 7, u$6 = 4;
					for (0 === a$37 && (h$6 = 138, u$6 = 3), t$13[2 * (r$12 + 1) + 1] = 65535, n$5 = 0; n$5 <= r$12; n$5++) i$7 = a$37, a$37 = t$13[2 * (n$5 + 1) + 1], ++o$35 < h$6 && i$7 === a$37 || (o$35 < u$6 ? e$60.bl_tree[2 * i$7] += o$35 : 0 !== i$7 ? (i$7 !== s$5 && e$60.bl_tree[2 * i$7]++, e$60.bl_tree[2 * b$4]++) : o$35 <= 10 ? e$60.bl_tree[2 * v$4]++ : e$60.bl_tree[2 * y$5]++, s$5 = i$7, u$6 = (o$35 = 0) === a$37 ? (h$6 = 138, 3) : i$7 === a$37 ? (h$6 = 6, 3) : (h$6 = 7, 4));
				}
				function V$3(e$60, t$13, r$12) {
					var n$5, i$7, s$5 = -1, a$37 = t$13[1], o$35 = 0, h$6 = 7, u$6 = 4;
					for (0 === a$37 && (h$6 = 138, u$6 = 3), n$5 = 0; n$5 <= r$12; n$5++) if (i$7 = a$37, a$37 = t$13[2 * (n$5 + 1) + 1], !(++o$35 < h$6 && i$7 === a$37)) {
						if (o$35 < u$6) for (; L$3(e$60, i$7, e$60.bl_tree), 0 != --o$35;);
						else 0 !== i$7 ? (i$7 !== s$5 && (L$3(e$60, i$7, e$60.bl_tree), o$35--), L$3(e$60, b$4, e$60.bl_tree), P$3(e$60, o$35 - 3, 2)) : o$35 <= 10 ? (L$3(e$60, v$4, e$60.bl_tree), P$3(e$60, o$35 - 3, 3)) : (L$3(e$60, y$5, e$60.bl_tree), P$3(e$60, o$35 - 11, 7));
						s$5 = i$7, u$6 = (o$35 = 0) === a$37 ? (h$6 = 138, 3) : i$7 === a$37 ? (h$6 = 6, 3) : (h$6 = 7, 4);
					}
				}
				n$4(T$4);
				var q$5 = !1;
				function J$3(e$60, t$13, r$12, n$5) {
					P$3(e$60, (s$4 << 1) + (n$5 ? 1 : 0), 3), function(e$61, t$14, r$13, n$6) {
						M$2(e$61), n$6 && (U$2(e$61, r$13), U$2(e$61, ~r$13)), i$6.arraySet(e$61.pending_buf, e$61.window, t$14, r$13, e$61.pending), e$61.pending += r$13;
					}(e$60, t$13, r$12, !0);
				}
				r$11._tr_init = function(e$60) {
					q$5 || (function() {
						var e$61, t$13, r$12, n$5, i$7, s$5 = new Array(g$5 + 1);
						for (n$5 = r$12 = 0; n$5 < a$36 - 1; n$5++) for (I$2[n$5] = r$12, e$61 = 0; e$61 < 1 << w$5[n$5]; e$61++) A$3[r$12++] = n$5;
						for (A$3[r$12 - 1] = n$5, n$5 = i$7 = 0; n$5 < 16; n$5++) for (T$4[n$5] = i$7, e$61 = 0; e$61 < 1 << k$4[n$5]; e$61++) E$4[i$7++] = n$5;
						for (i$7 >>= 7; n$5 < f$5; n$5++) for (T$4[n$5] = i$7 << 7, e$61 = 0; e$61 < 1 << k$4[n$5] - 7; e$61++) E$4[256 + i$7++] = n$5;
						for (t$13 = 0; t$13 <= g$5; t$13++) s$5[t$13] = 0;
						for (e$61 = 0; e$61 <= 143;) z$3[2 * e$61 + 1] = 8, e$61++, s$5[8]++;
						for (; e$61 <= 255;) z$3[2 * e$61 + 1] = 9, e$61++, s$5[9]++;
						for (; e$61 <= 279;) z$3[2 * e$61 + 1] = 7, e$61++, s$5[7]++;
						for (; e$61 <= 287;) z$3[2 * e$61 + 1] = 8, e$61++, s$5[8]++;
						for (Z$1(z$3, l$10 + 1, s$5), e$61 = 0; e$61 < f$5; e$61++) C$4[2 * e$61 + 1] = 5, C$4[2 * e$61] = j$4(e$61, 5);
						O$3 = new D$4(z$3, w$5, u$5 + 1, l$10, g$5), B$4 = new D$4(C$4, k$4, 0, f$5, g$5), R$2 = new D$4(new Array(0), x$4, 0, c$7, p$6);
					}(), q$5 = !0), e$60.l_desc = new F$4(e$60.dyn_ltree, O$3), e$60.d_desc = new F$4(e$60.dyn_dtree, B$4), e$60.bl_desc = new F$4(e$60.bl_tree, R$2), e$60.bi_buf = 0, e$60.bi_valid = 0, W$2(e$60);
				}, r$11._tr_stored_block = J$3, r$11._tr_flush_block = function(e$60, t$13, r$12, n$5) {
					var i$7, s$5, a$37 = 0;
					0 < e$60.level ? (2 === e$60.strm.data_type && (e$60.strm.data_type = function(e$61) {
						var t$14, r$13 = 4093624447;
						for (t$14 = 0; t$14 <= 31; t$14++, r$13 >>>= 1) if (1 & r$13 && 0 !== e$61.dyn_ltree[2 * t$14]) return o$34;
						if (0 !== e$61.dyn_ltree[18] || 0 !== e$61.dyn_ltree[20] || 0 !== e$61.dyn_ltree[26]) return h$5;
						for (t$14 = 32; t$14 < u$5; t$14++) if (0 !== e$61.dyn_ltree[2 * t$14]) return h$5;
						return o$34;
					}(e$60)), Y$1(e$60, e$60.l_desc), Y$1(e$60, e$60.d_desc), a$37 = function(e$61) {
						var t$14;
						for (X$2(e$61, e$61.dyn_ltree, e$61.l_desc.max_code), X$2(e$61, e$61.dyn_dtree, e$61.d_desc.max_code), Y$1(e$61, e$61.bl_desc), t$14 = c$7 - 1; 3 <= t$14 && 0 === e$61.bl_tree[2 * S$3[t$14] + 1]; t$14--);
						return e$61.opt_len += 3 * (t$14 + 1) + 5 + 5 + 4, t$14;
					}(e$60), i$7 = e$60.opt_len + 3 + 7 >>> 3, (s$5 = e$60.static_len + 3 + 7 >>> 3) <= i$7 && (i$7 = s$5)) : i$7 = s$5 = r$12 + 5, r$12 + 4 <= i$7 && -1 !== t$13 ? J$3(e$60, t$13, r$12, n$5) : 4 === e$60.strategy || s$5 === i$7 ? (P$3(e$60, 2 + (n$5 ? 1 : 0), 3), K$3(e$60, z$3, C$4)) : (P$3(e$60, 4 + (n$5 ? 1 : 0), 3), function(e$61, t$14, r$13, n$6) {
						var i$8;
						for (P$3(e$61, t$14 - 257, 5), P$3(e$61, r$13 - 1, 5), P$3(e$61, n$6 - 4, 4), i$8 = 0; i$8 < n$6; i$8++) P$3(e$61, e$61.bl_tree[2 * S$3[i$8] + 1], 3);
						V$3(e$61, e$61.dyn_ltree, t$14 - 1), V$3(e$61, e$61.dyn_dtree, r$13 - 1);
					}(e$60, e$60.l_desc.max_code + 1, e$60.d_desc.max_code + 1, a$37 + 1), K$3(e$60, e$60.dyn_ltree, e$60.dyn_dtree)), W$2(e$60), n$5 && M$2(e$60);
				}, r$11._tr_tally = function(e$60, t$13, r$12) {
					return e$60.pending_buf[e$60.d_buf + 2 * e$60.last_lit] = t$13 >>> 8 & 255, e$60.pending_buf[e$60.d_buf + 2 * e$60.last_lit + 1] = 255 & t$13, e$60.pending_buf[e$60.l_buf + e$60.last_lit] = 255 & r$12, e$60.last_lit++, 0 === t$13 ? e$60.dyn_ltree[2 * r$12]++ : (e$60.matches++, t$13--, e$60.dyn_ltree[2 * (A$3[r$12] + u$5 + 1)]++, e$60.dyn_dtree[2 * N$3(t$13)]++), e$60.last_lit === e$60.lit_bufsize - 1;
				}, r$11._tr_align = function(e$60) {
					P$3(e$60, 2, 3), L$3(e$60, m$5, z$3), function(e$61) {
						16 === e$61.bi_valid ? (U$2(e$61, e$61.bi_buf), e$61.bi_buf = 0, e$61.bi_valid = 0) : 8 <= e$61.bi_valid && (e$61.pending_buf[e$61.pending++] = 255 & e$61.bi_buf, e$61.bi_buf >>= 8, e$61.bi_valid -= 8);
					}(e$60);
				};
			}, { "../utils/common": 41 }],
			53: [function(e$59, t$12, r$11) {
				"use strict";
				t$12.exports = function() {
					this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
				};
			}, {}],
			54: [function(e$59, t$12, r$11) {
				(function(e$60) {
					(function(r$12, n$4) {
						"use strict";
						if (!r$12.setImmediate) {
							var i$6, s$4, t$13, a$36, o$34 = 1, h$5 = {}, u$5 = !1, l$10 = r$12.document, e$61 = Object.getPrototypeOf && Object.getPrototypeOf(r$12);
							e$61 = e$61 && e$61.setTimeout ? e$61 : r$12, i$6 = "[object process]" === {}.toString.call(r$12.process) ? function(e$62) {
								process.nextTick(function() {
									c$7(e$62);
								});
							} : function() {
								if (r$12.postMessage && !r$12.importScripts) {
									var e$62 = !0, t$14 = r$12.onmessage;
									return r$12.onmessage = function() {
										e$62 = !1;
									}, r$12.postMessage("", "*"), r$12.onmessage = t$14, e$62;
								}
							}() ? (a$36 = "setImmediate$" + Math.random() + "$", r$12.addEventListener ? r$12.addEventListener("message", d$5, !1) : r$12.attachEvent("onmessage", d$5), function(e$62) {
								r$12.postMessage(a$36 + e$62, "*");
							}) : r$12.MessageChannel ? ((t$13 = new MessageChannel()).port1.onmessage = function(e$62) {
								c$7(e$62.data);
							}, function(e$62) {
								t$13.port2.postMessage(e$62);
							}) : l$10 && "onreadystatechange" in l$10.createElement("script") ? (s$4 = l$10.documentElement, function(e$62) {
								var t$14 = l$10.createElement("script");
								t$14.onreadystatechange = function() {
									c$7(e$62), t$14.onreadystatechange = null, s$4.removeChild(t$14), t$14 = null;
								}, s$4.appendChild(t$14);
							}) : function(e$62) {
								setTimeout(c$7, 0, e$62);
							}, e$61.setImmediate = function(e$62) {
								"function" != typeof e$62 && (e$62 = new Function("" + e$62));
								for (var t$14 = new Array(arguments.length - 1), r$13 = 0; r$13 < t$14.length; r$13++) t$14[r$13] = arguments[r$13 + 1];
								return h$5[o$34] = {
									callback: e$62,
									args: t$14
								}, i$6(o$34), o$34++;
							}, e$61.clearImmediate = f$5;
						}
						function f$5(e$62) {
							delete h$5[e$62];
						}
						function c$7(e$62) {
							if (u$5) setTimeout(c$7, 0, e$62);
							else {
								var t$14 = h$5[e$62];
								if (t$14) {
									u$5 = !0;
									try {
										(function(e$63) {
											var t$15 = e$63.callback, r$13 = e$63.args;
											switch (r$13.length) {
												case 0:
													t$15();
													break;
												case 1:
													t$15(r$13[0]);
													break;
												case 2:
													t$15(r$13[0], r$13[1]);
													break;
												case 3:
													t$15(r$13[0], r$13[1], r$13[2]);
													break;
												default: t$15.apply(n$4, r$13);
											}
										})(t$14);
									} finally {
										f$5(e$62), u$5 = !1;
									}
								}
							}
						}
						function d$5(e$62) {
							e$62.source === r$12 && "string" == typeof e$62.data && 0 === e$62.data.indexOf(a$36) && c$7(+e$62.data.slice(a$36.length));
						}
					})("undefined" == typeof self ? void 0 === e$60 ? this : e$60 : self);
				}).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
			}, {}]
		}, {}, [10])(10);
	});
})))(), 1);
const Tools = () => {
	const handleDownloadProjects = async () => {
		const zip = new import_jszip_min.default();
		projects.value.forEach((project) => {
			zip.file(project.name + ".lm", project.scratch.code, {
				compression: "DEFLATE",
				compressionOptions: { level: 9 },
				unixPermissions: 420
			});
		});
		const blob = await zip.generateAsync({ type: "blob" });
		const url = URL.createObjectURL(blob);
		const a$36 = document.createElement("a");
		a$36.href = url;
		a$36.download = `loopmaster-projects-${(/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-").slice(0, -5)}.zip`;
		a$36.click();
		URL.revokeObjectURL(url);
	};
	return /* @__PURE__ */ u(SidebarMain, { children: [
		session.value && /* @__PURE__ */ u(SidebarButton, {
			onClick: () => sidebarTab.value = "share-project",
			children: [/* @__PURE__ */ u(o$7, {
				size: 16,
				class: "group-hover:text-white"
			}), /* @__PURE__ */ u("span", { children: "Share Project" })]
		}),
		/* @__PURE__ */ u(SidebarButton, {
			onClick: () => sidebarTab.value = "export-audio",
			children: [/* @__PURE__ */ u(e$6, {
				size: 16,
				class: "group-hover:text-white"
			}), /* @__PURE__ */ u("span", { children: "Export Audio" })]
		}),
		session.value && /* @__PURE__ */ u(SidebarButton, {
			onClick: handleDownloadProjects,
			children: [/* @__PURE__ */ u(a, {
				size: 16,
				class: "group-hover:text-white"
			}), /* @__PURE__ */ u("span", { children: "Download Projects" })]
		}),
		(settings.debug || session.value?.isAdmin) && /* @__PURE__ */ u(SidebarButton, {
			onClick: () => sidebarTab.value = "bytecode",
			children: [/* @__PURE__ */ u(o$6, {
				size: 16,
				class: "group-hover:text-white"
			}), /* @__PURE__ */ u("span", { children: "Bytecode" })]
		}),
		(settings.debug || session.value?.isAdmin) && /* @__PURE__ */ u(SidebarButton, {
			onClick: () => sidebarTab.value = "console",
			children: [/* @__PURE__ */ u(o$8, {
				size: 16,
				class: "group-hover:text-white"
			}), /* @__PURE__ */ u("span", { children: "Console" })]
		})
	] });
};
const tutorials = [
	{
		name: "Getting Started",
		description: "Learn the basics of loopmaster",
		href: "/tutorials/getting-started",
		Icon: e$8
	},
	{
		name: "Drum One-Liners",
		description: "Learn how to make drums with one-liners",
		href: "/tutorials/drum-one-liners",
		Icon: e$1
	},
	{
		name: "Making a House Loop",
		description: "Learn how to make a house loop",
		href: "/tutorials/making-a-house-loop",
		Icon: e$7
	}
];
const Tutorials = () => {
	const tutorialName = useComputed(() => pathname.value.split("/")[2]);
	return /* @__PURE__ */ u(SidebarMain, { children: tutorials.map((tutorial) => /* @__PURE__ */ u(SidebarLink, {
		to: tutorial.href,
		className: cn({ "text-white bg-white/5": tutorialName.value === tutorial.href }),
		children: [/* @__PURE__ */ u(tutorial.Icon, { size: 16 }), tutorial.name]
	})) });
};
var sidebarButtonClass = "select-none p-4 flex items-center justify-center hover:bg-white/5 focus:bg-white/5 outline-none text-neutral-400 text-sm";
var SidebarTabLink = ({ icon, tab, title: title$1 }) => /* @__PURE__ */ u(Link$1, {
	to: tab ? `/${tab}` : "/",
	title: title$1,
	class: cn(sidebarButtonClass, { "text-white": sidebarTab.value === tab?.split("/")[0] }),
	onClick: () => {
		const targetTab = tab?.split("/")[0];
		sidebarTab.value = targetTab === sidebarTab.value ? null : targetTab;
	},
	children: icon
});
var SidebarTabButton = ({ icon, tab, title: title$1 }) => /* @__PURE__ */ u("button", {
	class: cn(sidebarButtonClass, { "text-white": sidebarTab.value === tab }),
	title: title$1,
	onClick: () => {
		const targetTab = tab;
		sidebarTab.value = targetTab === sidebarTab.value ? null : targetTab;
	},
	children: icon
});
const Sidebar = () => /* @__PURE__ */ u("div", {
	class: "flex flex-row w-full h-[100dvh] overflow-hidden text-neutral-500",
	children: [/* @__PURE__ */ u("div", {
		class: "flex flex-col items-stretch justify-start h-full",
		children: [
			/* @__PURE__ */ u("div", {
				class: `w-full h-[50px] leading-none flex items-end border-b-2 border-[${primaryColor.value}]`,
				children: /* @__PURE__ */ u(Link$1, {
					to: "/",
					class: "px-2 py-1 top-[1px] relative hover:bg-white/5 focus:bg-white/5 outline-none",
					children: /* @__PURE__ */ u(Logo, {})
				})
			}),
			/* @__PURE__ */ u(SidebarTabLink, {
				icon: /* @__PURE__ */ u(e$6, { size: 16 }),
				tab: "projects",
				title: "Projects"
			}),
			session.value?.isAdmin && /* @__PURE__ */ u(SidebarTabLink, {
				icon: /* @__PURE__ */ u(o$1, { size: 16 }),
				tab: "dj",
				title: "DJ"
			}),
			/* @__PURE__ */ u(SidebarTabLink, {
				icon: /* @__PURE__ */ u(o$5, { size: 16 }),
				tab: "tools",
				title: "Tools"
			}),
			/* @__PURE__ */ u(SidebarTabButton, {
				icon: /* @__PURE__ */ u(o, { size: 16 }),
				tab: "settings",
				title: "Settings"
			}),
			/* @__PURE__ */ u(SidebarTabLink, {
				icon: /* @__PURE__ */ u(e$4, { size: 16 }),
				tab: "browse/newest",
				title: "Browse"
			}),
			/* @__PURE__ */ u(SidebarTabButton, {
				icon: /* @__PURE__ */ u(o$4, { size: 16 }),
				tab: "account",
				title: "Account"
			}),
			/* @__PURE__ */ u(SidebarTabLink, {
				icon: /* @__PURE__ */ u(e$3, { size: 16 }),
				tab: "docs",
				title: "Docs"
			}),
			/* @__PURE__ */ u(SidebarTabLink, {
				icon: /* @__PURE__ */ u(e, { size: 16 }),
				tab: "tutorials",
				title: "Tutorials"
			}),
			/* @__PURE__ */ u(SidebarTabLink, {
				icon: /* @__PURE__ */ u(e$5, { size: 16 }),
				tab: "help",
				title: "Help"
			}),
			session.value?.isAdmin && /* @__PURE__ */ u(SidebarTabLink, {
				icon: /* @__PURE__ */ u(o$2, { size: 16 }),
				tab: "ai",
				title: "AI"
			}),
			session.value?.isAdmin && /* @__PURE__ */ u(SidebarTabLink, {
				icon: /* @__PURE__ */ u(r, { size: 16 }),
				tab: "admin",
				title: "Admin"
			}),
			/* @__PURE__ */ u("div", { class: "flex-1" }),
			/* @__PURE__ */ u(Link$1, {
				to: "https://whop.com/loopmaster",
				title: "Support me on Whop",
				target: "_blank",
				class: "p-4 flex items-center justify-center hover:bg-white/5 focus:bg-white/5 outline-none text-neutral-400 text-sm",
				children: /* @__PURE__ */ u("img", {
					src: whop_default,
					alt: "Support me on Whop",
					width: 16,
					height: 16
				})
			}),
			/* @__PURE__ */ u(Link$1, {
				to: "https://www.buymeacoffee.com/loopmaster",
				title: "Buy Me a Coffee",
				target: "_blank",
				class: "p-4 flex items-center justify-center hover:bg-white/5 focus:bg-white/5 outline-none text-neutral-400 text-sm",
				children: /* @__PURE__ */ u("img", {
					src: bmc_default,
					alt: "Buy Me a Coffee",
					width: 16,
					height: 16
				})
			})
		]
	}), sidebarOpen.value && /* @__PURE__ */ u("div", {
		class: "flex flex-col w-full h-full max-h-[100dvh]",
		children: [/* @__PURE__ */ u("div", {
			class: `select-none pl-2 py-1.5 w-full h-[50px] flex items-end border-b-2 border-[${primaryColor.value}]`,
			children: /* @__PURE__ */ u("h2", {
				class: "text-sm font-bold w-full",
				children: {
					"": "",
					"projects": "Projects",
					"browse": "Browse",
					"bytecode": "Bytecode",
					"console": "Console",
					"themes": "Themes",
					"tools": "Tools",
					"settings": "Settings",
					"account": "Account",
					"share-project": "Share Project",
					"export-audio": "Export Audio",
					"help": "Help",
					"docs": /* @__PURE__ */ u("div", {
						class: "relative text-white",
						children: [/* @__PURE__ */ u(o$3, {
							size: 16,
							class: "text-neutral-400 absolute left-0 mt-0.5 top-1/2 -translate-y-1/2"
						}), /* @__PURE__ */ u("input", {
							ref: (el) => {
								el?.focus();
							},
							type: "text",
							value: docsSearch.value,
							onChange: (e$59) => docsSearch.value = e$59.target.value,
							class: "bg-transparent outline-none focus:bg-white/5 px-2 pl-8 py-1 -ml-2 -mb-2 placeholder:text-neutral-400",
							placeholder: "Search docs..."
						})]
					}),
					"tutorials": "Tutorials",
					"admin": "Admin",
					"artist": "",
					"ai": "AI",
					"dj": "DJ"
				}[sidebarTab.value ?? ""] ?? ""
			})
		}), /* @__PURE__ */ u("div", {
			class: "flex-1 min-h-0 flex flex-col",
			children: /* @__PURE__ */ u("div", {
				class: "flex-1 min-h-0 overflow-y-auto",
				children: sidebarTab.value === "projects" ? /* @__PURE__ */ u(Projects, {}) : sidebarTab.value === "tools" ? /* @__PURE__ */ u(Tools, {}) : sidebarTab.value === "bytecode" ? /* @__PURE__ */ u(Bytecode, {}) : sidebarTab.value === "settings" ? /* @__PURE__ */ u(Settings, {}) : sidebarTab.value === "console" ? /* @__PURE__ */ u(Console, {}) : sidebarTab.value === "account" ? /* @__PURE__ */ u(Account, {}) : sidebarTab.value === "themes" ? /* @__PURE__ */ u(Themes, {}) : sidebarTab.value === "share-project" ? /* @__PURE__ */ u(ShareProject, {}) : sidebarTab.value === "export-audio" ? /* @__PURE__ */ u(ExportAudio, {}) : sidebarTab.value === "help" ? /* @__PURE__ */ u(Help, {}) : sidebarTab.value === "docs" ? /* @__PURE__ */ u(Docs, {}) : sidebarTab.value === "tutorials" ? /* @__PURE__ */ u(Tutorials, {}) : sidebarTab.value === "browse" ? /* @__PURE__ */ u(Browse, {}) : sidebarTab.value === "admin" ? /* @__PURE__ */ u(Admin, {}) : sidebarTab.value === "artist" ? /* @__PURE__ */ u(Artist, {}) : sidebarTab.value === "ai" ? /* @__PURE__ */ u(AI, {}) : sidebarTab.value === "dj" ? /* @__PURE__ */ u(DJ, {}) : ""
			})
		})]
	})]
});
var blockquoteRule = {
	type: "inline-block",
	name: "blockquote",
	ruleStartChar: ">",
	test(state) {
		if (state.charAt(0) !== ">") return false;
		if (state.position > state.lineStart + state.indent) return false;
		return true;
	},
	parse(state, parser) {
		const cleanValue = parser.readUntil(() => {
			if (state.charAt(0) === "\n" && state.charAt(1) !== ">") {
				for (let i$6 = 1; i$6 < 4; i$6++) {
					if (state.charAt(i$6) === "\n") return true;
					if (state.charAt(i$6 + 1) === ">") return false;
				}
				return true;
			}
			return false;
		}).replace(/^\s*> ?/gm, "");
		return {
			type: "blockquote",
			children: parser.parse(cleanValue)
		};
	}
};
var BACKTICK = "`";
var CODE_BACKTICKS = "```";
var codeRule = {
	type: "block",
	name: "code",
	test(state) {
		if (state.indent >= 4) return true;
		if (state.charAt(0) === BACKTICK && state.charAt(1) === BACKTICK && state.charAt(2) === BACKTICK) return true;
		return false;
	},
	parse(state, parser) {
		const realIndent = state.position - state.lineStart;
		if (state.indent >= 4) {
			const match = state.src.slice(state.position - realIndent).match(/^((?: {4}|\t)[^\n]*(?:\n|$))+/g);
			if (!match) return {
				type: "code",
				value: parser.readUntil(() => state.charAt(-1) === "\n")
			};
			const raw = match[0];
			const value2 = raw.replace(/^( {4}|\t)/gm, "");
			parser.skip(raw.length - realIndent);
			return {
				type: "code",
				value: value2
			};
		}
		parser.skip(3);
		const language = parser.readUntil((char) => char === "\n") || void 0;
		parser.skip(1);
		const value = parser.readUntil((char) => char === BACKTICK && state.slice(0, 3) === CODE_BACKTICKS);
		parser.skip(3);
		return {
			type: "code",
			language,
			value
		};
	}
};
var COMMENT_REGEX = /<!--\s*(.*?)\s*-->/s;
var commentRule = {
	type: "inline-block",
	name: "comment",
	ruleStartChar: "<",
	test(state) {
		if (state.charAt(0) !== "<") return false;
		return COMMENT_REGEX.test(state.src.slice(state.position));
	},
	parse(state, parser) {
		const match = state.src.slice(state.position).match(COMMENT_REGEX);
		parser.skip(match[0].length);
		return {
			type: "comment",
			value: match[1]
		};
	}
};
var dividerRule = {
	type: "block",
	name: "divider",
	test(state) {
		if (state.indent > 3) return false;
		const symbol = state.charAt(0);
		if (symbol !== "*" && symbol !== "_" && symbol !== "-") return false;
		let symbolCount = 0;
		for (let i$6 = 0; i$6 + state.position < state.length; i$6++) {
			const char = state.charAt(i$6);
			if (char === symbol) {
				symbolCount += 1;
				continue;
			}
			if (char === " " && symbolCount >= 3) continue;
			if (char === "\n") break;
			return false;
		}
		return symbolCount >= 3;
	},
	parse(state, parser) {
		parser.skipUntil((char) => char === "\n");
		return { type: "divider" };
	}
};
function hasValidClosingInBlock(state, char) {
	const endOfRule = state.src.indexOf(char, state.position + char.length);
	const endOfBlock = state.src.indexOf("\n\n", state.position + char.length);
	if (endOfRule === -1) return false;
	return endOfRule < (endOfBlock === -1 ? state.length : endOfBlock);
}
function isSpecialCharacter(char) {
	return char === "*" || char === "_";
}
var emphasisRule = {
	type: "inline",
	name: "emphasis",
	ruleStartChar: ["*", "_"],
	test(state) {
		const char = state.charAt(0);
		if (!isSpecialCharacter(char) || isSpecialCharacter(state.charAt(1))) return false;
		return hasValidClosingInBlock(state, char);
	},
	parse(state, parser) {
		const symbol = state.charAt(0);
		parser.skip(1);
		const node = {
			type: "emphasis",
			children: parser.parseInline(() => {
				return state.charAt(0) === symbol;
			})
		};
		parser.skip(1);
		return node;
	}
};
function getLevel(src) {
	const length = src.length;
	for (let level = 0; level < length; level++) if (src.charAt(level) !== "#") return level;
	return 0;
}
var headingRule = {
	type: "block",
	name: "heading",
	test(state) {
		if (state.indent > 3) return false;
		if (state.charAt(0) !== "#") return false;
		const level = getLevel(state.src.slice(state.position));
		if (state.charAt(level) !== " ") return false;
		return level > 0 && level < 7;
	},
	parse(state, parser) {
		const start = state.position;
		parser.skipUntil((char) => char === " ");
		const level = state.position - start;
		parser.skip(1);
		return {
			type: "heading",
			level,
			children: parser.parseInline(() => state.charAt(0) === "\n")
		};
	}
};
var IMAGE_REGEX = /^!\[.*?]\(.*\)/;
var imageRule = {
	type: "inline",
	name: "image",
	ruleStartChar: "!",
	test(state) {
		if (state.charAt(0) !== "!" && state.charAt(1) !== "[") return false;
		return IMAGE_REGEX.test(state.src.slice(state.position));
	},
	parse(state, parser) {
		parser.skip(2);
		const alt = parser.readUntil((char) => char === "]");
		parser.skip(2);
		const src = parser.readUntil((char) => char === "\"" || char === ")").trimEnd();
		let title$1;
		if (state.charAt(0) === "\"") {
			parser.skip(1);
			title$1 = parser.readUntil((char) => char === "\"" || char === ")");
		}
		parser.skipUntil((char) => char === ")");
		parser.skip(1);
		return {
			type: "image",
			alt,
			src,
			title: title$1
		};
	}
};
var inlineCodeRule = {
	type: "inline",
	name: "inlineCode",
	ruleStartChar: "`",
	test(state) {
		if (state.charAt(0) === "`") return hasValidClosingInBlock(state, "`");
		return false;
	},
	parse(state, parser) {
		parser.skip(1);
		const value = parser.readUntil((char) => char === "`");
		parser.skip(1);
		return {
			type: "inlineCode",
			value
		};
	}
};
var lineBreakRule = {
	type: "inline",
	name: "lineBreak",
	ruleStartChar: ["\n", "\\"],
	test(state) {
		if (state.charAt(0) === "\\" && state.charAt(1) === "\n") return true;
		return state.charAt(0) === "\n";
	},
	parse(state, parser) {
		if (state.charAt(0) === "\\") parser.skip(1);
		parser.skip(1);
		return { type: "lineBreak" };
	}
};
var LINK_REGEX = /^\[.*]\(.*\)/;
var linkRule = {
	type: "inline",
	name: "link",
	ruleStartChar: "[",
	test(state) {
		if (state.charAt(0) !== "[") return false;
		return LINK_REGEX.test(state.src.slice(state.position));
	},
	parse(state, parser) {
		parser.skip(1);
		const children = parser.parseInline(() => state.charAt(0) === "]");
		parser.skip(2);
		const href = parser.readUntil((char) => char === "\"" || char === ")").trimEnd();
		let title$1;
		if (state.charAt(0) === "\"") {
			parser.skip(1);
			title$1 = parser.readUntil((char) => char === "\"" || char === ")");
		}
		parser.skipUntil((char) => char === ")");
		parser.skip(1);
		return {
			type: "link",
			href,
			title: title$1,
			children
		};
	}
};
var LIST_ITEM_REGEX = /^[\t ]*(?:[*+-]|\d+\.)[\t ]/;
var ORDERED_LIST_ITEM_REGEX = /^[\t ]*\d+.[\t ]/;
var EMPTY_LINE_REGEX = /^\s*$/;
function isList(value) {
	return LIST_ITEM_REGEX.test(value);
}
function getBull(value) {
	const match = value.match(LIST_ITEM_REGEX);
	return match ? match[0] : "";
}
function getLevel2(value) {
	const length = value.length;
	for (let level = 0; level < length; level++) {
		const char = value.charAt(level);
		if (char !== " " && char !== "	") return level;
	}
	return 0;
}
var internalIndentRegexCache = /* @__PURE__ */ new Map();
function getIndentRegex(indent) {
	if (internalIndentRegexCache.has(indent)) return internalIndentRegexCache.get(indent);
	const tabs = Math.ceil(indent / 4);
	const regex = /* @__PURE__ */ new RegExp(`^(?: {${indent}}|	{${tabs}})`);
	internalIndentRegexCache.set(indent, regex);
	return regex;
}
function getLines(text, indent) {
	const lineRegex = /^(.*)(?:\n|\r\n?|$)/gm;
	const lines = [];
	const indentRegex = getIndentRegex(indent);
	let prevEmptyLine = false;
	let match;
	let position = 0;
	let isFirstLine = true;
	while (match = lineRegex.exec(text)) {
		const line = match[0];
		if (line === "") break;
		const hasIndentation = indentRegex.test(line);
		if (prevEmptyLine && line !== "" && !hasIndentation) break;
		if (!hasIndentation && !isFirstLine && isList(line)) break;
		prevEmptyLine = EMPTY_LINE_REGEX.test(line);
		isFirstLine = false;
		position += line.length;
		lines.push(hasIndentation ? line.replace(indentRegex, "") : line);
	}
	return [lines.join(""), position];
}
var listRule = {
	type: "block",
	name: "list",
	test(state) {
		if (state.position > state.lineStart + state.indent) return false;
		const start = state.src.slice(state.position, state.position + 12);
		return LIST_ITEM_REGEX.test(start);
	},
	parse(state, parser) {
		function parseList(depth) {
			const lineStart = state.src.lastIndexOf("\n", state.position) + 1;
			const line = state.src.slice(lineStart);
			const ordered = ORDERED_LIST_ITEM_REGEX.test(line);
			const bullet = getBull(line);
			const node = {
				type: "list",
				ordered,
				children: []
			};
			if (ordered) node.start = Number.parseInt(bullet, 10);
			while (state.position < state.length) {
				const lineStart2 = state.src.lastIndexOf("\n", state.position) + 1;
				const line2 = state.src.slice(lineStart2);
				if (!isList(line2)) break;
				const ordered2 = ORDERED_LIST_ITEM_REGEX.test(line2);
				const bullet2 = getBull(line2);
				const level = getLevel2(bullet2);
				if (level === depth && node.ordered !== ordered2) break;
				if (level < depth) break;
				if (level > depth) {
					node.children.push(parseList(level));
					continue;
				}
				if (state.position >= state.length) break;
				if (state.charAt(0) === "\n" && (state.charAt(1) === "\n" || state.charAt(1) === "")) break;
				parser.skip(bullet2.length + (lineStart2 - state.position));
				const indent = state.position - state.lineStart;
				const [markdownSlice, position] = getLines(state.src.slice(state.position), indent);
				if (!markdownSlice) break;
				parser.skip(position);
				if (state.charAt(-1) === "\n") parser.skip(-1);
				parser.parseIndentation();
				node.children.push({
					type: "listItem",
					children: parser.parse(markdownSlice)
				});
			}
			return node;
		}
		return parseList(state.indent);
	}
};
function isSpecialCharacter2(char) {
	return char === "*" || char === "_";
}
var strongRule = {
	type: "inline",
	name: "strong",
	ruleStartChar: ["*", "_"],
	test(state) {
		const char = state.charAt(0);
		if (!isSpecialCharacter2(char)) return false;
		if (state.charAt(1) !== char) return false;
		return hasValidClosingInBlock(state, char + char);
	},
	parse(state, parser) {
		const symbol = state.charAt(0);
		parser.skip(2);
		const node = {
			type: "strong",
			children: parser.parseInline(() => {
				return state.charAt(0) === symbol && state.charAt(1) === symbol;
			})
		};
		parser.skip(2);
		return node;
	}
};
var SPLIT_PIPE_REGEX = /(?:^|[^\\])\|/;
var TABLE_MATCH_REGEX = /^\|.*?\|\n\s*\|[|\s-:]+\|\n/;
function parseAlignLine(line) {
	return line.replace(/(^\|\s*)|(\s*\|$)/g, "").split(SPLIT_PIPE_REGEX).map((cell) => {
		const trimmed = cell.trim();
		if (trimmed.startsWith(":") && trimmed.endsWith(":")) return "center";
		if (trimmed.startsWith(":")) return "left";
		if (trimmed.endsWith(":")) return "right";
		return "left";
	});
}
function parseTableHead(state, parser) {
	const rows = [];
	parser.skipUntil(() => state.charAt(0) !== "|" && state.charAt(0) !== " ");
	while (state.charAt(0) !== "\n" && state.charAt(0) !== " ") {
		const rowNode = {
			type: "tableHeader",
			align: "left",
			children: parser.parseInline(() => state.charAt(0) === "|" && state.charAt(-1) !== "\\")
		};
		rows.push(rowNode);
		parser.skipUntil(() => state.charAt(0) !== "|" && state.charAt(0) !== " ");
	}
	parser.skipUntil(() => state.charAt(0) === "|");
	const src = state.src.slice(state.position);
	const lineEnd = src.indexOf("\n");
	const alignment = parseAlignLine(src.slice(0, lineEnd));
	for (const [index, row] of rows.entries()) row.align = alignment[index];
	parser.skipUntil(() => state.charAt(0) === "\n");
	parser.skip(1);
	return {
		type: "tableRow",
		children: rows
	};
}
function parseTableRows(state, parser, align) {
	const rows = [];
	parser.skipUntil(() => state.charAt(0) === "|");
	while (state.charAt(0) === "|") {
		const row = [];
		parser.skipUntil(() => state.charAt(0) !== "|" && state.charAt(0) !== " ");
		while (state.charAt(0) !== "\n" && state.charAt(0) !== "") {
			row.push({
				type: "tableData",
				align: "left",
				children: parser.parseInline(() => state.charAt(0) === "|" && state.charAt(-1) !== "\\")
			});
			parser.skipUntil(() => state.charAt(0) !== "|" && state.charAt(0) !== " ");
		}
		if (state.charAt(0) === "\n") parser.skip(1);
		parser.skipUntil(() => state.charAt(0) !== " ");
		for (const [index, cell] of row.entries()) cell.align = align[index];
		rows.push({
			type: "tableRow",
			children: row
		});
	}
	return rows;
}
var tableRule = {
	type: "block",
	name: "table",
	test(state) {
		if (state.charAt(0) !== "|") return false;
		return TABLE_MATCH_REGEX.test(state.src.slice(state.position));
	},
	parse(state, parser) {
		const header = parseTableHead(state, parser);
		return {
			type: "table",
			header,
			rows: parseTableRows(state, parser, header.children.map((cell) => cell.align))
		};
	}
};
var ESCAPE_CHARS = "!\"#$%&'()\\*+,-./:;<=>?@[]^_`{|}~";
function mdAST(config = {}) {
	const rules = [
		codeRule,
		strongRule,
		emphasisRule,
		linkRule,
		imageRule,
		lineBreakRule,
		dividerRule,
		inlineCodeRule,
		headingRule,
		listRule,
		tableRule,
		blockquoteRule,
		commentRule
	];
	if (config.presets) rules.push(...config.presets.flat());
	const ruleStartChars = [...new Set(rules.flatMap((rule) => "ruleStartChar" in rule ? rule.ruleStartChar : []))].join("");
	const state = {
		src: "",
		position: 0,
		lineStart: 0,
		indent: 0,
		length: 0,
		charAt,
		slice
	};
	const parserContext = {
		skip,
		skipUntil,
		parseInline,
		readUntil,
		parseIndentation,
		parse: parseSubTree
	};
	let parserInstance;
	function parseSubTree(src) {
		if (!parserInstance) parserInstance = mdAST(config);
		return parserInstance.parse(src);
	}
	const charAtCache = {
		position: -1,
		value: ""
	};
	function charAt(position) {
		const index = state.position + position;
		if (position !== 0) return state.src.charAt(index);
		if (index !== charAtCache.position) {
			charAtCache.position = index;
			charAtCache.value = state.src.charAt(index);
		}
		return charAtCache.value;
	}
	function slice(position, length) {
		if (length === void 0) return state.src.slice(state.position + position);
		return state.src.slice(state.position + position, state.position + position + length);
	}
	function skip(position) {
		state.position = state.position + position;
	}
	function skipUntil(predicate) {
		while (state.position < state.length) {
			if (predicate(charAt(0))) break;
			state.position += 1;
		}
	}
	function readUntil(predicate) {
		const start = state.position;
		while (state.position < state.length) {
			if (predicate(charAt(0))) break;
			state.position += 1;
		}
		return state.src.slice(start, state.position);
	}
	function findRule(type) {
		if (type === "inline" && !ruleStartChars.includes(charAt(0))) return null;
		for (const rule of rules) if ((rule.type === type || rule.type === "inline-block") && rule.test(state)) return rule;
		return null;
	}
	function parseIndentation() {
		state.indent = 0;
		while (state.position < state.length) {
			const char = charAt(0);
			if (char === "\n") {
				state.indent = 0;
				state.lineStart = state.position + 1;
				state.position += 1;
			} else if (char === " ") {
				state.indent += 1;
				state.position += 1;
			} else if (char === "	") {
				state.indent += 4;
				state.position += 1;
			} else break;
		}
	}
	function parseBlock() {
		parseIndentation();
		if (state.position >= state.length) return null;
		const rule = findRule("block");
		if (rule) return rule.parse(state, parserContext);
		return {
			type: "paragraph",
			children: parseInline(() => {
				return charAt(0) === "\n" && (charAt(1) === "\n" || charAt(1) === "");
			})
		};
	}
	function parseInline(predicate) {
		const nodes = [];
		while (state.position < state.length) {
			if (predicate()) return nodes;
			if (charAt(0) === "\n") {
				parseIndentation();
				if (findRule("block")) return nodes;
				state.position = state.lineStart - 1;
				state.indent = 0;
			}
			const inlineRule = findRule("inline");
			if (inlineRule) nodes.push(inlineRule.parse(state, parserContext));
			else {
				const textNode = parseText(predicate);
				if (textNode) nodes.push(textNode);
			}
		}
		return nodes;
	}
	function parseText(predicate) {
		let value = "";
		let char = "";
		while (char = charAt(0)) {
			if (predicate()) break;
			if (char === "\\" && ESCAPE_CHARS.includes(charAt(1))) {
				value += charAt(1);
				state.position += 2;
				continue;
			}
			if (findRule("inline")) break;
			value += char;
			state.position++;
		}
		if (!value) return null;
		return {
			type: "text",
			value
		};
	}
	function parse(src) {
		state.src = src;
		state.length = src.length;
		state.position = 0;
		const nodes = [];
		let node;
		while (node = parseBlock()) nodes.push(node);
		return nodes;
	}
	return { parse };
}
function parseMarkdown(src, config) {
	return mdAST(config).parse(src);
}
var compile = (node) => {
	if (node.type === "text") return node.value;
	else if (node.type === "heading") return /* @__PURE__ */ u(Heading, {
		level: node.level,
		children: node.children
	});
	else if (node.type === "paragraph") return /* @__PURE__ */ u(Paragraph, { children: node.children });
	else if (node.type === "list") return /* @__PURE__ */ u(List, { children: node.children });
	else if (node.type === "listItem") return /* @__PURE__ */ u(ListItem, { children: node.children });
	else if (node.type === "link") return /* @__PURE__ */ u(Link, {
		href: node.href,
		children: node.children
	});
	else if (node.type === "image") return /* @__PURE__ */ u(Image$1, {
		src: node.src,
		alt: node.alt
	});
	else if (node.type === "code") return /* @__PURE__ */ u(Code, { value: node.value });
	else if (node.type === "emphasis") return /* @__PURE__ */ u(Emphasis, { children: node.children });
	else if (node.type === "strong") return /* @__PURE__ */ u(Strong, { children: node.children });
	else if (node.type === "strikeThrough") return /* @__PURE__ */ u(StrikeThrough, { children: node.children });
	else if (node.type === "inlineCode") return /* @__PURE__ */ u(InlineCode, { value: node.value });
	else if (node.type === "divider") return /* @__PURE__ */ u(Divider, {});
	else if (node.type === "checkbox") return /* @__PURE__ */ u(Checkbox, {
		checked: node.checked,
		children: node.children
	});
	else if (node.type === "comment") return /* @__PURE__ */ u(Comment, { value: node.value });
	else if (node.type === "table") return /* @__PURE__ */ u(Table, {
		header: node.header,
		rows: node.rows
	});
	else if (node.type === "subscript") return /* @__PURE__ */ u(Subscript, { children: node.children });
	else if (node.type === "superscript") return /* @__PURE__ */ u(Superscript, { children: node.children });
	else if (node.type === "blockquote") return /* @__PURE__ */ u(BlockQuote, { children: node.children });
	else if (node.type === "tableRow") return /* @__PURE__ */ u(TableRow, { children: node.children });
	else if (node.type === "tableHeader") return /* @__PURE__ */ u(TableHeader, { children: node.children });
	else if (node.type === "tableData") return /* @__PURE__ */ u(TableData, { children: node.children });
	else if (node.type === "lineBreak") return /* @__PURE__ */ u(LineBreak, {});
};
var getHeadingId = (children) => {
	return children.map((child) => child.type === "text" ? child.value : "").join("-").toLowerCase().replace(/[^a-z0-9-]/g, "-");
};
var Heading = ({ level, children }) => {
	const className = `text-${[
		"md",
		"lg",
		"md",
		"md",
		"sm",
		"xs"
	][level - 1]} text-white font-bold ${level > 1 ? `my-6 flex flex-row items-center gap-2 relative group ${level === 2 ? `py-1 border-b-2 border-[${primaryColor.value}]` : ""}` : ""}`;
	const ch = children.map(compile);
	const id = getHeadingId(children);
	const Wrapper = ({ children: children$1 }) => /* @__PURE__ */ u("a", {
		href: `#${id}`,
		children: children$1
	});
	const LinkIcon = () => /* @__PURE__ */ u("div", {
		class: "absolute hidden pr-2 group-hover:block top-1/2 -translate-y-1/2 right-[calc(100%)]",
		children: /* @__PURE__ */ u(e$2, { size: 16 })
	});
	if (level === 1) return /* @__PURE__ */ u(Wrapper, { children: /* @__PURE__ */ u("h1", {
		id,
		class: className,
		children: ch
	}) });
	else if (level === 2) return /* @__PURE__ */ u(Wrapper, { children: /* @__PURE__ */ u("h2", {
		id,
		class: className,
		children: [/* @__PURE__ */ u(LinkIcon, {}), ch]
	}) });
	else if (level === 3) return /* @__PURE__ */ u(Wrapper, { children: /* @__PURE__ */ u("h3", {
		id,
		class: className,
		children: [/* @__PURE__ */ u(LinkIcon, {}), ch]
	}) });
	else if (level === 4) return /* @__PURE__ */ u(Wrapper, { children: /* @__PURE__ */ u("h4", {
		id,
		class: className,
		children: [/* @__PURE__ */ u(LinkIcon, {}), ch]
	}) });
	else if (level === 5) return /* @__PURE__ */ u(Wrapper, { children: /* @__PURE__ */ u("h5", {
		id,
		class: className,
		children: [/* @__PURE__ */ u(LinkIcon, {}), ch]
	}) });
	else if (level === 6) return /* @__PURE__ */ u(Wrapper, { children: /* @__PURE__ */ u("h6", {
		id,
		class: className,
		children: [/* @__PURE__ */ u(LinkIcon, {}), ch]
	}) });
};
var Paragraph = ({ children }) => {
	return /* @__PURE__ */ u("p", {
		class: "my-2",
		children: children.map(compile)
	});
};
var List = ({ children }) => {
	return /* @__PURE__ */ u("ul", { children: children.map(compile) });
};
var ListItem = ({ children }) => {
	return /* @__PURE__ */ u("li", { children: children.map(compile) });
};
var Link = ({ href, children }) => {
	return /* @__PURE__ */ u("a", {
		href,
		children: children.map(compile)
	});
};
var Image$1 = ({ src, alt }) => {
	return /* @__PURE__ */ u("img", {
		src,
		alt
	});
};
var Code = ({ value }) => {
	return /* @__PURE__ */ u(InlineEditor, {
		id: `tutorial-code-${value}`,
		code: value.replace(/\n$/, ""),
		class: "mt-4 mb-10"
	});
};
var InlineCode = ({ value }) => {
	return /* @__PURE__ */ u("code", {
		class: `text-[${primaryColor.value}]`,
		children: value
	});
};
var Emphasis = ({ children }) => {
	return /* @__PURE__ */ u("em", { children: children.map(compile) });
};
var Strong = ({ children }) => {
	return /* @__PURE__ */ u("strong", { children: children.map(compile) });
};
var StrikeThrough = ({ children }) => {
	return /* @__PURE__ */ u("s", { children: children.map(compile) });
};
var Divider = () => {
	return /* @__PURE__ */ u("hr", {});
};
var Checkbox = ({ checked, children }) => {
	const ch = children.map(compile);
	return /* @__PURE__ */ u("label", { children: [
		/* @__PURE__ */ u("input", {
			type: "checkbox",
			checked
		}),
		" ",
		ch
	] });
};
var Comment = ({ value }) => {
	return /* @__PURE__ */ u("div", {
		class: "text-gray-500 text-sm",
		children: value
	});
};
var Table = ({ header, rows }) => {
	const headerCh = header.children.map(compile);
	const rowsCh = rows.map((row) => row.children.map(compile));
	return /* @__PURE__ */ u("table", { children: [/* @__PURE__ */ u("thead", { children: /* @__PURE__ */ u("tr", { children: headerCh }) }), /* @__PURE__ */ u("tbody", { children: rowsCh })] });
};
var Subscript = ({ children }) => {
	return /* @__PURE__ */ u("sub", { children: children.map(compile) });
};
var Superscript = ({ children }) => {
	return /* @__PURE__ */ u("sup", { children: children.map(compile) });
};
var BlockQuote = ({ children }) => {
	return /* @__PURE__ */ u("blockquote", { children: children.map(compile) });
};
var TableRow = ({ children }) => {
	return /* @__PURE__ */ u("tr", { children: children.map(compile) });
};
var TableHeader = ({ children }) => {
	return /* @__PURE__ */ u("th", { children: children.map(compile) });
};
var TableData = ({ children }) => {
	return /* @__PURE__ */ u("td", { children: children.map(compile) });
};
var LineBreak = () => {
	return /* @__PURE__ */ u("br", {});
};
const TutorialsMain = () => {
	widgetOptions.showVisuals = true;
	widgetOptions.showKnobs = true;
	widgetOptions.noHeader = true;
	const parsed = useSignal(null);
	const teardown = useSignal(false);
	const tutorialName = useComputed(() => pathname.value.split("/")[2]);
	const tutorialMarkdown = useAsyncMemo(() => tutorialName.value?.length ? fetch(`/tutorials/${tutorialName.value}.md`).then((res) => res.text()) : Promise.resolve(null));
	const tutorial = useComputed(() => tutorials.find((tutorial$1) => tutorial$1.href === pathname.value) ?? null);
	useReactiveEffect(() => {
		subsection.value = tutorial.value?.name ?? null;
	});
	useReactiveEffect(() => {
		if (tutorialMarkdown.value) {
			teardown.value = true;
			requestAnimationFrame(() => {
				if (tutorialMarkdown.value) {
					teardown.value = false;
					parsed.value = parseMarkdown(tutorialMarkdown.value);
				}
			});
		} else parsed.value = null;
	});
	return /* @__PURE__ */ u(k, { children: [/* @__PURE__ */ u(Header, { children: parsed.value && tutorial.value && /* @__PURE__ */ u(k, { children: [/* @__PURE__ */ u(tutorial.value.Icon, { size: "24" }), compile(parsed.value[0])] }) || isMobile() && /* @__PURE__ */ u(k, { children: [/* @__PURE__ */ u(e, {
		weight: "regular",
		size: 24
	}), "Tutorials"] }) }), /* @__PURE__ */ u(Main, {
		class: parsed.value ? "px-4 md:px-8 md:pl-12 py-4" : "p-4",
		children: teardown.value ? null : parsed.value ? /* @__PURE__ */ u(k, { children: [parsed.value.slice(1).map(compile), /* @__PURE__ */ u(e$1, {
			size: 20,
			class: "my-6"
		})] }) : /* @__PURE__ */ u(Grid, {
			cols: isMobile() ? 1 : 3,
			children: tutorials.map((tutorial$1) => /* @__PURE__ */ u(GridItem, {
				to: tutorial$1.href,
				children: [
					/* @__PURE__ */ u(tutorial$1.Icon, { size: 24 }),
					/* @__PURE__ */ u("span", {
						class: "mt-2",
						children: tutorial$1.name
					}),
					/* @__PURE__ */ u("span", {
						class: "text-sm text-white/50",
						children: tutorial$1.description
					})
				]
			}))
		})
	}, tutorialName.value)] });
};
const App = () => {
	const header = useSignal(null);
	y(() => () => ctx.value?.dispose(), []);
	useReactiveEffect(() => {
		if (!settings.debug) return;
		const c$7 = ctx.value;
		if (!c$7?.dsp?.core?.worklet) {
			memoryDebugInfo.value = null;
			return;
		}
		const id = setInterval(async () => {
			try {
				wasmMemoryUsage.value = (await c$7.dsp.core.worklet.getStats()).memoryUsage ?? null;
				memoryDebugInfo.value = await memoryDebug.getInfo({
					worklet: c$7.dsp.core.worklet,
					record: c$7.dsp.core.record
				});
			} catch (e$59) {
				console.error(e$59);
			}
		}, 250);
		return () => {
			clearInterval(id);
			memoryDebugInfo.value = null;
		};
	});
	useReactiveEffect(() => {
		setFaviconSvg(favIconSvgText.value);
	}, [favIconSvgText]);
	useReactiveEffect(() => {
		favIconSvgText.value = `
      <svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="1362" height="1362" viewBox="0 -150 1362 1362">
        <defs>
          <linearGradient id="gradient" x1="0" y1="0" x2=".75" y2=".75">
            <stop offset="0%" stop-color="${primaryGradientA.value}" />
            <stop offset="100%" stop-color="${primaryGradientB.value}" />
          </linearGradient>
        </defs>
        <path
          d="M0,0 L111,0 L112,610 L124,630 L136,649 L152,675 L156,681 L236,682 L236,806 L101,806 L80,774 L61,745 L42,716 L23,687 L4,658 L0,652 Z "
          fill="url(#gradient)"
          transform="translate(107,104)"
        />
        <path
          d="M0,0 L255,0 L266,51 L285,141 L285,145 L287,145 L288,136 L316,3 L317,0 L573,0 L584,14 L594,27 L604,40 L618,58 L631,75 L645,93 L655,106 L665,119 L675,132 L689,150 L690,152 L690,551 L567,551 L566,191 L555,177 L543,162 L532,148 L521,134 L512,123 L512,121 L402,121 L401,129 L367,283 L339,409 L338,413 L235,413 L221,352 L196,241 L170,126 L170,121 L61,122 L50,136 L39,150 L28,164 L17,178 L7,191 L6,551 L-118,551 L-118,151 L-105,135 L-93,119 L-81,104 L-71,91 L-60,77 L-46,59 L-35,45 L-21,27 L-7,9 Z "
          fill="url(#gradient)"
          transform="translate(554,359)"
        />
      </svg>
    `;
	}, []);
	useReactiveEffect(() => {
		if (!ctx.value) return;
		header.value = createHeader(ctx.value, currentProgramContext.value);
	});
	y(() => {
		let rafId;
		const tick = () => {
			tickCount.value++;
			if (deferDraw.value) {
				deferDraw.value = false;
				skipAnimations.value += 1;
				requestAnimationFrame(() => {
					rafId = requestAnimationFrame(tick);
				});
			} else {
				draw();
				if (skipAnimations.value) skipAnimations.value--;
				rafId = requestAnimationFrame(tick);
			}
		};
		tick();
		return () => cancelAnimationFrame(rafId);
	}, []);
	return /* @__PURE__ */ u(k, { children: [
		/* @__PURE__ */ u("style", { dangerouslySetInnerHTML: { __html: `
        *::selection {
          background-color: ${theme.value.blue + "42"};
        }
    ` } }),
		mainPage.value === null ? /* @__PURE__ */ u(Landing, {}) : /* @__PURE__ */ u(k, { children: /* @__PURE__ */ u("div", {
			class: "flex flex-row w-screen h-screen max-w-full max-h-full",
			style: { backgroundColor: theme.value.black },
			children: [
				!isMobile() && /* @__PURE__ */ u("div", {
					class: "flex w-auto h-full flex-shrink-0",
					children: /* @__PURE__ */ u(Sidebar, {})
				}),
				/* @__PURE__ */ u("div", {
					class: "flex flex-col flex-1 min-w-0 h-full",
					children: mainPage.value === "docs" ? /* @__PURE__ */ u(DocsMain, {}) : mainPage.value === "tutorials" ? /* @__PURE__ */ u(TutorialsMain, {}) : mainPage.value === "browse" ? /* @__PURE__ */ u(BrowseMain, {}) : mainPage.value === "admin" ? /* @__PURE__ */ u(AdminMain, {}) : mainPage.value === "artist" ? /* @__PURE__ */ u(ArtistMain, {}) : mainPage.value === "project" ? /* @__PURE__ */ u(ProjectMain, {}) : mainPage.value === "help" ? /* @__PURE__ */ u(HelpMain, {}) : mainPage.value === "about" ? /* @__PURE__ */ u(AboutMain, {}) : mainPage.value === "dj" ? /* @__PURE__ */ u(DJMain, {}) : mainPage.value === "editor" ? /* @__PURE__ */ u(k, { children: [/* @__PURE__ */ u("div", {
						class: "relative",
						children: /* @__PURE__ */ u(Nav, {})
					}), currentProgramContext.value?.doc && /* @__PURE__ */ u("div", {
						class: "flex-1 min-w-0 h-full overflow-hidden",
						children: /* @__PURE__ */ u(Editor, {
							doc: b(() => currentProgramContext.value?.doc ?? null),
							header: header.value
						})
					})] }) : null
				}),
				showIntro.value && /* @__PURE__ */ u(Intro, {})
			]
		}) }),
		(wasmMemoryUsage.value != null || memoryDebugInfo.value) && settings.debug && /* @__PURE__ */ u("div", {
			class: "fixed bottom-3 right-3 text-xs font-mono px-2 py-1 rounded z-50 text-white bg-black/70",
			children: [
				wasmMemoryUsage.value != null && /* @__PURE__ */ u("div", { children: [
					"WASM worklet: ",
					wasmMemoryUsage.value.toFixed(2),
					" MB"
				] }),
				memoryDebugInfo.value?.record?.wasmMemoryMb != null && /* @__PURE__ */ u("div", { children: [
					"WASM record: ",
					memoryDebugInfo.value.record.wasmMemoryMb.toFixed(2),
					" MB"
				] }),
				memoryDebugInfo.value && /* @__PURE__ */ u("div", {
					class: "mt-1",
					children: [/* @__PURE__ */ u("div", { children: [
						"SAB: ",
						(memoryDebugInfo.value.sab.totalBytes / 1024 / 1024).toFixed(2),
						" MB"
					] }), /* @__PURE__ */ u("div", { children: [
						"samples: ",
						memoryDebugInfo.value.samples.handleCount,
						" ",
						"(",
						(memoryDebugInfo.value.samples.totalChannelBytes / 1024).toFixed(0),
						" KB)"
					] })]
				})
			]
		})
	] });
};
J(/* @__PURE__ */ u(App, {}), document.getElementById("app"));
export { __commonJSMin as t };

//# sourceMappingURL=index-C5YSovd7.js.map